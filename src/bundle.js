/**
 * ============================================================================
 * ANIME WEBSITE - BUNDLE.JS GUIDE
 * ============================================================================
 * 
 * This file contains all the code for your anime streaming website.
 * Below is a guide to help you find and edit different parts.
 * 
 * ============================================================================
 * TABLE OF CONTENTS
 * ============================================================================
 * 
 * 1. CONFIGURATION & CONSTANTS (Search for these in the file)
 *    - API_URL: "https://apii-orcin-theta.vercel.app/api"
 *    - Site name: Search for "AniRock"
 * 
 * 2. MAIN PAGES (Search for "function" + page name)
 *    - HomePage: function Yk()
 *    - SplashPage: function f6()
 *    - WatchPage: function c6()
 *    - SearchPage: function bR()
 *    - ContactPage: function g6()
 *    - AnimePage (Info): function Qx()
 * 
 * 3. COMPONENTS
 *    - Header/Navigation: function hR()
 *    - Sidebar: function oR()
 *    - Search Bar: function dR()
 *    - Video Player: Look for "video" or "player"
 *    - Episode List: Look for "episode"
 * 
 * 4. STYLING & COLORS
 *    - Colors are defined inline in className strings
 *    - Main colors: #ffbade (pink), #B0E3AF (green), #B9E7FF (blue)
 *    - Background: #0a0a0a, #1a1a1a, #2a2a2a
 * 
 * 5. API CALLS
 *    - All API calls use: "https://apii-orcin-theta.vercel.app/api"
 *    - Search for "Ke.get" to find API calls
 * 
 * ============================================================================
 * HOW TO EDIT
 * ============================================================================
 * 
 * TO CHANGE COLORS:
 * - Search for the hex color (e.g., "#ffbade")
 * - Replace with your new color
 * 
 * TO CHANGE TEXT:
 * - Search for the text you see on the website
 * - Edit it directly
 * 
 * TO CHANGE API:
 * - Search for "https://apii-orcin-theta.vercel.app/api"
 * - Replace with your new API URL
 * 
 * TO CHANGE SITE NAME:
 * - Search for "AniRock"
 * - Replace with your site name
 * 
 * ============================================================================
 * COMMON EDITS
 * ============================================================================
 * 
 * 1. Change primary color (pink):
 *    Find: #ffbade
 *    Replace with: YOUR_COLOR
 * 
 * 2. Change site name:
 *    Find: AniRock
 *    Replace with: YOUR_SITE_NAME
 * 
 * 3. Change API endpoint:
 *    Find: https://apii-orcin-theta.vercel.app/api
 *    Replace with: YOUR_API_URL
 * 
 * ============================================================================
 */

// The actual bundle code starts below this comment
var Q2 = (n, e) => () => (e || n((e = { exports: {} }).exports, e), e.exports); var v6 = Q2((rS, Us) => {
  function Z2(n, e) { for (var t = 0; t < e.length; t++) { const r = e[t]; if (typeof r != "string" && !Array.isArray(r)) { for (const s in r) if (s !== "default" && !(s in n)) { const i = Object.getOwnPropertyDescriptor(r, s); i && Object.defineProperty(n, s, i.get ? i : { enumerable: !0, get: () => r[s] }) } } } return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const i of s) if (i.type === "childList") for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function t(s) { const i = {}; return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function r(s) { if (s.ep) return; s.ep = !0; const i = t(s); fetch(s.href, i) } })(); var y0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Mh(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var Md = { exports: {} }, Pa = {}, jd = { exports: {} }, Ge = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var b0; function J2() { if (b0) return Ge; b0 = 1; var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), a = Symbol.for("react.context"), o = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.iterator; function p(F) { return F === null || typeof F != "object" ? null : (F = h && F[h] || F["@@iterator"], typeof F == "function" ? F : null) } var v = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, g = Object.assign, y = {}; function w(F, H, ae) { this.props = F, this.context = H, this.refs = y, this.updater = ae || v } w.prototype.isReactComponent = {}, w.prototype.setState = function (F, H) { if (typeof F != "object" && typeof F != "function" && F != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, F, H, "setState") }, w.prototype.forceUpdate = function (F) { this.updater.enqueueForceUpdate(this, F, "forceUpdate") }; function T() { } T.prototype = w.prototype; function S(F, H, ae) { this.props = F, this.context = H, this.refs = y, this.updater = ae || v } var E = S.prototype = new T; E.constructor = S, g(E, w.prototype), E.isPureReactComponent = !0; var I = Array.isArray, C = Object.prototype.hasOwnProperty, D = { current: null }, R = { key: !0, ref: !0, __self: !0, __source: !0 }; function N(F, H, ae) { var he, de = {}, pe = null, Ce = null; if (H != null) for (he in H.ref !== void 0 && (Ce = H.ref), H.key !== void 0 && (pe = "" + H.key), H) C.call(H, he) && !R.hasOwnProperty(he) && (de[he] = H[he]); var Ie = arguments.length - 2; if (Ie === 1) de.children = ae; else if (1 < Ie) { for (var Pe = Array(Ie), Ve = 0; Ve < Ie; Ve++)Pe[Ve] = arguments[Ve + 2]; de.children = Pe } if (F && F.defaultProps) for (he in Ie = F.defaultProps, Ie) de[he] === void 0 && (de[he] = Ie[he]); return { $$typeof: n, type: F, key: pe, ref: Ce, props: de, _owner: D.current } } function P(F, H) { return { $$typeof: n, type: F.type, key: H, ref: F.ref, props: F.props, _owner: F._owner } } function _(F) { return typeof F == "object" && F !== null && F.$$typeof === n } function M(F) { var H = { "=": "=0", ":": "=2" }; return "$" + F.replace(/[=:]/g, function (ae) { return H[ae] }) } var $ = /\/+/g; function B(F, H) { return typeof F == "object" && F !== null && F.key != null ? M("" + F.key) : H.toString(36) } function V(F, H, ae, he, de) { var pe = typeof F; (pe === "undefined" || pe === "boolean") && (F = null); var Ce = !1; if (F === null) Ce = !0; else switch (pe) { case "string": case "number": Ce = !0; break; case "object": switch (F.$$typeof) { case n: case e: Ce = !0 } }if (Ce) return Ce = F, de = de(Ce), F = he === "" ? "." + B(Ce, 0) : he, I(de) ? (ae = "", F != null && (ae = F.replace($, "$&/") + "/"), V(de, H, ae, "", function (Ve) { return Ve })) : de != null && (_(de) && (de = P(de, ae + (!de.key || Ce && Ce.key === de.key ? "" : ("" + de.key).replace($, "$&/") + "/") + F)), H.push(de)), 1; if (Ce = 0, he = he === "" ? "." : he + ":", I(F)) for (var Ie = 0; Ie < F.length; Ie++) { pe = F[Ie]; var Pe = he + B(pe, Ie); Ce += V(pe, H, ae, Pe, de) } else if (Pe = p(F), typeof Pe == "function") for (F = Pe.call(F), Ie = 0; !(pe = F.next()).done;)pe = pe.value, Pe = he + B(pe, Ie++), Ce += V(pe, H, ae, Pe, de); else if (pe === "object") throw H = String(F), Error("Objects are not valid as a React child (found: " + (H === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : H) + "). If you meant to render a collection of children, use an array instead."); return Ce } function W(F, H, ae) { if (F == null) return F; var he = [], de = 0; return V(F, he, "", "", function (pe) { return H.call(ae, pe, de++) }), he } function U(F) { if (F._status === -1) { var H = F._result; H = H(), H.then(function (ae) { (F._status === 0 || F._status === -1) && (F._status = 1, F._result = ae) }, function (ae) { (F._status === 0 || F._status === -1) && (F._status = 2, F._result = ae) }), F._status === -1 && (F._status = 0, F._result = H) } if (F._status === 1) return F._result.default; throw F._result } var q = { current: null }, z = { transition: null }, X = { ReactCurrentDispatcher: q, ReactCurrentBatchConfig: z, ReactCurrentOwner: D }; function Z() { throw Error("act(...) is not supported in production builds of React.") } return Ge.Children = { map: W, forEach: function (F, H, ae) { W(F, function () { H.apply(this, arguments) }, ae) }, count: function (F) { var H = 0; return W(F, function () { H++ }), H }, toArray: function (F) { return W(F, function (H) { return H }) || [] }, only: function (F) { if (!_(F)) throw Error("React.Children.only expected to receive a single React element child."); return F } }, Ge.Component = w, Ge.Fragment = t, Ge.Profiler = s, Ge.PureComponent = S, Ge.StrictMode = r, Ge.Suspense = c, Ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = X, Ge.act = Z, Ge.cloneElement = function (F, H, ae) { if (F == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + F + "."); var he = g({}, F.props), de = F.key, pe = F.ref, Ce = F._owner; if (H != null) { if (H.ref !== void 0 && (pe = H.ref, Ce = D.current), H.key !== void 0 && (de = "" + H.key), F.type && F.type.defaultProps) var Ie = F.type.defaultProps; for (Pe in H) C.call(H, Pe) && !R.hasOwnProperty(Pe) && (he[Pe] = H[Pe] === void 0 && Ie !== void 0 ? Ie[Pe] : H[Pe]) } var Pe = arguments.length - 2; if (Pe === 1) he.children = ae; else if (1 < Pe) { Ie = Array(Pe); for (var Ve = 0; Ve < Pe; Ve++)Ie[Ve] = arguments[Ve + 2]; he.children = Ie } return { $$typeof: n, type: F.type, key: de, ref: pe, props: he, _owner: Ce } }, Ge.createContext = function (F) { return F = { $$typeof: a, _currentValue: F, _currentValue2: F, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, F.Provider = { $$typeof: i, _context: F }, F.Consumer = F }, Ge.createElement = N, Ge.createFactory = function (F) { var H = N.bind(null, F); return H.type = F, H }, Ge.createRef = function () { return { current: null } }, Ge.forwardRef = function (F) { return { $$typeof: o, render: F } }, Ge.isValidElement = _, Ge.lazy = function (F) { return { $$typeof: f, _payload: { _status: -1, _result: F }, _init: U } }, Ge.memo = function (F, H) { return { $$typeof: u, type: F, compare: H === void 0 ? null : H } }, Ge.startTransition = function (F) { var H = z.transition; z.transition = {}; try { F() } finally { z.transition = H } }, Ge.unstable_act = Z, Ge.useCallback = function (F, H) { return q.current.useCallback(F, H) }, Ge.useContext = function (F) { return q.current.useContext(F) }, Ge.useDebugValue = function () { }, Ge.useDeferredValue = function (F) { return q.current.useDeferredValue(F) }, Ge.useEffect = function (F, H) { return q.current.useEffect(F, H) }, Ge.useId = function () { return q.current.useId() }, Ge.useImperativeHandle = function (F, H, ae) { return q.current.useImperativeHandle(F, H, ae) }, Ge.useInsertionEffect = function (F, H) { return q.current.useInsertionEffect(F, H) }, Ge.useLayoutEffect = function (F, H) { return q.current.useLayoutEffect(F, H) }, Ge.useMemo = function (F, H) { return q.current.useMemo(F, H) }, Ge.useReducer = function (F, H, ae) { return q.current.useReducer(F, H, ae) }, Ge.useRef = function (F) { return q.current.useRef(F) }, Ge.useState = function (F) { return q.current.useState(F) }, Ge.useSyncExternalStore = function (F, H, ae) { return q.current.useSyncExternalStore(F, H, ae) }, Ge.useTransition = function () { return q.current.useTransition() }, Ge.version = "18.3.1", Ge } var w0; function jh() { return w0 || (w0 = 1, jd.exports = J2()), jd.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var S0; function eE() { if (S0) return Pa; S0 = 1; var n = jh(), e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 }; function a(o, c, u) { var f, h = {}, p = null, v = null; u !== void 0 && (p = "" + u), c.key !== void 0 && (p = "" + c.key), c.ref !== void 0 && (v = c.ref); for (f in c) r.call(c, f) && !i.hasOwnProperty(f) && (h[f] = c[f]); if (o && o.defaultProps) for (f in c = o.defaultProps, c) h[f] === void 0 && (h[f] = c[f]); return { $$typeof: e, type: o, key: p, ref: v, props: h, _owner: s.current } } return Pa.Fragment = t, Pa.jsx = a, Pa.jsxs = a, Pa } var E0; function tE() { return E0 || (E0 = 1, Md.exports = eE()), Md.exports } var x = tE(), j = jh(); const Qe = Mh(j), rE = Z2({ __proto__: null, default: Qe }, [j]), vy = j.createContext(), nE = ({ children: n }) => { const [e, t] = j.useState(() => { const s = localStorage.getItem("language"); return s || "EN" }); j.useEffect(() => { localStorage.setItem("language", e) }, [e]); const r = s => { t(s) }; return x.jsx(vy.Provider, { value: { language: e, toggleLanguage: r }, children: n }) }, pn = () => j.useContext(vy); var Al = {}, Fd = { exports: {} }, sr = {}, $d = { exports: {} }, Bd = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var T0; function sE() { return T0 || (T0 = 1, (function (n) { function e(z, X) { var Z = z.length; z.push(X); e: for (; 0 < Z;) { var F = Z - 1 >>> 1, H = z[F]; if (0 < s(H, X)) z[F] = X, z[Z] = H, Z = F; else break e } } function t(z) { return z.length === 0 ? null : z[0] } function r(z) { if (z.length === 0) return null; var X = z[0], Z = z.pop(); if (Z !== X) { z[0] = Z; e: for (var F = 0, H = z.length, ae = H >>> 1; F < ae;) { var he = 2 * (F + 1) - 1, de = z[he], pe = he + 1, Ce = z[pe]; if (0 > s(de, Z)) pe < H && 0 > s(Ce, de) ? (z[F] = Ce, z[pe] = Z, F = pe) : (z[F] = de, z[he] = Z, F = he); else if (pe < H && 0 > s(Ce, Z)) z[F] = Ce, z[pe] = Z, F = pe; else break e } } return X } function s(z, X) { var Z = z.sortIndex - X.sortIndex; return Z !== 0 ? Z : z.id - X.id } if (typeof performance == "object" && typeof performance.now == "function") { var i = performance; n.unstable_now = function () { return i.now() } } else { var a = Date, o = a.now(); n.unstable_now = function () { return a.now() - o } } var c = [], u = [], f = 1, h = null, p = 3, v = !1, g = !1, y = !1, w = typeof setTimeout == "function" ? setTimeout : null, T = typeof clearTimeout == "function" ? clearTimeout : null, S = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function E(z) { for (var X = t(u); X !== null;) { if (X.callback === null) r(u); else if (X.startTime <= z) r(u), X.sortIndex = X.expirationTime, e(c, X); else break; X = t(u) } } function I(z) { if (y = !1, E(z), !g) if (t(c) !== null) g = !0, U(C); else { var X = t(u); X !== null && q(I, X.startTime - z) } } function C(z, X) { g = !1, y && (y = !1, T(N), N = -1), v = !0; var Z = p; try { for (E(X), h = t(c); h !== null && (!(h.expirationTime > X) || z && !M());) { var F = h.callback; if (typeof F == "function") { h.callback = null, p = h.priorityLevel; var H = F(h.expirationTime <= X); X = n.unstable_now(), typeof H == "function" ? h.callback = H : h === t(c) && r(c), E(X) } else r(c); h = t(c) } if (h !== null) var ae = !0; else { var he = t(u); he !== null && q(I, he.startTime - X), ae = !1 } return ae } finally { h = null, p = Z, v = !1 } } var D = !1, R = null, N = -1, P = 5, _ = -1; function M() { return !(n.unstable_now() - _ < P) } function $() { if (R !== null) { var z = n.unstable_now(); _ = z; var X = !0; try { X = R(!0, z) } finally { X ? B() : (D = !1, R = null) } } else D = !1 } var B; if (typeof S == "function") B = function () { S($) }; else if (typeof MessageChannel < "u") { var V = new MessageChannel, W = V.port2; V.port1.onmessage = $, B = function () { W.postMessage(null) } } else B = function () { w($, 0) }; function U(z) { R = z, D || (D = !0, B()) } function q(z, X) { N = w(function () { z(n.unstable_now()) }, X) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (z) { z.callback = null }, n.unstable_continueExecution = function () { g || v || (g = !0, U(C)) }, n.unstable_forceFrameRate = function (z) { 0 > z || 125 < z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < z ? Math.floor(1e3 / z) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(c) }, n.unstable_next = function (z) { switch (p) { case 1: case 2: case 3: var X = 3; break; default: X = p }var Z = p; p = X; try { return z() } finally { p = Z } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (z, X) { switch (z) { case 1: case 2: case 3: case 4: case 5: break; default: z = 3 }var Z = p; p = z; try { return X() } finally { p = Z } }, n.unstable_scheduleCallback = function (z, X, Z) { var F = n.unstable_now(); switch (typeof Z == "object" && Z !== null ? (Z = Z.delay, Z = typeof Z == "number" && 0 < Z ? F + Z : F) : Z = F, z) { case 1: var H = -1; break; case 2: H = 250; break; case 5: H = 1073741823; break; case 4: H = 1e4; break; default: H = 5e3 }return H = Z + H, z = { id: f++, callback: X, priorityLevel: z, startTime: Z, expirationTime: H, sortIndex: -1 }, Z > F ? (z.sortIndex = Z, e(u, z), t(c) === null && z === t(u) && (y ? (T(N), N = -1) : y = !0, q(I, Z - F))) : (z.sortIndex = H, e(c, z), g || v || (g = !0, U(C))), z }, n.unstable_shouldYield = M, n.unstable_wrapCallback = function (z) { var X = p; return function () { var Z = p; p = X; try { return z.apply(this, arguments) } finally { p = Z } } } })(Bd)), Bd } var A0; function iE() { return A0 || (A0 = 1, $d.exports = sE()), $d.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var I0; function aE() {
    if (I0) return sr; I0 = 1; var n = jh(), e = iE(); function t(l) { for (var d = "https://reactjs.org/docs/error-decoder.html?invariant=" + l, m = 1; m < arguments.length; m++)d += "&args[]=" + encodeURIComponent(arguments[m]); return "Minified React error #" + l + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var r = new Set, s = {}; function i(l, d) { a(l, d), a(l + "Capture", d) } function a(l, d) { for (s[l] = d, l = 0; l < d.length; l++)r.add(d[l]) } var o = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), c = Object.prototype.hasOwnProperty, u = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, h = {}; function p(l) { return c.call(h, l) ? !0 : c.call(f, l) ? !1 : u.test(l) ? h[l] = !0 : (f[l] = !0, !1) } function v(l, d, m, b) { if (m !== null && m.type === 0) return !1; switch (typeof d) { case "function": case "symbol": return !0; case "boolean": return b ? !1 : m !== null ? !m.acceptsBooleans : (l = l.toLowerCase().slice(0, 5), l !== "data-" && l !== "aria-"); default: return !1 } } function g(l, d, m, b) { if (d === null || typeof d > "u" || v(l, d, m, b)) return !0; if (b) return !1; if (m !== null) switch (m.type) { case 3: return !d; case 4: return d === !1; case 5: return isNaN(d); case 6: return isNaN(d) || 1 > d }return !1 } function y(l, d, m, b, A, L, O) { this.acceptsBooleans = d === 2 || d === 3 || d === 4, this.attributeName = b, this.attributeNamespace = A, this.mustUseProperty = m, this.propertyName = l, this.type = d, this.sanitizeURL = L, this.removeEmptyString = O } var w = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (l) { w[l] = new y(l, 0, !1, l, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (l) { var d = l[0]; w[d] = new y(d, 1, !1, l[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (l) { w[l] = new y(l, 2, !1, l.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (l) { w[l] = new y(l, 2, !1, l, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (l) { w[l] = new y(l, 3, !1, l.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (l) { w[l] = new y(l, 3, !0, l, null, !1, !1) }), ["capture", "download"].forEach(function (l) { w[l] = new y(l, 4, !1, l, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (l) { w[l] = new y(l, 6, !1, l, null, !1, !1) }), ["rowSpan", "start"].forEach(function (l) { w[l] = new y(l, 5, !1, l.toLowerCase(), null, !1, !1) }); var T = /[\-:]([a-z])/g; function S(l) { return l[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (l) { var d = l.replace(T, S); w[d] = new y(d, 1, !1, l, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (l) { var d = l.replace(T, S); w[d] = new y(d, 1, !1, l, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (l) { var d = l.replace(T, S); w[d] = new y(d, 1, !1, l, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (l) { w[l] = new y(l, 1, !1, l.toLowerCase(), null, !1, !1) }), w.xlinkHref = new y("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (l) { w[l] = new y(l, 1, !1, l.toLowerCase(), null, !0, !0) }); function E(l, d, m, b) { var A = w.hasOwnProperty(d) ? w[d] : null; (A !== null ? A.type !== 0 : b || !(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (g(d, m, A, b) && (m = null), b || A === null ? p(d) && (m === null ? l.removeAttribute(d) : l.setAttribute(d, "" + m)) : A.mustUseProperty ? l[A.propertyName] = m === null ? A.type === 3 ? !1 : "" : m : (d = A.attributeName, b = A.attributeNamespace, m === null ? l.removeAttribute(d) : (A = A.type, m = A === 3 || A === 4 && m === !0 ? "" : "" + m, b ? l.setAttributeNS(b, d, m) : l.setAttribute(d, m)))) } var I = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, C = Symbol.for("react.element"), D = Symbol.for("react.portal"), R = Symbol.for("react.fragment"), N = Symbol.for("react.strict_mode"), P = Symbol.for("react.profiler"), _ = Symbol.for("react.provider"), M = Symbol.for("react.context"), $ = Symbol.for("react.forward_ref"), B = Symbol.for("react.suspense"), V = Symbol.for("react.suspense_list"), W = Symbol.for("react.memo"), U = Symbol.for("react.lazy"), q = Symbol.for("react.offscreen"), z = Symbol.iterator; function X(l) { return l === null || typeof l != "object" ? null : (l = z && l[z] || l["@@iterator"], typeof l == "function" ? l : null) } var Z = Object.assign, F; function H(l) {
      if (F === void 0) try { throw Error() } catch (m) { var d = m.stack.trim().match(/\n( *(at )?)/); F = d && d[1] || "" } return `
`+ F + l
    } var ae = !1; function he(l, d) {
      if (!l || ae) return ""; ae = !0; var m = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (d) if (d = function () { throw Error() }, Object.defineProperty(d.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(d, []) } catch (re) { var b = re } Reflect.construct(l, [], d) } else { try { d.call() } catch (re) { b = re } l.call(d.prototype) } else { try { throw Error() } catch (re) { b = re } l() } } catch (re) {
        if (re && b && typeof re.stack == "string") {
          for (var A = re.stack.split(`
`), L = b.stack.split(`
`), O = A.length - 1, G = L.length - 1; 1 <= O && 0 <= G && A[O] !== L[G];)G--; for (; 1 <= O && 0 <= G; O--, G--)if (A[O] !== L[G]) {
            if (O !== 1 || G !== 1) do if (O--, G--, 0 > G || A[O] !== L[G]) {
              var K = `
`+ A[O].replace(" at new ", " at "); return l.displayName && K.includes("<anonymous>") && (K = K.replace("<anonymous>", l.displayName)), K
            } while (1 <= O && 0 <= G); break
          }
        }
      } finally { ae = !1, Error.prepareStackTrace = m } return (l = l ? l.displayName || l.name : "") ? H(l) : ""
    } function de(l) { switch (l.tag) { case 5: return H(l.type); case 16: return H("Lazy"); case 13: return H("Suspense"); case 19: return H("SuspenseList"); case 0: case 2: case 15: return l = he(l.type, !1), l; case 11: return l = he(l.type.render, !1), l; case 1: return l = he(l.type, !0), l; default: return "" } } function pe(l) { if (l == null) return null; if (typeof l == "function") return l.displayName || l.name || null; if (typeof l == "string") return l; switch (l) { case R: return "Fragment"; case D: return "Portal"; case P: return "Profiler"; case N: return "StrictMode"; case B: return "Suspense"; case V: return "SuspenseList" }if (typeof l == "object") switch (l.$$typeof) { case M: return (l.displayName || "Context") + ".Consumer"; case _: return (l._context.displayName || "Context") + ".Provider"; case $: var d = l.render; return l = l.displayName, l || (l = d.displayName || d.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l; case W: return d = l.displayName || null, d !== null ? d : pe(l.type) || "Memo"; case U: d = l._payload, l = l._init; try { return pe(l(d)) } catch { } }return null } function Ce(l) { var d = l.type; switch (l.tag) { case 24: return "Cache"; case 9: return (d.displayName || "Context") + ".Consumer"; case 10: return (d._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return l = d.render, l = l.displayName || l.name || "", d.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return d; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return pe(d); case 8: return d === N ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof d == "function") return d.displayName || d.name || null; if (typeof d == "string") return d }return null } function Ie(l) { switch (typeof l) { case "boolean": case "number": case "string": case "undefined": return l; case "object": return l; default: return "" } } function Pe(l) { var d = l.type; return (l = l.nodeName) && l.toLowerCase() === "input" && (d === "checkbox" || d === "radio") } function Ve(l) { var d = Pe(l) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(l.constructor.prototype, d), b = "" + l[d]; if (!l.hasOwnProperty(d) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") { var A = m.get, L = m.set; return Object.defineProperty(l, d, { configurable: !0, get: function () { return A.call(this) }, set: function (O) { b = "" + O, L.call(this, O) } }), Object.defineProperty(l, d, { enumerable: m.enumerable }), { getValue: function () { return b }, setValue: function (O) { b = "" + O }, stopTracking: function () { l._valueTracker = null, delete l[d] } } } } function rt(l) { l._valueTracker || (l._valueTracker = Ve(l)) } function ft(l) { if (!l) return !1; var d = l._valueTracker; if (!d) return !0; var m = d.getValue(), b = ""; return l && (b = Pe(l) ? l.checked ? "true" : "false" : l.value), l = b, l !== m ? (d.setValue(l), !0) : !1 } function je(l) { if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null; try { return l.activeElement || l.body } catch { return l.body } } function Oe(l, d) { var m = d.checked; return Z({}, d, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: m ?? l._wrapperState.initialChecked }) } function ot(l, d) { var m = d.defaultValue == null ? "" : d.defaultValue, b = d.checked != null ? d.checked : d.defaultChecked; m = Ie(d.value != null ? d.value : m), l._wrapperState = { initialChecked: b, initialValue: m, controlled: d.type === "checkbox" || d.type === "radio" ? d.checked != null : d.value != null } } function Le(l, d) { d = d.checked, d != null && E(l, "checked", d, !1) } function ie(l, d) { Le(l, d); var m = Ie(d.value), b = d.type; if (m != null) b === "number" ? (m === 0 && l.value === "" || l.value != m) && (l.value = "" + m) : l.value !== "" + m && (l.value = "" + m); else if (b === "submit" || b === "reset") { l.removeAttribute("value"); return } d.hasOwnProperty("value") ? qe(l, d.type, m) : d.hasOwnProperty("defaultValue") && qe(l, d.type, Ie(d.defaultValue)), d.checked == null && d.defaultChecked != null && (l.defaultChecked = !!d.defaultChecked) } function _e(l, d, m) { if (d.hasOwnProperty("value") || d.hasOwnProperty("defaultValue")) { var b = d.type; if (!(b !== "submit" && b !== "reset" || d.value !== void 0 && d.value !== null)) return; d = "" + l._wrapperState.initialValue, m || d === l.value || (l.value = d), l.defaultValue = d } m = l.name, m !== "" && (l.name = ""), l.defaultChecked = !!l._wrapperState.initialChecked, m !== "" && (l.name = m) } function qe(l, d, m) { (d !== "number" || je(l.ownerDocument) !== l) && (m == null ? l.defaultValue = "" + l._wrapperState.initialValue : l.defaultValue !== "" + m && (l.defaultValue = "" + m)) } var Ze = Array.isArray; function vt(l, d, m, b) { if (l = l.options, d) { d = {}; for (var A = 0; A < m.length; A++)d["$" + m[A]] = !0; for (m = 0; m < l.length; m++)A = d.hasOwnProperty("$" + l[m].value), l[m].selected !== A && (l[m].selected = A), A && b && (l[m].defaultSelected = !0) } else { for (m = "" + Ie(m), d = null, A = 0; A < l.length; A++) { if (l[A].value === m) { l[A].selected = !0, b && (l[A].defaultSelected = !0); return } d !== null || l[A].disabled || (d = l[A]) } d !== null && (d.selected = !0) } } function Et(l, d) { if (d.dangerouslySetInnerHTML != null) throw Error(t(91)); return Z({}, d, { value: void 0, defaultValue: void 0, children: "" + l._wrapperState.initialValue }) } function _t(l, d) { var m = d.value; if (m == null) { if (m = d.children, d = d.defaultValue, m != null) { if (d != null) throw Error(t(92)); if (Ze(m)) { if (1 < m.length) throw Error(t(93)); m = m[0] } d = m } d == null && (d = ""), m = d } l._wrapperState = { initialValue: Ie(m) } } function dr(l, d) { var m = Ie(d.value), b = Ie(d.defaultValue); m != null && (m = "" + m, m !== l.value && (l.value = m), d.defaultValue == null && l.defaultValue !== m && (l.defaultValue = m)), b != null && (l.defaultValue = "" + b) } function Gr(l) { var d = l.textContent; d === l._wrapperState.initialValue && d !== "" && d !== null && (l.value = d) } function Zt(l) { switch (l) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Fn(l, d) { return l == null || l === "http://www.w3.org/1999/xhtml" ? Zt(d) : l === "http://www.w3.org/2000/svg" && d === "foreignObject" ? "http://www.w3.org/1999/xhtml" : l } var $n, Ts = (function (l) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (d, m, b, A) { MSApp.execUnsafeLocalFunction(function () { return l(d, m, b, A) }) } : l })(function (l, d) { if (l.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in l) l.innerHTML = d; else { for ($n = $n || document.createElement("div"), $n.innerHTML = "<svg>" + d.valueOf().toString() + "</svg>", d = $n.firstChild; l.firstChild;)l.removeChild(l.firstChild); for (; d.firstChild;)l.appendChild(d.firstChild) } }); function Hr(l, d) { if (d) { var m = l.firstChild; if (m && m === l.lastChild && m.nodeType === 3) { m.nodeValue = d; return } } l.textContent = d } var fr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Xc = ["Webkit", "ms", "Moz", "O"]; Object.keys(fr).forEach(function (l) { Xc.forEach(function (d) { d = d + l.charAt(0).toUpperCase() + l.substring(1), fr[d] = fr[l] }) }); function go(l, d, m) { return d == null || typeof d == "boolean" || d === "" ? "" : m || typeof d != "number" || d === 0 || fr.hasOwnProperty(l) && fr[l] ? ("" + d).trim() : d + "px" } function xo(l, d) { l = l.style; for (var m in d) if (d.hasOwnProperty(m)) { var b = m.indexOf("--") === 0, A = go(m, d[m], b); m === "float" && (m = "cssFloat"), b ? l.setProperty(m, A) : l[m] = A } } var Qc = Z({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Ki(l, d) { if (d) { if (Qc[l] && (d.children != null || d.dangerouslySetInnerHTML != null)) throw Error(t(137, l)); if (d.dangerouslySetInnerHTML != null) { if (d.children != null) throw Error(t(60)); if (typeof d.dangerouslySetInnerHTML != "object" || !("__html" in d.dangerouslySetInnerHTML)) throw Error(t(61)) } if (d.style != null && typeof d.style != "object") throw Error(t(62)) } } function qi(l, d) { if (l.indexOf("-") === -1) return typeof d.is == "string"; switch (l) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Yi = null; function Ue(l) { return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l } var Zc = null, Js = null, ei = null; function Mp(l) { if (l = xa(l)) { if (typeof Zc != "function") throw Error(t(280)); var d = l.stateNode; d && (d = Bo(d), Zc(l.stateNode, l.type, d)) } } function jp(l) { Js ? ei ? ei.push(l) : ei = [l] : Js = l } function Fp() { if (Js) { var l = Js, d = ei; if (ei = Js = null, Mp(l), d) for (l = 0; l < d.length; l++)Mp(d[l]) } } function $p(l, d) { return l(d) } function Bp() { } var Jc = !1; function Up(l, d, m) { if (Jc) return l(d, m); Jc = !0; try { return $p(l, d, m) } finally { Jc = !1, (Js !== null || ei !== null) && (Bp(), Fp()) } } function Xi(l, d) { var m = l.stateNode; if (m === null) return null; var b = Bo(m); if (b === null) return null; m = b[d]; e: switch (d) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (b = !b.disabled) || (l = l.type, b = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !b; break e; default: l = !1 }if (l) return null; if (m && typeof m != "function") throw Error(t(231, d, typeof m)); return m } var eu = !1; if (o) try { var Qi = {}; Object.defineProperty(Qi, "passive", { get: function () { eu = !0 } }), window.addEventListener("test", Qi, Qi), window.removeEventListener("test", Qi, Qi) } catch { eu = !1 } function nS(l, d, m, b, A, L, O, G, K) { var re = Array.prototype.slice.call(arguments, 3); try { d.apply(m, re) } catch (le) { this.onError(le) } } var Zi = !1, vo = null, yo = !1, tu = null, sS = { onError: function (l) { Zi = !0, vo = l } }; function iS(l, d, m, b, A, L, O, G, K) { Zi = !1, vo = null, nS.apply(sS, arguments) } function aS(l, d, m, b, A, L, O, G, K) { if (iS.apply(this, arguments), Zi) { if (Zi) { var re = vo; Zi = !1, vo = null } else throw Error(t(198)); yo || (yo = !0, tu = re) } } function As(l) { var d = l, m = l; if (l.alternate) for (; d.return;)d = d.return; else { l = d; do d = l, (d.flags & 4098) !== 0 && (m = d.return), l = d.return; while (l) } return d.tag === 3 ? m : null } function zp(l) { if (l.tag === 13) { var d = l.memoizedState; if (d === null && (l = l.alternate, l !== null && (d = l.memoizedState)), d !== null) return d.dehydrated } return null } function Vp(l) { if (As(l) !== l) throw Error(t(188)) } function oS(l) { var d = l.alternate; if (!d) { if (d = As(l), d === null) throw Error(t(188)); return d !== l ? null : l } for (var m = l, b = d; ;) { var A = m.return; if (A === null) break; var L = A.alternate; if (L === null) { if (b = A.return, b !== null) { m = b; continue } break } if (A.child === L.child) { for (L = A.child; L;) { if (L === m) return Vp(A), l; if (L === b) return Vp(A), d; L = L.sibling } throw Error(t(188)) } if (m.return !== b.return) m = A, b = L; else { for (var O = !1, G = A.child; G;) { if (G === m) { O = !0, m = A, b = L; break } if (G === b) { O = !0, b = A, m = L; break } G = G.sibling } if (!O) { for (G = L.child; G;) { if (G === m) { O = !0, m = L, b = A; break } if (G === b) { O = !0, b = L, m = A; break } G = G.sibling } if (!O) throw Error(t(189)) } } if (m.alternate !== b) throw Error(t(190)) } if (m.tag !== 3) throw Error(t(188)); return m.stateNode.current === m ? l : d } function Gp(l) { return l = oS(l), l !== null ? Hp(l) : null } function Hp(l) { if (l.tag === 5 || l.tag === 6) return l; for (l = l.child; l !== null;) { var d = Hp(l); if (d !== null) return d; l = l.sibling } return null } var Wp = e.unstable_scheduleCallback, Kp = e.unstable_cancelCallback, lS = e.unstable_shouldYield, cS = e.unstable_requestPaint, wt = e.unstable_now, uS = e.unstable_getCurrentPriorityLevel, ru = e.unstable_ImmediatePriority, qp = e.unstable_UserBlockingPriority, bo = e.unstable_NormalPriority, dS = e.unstable_LowPriority, Yp = e.unstable_IdlePriority, wo = null, Wr = null; function fS(l) { if (Wr && typeof Wr.onCommitFiberRoot == "function") try { Wr.onCommitFiberRoot(wo, l, void 0, (l.current.flags & 128) === 128) } catch { } } var Nr = Math.clz32 ? Math.clz32 : mS, hS = Math.log, pS = Math.LN2; function mS(l) { return l >>>= 0, l === 0 ? 32 : 31 - (hS(l) / pS | 0) | 0 } var So = 64, Eo = 4194304; function Ji(l) { switch (l & -l) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return l & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return l & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return l } } function To(l, d) { var m = l.pendingLanes; if (m === 0) return 0; var b = 0, A = l.suspendedLanes, L = l.pingedLanes, O = m & 268435455; if (O !== 0) { var G = O & ~A; G !== 0 ? b = Ji(G) : (L &= O, L !== 0 && (b = Ji(L))) } else O = m & ~A, O !== 0 ? b = Ji(O) : L !== 0 && (b = Ji(L)); if (b === 0) return 0; if (d !== 0 && d !== b && (d & A) === 0 && (A = b & -b, L = d & -d, A >= L || A === 16 && (L & 4194240) !== 0)) return d; if ((b & 4) !== 0 && (b |= m & 16), d = l.entangledLanes, d !== 0) for (l = l.entanglements, d &= b; 0 < d;)m = 31 - Nr(d), A = 1 << m, b |= l[m], d &= ~A; return b } function gS(l, d) { switch (l) { case 1: case 2: case 4: return d + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return d + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function xS(l, d) { for (var m = l.suspendedLanes, b = l.pingedLanes, A = l.expirationTimes, L = l.pendingLanes; 0 < L;) { var O = 31 - Nr(L), G = 1 << O, K = A[O]; K === -1 ? ((G & m) === 0 || (G & b) !== 0) && (A[O] = gS(G, d)) : K <= d && (l.expiredLanes |= G), L &= ~G } } function nu(l) { return l = l.pendingLanes & -1073741825, l !== 0 ? l : l & 1073741824 ? 1073741824 : 0 } function Xp() { var l = So; return So <<= 1, (So & 4194240) === 0 && (So = 64), l } function su(l) { for (var d = [], m = 0; 31 > m; m++)d.push(l); return d } function ea(l, d, m) { l.pendingLanes |= d, d !== 536870912 && (l.suspendedLanes = 0, l.pingedLanes = 0), l = l.eventTimes, d = 31 - Nr(d), l[d] = m } function vS(l, d) { var m = l.pendingLanes & ~d; l.pendingLanes = d, l.suspendedLanes = 0, l.pingedLanes = 0, l.expiredLanes &= d, l.mutableReadLanes &= d, l.entangledLanes &= d, d = l.entanglements; var b = l.eventTimes; for (l = l.expirationTimes; 0 < m;) { var A = 31 - Nr(m), L = 1 << A; d[A] = 0, b[A] = -1, l[A] = -1, m &= ~L } } function iu(l, d) { var m = l.entangledLanes |= d; for (l = l.entanglements; m;) { var b = 31 - Nr(m), A = 1 << b; A & d | l[b] & d && (l[b] |= d), m &= ~A } } var Je = 0; function Qp(l) { return l &= -l, 1 < l ? 4 < l ? (l & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var Zp, au, Jp, em, tm, ou = !1, Ao = [], Bn = null, Un = null, zn = null, ta = new Map, ra = new Map, Vn = [], yS = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function rm(l, d) { switch (l) { case "focusin": case "focusout": Bn = null; break; case "dragenter": case "dragleave": Un = null; break; case "mouseover": case "mouseout": zn = null; break; case "pointerover": case "pointerout": ta.delete(d.pointerId); break; case "gotpointercapture": case "lostpointercapture": ra.delete(d.pointerId) } } function na(l, d, m, b, A, L) { return l === null || l.nativeEvent !== L ? (l = { blockedOn: d, domEventName: m, eventSystemFlags: b, nativeEvent: L, targetContainers: [A] }, d !== null && (d = xa(d), d !== null && au(d)), l) : (l.eventSystemFlags |= b, d = l.targetContainers, A !== null && d.indexOf(A) === -1 && d.push(A), l) } function bS(l, d, m, b, A) { switch (d) { case "focusin": return Bn = na(Bn, l, d, m, b, A), !0; case "dragenter": return Un = na(Un, l, d, m, b, A), !0; case "mouseover": return zn = na(zn, l, d, m, b, A), !0; case "pointerover": var L = A.pointerId; return ta.set(L, na(ta.get(L) || null, l, d, m, b, A)), !0; case "gotpointercapture": return L = A.pointerId, ra.set(L, na(ra.get(L) || null, l, d, m, b, A)), !0 }return !1 } function nm(l) { var d = Is(l.target); if (d !== null) { var m = As(d); if (m !== null) { if (d = m.tag, d === 13) { if (d = zp(m), d !== null) { l.blockedOn = d, tm(l.priority, function () { Jp(m) }); return } } else if (d === 3 && m.stateNode.current.memoizedState.isDehydrated) { l.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null; return } } } l.blockedOn = null } function Io(l) { if (l.blockedOn !== null) return !1; for (var d = l.targetContainers; 0 < d.length;) { var m = cu(l.domEventName, l.eventSystemFlags, d[0], l.nativeEvent); if (m === null) { m = l.nativeEvent; var b = new m.constructor(m.type, m); Yi = b, m.target.dispatchEvent(b), Yi = null } else return d = xa(m), d !== null && au(d), l.blockedOn = m, !1; d.shift() } return !0 } function sm(l, d, m) { Io(l) && m.delete(d) } function wS() { ou = !1, Bn !== null && Io(Bn) && (Bn = null), Un !== null && Io(Un) && (Un = null), zn !== null && Io(zn) && (zn = null), ta.forEach(sm), ra.forEach(sm) } function sa(l, d) { l.blockedOn === d && (l.blockedOn = null, ou || (ou = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, wS))) } function ia(l) { function d(A) { return sa(A, l) } if (0 < Ao.length) { sa(Ao[0], l); for (var m = 1; m < Ao.length; m++) { var b = Ao[m]; b.blockedOn === l && (b.blockedOn = null) } } for (Bn !== null && sa(Bn, l), Un !== null && sa(Un, l), zn !== null && sa(zn, l), ta.forEach(d), ra.forEach(d), m = 0; m < Vn.length; m++)b = Vn[m], b.blockedOn === l && (b.blockedOn = null); for (; 0 < Vn.length && (m = Vn[0], m.blockedOn === null);)nm(m), m.blockedOn === null && Vn.shift() } var ti = I.ReactCurrentBatchConfig, Lo = !0; function SS(l, d, m, b) { var A = Je, L = ti.transition; ti.transition = null; try { Je = 1, lu(l, d, m, b) } finally { Je = A, ti.transition = L } } function ES(l, d, m, b) { var A = Je, L = ti.transition; ti.transition = null; try { Je = 4, lu(l, d, m, b) } finally { Je = A, ti.transition = L } } function lu(l, d, m, b) { if (Lo) { var A = cu(l, d, m, b); if (A === null) Iu(l, d, b, Co, m), rm(l, b); else if (bS(A, l, d, m, b)) b.stopPropagation(); else if (rm(l, b), d & 4 && -1 < yS.indexOf(l)) { for (; A !== null;) { var L = xa(A); if (L !== null && Zp(L), L = cu(l, d, m, b), L === null && Iu(l, d, b, Co, m), L === A) break; A = L } A !== null && b.stopPropagation() } else Iu(l, d, b, null, m) } } var Co = null; function cu(l, d, m, b) { if (Co = null, l = Ue(b), l = Is(l), l !== null) if (d = As(l), d === null) l = null; else if (m = d.tag, m === 13) { if (l = zp(d), l !== null) return l; l = null } else if (m === 3) { if (d.stateNode.current.memoizedState.isDehydrated) return d.tag === 3 ? d.stateNode.containerInfo : null; l = null } else d !== l && (l = null); return Co = l, null } function im(l) { switch (l) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (uS()) { case ru: return 1; case qp: return 4; case bo: case dS: return 16; case Yp: return 536870912; default: return 16 }default: return 16 } } var Gn = null, uu = null, ko = null; function am() { if (ko) return ko; var l, d = uu, m = d.length, b, A = "value" in Gn ? Gn.value : Gn.textContent, L = A.length; for (l = 0; l < m && d[l] === A[l]; l++); var O = m - l; for (b = 1; b <= O && d[m - b] === A[L - b]; b++); return ko = A.slice(l, 1 < b ? 1 - b : void 0) } function Ro(l) { var d = l.keyCode; return "charCode" in l ? (l = l.charCode, l === 0 && d === 13 && (l = 13)) : l = d, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0 } function _o() { return !0 } function om() { return !1 } function hr(l) { function d(m, b, A, L, O) { this._reactName = m, this._targetInst = A, this.type = b, this.nativeEvent = L, this.target = O, this.currentTarget = null; for (var G in l) l.hasOwnProperty(G) && (m = l[G], this[G] = m ? m(L) : L[G]); return this.isDefaultPrevented = (L.defaultPrevented != null ? L.defaultPrevented : L.returnValue === !1) ? _o : om, this.isPropagationStopped = om, this } return Z(d.prototype, { preventDefault: function () { this.defaultPrevented = !0; var m = this.nativeEvent; m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = _o) }, stopPropagation: function () { var m = this.nativeEvent; m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = _o) }, persist: function () { }, isPersistent: _o }), d } var ri = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (l) { return l.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, du = hr(ri), aa = Z({}, ri, { view: 0, detail: 0 }), TS = hr(aa), fu, hu, oa, Po = Z({}, aa, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: mu, button: 0, buttons: 0, relatedTarget: function (l) { return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget }, movementX: function (l) { return "movementX" in l ? l.movementX : (l !== oa && (oa && l.type === "mousemove" ? (fu = l.screenX - oa.screenX, hu = l.screenY - oa.screenY) : hu = fu = 0, oa = l), fu) }, movementY: function (l) { return "movementY" in l ? l.movementY : hu } }), lm = hr(Po), AS = Z({}, Po, { dataTransfer: 0 }), IS = hr(AS), LS = Z({}, aa, { relatedTarget: 0 }), pu = hr(LS), CS = Z({}, ri, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), kS = hr(CS), RS = Z({}, ri, { clipboardData: function (l) { return "clipboardData" in l ? l.clipboardData : window.clipboardData } }), _S = hr(RS), PS = Z({}, ri, { data: 0 }), cm = hr(PS), NS = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, DS = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, OS = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function MS(l) { var d = this.nativeEvent; return d.getModifierState ? d.getModifierState(l) : (l = OS[l]) ? !!d[l] : !1 } function mu() { return MS } var jS = Z({}, aa, { key: function (l) { if (l.key) { var d = NS[l.key] || l.key; if (d !== "Unidentified") return d } return l.type === "keypress" ? (l = Ro(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? DS[l.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: mu, charCode: function (l) { return l.type === "keypress" ? Ro(l) : 0 }, keyCode: function (l) { return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0 }, which: function (l) { return l.type === "keypress" ? Ro(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0 } }), FS = hr(jS), $S = Z({}, Po, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), um = hr($S), BS = Z({}, aa, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: mu }), US = hr(BS), zS = Z({}, ri, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), VS = hr(zS), GS = Z({}, Po, { deltaX: function (l) { return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0 }, deltaY: function (l) { return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), HS = hr(GS), WS = [9, 13, 27, 32], gu = o && "CompositionEvent" in window, la = null; o && "documentMode" in document && (la = document.documentMode); var KS = o && "TextEvent" in window && !la, dm = o && (!gu || la && 8 < la && 11 >= la), fm = " ", hm = !1; function pm(l, d) { switch (l) { case "keyup": return WS.indexOf(d.keyCode) !== -1; case "keydown": return d.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function mm(l) { return l = l.detail, typeof l == "object" && "data" in l ? l.data : null } var ni = !1; function qS(l, d) { switch (l) { case "compositionend": return mm(d); case "keypress": return d.which !== 32 ? null : (hm = !0, fm); case "textInput": return l = d.data, l === fm && hm ? null : l; default: return null } } function YS(l, d) { if (ni) return l === "compositionend" || !gu && pm(l, d) ? (l = am(), ko = uu = Gn = null, ni = !1, l) : null; switch (l) { case "paste": return null; case "keypress": if (!(d.ctrlKey || d.altKey || d.metaKey) || d.ctrlKey && d.altKey) { if (d.char && 1 < d.char.length) return d.char; if (d.which) return String.fromCharCode(d.which) } return null; case "compositionend": return dm && d.locale !== "ko" ? null : d.data; default: return null } } var XS = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function gm(l) { var d = l && l.nodeName && l.nodeName.toLowerCase(); return d === "input" ? !!XS[l.type] : d === "textarea" } function xm(l, d, m, b) { jp(b), d = jo(d, "onChange"), 0 < d.length && (m = new du("onChange", "change", null, m, b), l.push({ event: m, listeners: d })) } var ca = null, ua = null; function QS(l) { Om(l, 0) } function No(l) { var d = li(l); if (ft(d)) return l } function ZS(l, d) { if (l === "change") return d } var vm = !1; if (o) { var xu; if (o) { var vu = "oninput" in document; if (!vu) { var ym = document.createElement("div"); ym.setAttribute("oninput", "return;"), vu = typeof ym.oninput == "function" } xu = vu } else xu = !1; vm = xu && (!document.documentMode || 9 < document.documentMode) } function bm() { ca && (ca.detachEvent("onpropertychange", wm), ua = ca = null) } function wm(l) { if (l.propertyName === "value" && No(ua)) { var d = []; xm(d, ua, l, Ue(l)), Up(QS, d) } } function JS(l, d, m) { l === "focusin" ? (bm(), ca = d, ua = m, ca.attachEvent("onpropertychange", wm)) : l === "focusout" && bm() } function e2(l) { if (l === "selectionchange" || l === "keyup" || l === "keydown") return No(ua) } function t2(l, d) { if (l === "click") return No(d) } function r2(l, d) { if (l === "input" || l === "change") return No(d) } function n2(l, d) { return l === d && (l !== 0 || 1 / l === 1 / d) || l !== l && d !== d } var Dr = typeof Object.is == "function" ? Object.is : n2; function da(l, d) { if (Dr(l, d)) return !0; if (typeof l != "object" || l === null || typeof d != "object" || d === null) return !1; var m = Object.keys(l), b = Object.keys(d); if (m.length !== b.length) return !1; for (b = 0; b < m.length; b++) { var A = m[b]; if (!c.call(d, A) || !Dr(l[A], d[A])) return !1 } return !0 } function Sm(l) { for (; l && l.firstChild;)l = l.firstChild; return l } function Em(l, d) { var m = Sm(l); l = 0; for (var b; m;) { if (m.nodeType === 3) { if (b = l + m.textContent.length, l <= d && b >= d) return { node: m, offset: d - l }; l = b } e: { for (; m;) { if (m.nextSibling) { m = m.nextSibling; break e } m = m.parentNode } m = void 0 } m = Sm(m) } } function Tm(l, d) { return l && d ? l === d ? !0 : l && l.nodeType === 3 ? !1 : d && d.nodeType === 3 ? Tm(l, d.parentNode) : "contains" in l ? l.contains(d) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(d) & 16) : !1 : !1 } function Am() { for (var l = window, d = je(); d instanceof l.HTMLIFrameElement;) { try { var m = typeof d.contentWindow.location.href == "string" } catch { m = !1 } if (m) l = d.contentWindow; else break; d = je(l.document) } return d } function yu(l) { var d = l && l.nodeName && l.nodeName.toLowerCase(); return d && (d === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || d === "textarea" || l.contentEditable === "true") } function s2(l) { var d = Am(), m = l.focusedElem, b = l.selectionRange; if (d !== m && m && m.ownerDocument && Tm(m.ownerDocument.documentElement, m)) { if (b !== null && yu(m)) { if (d = b.start, l = b.end, l === void 0 && (l = d), "selectionStart" in m) m.selectionStart = d, m.selectionEnd = Math.min(l, m.value.length); else if (l = (d = m.ownerDocument || document) && d.defaultView || window, l.getSelection) { l = l.getSelection(); var A = m.textContent.length, L = Math.min(b.start, A); b = b.end === void 0 ? L : Math.min(b.end, A), !l.extend && L > b && (A = b, b = L, L = A), A = Em(m, L); var O = Em(m, b); A && O && (l.rangeCount !== 1 || l.anchorNode !== A.node || l.anchorOffset !== A.offset || l.focusNode !== O.node || l.focusOffset !== O.offset) && (d = d.createRange(), d.setStart(A.node, A.offset), l.removeAllRanges(), L > b ? (l.addRange(d), l.extend(O.node, O.offset)) : (d.setEnd(O.node, O.offset), l.addRange(d))) } } for (d = [], l = m; l = l.parentNode;)l.nodeType === 1 && d.push({ element: l, left: l.scrollLeft, top: l.scrollTop }); for (typeof m.focus == "function" && m.focus(), m = 0; m < d.length; m++)l = d[m], l.element.scrollLeft = l.left, l.element.scrollTop = l.top } } var i2 = o && "documentMode" in document && 11 >= document.documentMode, si = null, bu = null, fa = null, wu = !1; function Im(l, d, m) { var b = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument; wu || si == null || si !== je(b) || (b = si, "selectionStart" in b && yu(b) ? b = { start: b.selectionStart, end: b.selectionEnd } : (b = (b.ownerDocument && b.ownerDocument.defaultView || window).getSelection(), b = { anchorNode: b.anchorNode, anchorOffset: b.anchorOffset, focusNode: b.focusNode, focusOffset: b.focusOffset }), fa && da(fa, b) || (fa = b, b = jo(bu, "onSelect"), 0 < b.length && (d = new du("onSelect", "select", null, d, m), l.push({ event: d, listeners: b }), d.target = si))) } function Do(l, d) { var m = {}; return m[l.toLowerCase()] = d.toLowerCase(), m["Webkit" + l] = "webkit" + d, m["Moz" + l] = "moz" + d, m } var ii = { animationend: Do("Animation", "AnimationEnd"), animationiteration: Do("Animation", "AnimationIteration"), animationstart: Do("Animation", "AnimationStart"), transitionend: Do("Transition", "TransitionEnd") }, Su = {}, Lm = {}; o && (Lm = document.createElement("div").style, "AnimationEvent" in window || (delete ii.animationend.animation, delete ii.animationiteration.animation, delete ii.animationstart.animation), "TransitionEvent" in window || delete ii.transitionend.transition); function Oo(l) { if (Su[l]) return Su[l]; if (!ii[l]) return l; var d = ii[l], m; for (m in d) if (d.hasOwnProperty(m) && m in Lm) return Su[l] = d[m]; return l } var Cm = Oo("animationend"), km = Oo("animationiteration"), Rm = Oo("animationstart"), _m = Oo("transitionend"), Pm = new Map, Nm = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Hn(l, d) { Pm.set(l, d), i(d, [l]) } for (var Eu = 0; Eu < Nm.length; Eu++) { var Tu = Nm[Eu], a2 = Tu.toLowerCase(), o2 = Tu[0].toUpperCase() + Tu.slice(1); Hn(a2, "on" + o2) } Hn(Cm, "onAnimationEnd"), Hn(km, "onAnimationIteration"), Hn(Rm, "onAnimationStart"), Hn("dblclick", "onDoubleClick"), Hn("focusin", "onFocus"), Hn("focusout", "onBlur"), Hn(_m, "onTransitionEnd"), a("onMouseEnter", ["mouseout", "mouseover"]), a("onMouseLeave", ["mouseout", "mouseover"]), a("onPointerEnter", ["pointerout", "pointerover"]), a("onPointerLeave", ["pointerout", "pointerover"]), i("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), i("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), i("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), i("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), i("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), i("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ha = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), l2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(ha)); function Dm(l, d, m) { var b = l.type || "unknown-event"; l.currentTarget = m, aS(b, d, void 0, l), l.currentTarget = null } function Om(l, d) { d = (d & 4) !== 0; for (var m = 0; m < l.length; m++) { var b = l[m], A = b.event; b = b.listeners; e: { var L = void 0; if (d) for (var O = b.length - 1; 0 <= O; O--) { var G = b[O], K = G.instance, re = G.currentTarget; if (G = G.listener, K !== L && A.isPropagationStopped()) break e; Dm(A, G, re), L = K } else for (O = 0; O < b.length; O++) { if (G = b[O], K = G.instance, re = G.currentTarget, G = G.listener, K !== L && A.isPropagationStopped()) break e; Dm(A, G, re), L = K } } } if (yo) throw l = tu, yo = !1, tu = null, l } function lt(l, d) { var m = d[Pu]; m === void 0 && (m = d[Pu] = new Set); var b = l + "__bubble"; m.has(b) || (Mm(d, l, 2, !1), m.add(b)) } function Au(l, d, m) { var b = 0; d && (b |= 4), Mm(m, l, b, d) } var Mo = "_reactListening" + Math.random().toString(36).slice(2); function pa(l) { if (!l[Mo]) { l[Mo] = !0, r.forEach(function (m) { m !== "selectionchange" && (l2.has(m) || Au(m, !1, l), Au(m, !0, l)) }); var d = l.nodeType === 9 ? l : l.ownerDocument; d === null || d[Mo] || (d[Mo] = !0, Au("selectionchange", !1, d)) } } function Mm(l, d, m, b) { switch (im(d)) { case 1: var A = SS; break; case 4: A = ES; break; default: A = lu }m = A.bind(null, d, m, l), A = void 0, !eu || d !== "touchstart" && d !== "touchmove" && d !== "wheel" || (A = !0), b ? A !== void 0 ? l.addEventListener(d, m, { capture: !0, passive: A }) : l.addEventListener(d, m, !0) : A !== void 0 ? l.addEventListener(d, m, { passive: A }) : l.addEventListener(d, m, !1) } function Iu(l, d, m, b, A) { var L = b; if ((d & 1) === 0 && (d & 2) === 0 && b !== null) e: for (; ;) { if (b === null) return; var O = b.tag; if (O === 3 || O === 4) { var G = b.stateNode.containerInfo; if (G === A || G.nodeType === 8 && G.parentNode === A) break; if (O === 4) for (O = b.return; O !== null;) { var K = O.tag; if ((K === 3 || K === 4) && (K = O.stateNode.containerInfo, K === A || K.nodeType === 8 && K.parentNode === A)) return; O = O.return } for (; G !== null;) { if (O = Is(G), O === null) return; if (K = O.tag, K === 5 || K === 6) { b = L = O; continue e } G = G.parentNode } } b = b.return } Up(function () { var re = L, le = Ue(m), ce = []; e: { var oe = Pm.get(l); if (oe !== void 0) { var xe = du, be = l; switch (l) { case "keypress": if (Ro(m) === 0) break e; case "keydown": case "keyup": xe = FS; break; case "focusin": be = "focus", xe = pu; break; case "focusout": be = "blur", xe = pu; break; case "beforeblur": case "afterblur": xe = pu; break; case "click": if (m.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": xe = lm; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": xe = IS; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": xe = US; break; case Cm: case km: case Rm: xe = kS; break; case _m: xe = VS; break; case "scroll": xe = TS; break; case "wheel": xe = HS; break; case "copy": case "cut": case "paste": xe = _S; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": xe = um }var we = (d & 4) !== 0, St = !we && l === "scroll", ee = we ? oe !== null ? oe + "Capture" : null : oe; we = []; for (var Y = re, te; Y !== null;) { te = Y; var fe = te.stateNode; if (te.tag === 5 && fe !== null && (te = fe, ee !== null && (fe = Xi(Y, ee), fe != null && we.push(ma(Y, fe, te)))), St) break; Y = Y.return } 0 < we.length && (oe = new xe(oe, be, null, m, le), ce.push({ event: oe, listeners: we })) } } if ((d & 7) === 0) { e: { if (oe = l === "mouseover" || l === "pointerover", xe = l === "mouseout" || l === "pointerout", oe && m !== Yi && (be = m.relatedTarget || m.fromElement) && (Is(be) || be[mn])) break e; if ((xe || oe) && (oe = le.window === le ? le : (oe = le.ownerDocument) ? oe.defaultView || oe.parentWindow : window, xe ? (be = m.relatedTarget || m.toElement, xe = re, be = be ? Is(be) : null, be !== null && (St = As(be), be !== St || be.tag !== 5 && be.tag !== 6) && (be = null)) : (xe = null, be = re), xe !== be)) { if (we = lm, fe = "onMouseLeave", ee = "onMouseEnter", Y = "mouse", (l === "pointerout" || l === "pointerover") && (we = um, fe = "onPointerLeave", ee = "onPointerEnter", Y = "pointer"), St = xe == null ? oe : li(xe), te = be == null ? oe : li(be), oe = new we(fe, Y + "leave", xe, m, le), oe.target = St, oe.relatedTarget = te, fe = null, Is(le) === re && (we = new we(ee, Y + "enter", be, m, le), we.target = te, we.relatedTarget = St, fe = we), St = fe, xe && be) t: { for (we = xe, ee = be, Y = 0, te = we; te; te = ai(te))Y++; for (te = 0, fe = ee; fe; fe = ai(fe))te++; for (; 0 < Y - te;)we = ai(we), Y--; for (; 0 < te - Y;)ee = ai(ee), te--; for (; Y--;) { if (we === ee || ee !== null && we === ee.alternate) break t; we = ai(we), ee = ai(ee) } we = null } else we = null; xe !== null && jm(ce, oe, xe, we, !1), be !== null && St !== null && jm(ce, St, be, we, !0) } } e: { if (oe = re ? li(re) : window, xe = oe.nodeName && oe.nodeName.toLowerCase(), xe === "select" || xe === "input" && oe.type === "file") var Te = ZS; else if (gm(oe)) if (vm) Te = r2; else { Te = e2; var ke = JS } else (xe = oe.nodeName) && xe.toLowerCase() === "input" && (oe.type === "checkbox" || oe.type === "radio") && (Te = t2); if (Te && (Te = Te(l, re))) { xm(ce, Te, m, le); break e } ke && ke(l, oe, re), l === "focusout" && (ke = oe._wrapperState) && ke.controlled && oe.type === "number" && qe(oe, "number", oe.value) } switch (ke = re ? li(re) : window, l) { case "focusin": (gm(ke) || ke.contentEditable === "true") && (si = ke, bu = re, fa = null); break; case "focusout": fa = bu = si = null; break; case "mousedown": wu = !0; break; case "contextmenu": case "mouseup": case "dragend": wu = !1, Im(ce, m, le); break; case "selectionchange": if (i2) break; case "keydown": case "keyup": Im(ce, m, le) }var Re; if (gu) e: { switch (l) { case "compositionstart": var Ne = "onCompositionStart"; break e; case "compositionend": Ne = "onCompositionEnd"; break e; case "compositionupdate": Ne = "onCompositionUpdate"; break e }Ne = void 0 } else ni ? pm(l, m) && (Ne = "onCompositionEnd") : l === "keydown" && m.keyCode === 229 && (Ne = "onCompositionStart"); Ne && (dm && m.locale !== "ko" && (ni || Ne !== "onCompositionStart" ? Ne === "onCompositionEnd" && ni && (Re = am()) : (Gn = le, uu = "value" in Gn ? Gn.value : Gn.textContent, ni = !0)), ke = jo(re, Ne), 0 < ke.length && (Ne = new cm(Ne, l, null, m, le), ce.push({ event: Ne, listeners: ke }), Re ? Ne.data = Re : (Re = mm(m), Re !== null && (Ne.data = Re)))), (Re = KS ? qS(l, m) : YS(l, m)) && (re = jo(re, "onBeforeInput"), 0 < re.length && (le = new cm("onBeforeInput", "beforeinput", null, m, le), ce.push({ event: le, listeners: re }), le.data = Re)) } Om(ce, d) }) } function ma(l, d, m) { return { instance: l, listener: d, currentTarget: m } } function jo(l, d) { for (var m = d + "Capture", b = []; l !== null;) { var A = l, L = A.stateNode; A.tag === 5 && L !== null && (A = L, L = Xi(l, m), L != null && b.unshift(ma(l, L, A)), L = Xi(l, d), L != null && b.push(ma(l, L, A))), l = l.return } return b } function ai(l) { if (l === null) return null; do l = l.return; while (l && l.tag !== 5); return l || null } function jm(l, d, m, b, A) { for (var L = d._reactName, O = []; m !== null && m !== b;) { var G = m, K = G.alternate, re = G.stateNode; if (K !== null && K === b) break; G.tag === 5 && re !== null && (G = re, A ? (K = Xi(m, L), K != null && O.unshift(ma(m, K, G))) : A || (K = Xi(m, L), K != null && O.push(ma(m, K, G)))), m = m.return } O.length !== 0 && l.push({ event: d, listeners: O }) } var c2 = /\r\n?/g, u2 = /\u0000|\uFFFD/g; function Fm(l) {
      return (typeof l == "string" ? l : "" + l).replace(c2, `
`).replace(u2, "")
    } function Fo(l, d, m) { if (d = Fm(d), Fm(l) !== d && m) throw Error(t(425)) } function $o() { } var Lu = null, Cu = null; function ku(l, d) { return l === "textarea" || l === "noscript" || typeof d.children == "string" || typeof d.children == "number" || typeof d.dangerouslySetInnerHTML == "object" && d.dangerouslySetInnerHTML !== null && d.dangerouslySetInnerHTML.__html != null } var Ru = typeof setTimeout == "function" ? setTimeout : void 0, d2 = typeof clearTimeout == "function" ? clearTimeout : void 0, $m = typeof Promise == "function" ? Promise : void 0, f2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof $m < "u" ? function (l) { return $m.resolve(null).then(l).catch(h2) } : Ru; function h2(l) { setTimeout(function () { throw l }) } function _u(l, d) { var m = d, b = 0; do { var A = m.nextSibling; if (l.removeChild(m), A && A.nodeType === 8) if (m = A.data, m === "/$") { if (b === 0) { l.removeChild(A), ia(d); return } b-- } else m !== "$" && m !== "$?" && m !== "$!" || b++; m = A } while (m); ia(d) } function Wn(l) { for (; l != null; l = l.nextSibling) { var d = l.nodeType; if (d === 1 || d === 3) break; if (d === 8) { if (d = l.data, d === "$" || d === "$!" || d === "$?") break; if (d === "/$") return null } } return l } function Bm(l) { l = l.previousSibling; for (var d = 0; l;) { if (l.nodeType === 8) { var m = l.data; if (m === "$" || m === "$!" || m === "$?") { if (d === 0) return l; d-- } else m === "/$" && d++ } l = l.previousSibling } return null } var oi = Math.random().toString(36).slice(2), Kr = "__reactFiber$" + oi, ga = "__reactProps$" + oi, mn = "__reactContainer$" + oi, Pu = "__reactEvents$" + oi, p2 = "__reactListeners$" + oi, m2 = "__reactHandles$" + oi; function Is(l) { var d = l[Kr]; if (d) return d; for (var m = l.parentNode; m;) { if (d = m[mn] || m[Kr]) { if (m = d.alternate, d.child !== null || m !== null && m.child !== null) for (l = Bm(l); l !== null;) { if (m = l[Kr]) return m; l = Bm(l) } return d } l = m, m = l.parentNode } return null } function xa(l) { return l = l[Kr] || l[mn], !l || l.tag !== 5 && l.tag !== 6 && l.tag !== 13 && l.tag !== 3 ? null : l } function li(l) { if (l.tag === 5 || l.tag === 6) return l.stateNode; throw Error(t(33)) } function Bo(l) { return l[ga] || null } var Nu = [], ci = -1; function Kn(l) { return { current: l } } function ct(l) { 0 > ci || (l.current = Nu[ci], Nu[ci] = null, ci--) } function at(l, d) { ci++, Nu[ci] = l.current, l.current = d } var qn = {}, Bt = Kn(qn), Jt = Kn(!1), Ls = qn; function ui(l, d) { var m = l.type.contextTypes; if (!m) return qn; var b = l.stateNode; if (b && b.__reactInternalMemoizedUnmaskedChildContext === d) return b.__reactInternalMemoizedMaskedChildContext; var A = {}, L; for (L in m) A[L] = d[L]; return b && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = d, l.__reactInternalMemoizedMaskedChildContext = A), A } function er(l) { return l = l.childContextTypes, l != null } function Uo() { ct(Jt), ct(Bt) } function Um(l, d, m) { if (Bt.current !== qn) throw Error(t(168)); at(Bt, d), at(Jt, m) } function zm(l, d, m) { var b = l.stateNode; if (d = d.childContextTypes, typeof b.getChildContext != "function") return m; b = b.getChildContext(); for (var A in b) if (!(A in d)) throw Error(t(108, Ce(l) || "Unknown", A)); return Z({}, m, b) } function zo(l) { return l = (l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext || qn, Ls = Bt.current, at(Bt, l), at(Jt, Jt.current), !0 } function Vm(l, d, m) { var b = l.stateNode; if (!b) throw Error(t(169)); m ? (l = zm(l, d, Ls), b.__reactInternalMemoizedMergedChildContext = l, ct(Jt), ct(Bt), at(Bt, l)) : ct(Jt), at(Jt, m) } var gn = null, Vo = !1, Du = !1; function Gm(l) { gn === null ? gn = [l] : gn.push(l) } function g2(l) { Vo = !0, Gm(l) } function Yn() { if (!Du && gn !== null) { Du = !0; var l = 0, d = Je; try { var m = gn; for (Je = 1; l < m.length; l++) { var b = m[l]; do b = b(!0); while (b !== null) } gn = null, Vo = !1 } catch (A) { throw gn !== null && (gn = gn.slice(l + 1)), Wp(ru, Yn), A } finally { Je = d, Du = !1 } } return null } var di = [], fi = 0, Go = null, Ho = 0, Er = [], Tr = 0, Cs = null, xn = 1, vn = ""; function ks(l, d) { di[fi++] = Ho, di[fi++] = Go, Go = l, Ho = d } function Hm(l, d, m) { Er[Tr++] = xn, Er[Tr++] = vn, Er[Tr++] = Cs, Cs = l; var b = xn; l = vn; var A = 32 - Nr(b) - 1; b &= ~(1 << A), m += 1; var L = 32 - Nr(d) + A; if (30 < L) { var O = A - A % 5; L = (b & (1 << O) - 1).toString(32), b >>= O, A -= O, xn = 1 << 32 - Nr(d) + A | m << A | b, vn = L + l } else xn = 1 << L | m << A | b, vn = l } function Ou(l) { l.return !== null && (ks(l, 1), Hm(l, 1, 0)) } function Mu(l) { for (; l === Go;)Go = di[--fi], di[fi] = null, Ho = di[--fi], di[fi] = null; for (; l === Cs;)Cs = Er[--Tr], Er[Tr] = null, vn = Er[--Tr], Er[Tr] = null, xn = Er[--Tr], Er[Tr] = null } var pr = null, mr = null, ht = !1, Or = null; function Wm(l, d) { var m = Cr(5, null, null, 0); m.elementType = "DELETED", m.stateNode = d, m.return = l, d = l.deletions, d === null ? (l.deletions = [m], l.flags |= 16) : d.push(m) } function Km(l, d) { switch (l.tag) { case 5: var m = l.type; return d = d.nodeType !== 1 || m.toLowerCase() !== d.nodeName.toLowerCase() ? null : d, d !== null ? (l.stateNode = d, pr = l, mr = Wn(d.firstChild), !0) : !1; case 6: return d = l.pendingProps === "" || d.nodeType !== 3 ? null : d, d !== null ? (l.stateNode = d, pr = l, mr = null, !0) : !1; case 13: return d = d.nodeType !== 8 ? null : d, d !== null ? (m = Cs !== null ? { id: xn, overflow: vn } : null, l.memoizedState = { dehydrated: d, treeContext: m, retryLane: 1073741824 }, m = Cr(18, null, null, 0), m.stateNode = d, m.return = l, l.child = m, pr = l, mr = null, !0) : !1; default: return !1 } } function ju(l) { return (l.mode & 1) !== 0 && (l.flags & 128) === 0 } function Fu(l) { if (ht) { var d = mr; if (d) { var m = d; if (!Km(l, d)) { if (ju(l)) throw Error(t(418)); d = Wn(m.nextSibling); var b = pr; d && Km(l, d) ? Wm(b, m) : (l.flags = l.flags & -4097 | 2, ht = !1, pr = l) } } else { if (ju(l)) throw Error(t(418)); l.flags = l.flags & -4097 | 2, ht = !1, pr = l } } } function qm(l) { for (l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13;)l = l.return; pr = l } function Wo(l) { if (l !== pr) return !1; if (!ht) return qm(l), ht = !0, !1; var d; if ((d = l.tag !== 3) && !(d = l.tag !== 5) && (d = l.type, d = d !== "head" && d !== "body" && !ku(l.type, l.memoizedProps)), d && (d = mr)) { if (ju(l)) throw Ym(), Error(t(418)); for (; d;)Wm(l, d), d = Wn(d.nextSibling) } if (qm(l), l.tag === 13) { if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(t(317)); e: { for (l = l.nextSibling, d = 0; l;) { if (l.nodeType === 8) { var m = l.data; if (m === "/$") { if (d === 0) { mr = Wn(l.nextSibling); break e } d-- } else m !== "$" && m !== "$!" && m !== "$?" || d++ } l = l.nextSibling } mr = null } } else mr = pr ? Wn(l.stateNode.nextSibling) : null; return !0 } function Ym() { for (var l = mr; l;)l = Wn(l.nextSibling) } function hi() { mr = pr = null, ht = !1 } function $u(l) { Or === null ? Or = [l] : Or.push(l) } var x2 = I.ReactCurrentBatchConfig; function va(l, d, m) { if (l = m.ref, l !== null && typeof l != "function" && typeof l != "object") { if (m._owner) { if (m = m._owner, m) { if (m.tag !== 1) throw Error(t(309)); var b = m.stateNode } if (!b) throw Error(t(147, l)); var A = b, L = "" + l; return d !== null && d.ref !== null && typeof d.ref == "function" && d.ref._stringRef === L ? d.ref : (d = function (O) { var G = A.refs; O === null ? delete G[L] : G[L] = O }, d._stringRef = L, d) } if (typeof l != "string") throw Error(t(284)); if (!m._owner) throw Error(t(290, l)) } return l } function Ko(l, d) { throw l = Object.prototype.toString.call(d), Error(t(31, l === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : l)) } function Xm(l) { var d = l._init; return d(l._payload) } function Qm(l) { function d(ee, Y) { if (l) { var te = ee.deletions; te === null ? (ee.deletions = [Y], ee.flags |= 16) : te.push(Y) } } function m(ee, Y) { if (!l) return null; for (; Y !== null;)d(ee, Y), Y = Y.sibling; return null } function b(ee, Y) { for (ee = new Map; Y !== null;)Y.key !== null ? ee.set(Y.key, Y) : ee.set(Y.index, Y), Y = Y.sibling; return ee } function A(ee, Y) { return ee = ns(ee, Y), ee.index = 0, ee.sibling = null, ee } function L(ee, Y, te) { return ee.index = te, l ? (te = ee.alternate, te !== null ? (te = te.index, te < Y ? (ee.flags |= 2, Y) : te) : (ee.flags |= 2, Y)) : (ee.flags |= 1048576, Y) } function O(ee) { return l && ee.alternate === null && (ee.flags |= 2), ee } function G(ee, Y, te, fe) { return Y === null || Y.tag !== 6 ? (Y = Rd(te, ee.mode, fe), Y.return = ee, Y) : (Y = A(Y, te), Y.return = ee, Y) } function K(ee, Y, te, fe) { var Te = te.type; return Te === R ? le(ee, Y, te.props.children, fe, te.key) : Y !== null && (Y.elementType === Te || typeof Te == "object" && Te !== null && Te.$$typeof === U && Xm(Te) === Y.type) ? (fe = A(Y, te.props), fe.ref = va(ee, Y, te), fe.return = ee, fe) : (fe = xl(te.type, te.key, te.props, null, ee.mode, fe), fe.ref = va(ee, Y, te), fe.return = ee, fe) } function re(ee, Y, te, fe) { return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== te.containerInfo || Y.stateNode.implementation !== te.implementation ? (Y = _d(te, ee.mode, fe), Y.return = ee, Y) : (Y = A(Y, te.children || []), Y.return = ee, Y) } function le(ee, Y, te, fe, Te) { return Y === null || Y.tag !== 7 ? (Y = js(te, ee.mode, fe, Te), Y.return = ee, Y) : (Y = A(Y, te), Y.return = ee, Y) } function ce(ee, Y, te) { if (typeof Y == "string" && Y !== "" || typeof Y == "number") return Y = Rd("" + Y, ee.mode, te), Y.return = ee, Y; if (typeof Y == "object" && Y !== null) { switch (Y.$$typeof) { case C: return te = xl(Y.type, Y.key, Y.props, null, ee.mode, te), te.ref = va(ee, null, Y), te.return = ee, te; case D: return Y = _d(Y, ee.mode, te), Y.return = ee, Y; case U: var fe = Y._init; return ce(ee, fe(Y._payload), te) }if (Ze(Y) || X(Y)) return Y = js(Y, ee.mode, te, null), Y.return = ee, Y; Ko(ee, Y) } return null } function oe(ee, Y, te, fe) { var Te = Y !== null ? Y.key : null; if (typeof te == "string" && te !== "" || typeof te == "number") return Te !== null ? null : G(ee, Y, "" + te, fe); if (typeof te == "object" && te !== null) { switch (te.$$typeof) { case C: return te.key === Te ? K(ee, Y, te, fe) : null; case D: return te.key === Te ? re(ee, Y, te, fe) : null; case U: return Te = te._init, oe(ee, Y, Te(te._payload), fe) }if (Ze(te) || X(te)) return Te !== null ? null : le(ee, Y, te, fe, null); Ko(ee, te) } return null } function xe(ee, Y, te, fe, Te) { if (typeof fe == "string" && fe !== "" || typeof fe == "number") return ee = ee.get(te) || null, G(Y, ee, "" + fe, Te); if (typeof fe == "object" && fe !== null) { switch (fe.$$typeof) { case C: return ee = ee.get(fe.key === null ? te : fe.key) || null, K(Y, ee, fe, Te); case D: return ee = ee.get(fe.key === null ? te : fe.key) || null, re(Y, ee, fe, Te); case U: var ke = fe._init; return xe(ee, Y, te, ke(fe._payload), Te) }if (Ze(fe) || X(fe)) return ee = ee.get(te) || null, le(Y, ee, fe, Te, null); Ko(Y, fe) } return null } function be(ee, Y, te, fe) { for (var Te = null, ke = null, Re = Y, Ne = Y = 0, Dt = null; Re !== null && Ne < te.length; Ne++) { Re.index > Ne ? (Dt = Re, Re = null) : Dt = Re.sibling; var Xe = oe(ee, Re, te[Ne], fe); if (Xe === null) { Re === null && (Re = Dt); break } l && Re && Xe.alternate === null && d(ee, Re), Y = L(Xe, Y, Ne), ke === null ? Te = Xe : ke.sibling = Xe, ke = Xe, Re = Dt } if (Ne === te.length) return m(ee, Re), ht && ks(ee, Ne), Te; if (Re === null) { for (; Ne < te.length; Ne++)Re = ce(ee, te[Ne], fe), Re !== null && (Y = L(Re, Y, Ne), ke === null ? Te = Re : ke.sibling = Re, ke = Re); return ht && ks(ee, Ne), Te } for (Re = b(ee, Re); Ne < te.length; Ne++)Dt = xe(Re, ee, Ne, te[Ne], fe), Dt !== null && (l && Dt.alternate !== null && Re.delete(Dt.key === null ? Ne : Dt.key), Y = L(Dt, Y, Ne), ke === null ? Te = Dt : ke.sibling = Dt, ke = Dt); return l && Re.forEach(function (ss) { return d(ee, ss) }), ht && ks(ee, Ne), Te } function we(ee, Y, te, fe) { var Te = X(te); if (typeof Te != "function") throw Error(t(150)); if (te = Te.call(te), te == null) throw Error(t(151)); for (var ke = Te = null, Re = Y, Ne = Y = 0, Dt = null, Xe = te.next(); Re !== null && !Xe.done; Ne++, Xe = te.next()) { Re.index > Ne ? (Dt = Re, Re = null) : Dt = Re.sibling; var ss = oe(ee, Re, Xe.value, fe); if (ss === null) { Re === null && (Re = Dt); break } l && Re && ss.alternate === null && d(ee, Re), Y = L(ss, Y, Ne), ke === null ? Te = ss : ke.sibling = ss, ke = ss, Re = Dt } if (Xe.done) return m(ee, Re), ht && ks(ee, Ne), Te; if (Re === null) { for (; !Xe.done; Ne++, Xe = te.next())Xe = ce(ee, Xe.value, fe), Xe !== null && (Y = L(Xe, Y, Ne), ke === null ? Te = Xe : ke.sibling = Xe, ke = Xe); return ht && ks(ee, Ne), Te } for (Re = b(ee, Re); !Xe.done; Ne++, Xe = te.next())Xe = xe(Re, ee, Ne, Xe.value, fe), Xe !== null && (l && Xe.alternate !== null && Re.delete(Xe.key === null ? Ne : Xe.key), Y = L(Xe, Y, Ne), ke === null ? Te = Xe : ke.sibling = Xe, ke = Xe); return l && Re.forEach(function (X2) { return d(ee, X2) }), ht && ks(ee, Ne), Te } function St(ee, Y, te, fe) { if (typeof te == "object" && te !== null && te.type === R && te.key === null && (te = te.props.children), typeof te == "object" && te !== null) { switch (te.$$typeof) { case C: e: { for (var Te = te.key, ke = Y; ke !== null;) { if (ke.key === Te) { if (Te = te.type, Te === R) { if (ke.tag === 7) { m(ee, ke.sibling), Y = A(ke, te.props.children), Y.return = ee, ee = Y; break e } } else if (ke.elementType === Te || typeof Te == "object" && Te !== null && Te.$$typeof === U && Xm(Te) === ke.type) { m(ee, ke.sibling), Y = A(ke, te.props), Y.ref = va(ee, ke, te), Y.return = ee, ee = Y; break e } m(ee, ke); break } else d(ee, ke); ke = ke.sibling } te.type === R ? (Y = js(te.props.children, ee.mode, fe, te.key), Y.return = ee, ee = Y) : (fe = xl(te.type, te.key, te.props, null, ee.mode, fe), fe.ref = va(ee, Y, te), fe.return = ee, ee = fe) } return O(ee); case D: e: { for (ke = te.key; Y !== null;) { if (Y.key === ke) if (Y.tag === 4 && Y.stateNode.containerInfo === te.containerInfo && Y.stateNode.implementation === te.implementation) { m(ee, Y.sibling), Y = A(Y, te.children || []), Y.return = ee, ee = Y; break e } else { m(ee, Y); break } else d(ee, Y); Y = Y.sibling } Y = _d(te, ee.mode, fe), Y.return = ee, ee = Y } return O(ee); case U: return ke = te._init, St(ee, Y, ke(te._payload), fe) }if (Ze(te)) return be(ee, Y, te, fe); if (X(te)) return we(ee, Y, te, fe); Ko(ee, te) } return typeof te == "string" && te !== "" || typeof te == "number" ? (te = "" + te, Y !== null && Y.tag === 6 ? (m(ee, Y.sibling), Y = A(Y, te), Y.return = ee, ee = Y) : (m(ee, Y), Y = Rd(te, ee.mode, fe), Y.return = ee, ee = Y), O(ee)) : m(ee, Y) } return St } var pi = Qm(!0), Zm = Qm(!1), qo = Kn(null), Yo = null, mi = null, Bu = null; function Uu() { Bu = mi = Yo = null } function zu(l) { var d = qo.current; ct(qo), l._currentValue = d } function Vu(l, d, m) { for (; l !== null;) { var b = l.alternate; if ((l.childLanes & d) !== d ? (l.childLanes |= d, b !== null && (b.childLanes |= d)) : b !== null && (b.childLanes & d) !== d && (b.childLanes |= d), l === m) break; l = l.return } } function gi(l, d) { Yo = l, Bu = mi = null, l = l.dependencies, l !== null && l.firstContext !== null && ((l.lanes & d) !== 0 && (tr = !0), l.firstContext = null) } function Ar(l) { var d = l._currentValue; if (Bu !== l) if (l = { context: l, memoizedValue: d, next: null }, mi === null) { if (Yo === null) throw Error(t(308)); mi = l, Yo.dependencies = { lanes: 0, firstContext: l } } else mi = mi.next = l; return d } var Rs = null; function Gu(l) { Rs === null ? Rs = [l] : Rs.push(l) } function Jm(l, d, m, b) { var A = d.interleaved; return A === null ? (m.next = m, Gu(d)) : (m.next = A.next, A.next = m), d.interleaved = m, yn(l, b) } function yn(l, d) { l.lanes |= d; var m = l.alternate; for (m !== null && (m.lanes |= d), m = l, l = l.return; l !== null;)l.childLanes |= d, m = l.alternate, m !== null && (m.childLanes |= d), m = l, l = l.return; return m.tag === 3 ? m.stateNode : null } var Xn = !1; function Hu(l) { l.updateQueue = { baseState: l.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function eg(l, d) { l = l.updateQueue, d.updateQueue === l && (d.updateQueue = { baseState: l.baseState, firstBaseUpdate: l.firstBaseUpdate, lastBaseUpdate: l.lastBaseUpdate, shared: l.shared, effects: l.effects }) } function bn(l, d) { return { eventTime: l, lane: d, tag: 0, payload: null, callback: null, next: null } } function Qn(l, d, m) { var b = l.updateQueue; if (b === null) return null; if (b = b.shared, (Ye & 2) !== 0) { var A = b.pending; return A === null ? d.next = d : (d.next = A.next, A.next = d), b.pending = d, yn(l, m) } return A = b.interleaved, A === null ? (d.next = d, Gu(b)) : (d.next = A.next, A.next = d), b.interleaved = d, yn(l, m) } function Xo(l, d, m) { if (d = d.updateQueue, d !== null && (d = d.shared, (m & 4194240) !== 0)) { var b = d.lanes; b &= l.pendingLanes, m |= b, d.lanes = m, iu(l, m) } } function tg(l, d) { var m = l.updateQueue, b = l.alternate; if (b !== null && (b = b.updateQueue, m === b)) { var A = null, L = null; if (m = m.firstBaseUpdate, m !== null) { do { var O = { eventTime: m.eventTime, lane: m.lane, tag: m.tag, payload: m.payload, callback: m.callback, next: null }; L === null ? A = L = O : L = L.next = O, m = m.next } while (m !== null); L === null ? A = L = d : L = L.next = d } else A = L = d; m = { baseState: b.baseState, firstBaseUpdate: A, lastBaseUpdate: L, shared: b.shared, effects: b.effects }, l.updateQueue = m; return } l = m.lastBaseUpdate, l === null ? m.firstBaseUpdate = d : l.next = d, m.lastBaseUpdate = d } function Qo(l, d, m, b) { var A = l.updateQueue; Xn = !1; var L = A.firstBaseUpdate, O = A.lastBaseUpdate, G = A.shared.pending; if (G !== null) { A.shared.pending = null; var K = G, re = K.next; K.next = null, O === null ? L = re : O.next = re, O = K; var le = l.alternate; le !== null && (le = le.updateQueue, G = le.lastBaseUpdate, G !== O && (G === null ? le.firstBaseUpdate = re : G.next = re, le.lastBaseUpdate = K)) } if (L !== null) { var ce = A.baseState; O = 0, le = re = K = null, G = L; do { var oe = G.lane, xe = G.eventTime; if ((b & oe) === oe) { le !== null && (le = le.next = { eventTime: xe, lane: 0, tag: G.tag, payload: G.payload, callback: G.callback, next: null }); e: { var be = l, we = G; switch (oe = d, xe = m, we.tag) { case 1: if (be = we.payload, typeof be == "function") { ce = be.call(xe, ce, oe); break e } ce = be; break e; case 3: be.flags = be.flags & -65537 | 128; case 0: if (be = we.payload, oe = typeof be == "function" ? be.call(xe, ce, oe) : be, oe == null) break e; ce = Z({}, ce, oe); break e; case 2: Xn = !0 } } G.callback !== null && G.lane !== 0 && (l.flags |= 64, oe = A.effects, oe === null ? A.effects = [G] : oe.push(G)) } else xe = { eventTime: xe, lane: oe, tag: G.tag, payload: G.payload, callback: G.callback, next: null }, le === null ? (re = le = xe, K = ce) : le = le.next = xe, O |= oe; if (G = G.next, G === null) { if (G = A.shared.pending, G === null) break; oe = G, G = oe.next, oe.next = null, A.lastBaseUpdate = oe, A.shared.pending = null } } while (!0); if (le === null && (K = ce), A.baseState = K, A.firstBaseUpdate = re, A.lastBaseUpdate = le, d = A.shared.interleaved, d !== null) { A = d; do O |= A.lane, A = A.next; while (A !== d) } else L === null && (A.shared.lanes = 0); Ns |= O, l.lanes = O, l.memoizedState = ce } } function rg(l, d, m) { if (l = d.effects, d.effects = null, l !== null) for (d = 0; d < l.length; d++) { var b = l[d], A = b.callback; if (A !== null) { if (b.callback = null, b = m, typeof A != "function") throw Error(t(191, A)); A.call(b) } } } var ya = {}, qr = Kn(ya), ba = Kn(ya), wa = Kn(ya); function _s(l) { if (l === ya) throw Error(t(174)); return l } function Wu(l, d) { switch (at(wa, d), at(ba, l), at(qr, ya), l = d.nodeType, l) { case 9: case 11: d = (d = d.documentElement) ? d.namespaceURI : Fn(null, ""); break; default: l = l === 8 ? d.parentNode : d, d = l.namespaceURI || null, l = l.tagName, d = Fn(d, l) }ct(qr), at(qr, d) } function xi() { ct(qr), ct(ba), ct(wa) } function ng(l) { _s(wa.current); var d = _s(qr.current), m = Fn(d, l.type); d !== m && (at(ba, l), at(qr, m)) } function Ku(l) { ba.current === l && (ct(qr), ct(ba)) } var pt = Kn(0); function Zo(l) { for (var d = l; d !== null;) { if (d.tag === 13) { var m = d.memoizedState; if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || m.data === "$!")) return d } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) { if ((d.flags & 128) !== 0) return d } else if (d.child !== null) { d.child.return = d, d = d.child; continue } if (d === l) break; for (; d.sibling === null;) { if (d.return === null || d.return === l) return null; d = d.return } d.sibling.return = d.return, d = d.sibling } return null } var qu = []; function Yu() { for (var l = 0; l < qu.length; l++)qu[l]._workInProgressVersionPrimary = null; qu.length = 0 } var Jo = I.ReactCurrentDispatcher, Xu = I.ReactCurrentBatchConfig, Ps = 0, mt = null, Lt = null, Pt = null, el = !1, Sa = !1, Ea = 0, v2 = 0; function Ut() { throw Error(t(321)) } function Qu(l, d) { if (d === null) return !1; for (var m = 0; m < d.length && m < l.length; m++)if (!Dr(l[m], d[m])) return !1; return !0 } function Zu(l, d, m, b, A, L) { if (Ps = L, mt = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, Jo.current = l === null || l.memoizedState === null ? S2 : E2, l = m(b, A), Sa) { L = 0; do { if (Sa = !1, Ea = 0, 25 <= L) throw Error(t(301)); L += 1, Pt = Lt = null, d.updateQueue = null, Jo.current = T2, l = m(b, A) } while (Sa) } if (Jo.current = nl, d = Lt !== null && Lt.next !== null, Ps = 0, Pt = Lt = mt = null, el = !1, d) throw Error(t(300)); return l } function Ju() { var l = Ea !== 0; return Ea = 0, l } function Yr() { var l = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Pt === null ? mt.memoizedState = Pt = l : Pt = Pt.next = l, Pt } function Ir() { if (Lt === null) { var l = mt.alternate; l = l !== null ? l.memoizedState : null } else l = Lt.next; var d = Pt === null ? mt.memoizedState : Pt.next; if (d !== null) Pt = d, Lt = l; else { if (l === null) throw Error(t(310)); Lt = l, l = { memoizedState: Lt.memoizedState, baseState: Lt.baseState, baseQueue: Lt.baseQueue, queue: Lt.queue, next: null }, Pt === null ? mt.memoizedState = Pt = l : Pt = Pt.next = l } return Pt } function Ta(l, d) { return typeof d == "function" ? d(l) : d } function ed(l) { var d = Ir(), m = d.queue; if (m === null) throw Error(t(311)); m.lastRenderedReducer = l; var b = Lt, A = b.baseQueue, L = m.pending; if (L !== null) { if (A !== null) { var O = A.next; A.next = L.next, L.next = O } b.baseQueue = A = L, m.pending = null } if (A !== null) { L = A.next, b = b.baseState; var G = O = null, K = null, re = L; do { var le = re.lane; if ((Ps & le) === le) K !== null && (K = K.next = { lane: 0, action: re.action, hasEagerState: re.hasEagerState, eagerState: re.eagerState, next: null }), b = re.hasEagerState ? re.eagerState : l(b, re.action); else { var ce = { lane: le, action: re.action, hasEagerState: re.hasEagerState, eagerState: re.eagerState, next: null }; K === null ? (G = K = ce, O = b) : K = K.next = ce, mt.lanes |= le, Ns |= le } re = re.next } while (re !== null && re !== L); K === null ? O = b : K.next = G, Dr(b, d.memoizedState) || (tr = !0), d.memoizedState = b, d.baseState = O, d.baseQueue = K, m.lastRenderedState = b } if (l = m.interleaved, l !== null) { A = l; do L = A.lane, mt.lanes |= L, Ns |= L, A = A.next; while (A !== l) } else A === null && (m.lanes = 0); return [d.memoizedState, m.dispatch] } function td(l) { var d = Ir(), m = d.queue; if (m === null) throw Error(t(311)); m.lastRenderedReducer = l; var b = m.dispatch, A = m.pending, L = d.memoizedState; if (A !== null) { m.pending = null; var O = A = A.next; do L = l(L, O.action), O = O.next; while (O !== A); Dr(L, d.memoizedState) || (tr = !0), d.memoizedState = L, d.baseQueue === null && (d.baseState = L), m.lastRenderedState = L } return [L, b] } function sg() { } function ig(l, d) { var m = mt, b = Ir(), A = d(), L = !Dr(b.memoizedState, A); if (L && (b.memoizedState = A, tr = !0), b = b.queue, rd(lg.bind(null, m, b, l), [l]), b.getSnapshot !== d || L || Pt !== null && Pt.memoizedState.tag & 1) { if (m.flags |= 2048, Aa(9, og.bind(null, m, b, A, d), void 0, null), Nt === null) throw Error(t(349)); (Ps & 30) !== 0 || ag(m, d, A) } return A } function ag(l, d, m) { l.flags |= 16384, l = { getSnapshot: d, value: m }, d = mt.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, mt.updateQueue = d, d.stores = [l]) : (m = d.stores, m === null ? d.stores = [l] : m.push(l)) } function og(l, d, m, b) { d.value = m, d.getSnapshot = b, cg(d) && ug(l) } function lg(l, d, m) { return m(function () { cg(d) && ug(l) }) } function cg(l) { var d = l.getSnapshot; l = l.value; try { var m = d(); return !Dr(l, m) } catch { return !0 } } function ug(l) { var d = yn(l, 1); d !== null && $r(d, l, 1, -1) } function dg(l) { var d = Yr(); return typeof l == "function" && (l = l()), d.memoizedState = d.baseState = l, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ta, lastRenderedState: l }, d.queue = l, l = l.dispatch = w2.bind(null, mt, l), [d.memoizedState, l] } function Aa(l, d, m, b) { return l = { tag: l, create: d, destroy: m, deps: b, next: null }, d = mt.updateQueue, d === null ? (d = { lastEffect: null, stores: null }, mt.updateQueue = d, d.lastEffect = l.next = l) : (m = d.lastEffect, m === null ? d.lastEffect = l.next = l : (b = m.next, m.next = l, l.next = b, d.lastEffect = l)), l } function fg() { return Ir().memoizedState } function tl(l, d, m, b) { var A = Yr(); mt.flags |= l, A.memoizedState = Aa(1 | d, m, void 0, b === void 0 ? null : b) } function rl(l, d, m, b) { var A = Ir(); b = b === void 0 ? null : b; var L = void 0; if (Lt !== null) { var O = Lt.memoizedState; if (L = O.destroy, b !== null && Qu(b, O.deps)) { A.memoizedState = Aa(d, m, L, b); return } } mt.flags |= l, A.memoizedState = Aa(1 | d, m, L, b) } function hg(l, d) { return tl(8390656, 8, l, d) } function rd(l, d) { return rl(2048, 8, l, d) } function pg(l, d) { return rl(4, 2, l, d) } function mg(l, d) { return rl(4, 4, l, d) } function gg(l, d) { if (typeof d == "function") return l = l(), d(l), function () { d(null) }; if (d != null) return l = l(), d.current = l, function () { d.current = null } } function xg(l, d, m) { return m = m != null ? m.concat([l]) : null, rl(4, 4, gg.bind(null, d, l), m) } function nd() { } function vg(l, d) { var m = Ir(); d = d === void 0 ? null : d; var b = m.memoizedState; return b !== null && d !== null && Qu(d, b[1]) ? b[0] : (m.memoizedState = [l, d], l) } function yg(l, d) { var m = Ir(); d = d === void 0 ? null : d; var b = m.memoizedState; return b !== null && d !== null && Qu(d, b[1]) ? b[0] : (l = l(), m.memoizedState = [l, d], l) } function bg(l, d, m) { return (Ps & 21) === 0 ? (l.baseState && (l.baseState = !1, tr = !0), l.memoizedState = m) : (Dr(m, d) || (m = Xp(), mt.lanes |= m, Ns |= m, l.baseState = !0), d) } function y2(l, d) { var m = Je; Je = m !== 0 && 4 > m ? m : 4, l(!0); var b = Xu.transition; Xu.transition = {}; try { l(!1), d() } finally { Je = m, Xu.transition = b } } function wg() { return Ir().memoizedState } function b2(l, d, m) { var b = ts(l); if (m = { lane: b, action: m, hasEagerState: !1, eagerState: null, next: null }, Sg(l)) Eg(d, m); else if (m = Jm(l, d, m, b), m !== null) { var A = Kt(); $r(m, l, b, A), Tg(m, d, b) } } function w2(l, d, m) { var b = ts(l), A = { lane: b, action: m, hasEagerState: !1, eagerState: null, next: null }; if (Sg(l)) Eg(d, A); else { var L = l.alternate; if (l.lanes === 0 && (L === null || L.lanes === 0) && (L = d.lastRenderedReducer, L !== null)) try { var O = d.lastRenderedState, G = L(O, m); if (A.hasEagerState = !0, A.eagerState = G, Dr(G, O)) { var K = d.interleaved; K === null ? (A.next = A, Gu(d)) : (A.next = K.next, K.next = A), d.interleaved = A; return } } catch { } finally { } m = Jm(l, d, A, b), m !== null && (A = Kt(), $r(m, l, b, A), Tg(m, d, b)) } } function Sg(l) { var d = l.alternate; return l === mt || d !== null && d === mt } function Eg(l, d) { Sa = el = !0; var m = l.pending; m === null ? d.next = d : (d.next = m.next, m.next = d), l.pending = d } function Tg(l, d, m) { if ((m & 4194240) !== 0) { var b = d.lanes; b &= l.pendingLanes, m |= b, d.lanes = m, iu(l, m) } } var nl = { readContext: Ar, useCallback: Ut, useContext: Ut, useEffect: Ut, useImperativeHandle: Ut, useInsertionEffect: Ut, useLayoutEffect: Ut, useMemo: Ut, useReducer: Ut, useRef: Ut, useState: Ut, useDebugValue: Ut, useDeferredValue: Ut, useTransition: Ut, useMutableSource: Ut, useSyncExternalStore: Ut, useId: Ut, unstable_isNewReconciler: !1 }, S2 = { readContext: Ar, useCallback: function (l, d) { return Yr().memoizedState = [l, d === void 0 ? null : d], l }, useContext: Ar, useEffect: hg, useImperativeHandle: function (l, d, m) { return m = m != null ? m.concat([l]) : null, tl(4194308, 4, gg.bind(null, d, l), m) }, useLayoutEffect: function (l, d) { return tl(4194308, 4, l, d) }, useInsertionEffect: function (l, d) { return tl(4, 2, l, d) }, useMemo: function (l, d) { var m = Yr(); return d = d === void 0 ? null : d, l = l(), m.memoizedState = [l, d], l }, useReducer: function (l, d, m) { var b = Yr(); return d = m !== void 0 ? m(d) : d, b.memoizedState = b.baseState = d, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: l, lastRenderedState: d }, b.queue = l, l = l.dispatch = b2.bind(null, mt, l), [b.memoizedState, l] }, useRef: function (l) { var d = Yr(); return l = { current: l }, d.memoizedState = l }, useState: dg, useDebugValue: nd, useDeferredValue: function (l) { return Yr().memoizedState = l }, useTransition: function () { var l = dg(!1), d = l[0]; return l = y2.bind(null, l[1]), Yr().memoizedState = l, [d, l] }, useMutableSource: function () { }, useSyncExternalStore: function (l, d, m) { var b = mt, A = Yr(); if (ht) { if (m === void 0) throw Error(t(407)); m = m() } else { if (m = d(), Nt === null) throw Error(t(349)); (Ps & 30) !== 0 || ag(b, d, m) } A.memoizedState = m; var L = { value: m, getSnapshot: d }; return A.queue = L, hg(lg.bind(null, b, L, l), [l]), b.flags |= 2048, Aa(9, og.bind(null, b, L, m, d), void 0, null), m }, useId: function () { var l = Yr(), d = Nt.identifierPrefix; if (ht) { var m = vn, b = xn; m = (b & ~(1 << 32 - Nr(b) - 1)).toString(32) + m, d = ":" + d + "R" + m, m = Ea++, 0 < m && (d += "H" + m.toString(32)), d += ":" } else m = v2++, d = ":" + d + "r" + m.toString(32) + ":"; return l.memoizedState = d }, unstable_isNewReconciler: !1 }, E2 = { readContext: Ar, useCallback: vg, useContext: Ar, useEffect: rd, useImperativeHandle: xg, useInsertionEffect: pg, useLayoutEffect: mg, useMemo: yg, useReducer: ed, useRef: fg, useState: function () { return ed(Ta) }, useDebugValue: nd, useDeferredValue: function (l) { var d = Ir(); return bg(d, Lt.memoizedState, l) }, useTransition: function () { var l = ed(Ta)[0], d = Ir().memoizedState; return [l, d] }, useMutableSource: sg, useSyncExternalStore: ig, useId: wg, unstable_isNewReconciler: !1 }, T2 = { readContext: Ar, useCallback: vg, useContext: Ar, useEffect: rd, useImperativeHandle: xg, useInsertionEffect: pg, useLayoutEffect: mg, useMemo: yg, useReducer: td, useRef: fg, useState: function () { return td(Ta) }, useDebugValue: nd, useDeferredValue: function (l) { var d = Ir(); return Lt === null ? d.memoizedState = l : bg(d, Lt.memoizedState, l) }, useTransition: function () { var l = td(Ta)[0], d = Ir().memoizedState; return [l, d] }, useMutableSource: sg, useSyncExternalStore: ig, useId: wg, unstable_isNewReconciler: !1 }; function Mr(l, d) { if (l && l.defaultProps) { d = Z({}, d), l = l.defaultProps; for (var m in l) d[m] === void 0 && (d[m] = l[m]); return d } return d } function sd(l, d, m, b) { d = l.memoizedState, m = m(b, d), m = m == null ? d : Z({}, d, m), l.memoizedState = m, l.lanes === 0 && (l.updateQueue.baseState = m) } var sl = { isMounted: function (l) { return (l = l._reactInternals) ? As(l) === l : !1 }, enqueueSetState: function (l, d, m) { l = l._reactInternals; var b = Kt(), A = ts(l), L = bn(b, A); L.payload = d, m != null && (L.callback = m), d = Qn(l, L, A), d !== null && ($r(d, l, A, b), Xo(d, l, A)) }, enqueueReplaceState: function (l, d, m) { l = l._reactInternals; var b = Kt(), A = ts(l), L = bn(b, A); L.tag = 1, L.payload = d, m != null && (L.callback = m), d = Qn(l, L, A), d !== null && ($r(d, l, A, b), Xo(d, l, A)) }, enqueueForceUpdate: function (l, d) { l = l._reactInternals; var m = Kt(), b = ts(l), A = bn(m, b); A.tag = 2, d != null && (A.callback = d), d = Qn(l, A, b), d !== null && ($r(d, l, b, m), Xo(d, l, b)) } }; function Ag(l, d, m, b, A, L, O) { return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(b, L, O) : d.prototype && d.prototype.isPureReactComponent ? !da(m, b) || !da(A, L) : !0 } function Ig(l, d, m) { var b = !1, A = qn, L = d.contextType; return typeof L == "object" && L !== null ? L = Ar(L) : (A = er(d) ? Ls : Bt.current, b = d.contextTypes, L = (b = b != null) ? ui(l, A) : qn), d = new d(m, L), l.memoizedState = d.state !== null && d.state !== void 0 ? d.state : null, d.updater = sl, l.stateNode = d, d._reactInternals = l, b && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = A, l.__reactInternalMemoizedMaskedChildContext = L), d } function Lg(l, d, m, b) { l = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(m, b), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(m, b), d.state !== l && sl.enqueueReplaceState(d, d.state, null) } function id(l, d, m, b) { var A = l.stateNode; A.props = m, A.state = l.memoizedState, A.refs = {}, Hu(l); var L = d.contextType; typeof L == "object" && L !== null ? A.context = Ar(L) : (L = er(d) ? Ls : Bt.current, A.context = ui(l, L)), A.state = l.memoizedState, L = d.getDerivedStateFromProps, typeof L == "function" && (sd(l, d, L, m), A.state = l.memoizedState), typeof d.getDerivedStateFromProps == "function" || typeof A.getSnapshotBeforeUpdate == "function" || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (d = A.state, typeof A.componentWillMount == "function" && A.componentWillMount(), typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount(), d !== A.state && sl.enqueueReplaceState(A, A.state, null), Qo(l, m, A, b), A.state = l.memoizedState), typeof A.componentDidMount == "function" && (l.flags |= 4194308) } function vi(l, d) {
      try { var m = "", b = d; do m += de(b), b = b.return; while (b); var A = m } catch (L) {
        A = `
Error generating stack: `+ L.message + `
`+ L.stack
      } return { value: l, source: d, stack: A, digest: null }
    } function ad(l, d, m) { return { value: l, source: null, stack: m ?? null, digest: d ?? null } } function od(l, d) { try { console.error(d.value) } catch (m) { setTimeout(function () { throw m }) } } var A2 = typeof WeakMap == "function" ? WeakMap : Map; function Cg(l, d, m) { m = bn(-1, m), m.tag = 3, m.payload = { element: null }; var b = d.value; return m.callback = function () { dl || (dl = !0, Sd = b), od(l, d) }, m } function kg(l, d, m) { m = bn(-1, m), m.tag = 3; var b = l.type.getDerivedStateFromError; if (typeof b == "function") { var A = d.value; m.payload = function () { return b(A) }, m.callback = function () { od(l, d) } } var L = l.stateNode; return L !== null && typeof L.componentDidCatch == "function" && (m.callback = function () { od(l, d), typeof b != "function" && (Jn === null ? Jn = new Set([this]) : Jn.add(this)); var O = d.stack; this.componentDidCatch(d.value, { componentStack: O !== null ? O : "" }) }), m } function Rg(l, d, m) { var b = l.pingCache; if (b === null) { b = l.pingCache = new A2; var A = new Set; b.set(d, A) } else A = b.get(d), A === void 0 && (A = new Set, b.set(d, A)); A.has(m) || (A.add(m), l = $2.bind(null, l, d, m), d.then(l, l)) } function _g(l) { do { var d; if ((d = l.tag === 13) && (d = l.memoizedState, d = d !== null ? d.dehydrated !== null : !0), d) return l; l = l.return } while (l !== null); return null } function Pg(l, d, m, b, A) { return (l.mode & 1) === 0 ? (l === d ? l.flags |= 65536 : (l.flags |= 128, m.flags |= 131072, m.flags &= -52805, m.tag === 1 && (m.alternate === null ? m.tag = 17 : (d = bn(-1, 1), d.tag = 2, Qn(m, d, 1))), m.lanes |= 1), l) : (l.flags |= 65536, l.lanes = A, l) } var I2 = I.ReactCurrentOwner, tr = !1; function Wt(l, d, m, b) { d.child = l === null ? Zm(d, null, m, b) : pi(d, l.child, m, b) } function Ng(l, d, m, b, A) { m = m.render; var L = d.ref; return gi(d, A), b = Zu(l, d, m, b, L, A), m = Ju(), l !== null && !tr ? (d.updateQueue = l.updateQueue, d.flags &= -2053, l.lanes &= ~A, wn(l, d, A)) : (ht && m && Ou(d), d.flags |= 1, Wt(l, d, b, A), d.child) } function Dg(l, d, m, b, A) { if (l === null) { var L = m.type; return typeof L == "function" && !kd(L) && L.defaultProps === void 0 && m.compare === null && m.defaultProps === void 0 ? (d.tag = 15, d.type = L, Og(l, d, L, b, A)) : (l = xl(m.type, null, b, d, d.mode, A), l.ref = d.ref, l.return = d, d.child = l) } if (L = l.child, (l.lanes & A) === 0) { var O = L.memoizedProps; if (m = m.compare, m = m !== null ? m : da, m(O, b) && l.ref === d.ref) return wn(l, d, A) } return d.flags |= 1, l = ns(L, b), l.ref = d.ref, l.return = d, d.child = l } function Og(l, d, m, b, A) { if (l !== null) { var L = l.memoizedProps; if (da(L, b) && l.ref === d.ref) if (tr = !1, d.pendingProps = b = L, (l.lanes & A) !== 0) (l.flags & 131072) !== 0 && (tr = !0); else return d.lanes = l.lanes, wn(l, d, A) } return ld(l, d, m, b, A) } function Mg(l, d, m) { var b = d.pendingProps, A = b.children, L = l !== null ? l.memoizedState : null; if (b.mode === "hidden") if ((d.mode & 1) === 0) d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, at(bi, gr), gr |= m; else { if ((m & 1073741824) === 0) return l = L !== null ? L.baseLanes | m : m, d.lanes = d.childLanes = 1073741824, d.memoizedState = { baseLanes: l, cachePool: null, transitions: null }, d.updateQueue = null, at(bi, gr), gr |= l, null; d.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, b = L !== null ? L.baseLanes : m, at(bi, gr), gr |= b } else L !== null ? (b = L.baseLanes | m, d.memoizedState = null) : b = m, at(bi, gr), gr |= b; return Wt(l, d, A, m), d.child } function jg(l, d) { var m = d.ref; (l === null && m !== null || l !== null && l.ref !== m) && (d.flags |= 512, d.flags |= 2097152) } function ld(l, d, m, b, A) { var L = er(m) ? Ls : Bt.current; return L = ui(d, L), gi(d, A), m = Zu(l, d, m, b, L, A), b = Ju(), l !== null && !tr ? (d.updateQueue = l.updateQueue, d.flags &= -2053, l.lanes &= ~A, wn(l, d, A)) : (ht && b && Ou(d), d.flags |= 1, Wt(l, d, m, A), d.child) } function Fg(l, d, m, b, A) { if (er(m)) { var L = !0; zo(d) } else L = !1; if (gi(d, A), d.stateNode === null) al(l, d), Ig(d, m, b), id(d, m, b, A), b = !0; else if (l === null) { var O = d.stateNode, G = d.memoizedProps; O.props = G; var K = O.context, re = m.contextType; typeof re == "object" && re !== null ? re = Ar(re) : (re = er(m) ? Ls : Bt.current, re = ui(d, re)); var le = m.getDerivedStateFromProps, ce = typeof le == "function" || typeof O.getSnapshotBeforeUpdate == "function"; ce || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (G !== b || K !== re) && Lg(d, O, b, re), Xn = !1; var oe = d.memoizedState; O.state = oe, Qo(d, b, O, A), K = d.memoizedState, G !== b || oe !== K || Jt.current || Xn ? (typeof le == "function" && (sd(d, m, le, b), K = d.memoizedState), (G = Xn || Ag(d, m, G, b, oe, K, re)) ? (ce || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount()), typeof O.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof O.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = b, d.memoizedState = K), O.props = b, O.state = K, O.context = re, b = G) : (typeof O.componentDidMount == "function" && (d.flags |= 4194308), b = !1) } else { O = d.stateNode, eg(l, d), G = d.memoizedProps, re = d.type === d.elementType ? G : Mr(d.type, G), O.props = re, ce = d.pendingProps, oe = O.context, K = m.contextType, typeof K == "object" && K !== null ? K = Ar(K) : (K = er(m) ? Ls : Bt.current, K = ui(d, K)); var xe = m.getDerivedStateFromProps; (le = typeof xe == "function" || typeof O.getSnapshotBeforeUpdate == "function") || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (G !== ce || oe !== K) && Lg(d, O, b, K), Xn = !1, oe = d.memoizedState, O.state = oe, Qo(d, b, O, A); var be = d.memoizedState; G !== ce || oe !== be || Jt.current || Xn ? (typeof xe == "function" && (sd(d, m, xe, b), be = d.memoizedState), (re = Xn || Ag(d, m, re, b, oe, be, K) || !1) ? (le || typeof O.UNSAFE_componentWillUpdate != "function" && typeof O.componentWillUpdate != "function" || (typeof O.componentWillUpdate == "function" && O.componentWillUpdate(b, be, K), typeof O.UNSAFE_componentWillUpdate == "function" && O.UNSAFE_componentWillUpdate(b, be, K)), typeof O.componentDidUpdate == "function" && (d.flags |= 4), typeof O.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof O.componentDidUpdate != "function" || G === l.memoizedProps && oe === l.memoizedState || (d.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || G === l.memoizedProps && oe === l.memoizedState || (d.flags |= 1024), d.memoizedProps = b, d.memoizedState = be), O.props = b, O.state = be, O.context = K, b = re) : (typeof O.componentDidUpdate != "function" || G === l.memoizedProps && oe === l.memoizedState || (d.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || G === l.memoizedProps && oe === l.memoizedState || (d.flags |= 1024), b = !1) } return cd(l, d, m, b, L, A) } function cd(l, d, m, b, A, L) { jg(l, d); var O = (d.flags & 128) !== 0; if (!b && !O) return A && Vm(d, m, !1), wn(l, d, L); b = d.stateNode, I2.current = d; var G = O && typeof m.getDerivedStateFromError != "function" ? null : b.render(); return d.flags |= 1, l !== null && O ? (d.child = pi(d, l.child, null, L), d.child = pi(d, null, G, L)) : Wt(l, d, G, L), d.memoizedState = b.state, A && Vm(d, m, !0), d.child } function $g(l) { var d = l.stateNode; d.pendingContext ? Um(l, d.pendingContext, d.pendingContext !== d.context) : d.context && Um(l, d.context, !1), Wu(l, d.containerInfo) } function Bg(l, d, m, b, A) { return hi(), $u(A), d.flags |= 256, Wt(l, d, m, b), d.child } var ud = { dehydrated: null, treeContext: null, retryLane: 0 }; function dd(l) { return { baseLanes: l, cachePool: null, transitions: null } } function Ug(l, d, m) { var b = d.pendingProps, A = pt.current, L = !1, O = (d.flags & 128) !== 0, G; if ((G = O) || (G = l !== null && l.memoizedState === null ? !1 : (A & 2) !== 0), G ? (L = !0, d.flags &= -129) : (l === null || l.memoizedState !== null) && (A |= 1), at(pt, A & 1), l === null) return Fu(d), l = d.memoizedState, l !== null && (l = l.dehydrated, l !== null) ? ((d.mode & 1) === 0 ? d.lanes = 1 : l.data === "$!" ? d.lanes = 8 : d.lanes = 1073741824, null) : (O = b.children, l = b.fallback, L ? (b = d.mode, L = d.child, O = { mode: "hidden", children: O }, (b & 1) === 0 && L !== null ? (L.childLanes = 0, L.pendingProps = O) : L = vl(O, b, 0, null), l = js(l, b, m, null), L.return = d, l.return = d, L.sibling = l, d.child = L, d.child.memoizedState = dd(m), d.memoizedState = ud, l) : fd(d, O)); if (A = l.memoizedState, A !== null && (G = A.dehydrated, G !== null)) return L2(l, d, O, b, G, A, m); if (L) { L = b.fallback, O = d.mode, A = l.child, G = A.sibling; var K = { mode: "hidden", children: b.children }; return (O & 1) === 0 && d.child !== A ? (b = d.child, b.childLanes = 0, b.pendingProps = K, d.deletions = null) : (b = ns(A, K), b.subtreeFlags = A.subtreeFlags & 14680064), G !== null ? L = ns(G, L) : (L = js(L, O, m, null), L.flags |= 2), L.return = d, b.return = d, b.sibling = L, d.child = b, b = L, L = d.child, O = l.child.memoizedState, O = O === null ? dd(m) : { baseLanes: O.baseLanes | m, cachePool: null, transitions: O.transitions }, L.memoizedState = O, L.childLanes = l.childLanes & ~m, d.memoizedState = ud, b } return L = l.child, l = L.sibling, b = ns(L, { mode: "visible", children: b.children }), (d.mode & 1) === 0 && (b.lanes = m), b.return = d, b.sibling = null, l !== null && (m = d.deletions, m === null ? (d.deletions = [l], d.flags |= 16) : m.push(l)), d.child = b, d.memoizedState = null, b } function fd(l, d) { return d = vl({ mode: "visible", children: d }, l.mode, 0, null), d.return = l, l.child = d } function il(l, d, m, b) { return b !== null && $u(b), pi(d, l.child, null, m), l = fd(d, d.pendingProps.children), l.flags |= 2, d.memoizedState = null, l } function L2(l, d, m, b, A, L, O) { if (m) return d.flags & 256 ? (d.flags &= -257, b = ad(Error(t(422))), il(l, d, O, b)) : d.memoizedState !== null ? (d.child = l.child, d.flags |= 128, null) : (L = b.fallback, A = d.mode, b = vl({ mode: "visible", children: b.children }, A, 0, null), L = js(L, A, O, null), L.flags |= 2, b.return = d, L.return = d, b.sibling = L, d.child = b, (d.mode & 1) !== 0 && pi(d, l.child, null, O), d.child.memoizedState = dd(O), d.memoizedState = ud, L); if ((d.mode & 1) === 0) return il(l, d, O, null); if (A.data === "$!") { if (b = A.nextSibling && A.nextSibling.dataset, b) var G = b.dgst; return b = G, L = Error(t(419)), b = ad(L, b, void 0), il(l, d, O, b) } if (G = (O & l.childLanes) !== 0, tr || G) { if (b = Nt, b !== null) { switch (O & -O) { case 4: A = 2; break; case 16: A = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: A = 32; break; case 536870912: A = 268435456; break; default: A = 0 }A = (A & (b.suspendedLanes | O)) !== 0 ? 0 : A, A !== 0 && A !== L.retryLane && (L.retryLane = A, yn(l, A), $r(b, l, A, -1)) } return Cd(), b = ad(Error(t(421))), il(l, d, O, b) } return A.data === "$?" ? (d.flags |= 128, d.child = l.child, d = B2.bind(null, l), A._reactRetry = d, null) : (l = L.treeContext, mr = Wn(A.nextSibling), pr = d, ht = !0, Or = null, l !== null && (Er[Tr++] = xn, Er[Tr++] = vn, Er[Tr++] = Cs, xn = l.id, vn = l.overflow, Cs = d), d = fd(d, b.children), d.flags |= 4096, d) } function zg(l, d, m) { l.lanes |= d; var b = l.alternate; b !== null && (b.lanes |= d), Vu(l.return, d, m) } function hd(l, d, m, b, A) { var L = l.memoizedState; L === null ? l.memoizedState = { isBackwards: d, rendering: null, renderingStartTime: 0, last: b, tail: m, tailMode: A } : (L.isBackwards = d, L.rendering = null, L.renderingStartTime = 0, L.last = b, L.tail = m, L.tailMode = A) } function Vg(l, d, m) { var b = d.pendingProps, A = b.revealOrder, L = b.tail; if (Wt(l, d, b.children, m), b = pt.current, (b & 2) !== 0) b = b & 1 | 2, d.flags |= 128; else { if (l !== null && (l.flags & 128) !== 0) e: for (l = d.child; l !== null;) { if (l.tag === 13) l.memoizedState !== null && zg(l, m, d); else if (l.tag === 19) zg(l, m, d); else if (l.child !== null) { l.child.return = l, l = l.child; continue } if (l === d) break e; for (; l.sibling === null;) { if (l.return === null || l.return === d) break e; l = l.return } l.sibling.return = l.return, l = l.sibling } b &= 1 } if (at(pt, b), (d.mode & 1) === 0) d.memoizedState = null; else switch (A) { case "forwards": for (m = d.child, A = null; m !== null;)l = m.alternate, l !== null && Zo(l) === null && (A = m), m = m.sibling; m = A, m === null ? (A = d.child, d.child = null) : (A = m.sibling, m.sibling = null), hd(d, !1, A, m, L); break; case "backwards": for (m = null, A = d.child, d.child = null; A !== null;) { if (l = A.alternate, l !== null && Zo(l) === null) { d.child = A; break } l = A.sibling, A.sibling = m, m = A, A = l } hd(d, !0, m, null, L); break; case "together": hd(d, !1, null, null, void 0); break; default: d.memoizedState = null }return d.child } function al(l, d) { (d.mode & 1) === 0 && l !== null && (l.alternate = null, d.alternate = null, d.flags |= 2) } function wn(l, d, m) { if (l !== null && (d.dependencies = l.dependencies), Ns |= d.lanes, (m & d.childLanes) === 0) return null; if (l !== null && d.child !== l.child) throw Error(t(153)); if (d.child !== null) { for (l = d.child, m = ns(l, l.pendingProps), d.child = m, m.return = d; l.sibling !== null;)l = l.sibling, m = m.sibling = ns(l, l.pendingProps), m.return = d; m.sibling = null } return d.child } function C2(l, d, m) { switch (d.tag) { case 3: $g(d), hi(); break; case 5: ng(d); break; case 1: er(d.type) && zo(d); break; case 4: Wu(d, d.stateNode.containerInfo); break; case 10: var b = d.type._context, A = d.memoizedProps.value; at(qo, b._currentValue), b._currentValue = A; break; case 13: if (b = d.memoizedState, b !== null) return b.dehydrated !== null ? (at(pt, pt.current & 1), d.flags |= 128, null) : (m & d.child.childLanes) !== 0 ? Ug(l, d, m) : (at(pt, pt.current & 1), l = wn(l, d, m), l !== null ? l.sibling : null); at(pt, pt.current & 1); break; case 19: if (b = (m & d.childLanes) !== 0, (l.flags & 128) !== 0) { if (b) return Vg(l, d, m); d.flags |= 128 } if (A = d.memoizedState, A !== null && (A.rendering = null, A.tail = null, A.lastEffect = null), at(pt, pt.current), b) break; return null; case 22: case 23: return d.lanes = 0, Mg(l, d, m) }return wn(l, d, m) } var Gg, pd, Hg, Wg; Gg = function (l, d) { for (var m = d.child; m !== null;) { if (m.tag === 5 || m.tag === 6) l.appendChild(m.stateNode); else if (m.tag !== 4 && m.child !== null) { m.child.return = m, m = m.child; continue } if (m === d) break; for (; m.sibling === null;) { if (m.return === null || m.return === d) return; m = m.return } m.sibling.return = m.return, m = m.sibling } }, pd = function () { }, Hg = function (l, d, m, b) { var A = l.memoizedProps; if (A !== b) { l = d.stateNode, _s(qr.current); var L = null; switch (m) { case "input": A = Oe(l, A), b = Oe(l, b), L = []; break; case "select": A = Z({}, A, { value: void 0 }), b = Z({}, b, { value: void 0 }), L = []; break; case "textarea": A = Et(l, A), b = Et(l, b), L = []; break; default: typeof A.onClick != "function" && typeof b.onClick == "function" && (l.onclick = $o) }Ki(m, b); var O; m = null; for (re in A) if (!b.hasOwnProperty(re) && A.hasOwnProperty(re) && A[re] != null) if (re === "style") { var G = A[re]; for (O in G) G.hasOwnProperty(O) && (m || (m = {}), m[O] = "") } else re !== "dangerouslySetInnerHTML" && re !== "children" && re !== "suppressContentEditableWarning" && re !== "suppressHydrationWarning" && re !== "autoFocus" && (s.hasOwnProperty(re) ? L || (L = []) : (L = L || []).push(re, null)); for (re in b) { var K = b[re]; if (G = A?.[re], b.hasOwnProperty(re) && K !== G && (K != null || G != null)) if (re === "style") if (G) { for (O in G) !G.hasOwnProperty(O) || K && K.hasOwnProperty(O) || (m || (m = {}), m[O] = ""); for (O in K) K.hasOwnProperty(O) && G[O] !== K[O] && (m || (m = {}), m[O] = K[O]) } else m || (L || (L = []), L.push(re, m)), m = K; else re === "dangerouslySetInnerHTML" ? (K = K ? K.__html : void 0, G = G ? G.__html : void 0, K != null && G !== K && (L = L || []).push(re, K)) : re === "children" ? typeof K != "string" && typeof K != "number" || (L = L || []).push(re, "" + K) : re !== "suppressContentEditableWarning" && re !== "suppressHydrationWarning" && (s.hasOwnProperty(re) ? (K != null && re === "onScroll" && lt("scroll", l), L || G === K || (L = [])) : (L = L || []).push(re, K)) } m && (L = L || []).push("style", m); var re = L; (d.updateQueue = re) && (d.flags |= 4) } }, Wg = function (l, d, m, b) { m !== b && (d.flags |= 4) }; function Ia(l, d) { if (!ht) switch (l.tailMode) { case "hidden": d = l.tail; for (var m = null; d !== null;)d.alternate !== null && (m = d), d = d.sibling; m === null ? l.tail = null : m.sibling = null; break; case "collapsed": m = l.tail; for (var b = null; m !== null;)m.alternate !== null && (b = m), m = m.sibling; b === null ? d || l.tail === null ? l.tail = null : l.tail.sibling = null : b.sibling = null } } function zt(l) { var d = l.alternate !== null && l.alternate.child === l.child, m = 0, b = 0; if (d) for (var A = l.child; A !== null;)m |= A.lanes | A.childLanes, b |= A.subtreeFlags & 14680064, b |= A.flags & 14680064, A.return = l, A = A.sibling; else for (A = l.child; A !== null;)m |= A.lanes | A.childLanes, b |= A.subtreeFlags, b |= A.flags, A.return = l, A = A.sibling; return l.subtreeFlags |= b, l.childLanes = m, d } function k2(l, d, m) { var b = d.pendingProps; switch (Mu(d), d.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return zt(d), null; case 1: return er(d.type) && Uo(), zt(d), null; case 3: return b = d.stateNode, xi(), ct(Jt), ct(Bt), Yu(), b.pendingContext && (b.context = b.pendingContext, b.pendingContext = null), (l === null || l.child === null) && (Wo(d) ? d.flags |= 4 : l === null || l.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024, Or !== null && (Ad(Or), Or = null))), pd(l, d), zt(d), null; case 5: Ku(d); var A = _s(wa.current); if (m = d.type, l !== null && d.stateNode != null) Hg(l, d, m, b, A), l.ref !== d.ref && (d.flags |= 512, d.flags |= 2097152); else { if (!b) { if (d.stateNode === null) throw Error(t(166)); return zt(d), null } if (l = _s(qr.current), Wo(d)) { b = d.stateNode, m = d.type; var L = d.memoizedProps; switch (b[Kr] = d, b[ga] = L, l = (d.mode & 1) !== 0, m) { case "dialog": lt("cancel", b), lt("close", b); break; case "iframe": case "object": case "embed": lt("load", b); break; case "video": case "audio": for (A = 0; A < ha.length; A++)lt(ha[A], b); break; case "source": lt("error", b); break; case "img": case "image": case "link": lt("error", b), lt("load", b); break; case "details": lt("toggle", b); break; case "input": ot(b, L), lt("invalid", b); break; case "select": b._wrapperState = { wasMultiple: !!L.multiple }, lt("invalid", b); break; case "textarea": _t(b, L), lt("invalid", b) }Ki(m, L), A = null; for (var O in L) if (L.hasOwnProperty(O)) { var G = L[O]; O === "children" ? typeof G == "string" ? b.textContent !== G && (L.suppressHydrationWarning !== !0 && Fo(b.textContent, G, l), A = ["children", G]) : typeof G == "number" && b.textContent !== "" + G && (L.suppressHydrationWarning !== !0 && Fo(b.textContent, G, l), A = ["children", "" + G]) : s.hasOwnProperty(O) && G != null && O === "onScroll" && lt("scroll", b) } switch (m) { case "input": rt(b), _e(b, L, !0); break; case "textarea": rt(b), Gr(b); break; case "select": case "option": break; default: typeof L.onClick == "function" && (b.onclick = $o) }b = A, d.updateQueue = b, b !== null && (d.flags |= 4) } else { O = A.nodeType === 9 ? A : A.ownerDocument, l === "http://www.w3.org/1999/xhtml" && (l = Zt(m)), l === "http://www.w3.org/1999/xhtml" ? m === "script" ? (l = O.createElement("div"), l.innerHTML = "<script><\/script>", l = l.removeChild(l.firstChild)) : typeof b.is == "string" ? l = O.createElement(m, { is: b.is }) : (l = O.createElement(m), m === "select" && (O = l, b.multiple ? O.multiple = !0 : b.size && (O.size = b.size))) : l = O.createElementNS(l, m), l[Kr] = d, l[ga] = b, Gg(l, d, !1, !1), d.stateNode = l; e: { switch (O = qi(m, b), m) { case "dialog": lt("cancel", l), lt("close", l), A = b; break; case "iframe": case "object": case "embed": lt("load", l), A = b; break; case "video": case "audio": for (A = 0; A < ha.length; A++)lt(ha[A], l); A = b; break; case "source": lt("error", l), A = b; break; case "img": case "image": case "link": lt("error", l), lt("load", l), A = b; break; case "details": lt("toggle", l), A = b; break; case "input": ot(l, b), A = Oe(l, b), lt("invalid", l); break; case "option": A = b; break; case "select": l._wrapperState = { wasMultiple: !!b.multiple }, A = Z({}, b, { value: void 0 }), lt("invalid", l); break; case "textarea": _t(l, b), A = Et(l, b), lt("invalid", l); break; default: A = b }Ki(m, A), G = A; for (L in G) if (G.hasOwnProperty(L)) { var K = G[L]; L === "style" ? xo(l, K) : L === "dangerouslySetInnerHTML" ? (K = K ? K.__html : void 0, K != null && Ts(l, K)) : L === "children" ? typeof K == "string" ? (m !== "textarea" || K !== "") && Hr(l, K) : typeof K == "number" && Hr(l, "" + K) : L !== "suppressContentEditableWarning" && L !== "suppressHydrationWarning" && L !== "autoFocus" && (s.hasOwnProperty(L) ? K != null && L === "onScroll" && lt("scroll", l) : K != null && E(l, L, K, O)) } switch (m) { case "input": rt(l), _e(l, b, !1); break; case "textarea": rt(l), Gr(l); break; case "option": b.value != null && l.setAttribute("value", "" + Ie(b.value)); break; case "select": l.multiple = !!b.multiple, L = b.value, L != null ? vt(l, !!b.multiple, L, !1) : b.defaultValue != null && vt(l, !!b.multiple, b.defaultValue, !0); break; default: typeof A.onClick == "function" && (l.onclick = $o) }switch (m) { case "button": case "input": case "select": case "textarea": b = !!b.autoFocus; break e; case "img": b = !0; break e; default: b = !1 } } b && (d.flags |= 4) } d.ref !== null && (d.flags |= 512, d.flags |= 2097152) } return zt(d), null; case 6: if (l && d.stateNode != null) Wg(l, d, l.memoizedProps, b); else { if (typeof b != "string" && d.stateNode === null) throw Error(t(166)); if (m = _s(wa.current), _s(qr.current), Wo(d)) { if (b = d.stateNode, m = d.memoizedProps, b[Kr] = d, (L = b.nodeValue !== m) && (l = pr, l !== null)) switch (l.tag) { case 3: Fo(b.nodeValue, m, (l.mode & 1) !== 0); break; case 5: l.memoizedProps.suppressHydrationWarning !== !0 && Fo(b.nodeValue, m, (l.mode & 1) !== 0) }L && (d.flags |= 4) } else b = (m.nodeType === 9 ? m : m.ownerDocument).createTextNode(b), b[Kr] = d, d.stateNode = b } return zt(d), null; case 13: if (ct(pt), b = d.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) { if (ht && mr !== null && (d.mode & 1) !== 0 && (d.flags & 128) === 0) Ym(), hi(), d.flags |= 98560, L = !1; else if (L = Wo(d), b !== null && b.dehydrated !== null) { if (l === null) { if (!L) throw Error(t(318)); if (L = d.memoizedState, L = L !== null ? L.dehydrated : null, !L) throw Error(t(317)); L[Kr] = d } else hi(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4; zt(d), L = !1 } else Or !== null && (Ad(Or), Or = null), L = !0; if (!L) return d.flags & 65536 ? d : null } return (d.flags & 128) !== 0 ? (d.lanes = m, d) : (b = b !== null, b !== (l !== null && l.memoizedState !== null) && b && (d.child.flags |= 8192, (d.mode & 1) !== 0 && (l === null || (pt.current & 1) !== 0 ? Ct === 0 && (Ct = 3) : Cd())), d.updateQueue !== null && (d.flags |= 4), zt(d), null); case 4: return xi(), pd(l, d), l === null && pa(d.stateNode.containerInfo), zt(d), null; case 10: return zu(d.type._context), zt(d), null; case 17: return er(d.type) && Uo(), zt(d), null; case 19: if (ct(pt), L = d.memoizedState, L === null) return zt(d), null; if (b = (d.flags & 128) !== 0, O = L.rendering, O === null) if (b) Ia(L, !1); else { if (Ct !== 0 || l !== null && (l.flags & 128) !== 0) for (l = d.child; l !== null;) { if (O = Zo(l), O !== null) { for (d.flags |= 128, Ia(L, !1), b = O.updateQueue, b !== null && (d.updateQueue = b, d.flags |= 4), d.subtreeFlags = 0, b = m, m = d.child; m !== null;)L = m, l = b, L.flags &= 14680066, O = L.alternate, O === null ? (L.childLanes = 0, L.lanes = l, L.child = null, L.subtreeFlags = 0, L.memoizedProps = null, L.memoizedState = null, L.updateQueue = null, L.dependencies = null, L.stateNode = null) : (L.childLanes = O.childLanes, L.lanes = O.lanes, L.child = O.child, L.subtreeFlags = 0, L.deletions = null, L.memoizedProps = O.memoizedProps, L.memoizedState = O.memoizedState, L.updateQueue = O.updateQueue, L.type = O.type, l = O.dependencies, L.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }), m = m.sibling; return at(pt, pt.current & 1 | 2), d.child } l = l.sibling } L.tail !== null && wt() > wi && (d.flags |= 128, b = !0, Ia(L, !1), d.lanes = 4194304) } else { if (!b) if (l = Zo(O), l !== null) { if (d.flags |= 128, b = !0, m = l.updateQueue, m !== null && (d.updateQueue = m, d.flags |= 4), Ia(L, !0), L.tail === null && L.tailMode === "hidden" && !O.alternate && !ht) return zt(d), null } else 2 * wt() - L.renderingStartTime > wi && m !== 1073741824 && (d.flags |= 128, b = !0, Ia(L, !1), d.lanes = 4194304); L.isBackwards ? (O.sibling = d.child, d.child = O) : (m = L.last, m !== null ? m.sibling = O : d.child = O, L.last = O) } return L.tail !== null ? (d = L.tail, L.rendering = d, L.tail = d.sibling, L.renderingStartTime = wt(), d.sibling = null, m = pt.current, at(pt, b ? m & 1 | 2 : m & 1), d) : (zt(d), null); case 22: case 23: return Ld(), b = d.memoizedState !== null, l !== null && l.memoizedState !== null !== b && (d.flags |= 8192), b && (d.mode & 1) !== 0 ? (gr & 1073741824) !== 0 && (zt(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : zt(d), null; case 24: return null; case 25: return null }throw Error(t(156, d.tag)) } function R2(l, d) { switch (Mu(d), d.tag) { case 1: return er(d.type) && Uo(), l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null; case 3: return xi(), ct(Jt), ct(Bt), Yu(), l = d.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (d.flags = l & -65537 | 128, d) : null; case 5: return Ku(d), null; case 13: if (ct(pt), l = d.memoizedState, l !== null && l.dehydrated !== null) { if (d.alternate === null) throw Error(t(340)); hi() } return l = d.flags, l & 65536 ? (d.flags = l & -65537 | 128, d) : null; case 19: return ct(pt), null; case 4: return xi(), null; case 10: return zu(d.type._context), null; case 22: case 23: return Ld(), null; case 24: return null; default: return null } } var ol = !1, Vt = !1, _2 = typeof WeakSet == "function" ? WeakSet : Set, ye = null; function yi(l, d) { var m = l.ref; if (m !== null) if (typeof m == "function") try { m(null) } catch (b) { yt(l, d, b) } else m.current = null } function md(l, d, m) { try { m() } catch (b) { yt(l, d, b) } } var Kg = !1; function P2(l, d) { if (Lu = Lo, l = Am(), yu(l)) { if ("selectionStart" in l) var m = { start: l.selectionStart, end: l.selectionEnd }; else e: { m = (m = l.ownerDocument) && m.defaultView || window; var b = m.getSelection && m.getSelection(); if (b && b.rangeCount !== 0) { m = b.anchorNode; var A = b.anchorOffset, L = b.focusNode; b = b.focusOffset; try { m.nodeType, L.nodeType } catch { m = null; break e } var O = 0, G = -1, K = -1, re = 0, le = 0, ce = l, oe = null; t: for (; ;) { for (var xe; ce !== m || A !== 0 && ce.nodeType !== 3 || (G = O + A), ce !== L || b !== 0 && ce.nodeType !== 3 || (K = O + b), ce.nodeType === 3 && (O += ce.nodeValue.length), (xe = ce.firstChild) !== null;)oe = ce, ce = xe; for (; ;) { if (ce === l) break t; if (oe === m && ++re === A && (G = O), oe === L && ++le === b && (K = O), (xe = ce.nextSibling) !== null) break; ce = oe, oe = ce.parentNode } ce = xe } m = G === -1 || K === -1 ? null : { start: G, end: K } } else m = null } m = m || { start: 0, end: 0 } } else m = null; for (Cu = { focusedElem: l, selectionRange: m }, Lo = !1, ye = d; ye !== null;)if (d = ye, l = d.child, (d.subtreeFlags & 1028) !== 0 && l !== null) l.return = d, ye = l; else for (; ye !== null;) { d = ye; try { var be = d.alternate; if ((d.flags & 1024) !== 0) switch (d.tag) { case 0: case 11: case 15: break; case 1: if (be !== null) { var we = be.memoizedProps, St = be.memoizedState, ee = d.stateNode, Y = ee.getSnapshotBeforeUpdate(d.elementType === d.type ? we : Mr(d.type, we), St); ee.__reactInternalSnapshotBeforeUpdate = Y } break; case 3: var te = d.stateNode.containerInfo; te.nodeType === 1 ? te.textContent = "" : te.nodeType === 9 && te.documentElement && te.removeChild(te.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(t(163)) } } catch (fe) { yt(d, d.return, fe) } if (l = d.sibling, l !== null) { l.return = d.return, ye = l; break } ye = d.return } return be = Kg, Kg = !1, be } function La(l, d, m) { var b = d.updateQueue; if (b = b !== null ? b.lastEffect : null, b !== null) { var A = b = b.next; do { if ((A.tag & l) === l) { var L = A.destroy; A.destroy = void 0, L !== void 0 && md(d, m, L) } A = A.next } while (A !== b) } } function ll(l, d) { if (d = d.updateQueue, d = d !== null ? d.lastEffect : null, d !== null) { var m = d = d.next; do { if ((m.tag & l) === l) { var b = m.create; m.destroy = b() } m = m.next } while (m !== d) } } function gd(l) { var d = l.ref; if (d !== null) { var m = l.stateNode; switch (l.tag) { case 5: l = m; break; default: l = m }typeof d == "function" ? d(l) : d.current = l } } function qg(l) { var d = l.alternate; d !== null && (l.alternate = null, qg(d)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (d = l.stateNode, d !== null && (delete d[Kr], delete d[ga], delete d[Pu], delete d[p2], delete d[m2])), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null } function Yg(l) { return l.tag === 5 || l.tag === 3 || l.tag === 4 } function Xg(l) { e: for (; ;) { for (; l.sibling === null;) { if (l.return === null || Yg(l.return)) return null; l = l.return } for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18;) { if (l.flags & 2 || l.child === null || l.tag === 4) continue e; l.child.return = l, l = l.child } if (!(l.flags & 2)) return l.stateNode } } function xd(l, d, m) { var b = l.tag; if (b === 5 || b === 6) l = l.stateNode, d ? m.nodeType === 8 ? m.parentNode.insertBefore(l, d) : m.insertBefore(l, d) : (m.nodeType === 8 ? (d = m.parentNode, d.insertBefore(l, m)) : (d = m, d.appendChild(l)), m = m._reactRootContainer, m != null || d.onclick !== null || (d.onclick = $o)); else if (b !== 4 && (l = l.child, l !== null)) for (xd(l, d, m), l = l.sibling; l !== null;)xd(l, d, m), l = l.sibling } function vd(l, d, m) { var b = l.tag; if (b === 5 || b === 6) l = l.stateNode, d ? m.insertBefore(l, d) : m.appendChild(l); else if (b !== 4 && (l = l.child, l !== null)) for (vd(l, d, m), l = l.sibling; l !== null;)vd(l, d, m), l = l.sibling } var jt = null, jr = !1; function Zn(l, d, m) { for (m = m.child; m !== null;)Qg(l, d, m), m = m.sibling } function Qg(l, d, m) { if (Wr && typeof Wr.onCommitFiberUnmount == "function") try { Wr.onCommitFiberUnmount(wo, m) } catch { } switch (m.tag) { case 5: Vt || yi(m, d); case 6: var b = jt, A = jr; jt = null, Zn(l, d, m), jt = b, jr = A, jt !== null && (jr ? (l = jt, m = m.stateNode, l.nodeType === 8 ? l.parentNode.removeChild(m) : l.removeChild(m)) : jt.removeChild(m.stateNode)); break; case 18: jt !== null && (jr ? (l = jt, m = m.stateNode, l.nodeType === 8 ? _u(l.parentNode, m) : l.nodeType === 1 && _u(l, m), ia(l)) : _u(jt, m.stateNode)); break; case 4: b = jt, A = jr, jt = m.stateNode.containerInfo, jr = !0, Zn(l, d, m), jt = b, jr = A; break; case 0: case 11: case 14: case 15: if (!Vt && (b = m.updateQueue, b !== null && (b = b.lastEffect, b !== null))) { A = b = b.next; do { var L = A, O = L.destroy; L = L.tag, O !== void 0 && ((L & 2) !== 0 || (L & 4) !== 0) && md(m, d, O), A = A.next } while (A !== b) } Zn(l, d, m); break; case 1: if (!Vt && (yi(m, d), b = m.stateNode, typeof b.componentWillUnmount == "function")) try { b.props = m.memoizedProps, b.state = m.memoizedState, b.componentWillUnmount() } catch (G) { yt(m, d, G) } Zn(l, d, m); break; case 21: Zn(l, d, m); break; case 22: m.mode & 1 ? (Vt = (b = Vt) || m.memoizedState !== null, Zn(l, d, m), Vt = b) : Zn(l, d, m); break; default: Zn(l, d, m) } } function Zg(l) { var d = l.updateQueue; if (d !== null) { l.updateQueue = null; var m = l.stateNode; m === null && (m = l.stateNode = new _2), d.forEach(function (b) { var A = U2.bind(null, l, b); m.has(b) || (m.add(b), b.then(A, A)) }) } } function Fr(l, d) { var m = d.deletions; if (m !== null) for (var b = 0; b < m.length; b++) { var A = m[b]; try { var L = l, O = d, G = O; e: for (; G !== null;) { switch (G.tag) { case 5: jt = G.stateNode, jr = !1; break e; case 3: jt = G.stateNode.containerInfo, jr = !0; break e; case 4: jt = G.stateNode.containerInfo, jr = !0; break e }G = G.return } if (jt === null) throw Error(t(160)); Qg(L, O, A), jt = null, jr = !1; var K = A.alternate; K !== null && (K.return = null), A.return = null } catch (re) { yt(A, d, re) } } if (d.subtreeFlags & 12854) for (d = d.child; d !== null;)Jg(d, l), d = d.sibling } function Jg(l, d) { var m = l.alternate, b = l.flags; switch (l.tag) { case 0: case 11: case 14: case 15: if (Fr(d, l), Xr(l), b & 4) { try { La(3, l, l.return), ll(3, l) } catch (we) { yt(l, l.return, we) } try { La(5, l, l.return) } catch (we) { yt(l, l.return, we) } } break; case 1: Fr(d, l), Xr(l), b & 512 && m !== null && yi(m, m.return); break; case 5: if (Fr(d, l), Xr(l), b & 512 && m !== null && yi(m, m.return), l.flags & 32) { var A = l.stateNode; try { Hr(A, "") } catch (we) { yt(l, l.return, we) } } if (b & 4 && (A = l.stateNode, A != null)) { var L = l.memoizedProps, O = m !== null ? m.memoizedProps : L, G = l.type, K = l.updateQueue; if (l.updateQueue = null, K !== null) try { G === "input" && L.type === "radio" && L.name != null && Le(A, L), qi(G, O); var re = qi(G, L); for (O = 0; O < K.length; O += 2) { var le = K[O], ce = K[O + 1]; le === "style" ? xo(A, ce) : le === "dangerouslySetInnerHTML" ? Ts(A, ce) : le === "children" ? Hr(A, ce) : E(A, le, ce, re) } switch (G) { case "input": ie(A, L); break; case "textarea": dr(A, L); break; case "select": var oe = A._wrapperState.wasMultiple; A._wrapperState.wasMultiple = !!L.multiple; var xe = L.value; xe != null ? vt(A, !!L.multiple, xe, !1) : oe !== !!L.multiple && (L.defaultValue != null ? vt(A, !!L.multiple, L.defaultValue, !0) : vt(A, !!L.multiple, L.multiple ? [] : "", !1)) }A[ga] = L } catch (we) { yt(l, l.return, we) } } break; case 6: if (Fr(d, l), Xr(l), b & 4) { if (l.stateNode === null) throw Error(t(162)); A = l.stateNode, L = l.memoizedProps; try { A.nodeValue = L } catch (we) { yt(l, l.return, we) } } break; case 3: if (Fr(d, l), Xr(l), b & 4 && m !== null && m.memoizedState.isDehydrated) try { ia(d.containerInfo) } catch (we) { yt(l, l.return, we) } break; case 4: Fr(d, l), Xr(l); break; case 13: Fr(d, l), Xr(l), A = l.child, A.flags & 8192 && (L = A.memoizedState !== null, A.stateNode.isHidden = L, !L || A.alternate !== null && A.alternate.memoizedState !== null || (wd = wt())), b & 4 && Zg(l); break; case 22: if (le = m !== null && m.memoizedState !== null, l.mode & 1 ? (Vt = (re = Vt) || le, Fr(d, l), Vt = re) : Fr(d, l), Xr(l), b & 8192) { if (re = l.memoizedState !== null, (l.stateNode.isHidden = re) && !le && (l.mode & 1) !== 0) for (ye = l, le = l.child; le !== null;) { for (ce = ye = le; ye !== null;) { switch (oe = ye, xe = oe.child, oe.tag) { case 0: case 11: case 14: case 15: La(4, oe, oe.return); break; case 1: yi(oe, oe.return); var be = oe.stateNode; if (typeof be.componentWillUnmount == "function") { b = oe, m = oe.return; try { d = b, be.props = d.memoizedProps, be.state = d.memoizedState, be.componentWillUnmount() } catch (we) { yt(b, m, we) } } break; case 5: yi(oe, oe.return); break; case 22: if (oe.memoizedState !== null) { r0(ce); continue } }xe !== null ? (xe.return = oe, ye = xe) : r0(ce) } le = le.sibling } e: for (le = null, ce = l; ;) { if (ce.tag === 5) { if (le === null) { le = ce; try { A = ce.stateNode, re ? (L = A.style, typeof L.setProperty == "function" ? L.setProperty("display", "none", "important") : L.display = "none") : (G = ce.stateNode, K = ce.memoizedProps.style, O = K != null && K.hasOwnProperty("display") ? K.display : null, G.style.display = go("display", O)) } catch (we) { yt(l, l.return, we) } } } else if (ce.tag === 6) { if (le === null) try { ce.stateNode.nodeValue = re ? "" : ce.memoizedProps } catch (we) { yt(l, l.return, we) } } else if ((ce.tag !== 22 && ce.tag !== 23 || ce.memoizedState === null || ce === l) && ce.child !== null) { ce.child.return = ce, ce = ce.child; continue } if (ce === l) break e; for (; ce.sibling === null;) { if (ce.return === null || ce.return === l) break e; le === ce && (le = null), ce = ce.return } le === ce && (le = null), ce.sibling.return = ce.return, ce = ce.sibling } } break; case 19: Fr(d, l), Xr(l), b & 4 && Zg(l); break; case 21: break; default: Fr(d, l), Xr(l) } } function Xr(l) { var d = l.flags; if (d & 2) { try { e: { for (var m = l.return; m !== null;) { if (Yg(m)) { var b = m; break e } m = m.return } throw Error(t(160)) } switch (b.tag) { case 5: var A = b.stateNode; b.flags & 32 && (Hr(A, ""), b.flags &= -33); var L = Xg(l); vd(l, L, A); break; case 3: case 4: var O = b.stateNode.containerInfo, G = Xg(l); xd(l, G, O); break; default: throw Error(t(161)) } } catch (K) { yt(l, l.return, K) } l.flags &= -3 } d & 4096 && (l.flags &= -4097) } function N2(l, d, m) { ye = l, e0(l) } function e0(l, d, m) { for (var b = (l.mode & 1) !== 0; ye !== null;) { var A = ye, L = A.child; if (A.tag === 22 && b) { var O = A.memoizedState !== null || ol; if (!O) { var G = A.alternate, K = G !== null && G.memoizedState !== null || Vt; G = ol; var re = Vt; if (ol = O, (Vt = K) && !re) for (ye = A; ye !== null;)O = ye, K = O.child, O.tag === 22 && O.memoizedState !== null ? n0(A) : K !== null ? (K.return = O, ye = K) : n0(A); for (; L !== null;)ye = L, e0(L), L = L.sibling; ye = A, ol = G, Vt = re } t0(l) } else (A.subtreeFlags & 8772) !== 0 && L !== null ? (L.return = A, ye = L) : t0(l) } } function t0(l) { for (; ye !== null;) { var d = ye; if ((d.flags & 8772) !== 0) { var m = d.alternate; try { if ((d.flags & 8772) !== 0) switch (d.tag) { case 0: case 11: case 15: Vt || ll(5, d); break; case 1: var b = d.stateNode; if (d.flags & 4 && !Vt) if (m === null) b.componentDidMount(); else { var A = d.elementType === d.type ? m.memoizedProps : Mr(d.type, m.memoizedProps); b.componentDidUpdate(A, m.memoizedState, b.__reactInternalSnapshotBeforeUpdate) } var L = d.updateQueue; L !== null && rg(d, L, b); break; case 3: var O = d.updateQueue; if (O !== null) { if (m = null, d.child !== null) switch (d.child.tag) { case 5: m = d.child.stateNode; break; case 1: m = d.child.stateNode }rg(d, O, m) } break; case 5: var G = d.stateNode; if (m === null && d.flags & 4) { m = G; var K = d.memoizedProps; switch (d.type) { case "button": case "input": case "select": case "textarea": K.autoFocus && m.focus(); break; case "img": K.src && (m.src = K.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (d.memoizedState === null) { var re = d.alternate; if (re !== null) { var le = re.memoizedState; if (le !== null) { var ce = le.dehydrated; ce !== null && ia(ce) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(t(163)) }Vt || d.flags & 512 && gd(d) } catch (oe) { yt(d, d.return, oe) } } if (d === l) { ye = null; break } if (m = d.sibling, m !== null) { m.return = d.return, ye = m; break } ye = d.return } } function r0(l) { for (; ye !== null;) { var d = ye; if (d === l) { ye = null; break } var m = d.sibling; if (m !== null) { m.return = d.return, ye = m; break } ye = d.return } } function n0(l) { for (; ye !== null;) { var d = ye; try { switch (d.tag) { case 0: case 11: case 15: var m = d.return; try { ll(4, d) } catch (K) { yt(d, m, K) } break; case 1: var b = d.stateNode; if (typeof b.componentDidMount == "function") { var A = d.return; try { b.componentDidMount() } catch (K) { yt(d, A, K) } } var L = d.return; try { gd(d) } catch (K) { yt(d, L, K) } break; case 5: var O = d.return; try { gd(d) } catch (K) { yt(d, O, K) } } } catch (K) { yt(d, d.return, K) } if (d === l) { ye = null; break } var G = d.sibling; if (G !== null) { G.return = d.return, ye = G; break } ye = d.return } } var D2 = Math.ceil, cl = I.ReactCurrentDispatcher, yd = I.ReactCurrentOwner, Lr = I.ReactCurrentBatchConfig, Ye = 0, Nt = null, Tt = null, Ft = 0, gr = 0, bi = Kn(0), Ct = 0, Ca = null, Ns = 0, ul = 0, bd = 0, ka = null, rr = null, wd = 0, wi = 1 / 0, Sn = null, dl = !1, Sd = null, Jn = null, fl = !1, es = null, hl = 0, Ra = 0, Ed = null, pl = -1, ml = 0; function Kt() { return (Ye & 6) !== 0 ? wt() : pl !== -1 ? pl : pl = wt() } function ts(l) { return (l.mode & 1) === 0 ? 1 : (Ye & 2) !== 0 && Ft !== 0 ? Ft & -Ft : x2.transition !== null ? (ml === 0 && (ml = Xp()), ml) : (l = Je, l !== 0 || (l = window.event, l = l === void 0 ? 16 : im(l.type)), l) } function $r(l, d, m, b) { if (50 < Ra) throw Ra = 0, Ed = null, Error(t(185)); ea(l, m, b), ((Ye & 2) === 0 || l !== Nt) && (l === Nt && ((Ye & 2) === 0 && (ul |= m), Ct === 4 && rs(l, Ft)), nr(l, b), m === 1 && Ye === 0 && (d.mode & 1) === 0 && (wi = wt() + 500, Vo && Yn())) } function nr(l, d) { var m = l.callbackNode; xS(l, d); var b = To(l, l === Nt ? Ft : 0); if (b === 0) m !== null && Kp(m), l.callbackNode = null, l.callbackPriority = 0; else if (d = b & -b, l.callbackPriority !== d) { if (m != null && Kp(m), d === 1) l.tag === 0 ? g2(i0.bind(null, l)) : Gm(i0.bind(null, l)), f2(function () { (Ye & 6) === 0 && Yn() }), m = null; else { switch (Qp(b)) { case 1: m = ru; break; case 4: m = qp; break; case 16: m = bo; break; case 536870912: m = Yp; break; default: m = bo }m = h0(m, s0.bind(null, l)) } l.callbackPriority = d, l.callbackNode = m } } function s0(l, d) { if (pl = -1, ml = 0, (Ye & 6) !== 0) throw Error(t(327)); var m = l.callbackNode; if (Si() && l.callbackNode !== m) return null; var b = To(l, l === Nt ? Ft : 0); if (b === 0) return null; if ((b & 30) !== 0 || (b & l.expiredLanes) !== 0 || d) d = gl(l, b); else { d = b; var A = Ye; Ye |= 2; var L = o0(); (Nt !== l || Ft !== d) && (Sn = null, wi = wt() + 500, Os(l, d)); do try { j2(); break } catch (G) { a0(l, G) } while (!0); Uu(), cl.current = L, Ye = A, Tt !== null ? d = 0 : (Nt = null, Ft = 0, d = Ct) } if (d !== 0) { if (d === 2 && (A = nu(l), A !== 0 && (b = A, d = Td(l, A))), d === 1) throw m = Ca, Os(l, 0), rs(l, b), nr(l, wt()), m; if (d === 6) rs(l, b); else { if (A = l.current.alternate, (b & 30) === 0 && !O2(A) && (d = gl(l, b), d === 2 && (L = nu(l), L !== 0 && (b = L, d = Td(l, L))), d === 1)) throw m = Ca, Os(l, 0), rs(l, b), nr(l, wt()), m; switch (l.finishedWork = A, l.finishedLanes = b, d) { case 0: case 1: throw Error(t(345)); case 2: Ms(l, rr, Sn); break; case 3: if (rs(l, b), (b & 130023424) === b && (d = wd + 500 - wt(), 10 < d)) { if (To(l, 0) !== 0) break; if (A = l.suspendedLanes, (A & b) !== b) { Kt(), l.pingedLanes |= l.suspendedLanes & A; break } l.timeoutHandle = Ru(Ms.bind(null, l, rr, Sn), d); break } Ms(l, rr, Sn); break; case 4: if (rs(l, b), (b & 4194240) === b) break; for (d = l.eventTimes, A = -1; 0 < b;) { var O = 31 - Nr(b); L = 1 << O, O = d[O], O > A && (A = O), b &= ~L } if (b = A, b = wt() - b, b = (120 > b ? 120 : 480 > b ? 480 : 1080 > b ? 1080 : 1920 > b ? 1920 : 3e3 > b ? 3e3 : 4320 > b ? 4320 : 1960 * D2(b / 1960)) - b, 10 < b) { l.timeoutHandle = Ru(Ms.bind(null, l, rr, Sn), b); break } Ms(l, rr, Sn); break; case 5: Ms(l, rr, Sn); break; default: throw Error(t(329)) } } } return nr(l, wt()), l.callbackNode === m ? s0.bind(null, l) : null } function Td(l, d) { var m = ka; return l.current.memoizedState.isDehydrated && (Os(l, d).flags |= 256), l = gl(l, d), l !== 2 && (d = rr, rr = m, d !== null && Ad(d)), l } function Ad(l) { rr === null ? rr = l : rr.push.apply(rr, l) } function O2(l) { for (var d = l; ;) { if (d.flags & 16384) { var m = d.updateQueue; if (m !== null && (m = m.stores, m !== null)) for (var b = 0; b < m.length; b++) { var A = m[b], L = A.getSnapshot; A = A.value; try { if (!Dr(L(), A)) return !1 } catch { return !1 } } } if (m = d.child, d.subtreeFlags & 16384 && m !== null) m.return = d, d = m; else { if (d === l) break; for (; d.sibling === null;) { if (d.return === null || d.return === l) return !0; d = d.return } d.sibling.return = d.return, d = d.sibling } } return !0 } function rs(l, d) { for (d &= ~bd, d &= ~ul, l.suspendedLanes |= d, l.pingedLanes &= ~d, l = l.expirationTimes; 0 < d;) { var m = 31 - Nr(d), b = 1 << m; l[m] = -1, d &= ~b } } function i0(l) { if ((Ye & 6) !== 0) throw Error(t(327)); Si(); var d = To(l, 0); if ((d & 1) === 0) return nr(l, wt()), null; var m = gl(l, d); if (l.tag !== 0 && m === 2) { var b = nu(l); b !== 0 && (d = b, m = Td(l, b)) } if (m === 1) throw m = Ca, Os(l, 0), rs(l, d), nr(l, wt()), m; if (m === 6) throw Error(t(345)); return l.finishedWork = l.current.alternate, l.finishedLanes = d, Ms(l, rr, Sn), nr(l, wt()), null } function Id(l, d) { var m = Ye; Ye |= 1; try { return l(d) } finally { Ye = m, Ye === 0 && (wi = wt() + 500, Vo && Yn()) } } function Ds(l) { es !== null && es.tag === 0 && (Ye & 6) === 0 && Si(); var d = Ye; Ye |= 1; var m = Lr.transition, b = Je; try { if (Lr.transition = null, Je = 1, l) return l() } finally { Je = b, Lr.transition = m, Ye = d, (Ye & 6) === 0 && Yn() } } function Ld() { gr = bi.current, ct(bi) } function Os(l, d) { l.finishedWork = null, l.finishedLanes = 0; var m = l.timeoutHandle; if (m !== -1 && (l.timeoutHandle = -1, d2(m)), Tt !== null) for (m = Tt.return; m !== null;) { var b = m; switch (Mu(b), b.tag) { case 1: b = b.type.childContextTypes, b != null && Uo(); break; case 3: xi(), ct(Jt), ct(Bt), Yu(); break; case 5: Ku(b); break; case 4: xi(); break; case 13: ct(pt); break; case 19: ct(pt); break; case 10: zu(b.type._context); break; case 22: case 23: Ld() }m = m.return } if (Nt = l, Tt = l = ns(l.current, null), Ft = gr = d, Ct = 0, Ca = null, bd = ul = Ns = 0, rr = ka = null, Rs !== null) { for (d = 0; d < Rs.length; d++)if (m = Rs[d], b = m.interleaved, b !== null) { m.interleaved = null; var A = b.next, L = m.pending; if (L !== null) { var O = L.next; L.next = A, b.next = O } m.pending = b } Rs = null } return l } function a0(l, d) { do { var m = Tt; try { if (Uu(), Jo.current = nl, el) { for (var b = mt.memoizedState; b !== null;) { var A = b.queue; A !== null && (A.pending = null), b = b.next } el = !1 } if (Ps = 0, Pt = Lt = mt = null, Sa = !1, Ea = 0, yd.current = null, m === null || m.return === null) { Ct = 1, Ca = d, Tt = null; break } e: { var L = l, O = m.return, G = m, K = d; if (d = Ft, G.flags |= 32768, K !== null && typeof K == "object" && typeof K.then == "function") { var re = K, le = G, ce = le.tag; if ((le.mode & 1) === 0 && (ce === 0 || ce === 11 || ce === 15)) { var oe = le.alternate; oe ? (le.updateQueue = oe.updateQueue, le.memoizedState = oe.memoizedState, le.lanes = oe.lanes) : (le.updateQueue = null, le.memoizedState = null) } var xe = _g(O); if (xe !== null) { xe.flags &= -257, Pg(xe, O, G, L, d), xe.mode & 1 && Rg(L, re, d), d = xe, K = re; var be = d.updateQueue; if (be === null) { var we = new Set; we.add(K), d.updateQueue = we } else be.add(K); break e } else { if ((d & 1) === 0) { Rg(L, re, d), Cd(); break e } K = Error(t(426)) } } else if (ht && G.mode & 1) { var St = _g(O); if (St !== null) { (St.flags & 65536) === 0 && (St.flags |= 256), Pg(St, O, G, L, d), $u(vi(K, G)); break e } } L = K = vi(K, G), Ct !== 4 && (Ct = 2), ka === null ? ka = [L] : ka.push(L), L = O; do { switch (L.tag) { case 3: L.flags |= 65536, d &= -d, L.lanes |= d; var ee = Cg(L, K, d); tg(L, ee); break e; case 1: G = K; var Y = L.type, te = L.stateNode; if ((L.flags & 128) === 0 && (typeof Y.getDerivedStateFromError == "function" || te !== null && typeof te.componentDidCatch == "function" && (Jn === null || !Jn.has(te)))) { L.flags |= 65536, d &= -d, L.lanes |= d; var fe = kg(L, G, d); tg(L, fe); break e } }L = L.return } while (L !== null) } c0(m) } catch (Te) { d = Te, Tt === m && m !== null && (Tt = m = m.return); continue } break } while (!0) } function o0() { var l = cl.current; return cl.current = nl, l === null ? nl : l } function Cd() { (Ct === 0 || Ct === 3 || Ct === 2) && (Ct = 4), Nt === null || (Ns & 268435455) === 0 && (ul & 268435455) === 0 || rs(Nt, Ft) } function gl(l, d) { var m = Ye; Ye |= 2; var b = o0(); (Nt !== l || Ft !== d) && (Sn = null, Os(l, d)); do try { M2(); break } catch (A) { a0(l, A) } while (!0); if (Uu(), Ye = m, cl.current = b, Tt !== null) throw Error(t(261)); return Nt = null, Ft = 0, Ct } function M2() { for (; Tt !== null;)l0(Tt) } function j2() { for (; Tt !== null && !lS();)l0(Tt) } function l0(l) { var d = f0(l.alternate, l, gr); l.memoizedProps = l.pendingProps, d === null ? c0(l) : Tt = d, yd.current = null } function c0(l) { var d = l; do { var m = d.alternate; if (l = d.return, (d.flags & 32768) === 0) { if (m = k2(m, d, gr), m !== null) { Tt = m; return } } else { if (m = R2(m, d), m !== null) { m.flags &= 32767, Tt = m; return } if (l !== null) l.flags |= 32768, l.subtreeFlags = 0, l.deletions = null; else { Ct = 6, Tt = null; return } } if (d = d.sibling, d !== null) { Tt = d; return } Tt = d = l } while (d !== null); Ct === 0 && (Ct = 5) } function Ms(l, d, m) { var b = Je, A = Lr.transition; try { Lr.transition = null, Je = 1, F2(l, d, m, b) } finally { Lr.transition = A, Je = b } return null } function F2(l, d, m, b) { do Si(); while (es !== null); if ((Ye & 6) !== 0) throw Error(t(327)); m = l.finishedWork; var A = l.finishedLanes; if (m === null) return null; if (l.finishedWork = null, l.finishedLanes = 0, m === l.current) throw Error(t(177)); l.callbackNode = null, l.callbackPriority = 0; var L = m.lanes | m.childLanes; if (vS(l, L), l === Nt && (Tt = Nt = null, Ft = 0), (m.subtreeFlags & 2064) === 0 && (m.flags & 2064) === 0 || fl || (fl = !0, h0(bo, function () { return Si(), null })), L = (m.flags & 15990) !== 0, (m.subtreeFlags & 15990) !== 0 || L) { L = Lr.transition, Lr.transition = null; var O = Je; Je = 1; var G = Ye; Ye |= 4, yd.current = null, P2(l, m), Jg(m, l), s2(Cu), Lo = !!Lu, Cu = Lu = null, l.current = m, N2(m), cS(), Ye = G, Je = O, Lr.transition = L } else l.current = m; if (fl && (fl = !1, es = l, hl = A), L = l.pendingLanes, L === 0 && (Jn = null), fS(m.stateNode), nr(l, wt()), d !== null) for (b = l.onRecoverableError, m = 0; m < d.length; m++)A = d[m], b(A.value, { componentStack: A.stack, digest: A.digest }); if (dl) throw dl = !1, l = Sd, Sd = null, l; return (hl & 1) !== 0 && l.tag !== 0 && Si(), L = l.pendingLanes, (L & 1) !== 0 ? l === Ed ? Ra++ : (Ra = 0, Ed = l) : Ra = 0, Yn(), null } function Si() { if (es !== null) { var l = Qp(hl), d = Lr.transition, m = Je; try { if (Lr.transition = null, Je = 16 > l ? 16 : l, es === null) var b = !1; else { if (l = es, es = null, hl = 0, (Ye & 6) !== 0) throw Error(t(331)); var A = Ye; for (Ye |= 4, ye = l.current; ye !== null;) { var L = ye, O = L.child; if ((ye.flags & 16) !== 0) { var G = L.deletions; if (G !== null) { for (var K = 0; K < G.length; K++) { var re = G[K]; for (ye = re; ye !== null;) { var le = ye; switch (le.tag) { case 0: case 11: case 15: La(8, le, L) }var ce = le.child; if (ce !== null) ce.return = le, ye = ce; else for (; ye !== null;) { le = ye; var oe = le.sibling, xe = le.return; if (qg(le), le === re) { ye = null; break } if (oe !== null) { oe.return = xe, ye = oe; break } ye = xe } } } var be = L.alternate; if (be !== null) { var we = be.child; if (we !== null) { be.child = null; do { var St = we.sibling; we.sibling = null, we = St } while (we !== null) } } ye = L } } if ((L.subtreeFlags & 2064) !== 0 && O !== null) O.return = L, ye = O; else e: for (; ye !== null;) { if (L = ye, (L.flags & 2048) !== 0) switch (L.tag) { case 0: case 11: case 15: La(9, L, L.return) }var ee = L.sibling; if (ee !== null) { ee.return = L.return, ye = ee; break e } ye = L.return } } var Y = l.current; for (ye = Y; ye !== null;) { O = ye; var te = O.child; if ((O.subtreeFlags & 2064) !== 0 && te !== null) te.return = O, ye = te; else e: for (O = Y; ye !== null;) { if (G = ye, (G.flags & 2048) !== 0) try { switch (G.tag) { case 0: case 11: case 15: ll(9, G) } } catch (Te) { yt(G, G.return, Te) } if (G === O) { ye = null; break e } var fe = G.sibling; if (fe !== null) { fe.return = G.return, ye = fe; break e } ye = G.return } } if (Ye = A, Yn(), Wr && typeof Wr.onPostCommitFiberRoot == "function") try { Wr.onPostCommitFiberRoot(wo, l) } catch { } b = !0 } return b } finally { Je = m, Lr.transition = d } } return !1 } function u0(l, d, m) { d = vi(m, d), d = Cg(l, d, 1), l = Qn(l, d, 1), d = Kt(), l !== null && (ea(l, 1, d), nr(l, d)) } function yt(l, d, m) { if (l.tag === 3) u0(l, l, m); else for (; d !== null;) { if (d.tag === 3) { u0(d, l, m); break } else if (d.tag === 1) { var b = d.stateNode; if (typeof d.type.getDerivedStateFromError == "function" || typeof b.componentDidCatch == "function" && (Jn === null || !Jn.has(b))) { l = vi(m, l), l = kg(d, l, 1), d = Qn(d, l, 1), l = Kt(), d !== null && (ea(d, 1, l), nr(d, l)); break } } d = d.return } } function $2(l, d, m) { var b = l.pingCache; b !== null && b.delete(d), d = Kt(), l.pingedLanes |= l.suspendedLanes & m, Nt === l && (Ft & m) === m && (Ct === 4 || Ct === 3 && (Ft & 130023424) === Ft && 500 > wt() - wd ? Os(l, 0) : bd |= m), nr(l, d) } function d0(l, d) { d === 0 && ((l.mode & 1) === 0 ? d = 1 : (d = Eo, Eo <<= 1, (Eo & 130023424) === 0 && (Eo = 4194304))); var m = Kt(); l = yn(l, d), l !== null && (ea(l, d, m), nr(l, m)) } function B2(l) { var d = l.memoizedState, m = 0; d !== null && (m = d.retryLane), d0(l, m) } function U2(l, d) { var m = 0; switch (l.tag) { case 13: var b = l.stateNode, A = l.memoizedState; A !== null && (m = A.retryLane); break; case 19: b = l.stateNode; break; default: throw Error(t(314)) }b !== null && b.delete(d), d0(l, m) } var f0; f0 = function (l, d, m) { if (l !== null) if (l.memoizedProps !== d.pendingProps || Jt.current) tr = !0; else { if ((l.lanes & m) === 0 && (d.flags & 128) === 0) return tr = !1, C2(l, d, m); tr = (l.flags & 131072) !== 0 } else tr = !1, ht && (d.flags & 1048576) !== 0 && Hm(d, Ho, d.index); switch (d.lanes = 0, d.tag) { case 2: var b = d.type; al(l, d), l = d.pendingProps; var A = ui(d, Bt.current); gi(d, m), A = Zu(null, d, b, l, A, m); var L = Ju(); return d.flags |= 1, typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0 ? (d.tag = 1, d.memoizedState = null, d.updateQueue = null, er(b) ? (L = !0, zo(d)) : L = !1, d.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, Hu(d), A.updater = sl, d.stateNode = A, A._reactInternals = d, id(d, b, l, m), d = cd(null, d, b, !0, L, m)) : (d.tag = 0, ht && L && Ou(d), Wt(null, d, A, m), d = d.child), d; case 16: b = d.elementType; e: { switch (al(l, d), l = d.pendingProps, A = b._init, b = A(b._payload), d.type = b, A = d.tag = V2(b), l = Mr(b, l), A) { case 0: d = ld(null, d, b, l, m); break e; case 1: d = Fg(null, d, b, l, m); break e; case 11: d = Ng(null, d, b, l, m); break e; case 14: d = Dg(null, d, b, Mr(b.type, l), m); break e }throw Error(t(306, b, "")) } return d; case 0: return b = d.type, A = d.pendingProps, A = d.elementType === b ? A : Mr(b, A), ld(l, d, b, A, m); case 1: return b = d.type, A = d.pendingProps, A = d.elementType === b ? A : Mr(b, A), Fg(l, d, b, A, m); case 3: e: { if ($g(d), l === null) throw Error(t(387)); b = d.pendingProps, L = d.memoizedState, A = L.element, eg(l, d), Qo(d, b, null, m); var O = d.memoizedState; if (b = O.element, L.isDehydrated) if (L = { element: b, isDehydrated: !1, cache: O.cache, pendingSuspenseBoundaries: O.pendingSuspenseBoundaries, transitions: O.transitions }, d.updateQueue.baseState = L, d.memoizedState = L, d.flags & 256) { A = vi(Error(t(423)), d), d = Bg(l, d, b, m, A); break e } else if (b !== A) { A = vi(Error(t(424)), d), d = Bg(l, d, b, m, A); break e } else for (mr = Wn(d.stateNode.containerInfo.firstChild), pr = d, ht = !0, Or = null, m = Zm(d, null, b, m), d.child = m; m;)m.flags = m.flags & -3 | 4096, m = m.sibling; else { if (hi(), b === A) { d = wn(l, d, m); break e } Wt(l, d, b, m) } d = d.child } return d; case 5: return ng(d), l === null && Fu(d), b = d.type, A = d.pendingProps, L = l !== null ? l.memoizedProps : null, O = A.children, ku(b, A) ? O = null : L !== null && ku(b, L) && (d.flags |= 32), jg(l, d), Wt(l, d, O, m), d.child; case 6: return l === null && Fu(d), null; case 13: return Ug(l, d, m); case 4: return Wu(d, d.stateNode.containerInfo), b = d.pendingProps, l === null ? d.child = pi(d, null, b, m) : Wt(l, d, b, m), d.child; case 11: return b = d.type, A = d.pendingProps, A = d.elementType === b ? A : Mr(b, A), Ng(l, d, b, A, m); case 7: return Wt(l, d, d.pendingProps, m), d.child; case 8: return Wt(l, d, d.pendingProps.children, m), d.child; case 12: return Wt(l, d, d.pendingProps.children, m), d.child; case 10: e: { if (b = d.type._context, A = d.pendingProps, L = d.memoizedProps, O = A.value, at(qo, b._currentValue), b._currentValue = O, L !== null) if (Dr(L.value, O)) { if (L.children === A.children && !Jt.current) { d = wn(l, d, m); break e } } else for (L = d.child, L !== null && (L.return = d); L !== null;) { var G = L.dependencies; if (G !== null) { O = L.child; for (var K = G.firstContext; K !== null;) { if (K.context === b) { if (L.tag === 1) { K = bn(-1, m & -m), K.tag = 2; var re = L.updateQueue; if (re !== null) { re = re.shared; var le = re.pending; le === null ? K.next = K : (K.next = le.next, le.next = K), re.pending = K } } L.lanes |= m, K = L.alternate, K !== null && (K.lanes |= m), Vu(L.return, m, d), G.lanes |= m; break } K = K.next } } else if (L.tag === 10) O = L.type === d.type ? null : L.child; else if (L.tag === 18) { if (O = L.return, O === null) throw Error(t(341)); O.lanes |= m, G = O.alternate, G !== null && (G.lanes |= m), Vu(O, m, d), O = L.sibling } else O = L.child; if (O !== null) O.return = L; else for (O = L; O !== null;) { if (O === d) { O = null; break } if (L = O.sibling, L !== null) { L.return = O.return, O = L; break } O = O.return } L = O } Wt(l, d, A.children, m), d = d.child } return d; case 9: return A = d.type, b = d.pendingProps.children, gi(d, m), A = Ar(A), b = b(A), d.flags |= 1, Wt(l, d, b, m), d.child; case 14: return b = d.type, A = Mr(b, d.pendingProps), A = Mr(b.type, A), Dg(l, d, b, A, m); case 15: return Og(l, d, d.type, d.pendingProps, m); case 17: return b = d.type, A = d.pendingProps, A = d.elementType === b ? A : Mr(b, A), al(l, d), d.tag = 1, er(b) ? (l = !0, zo(d)) : l = !1, gi(d, m), Ig(d, b, A), id(d, b, A, m), cd(null, d, b, !0, l, m); case 19: return Vg(l, d, m); case 22: return Mg(l, d, m) }throw Error(t(156, d.tag)) }; function h0(l, d) { return Wp(l, d) } function z2(l, d, m, b) { this.tag = l, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = b, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Cr(l, d, m, b) { return new z2(l, d, m, b) } function kd(l) { return l = l.prototype, !(!l || !l.isReactComponent) } function V2(l) { if (typeof l == "function") return kd(l) ? 1 : 0; if (l != null) { if (l = l.$$typeof, l === $) return 11; if (l === W) return 14 } return 2 } function ns(l, d) { var m = l.alternate; return m === null ? (m = Cr(l.tag, d, l.key, l.mode), m.elementType = l.elementType, m.type = l.type, m.stateNode = l.stateNode, m.alternate = l, l.alternate = m) : (m.pendingProps = d, m.type = l.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = l.flags & 14680064, m.childLanes = l.childLanes, m.lanes = l.lanes, m.child = l.child, m.memoizedProps = l.memoizedProps, m.memoizedState = l.memoizedState, m.updateQueue = l.updateQueue, d = l.dependencies, m.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }, m.sibling = l.sibling, m.index = l.index, m.ref = l.ref, m } function xl(l, d, m, b, A, L) { var O = 2; if (b = l, typeof l == "function") kd(l) && (O = 1); else if (typeof l == "string") O = 5; else e: switch (l) { case R: return js(m.children, A, L, d); case N: O = 8, A |= 8; break; case P: return l = Cr(12, m, d, A | 2), l.elementType = P, l.lanes = L, l; case B: return l = Cr(13, m, d, A), l.elementType = B, l.lanes = L, l; case V: return l = Cr(19, m, d, A), l.elementType = V, l.lanes = L, l; case q: return vl(m, A, L, d); default: if (typeof l == "object" && l !== null) switch (l.$$typeof) { case _: O = 10; break e; case M: O = 9; break e; case $: O = 11; break e; case W: O = 14; break e; case U: O = 16, b = null; break e }throw Error(t(130, l == null ? l : typeof l, "")) }return d = Cr(O, m, d, A), d.elementType = l, d.type = b, d.lanes = L, d } function js(l, d, m, b) { return l = Cr(7, l, b, d), l.lanes = m, l } function vl(l, d, m, b) { return l = Cr(22, l, b, d), l.elementType = q, l.lanes = m, l.stateNode = { isHidden: !1 }, l } function Rd(l, d, m) { return l = Cr(6, l, null, d), l.lanes = m, l } function _d(l, d, m) { return d = Cr(4, l.children !== null ? l.children : [], l.key, d), d.lanes = m, d.stateNode = { containerInfo: l.containerInfo, pendingChildren: null, implementation: l.implementation }, d } function G2(l, d, m, b, A) { this.tag = d, this.containerInfo = l, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = su(0), this.expirationTimes = su(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = su(0), this.identifierPrefix = b, this.onRecoverableError = A, this.mutableSourceEagerHydrationData = null } function Pd(l, d, m, b, A, L, O, G, K) { return l = new G2(l, d, m, G, K), d === 1 ? (d = 1, L === !0 && (d |= 8)) : d = 0, L = Cr(3, null, null, d), l.current = L, L.stateNode = l, L.memoizedState = { element: b, isDehydrated: m, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Hu(L), l } function H2(l, d, m) { var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: D, key: b == null ? null : "" + b, children: l, containerInfo: d, implementation: m } } function p0(l) { if (!l) return qn; l = l._reactInternals; e: { if (As(l) !== l || l.tag !== 1) throw Error(t(170)); var d = l; do { switch (d.tag) { case 3: d = d.stateNode.context; break e; case 1: if (er(d.type)) { d = d.stateNode.__reactInternalMemoizedMergedChildContext; break e } }d = d.return } while (d !== null); throw Error(t(171)) } if (l.tag === 1) { var m = l.type; if (er(m)) return zm(l, m, d) } return d } function m0(l, d, m, b, A, L, O, G, K) { return l = Pd(m, b, !0, l, A, L, O, G, K), l.context = p0(null), m = l.current, b = Kt(), A = ts(m), L = bn(b, A), L.callback = d ?? null, Qn(m, L, A), l.current.lanes = A, ea(l, A, b), nr(l, b), l } function yl(l, d, m, b) { var A = d.current, L = Kt(), O = ts(A); return m = p0(m), d.context === null ? d.context = m : d.pendingContext = m, d = bn(L, O), d.payload = { element: l }, b = b === void 0 ? null : b, b !== null && (d.callback = b), l = Qn(A, d, O), l !== null && ($r(l, A, O, L), Xo(l, A, O)), O } function bl(l) { if (l = l.current, !l.child) return null; switch (l.child.tag) { case 5: return l.child.stateNode; default: return l.child.stateNode } } function g0(l, d) { if (l = l.memoizedState, l !== null && l.dehydrated !== null) { var m = l.retryLane; l.retryLane = m !== 0 && m < d ? m : d } } function Nd(l, d) { g0(l, d), (l = l.alternate) && g0(l, d) } function W2() { return null } var x0 = typeof reportError == "function" ? reportError : function (l) { console.error(l) }; function Dd(l) { this._internalRoot = l } wl.prototype.render = Dd.prototype.render = function (l) { var d = this._internalRoot; if (d === null) throw Error(t(409)); yl(l, d, null, null) }, wl.prototype.unmount = Dd.prototype.unmount = function () { var l = this._internalRoot; if (l !== null) { this._internalRoot = null; var d = l.containerInfo; Ds(function () { yl(null, l, null, null) }), d[mn] = null } }; function wl(l) { this._internalRoot = l } wl.prototype.unstable_scheduleHydration = function (l) { if (l) { var d = em(); l = { blockedOn: null, target: l, priority: d }; for (var m = 0; m < Vn.length && d !== 0 && d < Vn[m].priority; m++); Vn.splice(m, 0, l), m === 0 && nm(l) } }; function Od(l) { return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11) } function Sl(l) { return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11 && (l.nodeType !== 8 || l.nodeValue !== " react-mount-point-unstable ")) } function v0() { } function K2(l, d, m, b, A) { if (A) { if (typeof b == "function") { var L = b; b = function () { var re = bl(O); L.call(re) } } var O = m0(d, b, l, 0, null, !1, !1, "", v0); return l._reactRootContainer = O, l[mn] = O.current, pa(l.nodeType === 8 ? l.parentNode : l), Ds(), O } for (; A = l.lastChild;)l.removeChild(A); if (typeof b == "function") { var G = b; b = function () { var re = bl(K); G.call(re) } } var K = Pd(l, 0, !1, null, null, !1, !1, "", v0); return l._reactRootContainer = K, l[mn] = K.current, pa(l.nodeType === 8 ? l.parentNode : l), Ds(function () { yl(d, K, m, b) }), K } function El(l, d, m, b, A) { var L = m._reactRootContainer; if (L) { var O = L; if (typeof A == "function") { var G = A; A = function () { var K = bl(O); G.call(K) } } yl(d, O, l, A) } else O = K2(m, d, l, A, b); return bl(O) } Zp = function (l) { switch (l.tag) { case 3: var d = l.stateNode; if (d.current.memoizedState.isDehydrated) { var m = Ji(d.pendingLanes); m !== 0 && (iu(d, m | 1), nr(d, wt()), (Ye & 6) === 0 && (wi = wt() + 500, Yn())) } break; case 13: Ds(function () { var b = yn(l, 1); if (b !== null) { var A = Kt(); $r(b, l, 1, A) } }), Nd(l, 1) } }, au = function (l) { if (l.tag === 13) { var d = yn(l, 134217728); if (d !== null) { var m = Kt(); $r(d, l, 134217728, m) } Nd(l, 134217728) } }, Jp = function (l) { if (l.tag === 13) { var d = ts(l), m = yn(l, d); if (m !== null) { var b = Kt(); $r(m, l, d, b) } Nd(l, d) } }, em = function () { return Je }, tm = function (l, d) { var m = Je; try { return Je = l, d() } finally { Je = m } }, Zc = function (l, d, m) { switch (d) { case "input": if (ie(l, m), d = m.name, m.type === "radio" && d != null) { for (m = l; m.parentNode;)m = m.parentNode; for (m = m.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), d = 0; d < m.length; d++) { var b = m[d]; if (b !== l && b.form === l.form) { var A = Bo(b); if (!A) throw Error(t(90)); ft(b), ie(b, A) } } } break; case "textarea": dr(l, m); break; case "select": d = m.value, d != null && vt(l, !!m.multiple, d, !1) } }, $p = Id, Bp = Ds; var q2 = { usingClientEntryPoint: !1, Events: [xa, li, Bo, jp, Fp, Id] }, _a = { findFiberByHostInstance: Is, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Y2 = { bundleType: _a.bundleType, version: _a.version, rendererPackageName: _a.rendererPackageName, rendererConfig: _a.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: I.ReactCurrentDispatcher, findHostInstanceByFiber: function (l) { return l = Gp(l), l === null ? null : l.stateNode }, findFiberByHostInstance: _a.findFiberByHostInstance || W2, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Tl = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Tl.isDisabled && Tl.supportsFiber) try { wo = Tl.inject(Y2), Wr = Tl } catch { } } return sr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = q2, sr.createPortal = function (l, d) { var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Od(d)) throw Error(t(200)); return H2(l, d, null, m) }, sr.createRoot = function (l, d) { if (!Od(l)) throw Error(t(299)); var m = !1, b = "", A = x0; return d != null && (d.unstable_strictMode === !0 && (m = !0), d.identifierPrefix !== void 0 && (b = d.identifierPrefix), d.onRecoverableError !== void 0 && (A = d.onRecoverableError)), d = Pd(l, 1, !1, null, null, m, !1, b, A), l[mn] = d.current, pa(l.nodeType === 8 ? l.parentNode : l), new Dd(d) }, sr.findDOMNode = function (l) { if (l == null) return null; if (l.nodeType === 1) return l; var d = l._reactInternals; if (d === void 0) throw typeof l.render == "function" ? Error(t(188)) : (l = Object.keys(l).join(","), Error(t(268, l))); return l = Gp(d), l = l === null ? null : l.stateNode, l }, sr.flushSync = function (l) { return Ds(l) }, sr.hydrate = function (l, d, m) { if (!Sl(d)) throw Error(t(200)); return El(null, l, d, !0, m) }, sr.hydrateRoot = function (l, d, m) { if (!Od(l)) throw Error(t(405)); var b = m != null && m.hydratedSources || null, A = !1, L = "", O = x0; if (m != null && (m.unstable_strictMode === !0 && (A = !0), m.identifierPrefix !== void 0 && (L = m.identifierPrefix), m.onRecoverableError !== void 0 && (O = m.onRecoverableError)), d = m0(d, null, l, 1, m ?? null, A, !1, L, O), l[mn] = d.current, pa(l), b) for (l = 0; l < b.length; l++)m = b[l], A = m._getVersion, A = A(m._source), d.mutableSourceEagerHydrationData == null ? d.mutableSourceEagerHydrationData = [m, A] : d.mutableSourceEagerHydrationData.push(m, A); return new wl(d) }, sr.render = function (l, d, m) { if (!Sl(d)) throw Error(t(200)); return El(null, l, d, !1, m) }, sr.unmountComponentAtNode = function (l) { if (!Sl(l)) throw Error(t(40)); return l._reactRootContainer ? (Ds(function () { El(null, null, l, !1, function () { l._reactRootContainer = null, l[mn] = null }) }), !0) : !1 }, sr.unstable_batchedUpdates = Id, sr.unstable_renderSubtreeIntoContainer = function (l, d, m, b) { if (!Sl(m)) throw Error(t(200)); if (l == null || l._reactInternals === void 0) throw Error(t(38)); return El(l, d, m, !1, b) }, sr.version = "18.3.1-next-f1338f8080-20240426", sr
  } var L0; function yy() { if (L0) return Fd.exports; L0 = 1; function n() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n) } catch (e) { console.error(e) } } return n(), Fd.exports = aE(), Fd.exports } var C0; function oE() { if (C0) return Al; C0 = 1; var n = yy(); return Al.createRoot = n.createRoot, Al.hydrateRoot = n.hydrateRoot, Al } var lE = oE(); yy();/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ka() { return Ka = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, Ka.apply(this, arguments) } var hs; (function (n) { n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE" })(hs || (hs = {})); const k0 = "popstate"; function cE(n) { n === void 0 && (n = {}); function e(r, s) { let { pathname: i, search: a, hash: o } = r.location; return Df("", { pathname: i, search: a, hash: o }, s.state && s.state.usr || null, s.state && s.state.key || "default") } function t(r, s) { return typeof s == "string" ? s : lc(s) } return dE(e, t, null, n) } function It(n, e) { if (n === !1 || n === null || typeof n > "u") throw new Error(e) } function by(n, e) { if (!n) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function uE() { return Math.random().toString(36).substr(2, 8) } function R0(n, e) { return { usr: n.state, key: n.key, idx: e } } function Df(n, e, t, r) { return t === void 0 && (t = null), Ka({ pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" }, typeof e == "string" ? Ui(e) : e, { state: t, key: e && e.key || r || uE() }) } function lc(n) { let { pathname: e = "/", search: t = "", hash: r = "" } = n; return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e } function Ui(n) { let e = {}; if (n) { let t = n.indexOf("#"); t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t)); let r = n.indexOf("?"); r >= 0 && (e.search = n.substr(r), n = n.substr(0, r)), n && (e.pathname = n) } return e } function dE(n, e, t, r) { r === void 0 && (r = {}); let { window: s = document.defaultView, v5Compat: i = !1 } = r, a = s.history, o = hs.Pop, c = null, u = f(); u == null && (u = 0, a.replaceState(Ka({}, a.state, { idx: u }), "")); function f() { return (a.state || { idx: null }).idx } function h() { o = hs.Pop; let w = f(), T = w == null ? null : w - u; u = w, c && c({ action: o, location: y.location, delta: T }) } function p(w, T) { o = hs.Push; let S = Df(y.location, w, T); u = f() + 1; let E = R0(S, u), I = y.createHref(S); try { a.pushState(E, "", I) } catch (C) { if (C instanceof DOMException && C.name === "DataCloneError") throw C; s.location.assign(I) } i && c && c({ action: o, location: y.location, delta: 1 }) } function v(w, T) { o = hs.Replace; let S = Df(y.location, w, T); u = f(); let E = R0(S, u), I = y.createHref(S); a.replaceState(E, "", I), i && c && c({ action: o, location: y.location, delta: 0 }) } function g(w) { let T = s.location.origin !== "null" ? s.location.origin : s.location.href, S = typeof w == "string" ? w : lc(w); return S = S.replace(/ $/, "%20"), It(T, "No window.location.(origin|href) available to create URL for href: " + S), new URL(S, T) } let y = { get action() { return o }, get location() { return n(s, a) }, listen(w) { if (c) throw new Error("A history only accepts one active listener"); return s.addEventListener(k0, h), c = w, () => { s.removeEventListener(k0, h), c = null } }, createHref(w) { return e(s, w) }, createURL: g, encodeLocation(w) { let T = g(w); return { pathname: T.pathname, search: T.search, hash: T.hash } }, push: p, replace: v, go(w) { return a.go(w) } }; return y } var _0; (function (n) { n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error" })(_0 || (_0 = {})); function fE(n, e, t) { return t === void 0 && (t = "/"), hE(n, e, t) } function hE(n, e, t, r) { let s = typeof e == "string" ? Ui(e) : e, i = Fh(s.pathname || "/", t); if (i == null) return null; let a = wy(n); pE(a); let o = null; for (let c = 0; o == null && c < a.length; ++c) { let u = IE(i); o = EE(a[c], u) } return o } function wy(n, e, t, r) { e === void 0 && (e = []), t === void 0 && (t = []), r === void 0 && (r = ""); let s = (i, a, o) => { let c = { relativePath: o === void 0 ? i.path || "" : o, caseSensitive: i.caseSensitive === !0, childrenIndex: a, route: i }; c.relativePath.startsWith("/") && (It(c.relativePath.startsWith(r), 'Absolute route path "' + c.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), c.relativePath = c.relativePath.slice(r.length)); let u = ms([r, c.relativePath]), f = t.concat(c); i.children && i.children.length > 0 && (It(i.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + u + '".')), wy(i.children, e, f, u)), !(i.path == null && !i.index) && e.push({ path: u, score: wE(u, i.index), routesMeta: f }) }; return n.forEach((i, a) => { var o; if (i.path === "" || !((o = i.path) != null && o.includes("?"))) s(i, a); else for (let c of Sy(i.path)) s(i, a, c) }), e } function Sy(n) { let e = n.split("/"); if (e.length === 0) return []; let [t, ...r] = e, s = t.endsWith("?"), i = t.replace(/\?$/, ""); if (r.length === 0) return s ? [i, ""] : [i]; let a = Sy(r.join("/")), o = []; return o.push(...a.map(c => c === "" ? i : [i, c].join("/"))), s && o.push(...a), o.map(c => n.startsWith("/") && c === "" ? "/" : c) } function pE(n) { n.sort((e, t) => e.score !== t.score ? t.score - e.score : SE(e.routesMeta.map(r => r.childrenIndex), t.routesMeta.map(r => r.childrenIndex))) } const mE = /^:[\w-]+$/, gE = 3, xE = 2, vE = 1, yE = 10, bE = -2, P0 = n => n === "*"; function wE(n, e) { let t = n.split("/"), r = t.length; return t.some(P0) && (r += bE), e && (r += xE), t.filter(s => !P0(s)).reduce((s, i) => s + (mE.test(i) ? gE : i === "" ? vE : yE), r) } function SE(n, e) { return n.length === e.length && n.slice(0, -1).every((r, s) => r === e[s]) ? n[n.length - 1] - e[e.length - 1] : 0 } function EE(n, e, t) { let { routesMeta: r } = n, s = {}, i = "/", a = []; for (let o = 0; o < r.length; ++o) { let c = r[o], u = o === r.length - 1, f = i === "/" ? e : e.slice(i.length) || "/", h = TE({ path: c.relativePath, caseSensitive: c.caseSensitive, end: u }, f), p = c.route; if (!h) return null; Object.assign(s, h.params), a.push({ params: s, pathname: ms([i, h.pathname]), pathnameBase: RE(ms([i, h.pathnameBase])), route: p }), h.pathnameBase !== "/" && (i = ms([i, h.pathnameBase])) } return a } function TE(n, e) { typeof n == "string" && (n = { path: n, caseSensitive: !1, end: !0 }); let [t, r] = AE(n.path, n.caseSensitive, n.end), s = e.match(t); if (!s) return null; let i = s[0], a = i.replace(/(.)\/+$/, "$1"), o = s.slice(1); return { params: r.reduce((u, f, h) => { let { paramName: p, isOptional: v } = f; if (p === "*") { let y = o[h] || ""; a = i.slice(0, i.length - y.length).replace(/(.)\/+$/, "$1") } const g = o[h]; return v && !g ? u[p] = void 0 : u[p] = (g || "").replace(/%2F/g, "/"), u }, {}), pathname: i, pathnameBase: a, pattern: n } } function AE(n, e, t) { e === void 0 && (e = !1), t === void 0 && (t = !0), by(n === "*" || !n.endsWith("*") || n.endsWith("/*"), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".')); let r = [], s = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, o, c) => (r.push({ paramName: o, isOptional: c != null }), c ? "/?([^\\/]+)?" : "/([^\\/]+)")); return n.endsWith("*") ? (r.push({ paramName: "*" }), s += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? s += "\\/*$" : n !== "" && n !== "/" && (s += "(?:(?=\\/|$))"), [new RegExp(s, e ? void 0 : "i"), r] } function IE(n) { try { return n.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (e) { return by(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), n } } function Fh(n, e) { if (e === "/") return n; if (!n.toLowerCase().startsWith(e.toLowerCase())) return null; let t = e.endsWith("/") ? e.length - 1 : e.length, r = n.charAt(t); return r && r !== "/" ? null : n.slice(t) || "/" } function LE(n, e) { e === void 0 && (e = "/"); let { pathname: t, search: r = "", hash: s = "" } = typeof n == "string" ? Ui(n) : n; return { pathname: t ? t.startsWith("/") ? t : CE(t, e) : e, search: _E(r), hash: PE(s) } } function CE(n, e) { let t = e.replace(/\/+$/, "").split("/"); return n.split("/").forEach(s => { s === ".." ? t.length > 1 && t.pop() : s !== "." && t.push(s) }), t.length > 1 ? t.join("/") : "/" } function Ud(n, e, t, r) { return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function kE(n) { return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0) } function Ey(n, e) { let t = kE(n); return e ? t.map((r, s) => s === t.length - 1 ? r.pathname : r.pathnameBase) : t.map(r => r.pathnameBase) } function Ty(n, e, t, r) { r === void 0 && (r = !1); let s; typeof n == "string" ? s = Ui(n) : (s = Ka({}, n), It(!s.pathname || !s.pathname.includes("?"), Ud("?", "pathname", "search", s)), It(!s.pathname || !s.pathname.includes("#"), Ud("#", "pathname", "hash", s)), It(!s.search || !s.search.includes("#"), Ud("#", "search", "hash", s))); let i = n === "" || s.pathname === "", a = i ? "/" : s.pathname, o; if (a == null) o = t; else { let h = e.length - 1; if (!r && a.startsWith("..")) { let p = a.split("/"); for (; p[0] === "..";)p.shift(), h -= 1; s.pathname = p.join("/") } o = h >= 0 ? e[h] : "/" } let c = LE(s, o), u = a && a !== "/" && a.endsWith("/"), f = (i || a === ".") && t.endsWith("/"); return !c.pathname.endsWith("/") && (u || f) && (c.pathname += "/"), c } const ms = n => n.join("/").replace(/\/\/+/g, "/"), RE = n => n.replace(/\/+$/, "").replace(/^\/*/, "/"), _E = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, PE = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n; function NE(n) { return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n } const Ay = ["post", "put", "patch", "delete"]; new Set(Ay); const DE = ["get", ...Ay]; new Set(DE);/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function qa() { return qa = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, qa.apply(this, arguments) } const $h = j.createContext(null), OE = j.createContext(null), Qs = j.createContext(null), Pc = j.createContext(null), Ss = j.createContext({ outlet: null, matches: [], isDataRoute: !1 }), Iy = j.createContext(null); function ME(n, e) { let { relative: t } = e === void 0 ? {} : e; ao() || It(!1); let { basename: r, navigator: s } = j.useContext(Qs), { hash: i, pathname: a, search: o } = Cy(n, { relative: t }), c = a; return r !== "/" && (c = a === "/" ? r : ms([r, a])), s.createHref({ pathname: c, search: o, hash: i }) } function ao() { return j.useContext(Pc) != null } function zr() { return ao() || It(!1), j.useContext(Pc).location } function Ly(n) { j.useContext(Qs).static || j.useLayoutEffect(n) } function _r() { let { isDataRoute: n } = j.useContext(Ss); return n ? YE() : jE() } function jE() { ao() || It(!1); let n = j.useContext($h), { basename: e, future: t, navigator: r } = j.useContext(Qs), { matches: s } = j.useContext(Ss), { pathname: i } = zr(), a = JSON.stringify(Ey(s, t.v7_relativeSplatPath)), o = j.useRef(!1); return Ly(() => { o.current = !0 }), j.useCallback(function (u, f) { if (f === void 0 && (f = {}), !o.current) return; if (typeof u == "number") { r.go(u); return } let h = Ty(u, JSON.parse(a), i, f.relative === "path"); n == null && e !== "/" && (h.pathname = h.pathname === "/" ? e : ms([e, h.pathname])), (f.replace ? r.replace : r.push)(h, f.state, f) }, [e, r, a, i, n]) } function cc() { let { matches: n } = j.useContext(Ss), e = n[n.length - 1]; return e ? e.params : {} } function Cy(n, e) { let { relative: t } = e === void 0 ? {} : e, { future: r } = j.useContext(Qs), { matches: s } = j.useContext(Ss), { pathname: i } = zr(), a = JSON.stringify(Ey(s, r.v7_relativeSplatPath)); return j.useMemo(() => Ty(n, JSON.parse(a), i, t === "path"), [n, a, i, t]) } function FE(n, e) { return $E(n, e) } function $E(n, e, t, r) { ao() || It(!1); let { navigator: s } = j.useContext(Qs), { matches: i } = j.useContext(Ss), a = i[i.length - 1], o = a ? a.params : {}; a && a.pathname; let c = a ? a.pathnameBase : "/"; a && a.route; let u = zr(), f; if (e) { var h; let w = typeof e == "string" ? Ui(e) : e; c === "/" || (h = w.pathname) != null && h.startsWith(c) || It(!1), f = w } else f = u; let p = f.pathname || "/", v = p; if (c !== "/") { let w = c.replace(/^\//, "").split("/"); v = "/" + p.replace(/^\//, "").split("/").slice(w.length).join("/") } let g = fE(n, { pathname: v }), y = GE(g && g.map(w => Object.assign({}, w, { params: Object.assign({}, o, w.params), pathname: ms([c, s.encodeLocation ? s.encodeLocation(w.pathname).pathname : w.pathname]), pathnameBase: w.pathnameBase === "/" ? c : ms([c, s.encodeLocation ? s.encodeLocation(w.pathnameBase).pathname : w.pathnameBase]) })), i, t, r); return e && y ? j.createElement(Pc.Provider, { value: { location: qa({ pathname: "/", search: "", hash: "", state: null, key: "default" }, f), navigationType: hs.Pop } }, y) : y } function BE() { let n = qE(), e = NE(n) ? n.status + " " + n.statusText : n instanceof Error ? n.message : JSON.stringify(n), t = n instanceof Error ? n.stack : null, s = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return j.createElement(j.Fragment, null, j.createElement("h2", null, "Unexpected Application Error!"), j.createElement("h3", { style: { fontStyle: "italic" } }, e), t ? j.createElement("pre", { style: s }, t) : null, null) } const UE = j.createElement(BE, null); class zE extends j.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return this.state.error !== void 0 ? j.createElement(Ss.Provider, { value: this.props.routeContext }, j.createElement(Iy.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function VE(n) { let { routeContext: e, match: t, children: r } = n, s = j.useContext($h); return s && s.static && s.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = t.route.id), j.createElement(Ss.Provider, { value: e }, r) } function GE(n, e, t, r) { var s; if (e === void 0 && (e = []), t === void 0 && (t = null), r === void 0 && (r = null), n == null) { var i; if (!t) return null; if (t.errors) n = t.matches; else if ((i = r) != null && i.v7_partialHydration && e.length === 0 && !t.initialized && t.matches.length > 0) n = t.matches; else return null } let a = n, o = (s = t) == null ? void 0 : s.errors; if (o != null) { let f = a.findIndex(h => h.route.id && o?.[h.route.id] !== void 0); f >= 0 || It(!1), a = a.slice(0, Math.min(a.length, f + 1)) } let c = !1, u = -1; if (t && r && r.v7_partialHydration) for (let f = 0; f < a.length; f++) { let h = a[f]; if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (u = f), h.route.id) { let { loaderData: p, errors: v } = t, g = h.route.loader && p[h.route.id] === void 0 && (!v || v[h.route.id] === void 0); if (h.route.lazy || g) { c = !0, u >= 0 ? a = a.slice(0, u + 1) : a = [a[0]]; break } } } return a.reduceRight((f, h, p) => { let v, g = !1, y = null, w = null; t && (v = o && h.route.id ? o[h.route.id] : void 0, y = h.route.errorElement || UE, c && (u < 0 && p === 0 ? (XE("route-fallback"), g = !0, w = null) : u === p && (g = !0, w = h.route.hydrateFallbackElement || null))); let T = e.concat(a.slice(0, p + 1)), S = () => { let E; return v ? E = y : g ? E = w : h.route.Component ? E = j.createElement(h.route.Component, null) : h.route.element ? E = h.route.element : E = f, j.createElement(VE, { match: h, routeContext: { outlet: f, matches: T, isDataRoute: t != null }, children: E }) }; return t && (h.route.ErrorBoundary || h.route.errorElement || p === 0) ? j.createElement(zE, { location: t.location, revalidation: t.revalidation, component: y, error: v, children: S(), routeContext: { outlet: null, matches: T, isDataRoute: !0 } }) : S() }, null) } var ky = (function (n) { return n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n })(ky || {}), Ry = (function (n) { return n.UseBlocker = "useBlocker", n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n.UseRouteId = "useRouteId", n })(Ry || {}); function HE(n) { let e = j.useContext($h); return e || It(!1), e } function WE(n) { let e = j.useContext(OE); return e || It(!1), e } function KE(n) { let e = j.useContext(Ss); return e || It(!1), e } function _y(n) { let e = KE(), t = e.matches[e.matches.length - 1]; return t.route.id || It(!1), t.route.id } function qE() { var n; let e = j.useContext(Iy), t = WE(), r = _y(); return e !== void 0 ? e : (n = t.errors) == null ? void 0 : n[r] } function YE() { let { router: n } = HE(ky.UseNavigateStable), e = _y(Ry.UseNavigateStable), t = j.useRef(!1); return Ly(() => { t.current = !0 }), j.useCallback(function (s, i) { i === void 0 && (i = {}), t.current && (typeof s == "number" ? n.navigate(s) : n.navigate(s, qa({ fromRouteId: e }, i))) }, [n, e]) } const N0 = {}; function XE(n, e, t) { N0[n] || (N0[n] = !0) } function QE(n, e) { n?.v7_startTransition, n?.v7_relativeSplatPath } function ar(n) { It(!1) } function ZE(n) { let { basename: e = "/", children: t = null, location: r, navigationType: s = hs.Pop, navigator: i, static: a = !1, future: o } = n; ao() && It(!1); let c = e.replace(/^\/*/, "/"), u = j.useMemo(() => ({ basename: c, navigator: i, static: a, future: qa({ v7_relativeSplatPath: !1 }, o) }), [c, o, i, a]); typeof r == "string" && (r = Ui(r)); let { pathname: f = "/", search: h = "", hash: p = "", state: v = null, key: g = "default" } = r, y = j.useMemo(() => { let w = Fh(f, c); return w == null ? null : { location: { pathname: w, search: h, hash: p, state: v, key: g }, navigationType: s } }, [c, f, h, p, v, g, s]); return y == null ? null : j.createElement(Qs.Provider, { value: u }, j.createElement(Pc.Provider, { children: t, value: y })) } function JE(n) { let { children: e, location: t } = n; return FE(Of(e), t) } new Promise(() => { }); function Of(n, e) { e === void 0 && (e = []); let t = []; return j.Children.forEach(n, (r, s) => { if (!j.isValidElement(r)) return; let i = [...e, s]; if (r.type === j.Fragment) { t.push.apply(t, Of(r.props.children, i)); return } r.type !== ar && It(!1), !r.props.index || !r.props.children || It(!1); let a = { id: r.props.id || i.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (a.children = Of(r.props.children, i)), t.push(a) }), t }/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Mf() { return Mf = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, Mf.apply(this, arguments) } function eT(n, e) { if (n == null) return {}; var t = {}, r = Object.keys(n), s, i; for (i = 0; i < r.length; i++)s = r[i], !(e.indexOf(s) >= 0) && (t[s] = n[s]); return t } function tT(n) { return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) } function rT(n, e) { return n.button === 0 && (!e || e === "_self") && !tT(n) } function jf(n) { return n === void 0 && (n = ""), new URLSearchParams(typeof n == "string" || Array.isArray(n) || n instanceof URLSearchParams ? n : Object.keys(n).reduce((e, t) => { let r = n[t]; return e.concat(Array.isArray(r) ? r.map(s => [t, s]) : [[t, r]]) }, [])) } function nT(n, e) { let t = jf(n); return e && e.forEach((r, s) => { t.has(s) || e.getAll(s).forEach(i => { t.append(s, i) }) }), t } const sT = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], iT = "6"; try { window.__reactRouterVersion = iT } catch { } const aT = "startTransition", D0 = rE[aT]; function oT(n) { let { basename: e, children: t, future: r, window: s } = n, i = j.useRef(); i.current == null && (i.current = cE({ window: s, v5Compat: !0 })); let a = i.current, [o, c] = j.useState({ action: a.action, location: a.location }), { v7_startTransition: u } = r || {}, f = j.useCallback(h => { u && D0 ? D0(() => c(h)) : c(h) }, [c, u]); return j.useLayoutEffect(() => a.listen(f), [a, f]), j.useEffect(() => QE(r), [r]), j.createElement(ZE, { basename: e, children: t, location: o.location, navigationType: o.action, navigator: a, future: r }) } const lT = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", cT = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, We = j.forwardRef(function (e, t) { let { onClick: r, relative: s, reloadDocument: i, replace: a, state: o, target: c, to: u, preventScrollReset: f, viewTransition: h } = e, p = eT(e, sT), { basename: v } = j.useContext(Qs), g, y = !1; if (typeof u == "string" && cT.test(u) && (g = u, lT)) try { let E = new URL(window.location.href), I = u.startsWith("//") ? new URL(E.protocol + u) : new URL(u), C = Fh(I.pathname, v); I.origin === E.origin && C != null ? u = C + I.search + I.hash : y = !0 } catch { } let w = ME(u, { relative: s }), T = uT(u, { replace: a, state: o, target: c, preventScrollReset: f, relative: s, viewTransition: h }); function S(E) { r && r(E), E.defaultPrevented || T(E) } return j.createElement("a", Mf({}, p, { href: g || w, onClick: y || i ? r : S, ref: t, target: c })) }); var O0; (function (n) { n.UseScrollRestoration = "useScrollRestoration", n.UseSubmit = "useSubmit", n.UseSubmitFetcher = "useSubmitFetcher", n.UseFetcher = "useFetcher", n.useViewTransitionState = "useViewTransitionState" })(O0 || (O0 = {})); var M0; (function (n) { n.UseFetcher = "useFetcher", n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration" })(M0 || (M0 = {})); function uT(n, e) { let { target: t, replace: r, state: s, preventScrollReset: i, relative: a, viewTransition: o } = e === void 0 ? {} : e, c = _r(), u = zr(), f = Cy(n, { relative: a }); return j.useCallback(h => { if (rT(h, t)) { h.preventDefault(); let p = r !== void 0 ? r : lc(u) === lc(f); c(n, { replace: p, state: s, preventScrollReset: i, relative: a, viewTransition: o }) } }, [u, c, f, r, s, t, n, i, a, o]) } function Nc(n) { let e = j.useRef(jf(n)), t = j.useRef(!1), r = zr(), s = j.useMemo(() => nT(r.search, t.current ? null : e.current), [r.search]), i = _r(), a = j.useCallback((o, c) => { const u = jf(typeof o == "function" ? o(s) : o); t.current = !0, i("?" + u, c) }, [i, s]); return [s, a] } var j0 = {}, dT = "@vercel/analytics", fT = "1.5.0", hT = () => { window.va || (window.va = function (...e) { (window.vaq = window.vaq || []).push(e) }) }; function Py() { return typeof window < "u" } function Ny() { try { const n = "production" } catch { } return "production" } function pT(n = "auto") { if (n === "auto") { window.vam = Ny(); return } window.vam = n } function mT() { return (Py() ? window.vam : Ny()) || "production" } function Ff() { return mT() === "development" } function gT(n) { return n.scriptSrc ? n.scriptSrc : Ff() ? "https://va.vercel-scripts.com/v1/script.debug.js" : n.basePath ? `${n.basePath}/insights/script.js` : "/_vercel/insights/script.js" } function xT(n = { debug: !0 }) { var e; if (!Py()) return; pT(n.mode), hT(), n.beforeSend && ((e = window.va) == null || e.call(window, "beforeSend", n.beforeSend)); const t = gT(n); if (document.head.querySelector(`script[src*="${t}"]`)) return; const r = document.createElement("script"); r.src = t, r.defer = !0, r.dataset.sdkn = dT + (n.framework ? `/${n.framework}` : ""), r.dataset.sdkv = fT, n.disableAutoTrack && (r.dataset.disableAutoTrack = "1"), n.endpoint ? r.dataset.endpoint = n.endpoint : n.basePath && (r.dataset.endpoint = `${n.basePath}/insights`), n.dsn && (r.dataset.dsn = n.dsn), r.onerror = () => { const s = Ff() ? "Please check if any ad blockers are enabled and try again." : "Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information."; console.log(`[Vercel Web Analytics] Failed to load script from ${t}. ${s}`) }, Ff() && n.debug === !1 && (r.dataset.debug = "false"), document.head.appendChild(r) } function vT({ route: n, path: e }) { var t; (t = window.va) == null || t.call(window, "pageview", { route: n, path: e }) } function yT() { if (!(typeof process > "u" || typeof j0 > "u")) return j0.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH } function bT(n) { return j.useEffect(() => { var e; n.beforeSend && ((e = window.va) == null || e.call(window, "beforeSend", n.beforeSend)) }, [n.beforeSend]), j.useEffect(() => { xT({ framework: n.framework || "react", basePath: n.basePath ?? yT(), ...n.route !== void 0 && { disableAutoTrack: !0 }, ...n }) }, []), j.useEffect(() => { n.route && n.path && vT({ route: n.route, path: n.path }) }, [n.route, n.path]), null } var F0 = {}, wT = "@vercel/speed-insights", ST = "1.2.0", ET = () => { window.si || (window.si = function (...e) { (window.siq = window.siq || []).push(e) }) }; function TT() { return typeof window < "u" } function AT() { try { const n = "production" } catch { } return "production" } function Dy() { return AT() === "development" } function IT(n) { return n.scriptSrc ? n.scriptSrc : Dy() ? "https://va.vercel-scripts.com/v1/speed-insights/script.debug.js" : n.dsn ? "https://va.vercel-scripts.com/v1/speed-insights/script.js" : n.basePath ? `${n.basePath}/speed-insights/script.js` : "/_vercel/speed-insights/script.js" } function LT(n = {}) { var e; if (!TT() || n.route === null) return null; ET(); const t = IT(n); if (document.head.querySelector(`script[src*="${t}"]`)) return null; n.beforeSend && ((e = window.si) == null || e.call(window, "beforeSend", n.beforeSend)); const r = document.createElement("script"); return r.src = t, r.defer = !0, r.dataset.sdkn = wT + (n.framework ? `/${n.framework}` : ""), r.dataset.sdkv = ST, n.sampleRate && (r.dataset.sampleRate = n.sampleRate.toString()), n.route && (r.dataset.route = n.route), n.endpoint ? r.dataset.endpoint = n.endpoint : n.basePath && (r.dataset.endpoint = `${n.basePath}/speed-insights/vitals`), n.dsn && (r.dataset.dsn = n.dsn), Dy() && n.debug === !1 && (r.dataset.debug = "false"), r.onerror = () => { console.log(`[Vercel Speed Insights] Failed to load script from ${t}. Please check if any content blockers are enabled and try again.`) }, document.head.appendChild(r), { setRoute: s => { r.dataset.route = s ?? void 0 } } } function CT() { if (!(typeof process > "u" || typeof F0 > "u")) return F0.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH } function kT(n) { j.useEffect(() => { var t; n.beforeSend && ((t = window.si) == null || t.call(window, "beforeSend", n.beforeSend)) }, [n.beforeSend]); const e = j.useRef(null); return j.useEffect(() => { if (e.current) n.route && e.current(n.route); else { const t = LT({ framework: n.framework ?? "react", basePath: n.basePath ?? CT(), ...n }); t && (e.current = t.setRoute) } }, [n.route]), null } function Oy(n, e) { return function () { return n.apply(e, arguments) } } const { toString: RT } = Object.prototype, { getPrototypeOf: Bh } = Object, { iterator: Dc, toStringTag: My } = Symbol, Oc = (n => e => { const t = RT.call(e); return n[t] || (n[t] = t.slice(8, -1).toLowerCase()) })(Object.create(null)), Vr = n => (n = n.toLowerCase(), e => Oc(e) === n), Mc = n => e => typeof e === n, { isArray: zi } = Array, ji = Mc("undefined"); function oo(n) { return n !== null && !ji(n) && n.constructor !== null && !ji(n.constructor) && cr(n.constructor.isBuffer) && n.constructor.isBuffer(n) } const jy = Vr("ArrayBuffer"); function _T(n) { let e; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && jy(n.buffer), e } const PT = Mc("string"), cr = Mc("function"), Fy = Mc("number"), lo = n => n !== null && typeof n == "object", NT = n => n === !0 || n === !1, ql = n => { if (Oc(n) !== "object") return !1; const e = Bh(n); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(My in n) && !(Dc in n) }, DT = n => { if (!lo(n) || oo(n)) return !1; try { return Object.keys(n).length === 0 && Object.getPrototypeOf(n) === Object.prototype } catch { return !1 } }, OT = Vr("Date"), MT = Vr("File"), jT = Vr("Blob"), FT = Vr("FileList"), $T = n => lo(n) && cr(n.pipe), BT = n => { let e; return n && (typeof FormData == "function" && n instanceof FormData || cr(n.append) && ((e = Oc(n)) === "formdata" || e === "object" && cr(n.toString) && n.toString() === "[object FormData]")) }, UT = Vr("URLSearchParams"), [zT, VT, GT, HT] = ["ReadableStream", "Request", "Response", "Headers"].map(Vr), WT = n => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function co(n, e, { allOwnKeys: t = !1 } = {}) { if (n === null || typeof n > "u") return; let r, s; if (typeof n != "object" && (n = [n]), zi(n)) for (r = 0, s = n.length; r < s; r++)e.call(null, n[r], r, n); else { if (oo(n)) return; const i = t ? Object.getOwnPropertyNames(n) : Object.keys(n), a = i.length; let o; for (r = 0; r < a; r++)o = i[r], e.call(null, n[o], o, n) } } function $y(n, e) { if (oo(n)) return null; e = e.toLowerCase(); const t = Object.keys(n); let r = t.length, s; for (; r-- > 0;)if (s = t[r], e === s.toLowerCase()) return s; return null } const zs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, By = n => !ji(n) && n !== zs; function $f() { const { caseless: n, skipUndefined: e } = By(this) && this || {}, t = {}, r = (s, i) => { const a = n && $y(t, i) || i; ql(t[a]) && ql(s) ? t[a] = $f(t[a], s) : ql(s) ? t[a] = $f({}, s) : zi(s) ? t[a] = s.slice() : (!e || !ji(s)) && (t[a] = s) }; for (let s = 0, i = arguments.length; s < i; s++)arguments[s] && co(arguments[s], r); return t } const KT = (n, e, t, { allOwnKeys: r } = {}) => (co(e, (s, i) => { t && cr(s) ? n[i] = Oy(s, t) : n[i] = s }, { allOwnKeys: r }), n), qT = n => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), YT = (n, e, t, r) => { n.prototype = Object.create(e.prototype, r), n.prototype.constructor = n, Object.defineProperty(n, "super", { value: e.prototype }), t && Object.assign(n.prototype, t) }, XT = (n, e, t, r) => { let s, i, a; const o = {}; if (e = e || {}, n == null) return e; do { for (s = Object.getOwnPropertyNames(n), i = s.length; i-- > 0;)a = s[i], (!r || r(a, n, e)) && !o[a] && (e[a] = n[a], o[a] = !0); n = t !== !1 && Bh(n) } while (n && (!t || t(n, e)) && n !== Object.prototype); return e }, QT = (n, e, t) => { n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length; const r = n.indexOf(e, t); return r !== -1 && r === t }, ZT = n => { if (!n) return null; if (zi(n)) return n; let e = n.length; if (!Fy(e)) return null; const t = new Array(e); for (; e-- > 0;)t[e] = n[e]; return t }, JT = (n => e => n && e instanceof n)(typeof Uint8Array < "u" && Bh(Uint8Array)), eA = (n, e) => { const r = (n && n[Dc]).call(n); let s; for (; (s = r.next()) && !s.done;) { const i = s.value; e.call(n, i[0], i[1]) } }, tA = (n, e) => { let t; const r = []; for (; (t = n.exec(e)) !== null;)r.push(t); return r }, rA = Vr("HTMLFormElement"), nA = n => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, r, s) { return r.toUpperCase() + s }), $0 = (({ hasOwnProperty: n }) => (e, t) => n.call(e, t))(Object.prototype), sA = Vr("RegExp"), Uy = (n, e) => { const t = Object.getOwnPropertyDescriptors(n), r = {}; co(t, (s, i) => { let a; (a = e(s, i, n)) !== !1 && (r[i] = a || s) }), Object.defineProperties(n, r) }, iA = n => { Uy(n, (e, t) => { if (cr(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1) return !1; const r = n[t]; if (cr(r)) { if (e.enumerable = !1, "writable" in e) { e.writable = !1; return } e.set || (e.set = () => { throw Error("Can not rewrite read-only method '" + t + "'") }) } }) }, aA = (n, e) => { const t = {}, r = s => { s.forEach(i => { t[i] = !0 }) }; return zi(n) ? r(n) : r(String(n).split(e)), t }, oA = () => { }, lA = (n, e) => n != null && Number.isFinite(n = +n) ? n : e; function cA(n) { return !!(n && cr(n.append) && n[My] === "FormData" && n[Dc]) } const uA = n => { const e = new Array(10), t = (r, s) => { if (lo(r)) { if (e.indexOf(r) >= 0) return; if (oo(r)) return r; if (!("toJSON" in r)) { e[s] = r; const i = zi(r) ? [] : {}; return co(r, (a, o) => { const c = t(a, s + 1); !ji(c) && (i[o] = c) }), e[s] = void 0, i } } return r }; return t(n, 0) }, dA = Vr("AsyncFunction"), fA = n => n && (lo(n) || cr(n)) && cr(n.then) && cr(n.catch), zy = ((n, e) => n ? setImmediate : e ? ((t, r) => (zs.addEventListener("message", ({ source: s, data: i }) => { s === zs && i === t && r.length && r.shift()() }, !1), s => { r.push(s), zs.postMessage(t, "*") }))(`axios@${Math.random()}`, []) : t => setTimeout(t))(typeof setImmediate == "function", cr(zs.postMessage)), hA = typeof queueMicrotask < "u" ? queueMicrotask.bind(zs) : typeof process < "u" && process.nextTick || zy, pA = n => n != null && cr(n[Dc]), ne = { isArray: zi, isArrayBuffer: jy, isBuffer: oo, isFormData: BT, isArrayBufferView: _T, isString: PT, isNumber: Fy, isBoolean: NT, isObject: lo, isPlainObject: ql, isEmptyObject: DT, isReadableStream: zT, isRequest: VT, isResponse: GT, isHeaders: HT, isUndefined: ji, isDate: OT, isFile: MT, isBlob: jT, isRegExp: sA, isFunction: cr, isStream: $T, isURLSearchParams: UT, isTypedArray: JT, isFileList: FT, forEach: co, merge: $f, extend: KT, trim: WT, stripBOM: qT, inherits: YT, toFlatObject: XT, kindOf: Oc, kindOfTest: Vr, endsWith: QT, toArray: ZT, forEachEntry: eA, matchAll: tA, isHTMLForm: rA, hasOwnProperty: $0, hasOwnProp: $0, reduceDescriptors: Uy, freezeMethods: iA, toObjectSet: aA, toCamelCase: nA, noop: oA, toFiniteNumber: lA, findKey: $y, global: zs, isContextDefined: By, isSpecCompliantForm: cA, toJSONObject: uA, isAsyncFn: dA, isThenable: fA, setImmediate: zy, asap: hA, isIterable: pA }; function $e(n, e, t, r, s) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null) } ne.inherits($e, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: ne.toJSONObject(this.config), code: this.code, status: this.status } } }); const Vy = $e.prototype, Gy = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(n => { Gy[n] = { value: n } }); Object.defineProperties($e, Gy); Object.defineProperty(Vy, "isAxiosError", { value: !0 }); $e.from = (n, e, t, r, s, i) => { const a = Object.create(Vy); ne.toFlatObject(n, a, function (f) { return f !== Error.prototype }, u => u !== "isAxiosError"); const o = n && n.message ? n.message : "Error", c = e == null && n ? n.code : e; return $e.call(a, o, c, t, r, s), n && a.cause == null && Object.defineProperty(a, "cause", { value: n, configurable: !0 }), a.name = n && n.name || "Error", i && Object.assign(a, i), a }; const mA = null; function Bf(n) { return ne.isPlainObject(n) || ne.isArray(n) } function Hy(n) { return ne.endsWith(n, "[]") ? n.slice(0, -2) : n } function B0(n, e, t) { return n ? n.concat(e).map(function (s, i) { return s = Hy(s), !t && i ? "[" + s + "]" : s }).join(t ? "." : "") : e } function gA(n) { return ne.isArray(n) && !n.some(Bf) } const xA = ne.toFlatObject(ne, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function jc(n, e, t) { if (!ne.isObject(n)) throw new TypeError("target must be an object"); e = e || new FormData, t = ne.toFlatObject(t, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (y, w) { return !ne.isUndefined(w[y]) }); const r = t.metaTokens, s = t.visitor || f, i = t.dots, a = t.indexes, c = (t.Blob || typeof Blob < "u" && Blob) && ne.isSpecCompliantForm(e); if (!ne.isFunction(s)) throw new TypeError("visitor must be a function"); function u(g) { if (g === null) return ""; if (ne.isDate(g)) return g.toISOString(); if (ne.isBoolean(g)) return g.toString(); if (!c && ne.isBlob(g)) throw new $e("Blob is not supported. Use a Buffer instead."); return ne.isArrayBuffer(g) || ne.isTypedArray(g) ? c && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g } function f(g, y, w) { let T = g; if (g && !w && typeof g == "object") { if (ne.endsWith(y, "{}")) y = r ? y : y.slice(0, -2), g = JSON.stringify(g); else if (ne.isArray(g) && gA(g) || (ne.isFileList(g) || ne.endsWith(y, "[]")) && (T = ne.toArray(g))) return y = Hy(y), T.forEach(function (E, I) { !(ne.isUndefined(E) || E === null) && e.append(a === !0 ? B0([y], I, i) : a === null ? y : y + "[]", u(E)) }), !1 } return Bf(g) ? !0 : (e.append(B0(w, y, i), u(g)), !1) } const h = [], p = Object.assign(xA, { defaultVisitor: f, convertValue: u, isVisitable: Bf }); function v(g, y) { if (!ne.isUndefined(g)) { if (h.indexOf(g) !== -1) throw Error("Circular reference detected in " + y.join(".")); h.push(g), ne.forEach(g, function (T, S) { (!(ne.isUndefined(T) || T === null) && s.call(e, T, ne.isString(S) ? S.trim() : S, y, p)) === !0 && v(T, y ? y.concat(S) : [S]) }), h.pop() } } if (!ne.isObject(n)) throw new TypeError("data must be an object"); return v(n), e } function U0(n) { const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (r) { return e[r] }) } function Uh(n, e) { this._pairs = [], n && jc(n, this, e) } const Wy = Uh.prototype; Wy.append = function (e, t) { this._pairs.push([e, t]) }; Wy.toString = function (e) { const t = e ? function (r) { return e.call(this, r, U0) } : U0; return this._pairs.map(function (s) { return t(s[0]) + "=" + t(s[1]) }, "").join("&") }; function vA(n) { return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function Ky(n, e, t) { if (!e) return n; const r = t && t.encode || vA; ne.isFunction(t) && (t = { serialize: t }); const s = t && t.serialize; let i; if (s ? i = s(e, t) : i = ne.isURLSearchParams(e) ? e.toString() : new Uh(e, t).toString(r), i) { const a = n.indexOf("#"); a !== -1 && (n = n.slice(0, a)), n += (n.indexOf("?") === -1 ? "?" : "&") + i } return n } class z0 { constructor() { this.handlers = [] } use(e, t, r) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { ne.forEach(this.handlers, function (r) { r !== null && e(r) }) } } const qy = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, yA = typeof URLSearchParams < "u" ? URLSearchParams : Uh, bA = typeof FormData < "u" ? FormData : null, wA = typeof Blob < "u" ? Blob : null, SA = { isBrowser: !0, classes: { URLSearchParams: yA, FormData: bA, Blob: wA }, protocols: ["http", "https", "file", "blob", "url", "data"] }, zh = typeof window < "u" && typeof document < "u", Uf = typeof navigator == "object" && navigator || void 0, EA = zh && (!Uf || ["ReactNative", "NativeScript", "NS"].indexOf(Uf.product) < 0), TA = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", AA = zh && window.location.href || "http://localhost", IA = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: zh, hasStandardBrowserEnv: EA, hasStandardBrowserWebWorkerEnv: TA, navigator: Uf, origin: AA }, Symbol.toStringTag, { value: "Module" })), Gt = { ...IA, ...SA }; function LA(n, e) { return jc(n, new Gt.classes.URLSearchParams, { visitor: function (t, r, s, i) { return Gt.isNode && ne.isBuffer(t) ? (this.append(r, t.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments) }, ...e }) } function CA(n) { return ne.matchAll(/\w+|\[(\w*)]/g, n).map(e => e[0] === "[]" ? "" : e[1] || e[0]) } function kA(n) { const e = {}, t = Object.keys(n); let r; const s = t.length; let i; for (r = 0; r < s; r++)i = t[r], e[i] = n[i]; return e } function Yy(n) { function e(t, r, s, i) { let a = t[i++]; if (a === "__proto__") return !0; const o = Number.isFinite(+a), c = i >= t.length; return a = !a && ne.isArray(s) ? s.length : a, c ? (ne.hasOwnProp(s, a) ? s[a] = [s[a], r] : s[a] = r, !o) : ((!s[a] || !ne.isObject(s[a])) && (s[a] = []), e(t, r, s[a], i) && ne.isArray(s[a]) && (s[a] = kA(s[a])), !o) } if (ne.isFormData(n) && ne.isFunction(n.entries)) { const t = {}; return ne.forEachEntry(n, (r, s) => { e(CA(r), s, t, 0) }), t } return null } function RA(n, e, t) { if (ne.isString(n)) try { return (e || JSON.parse)(n), ne.trim(n) } catch (r) { if (r.name !== "SyntaxError") throw r } return (t || JSON.stringify)(n) } const uo = { transitional: qy, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const r = t.getContentType() || "", s = r.indexOf("application/json") > -1, i = ne.isObject(e); if (i && ne.isHTMLForm(e) && (e = new FormData(e)), ne.isFormData(e)) return s ? JSON.stringify(Yy(e)) : e; if (ne.isArrayBuffer(e) || ne.isBuffer(e) || ne.isStream(e) || ne.isFile(e) || ne.isBlob(e) || ne.isReadableStream(e)) return e; if (ne.isArrayBufferView(e)) return e.buffer; if (ne.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let o; if (i) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return LA(e, this.formSerializer).toString(); if ((o = ne.isFileList(e)) || r.indexOf("multipart/form-data") > -1) { const c = this.env && this.env.FormData; return jc(o ? { "files[]": e } : e, c && new c, this.formSerializer) } } return i || s ? (t.setContentType("application/json", !1), RA(e)) : e }], transformResponse: [function (e) { const t = this.transitional || uo.transitional, r = t && t.forcedJSONParsing, s = this.responseType === "json"; if (ne.isResponse(e) || ne.isReadableStream(e)) return e; if (e && ne.isString(e) && (r && !this.responseType || s)) { const a = !(t && t.silentJSONParsing) && s; try { return JSON.parse(e, this.parseReviver) } catch (o) { if (a) throw o.name === "SyntaxError" ? $e.from(o, $e.ERR_BAD_RESPONSE, this, null, this.response) : o } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Gt.classes.FormData, Blob: Gt.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; ne.forEach(["delete", "get", "head", "post", "put", "patch"], n => { uo.headers[n] = {} }); const _A = ne.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), PA = n => {
    const e = {}; let t, r, s; return n && n.split(`
`).forEach(function (a) { s = a.indexOf(":"), t = a.substring(0, s).trim().toLowerCase(), r = a.substring(s + 1).trim(), !(!t || e[t] && _A[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r) }), e
  }, V0 = Symbol("internals"); function Na(n) { return n && String(n).trim().toLowerCase() } function Yl(n) { return n === !1 || n == null ? n : ne.isArray(n) ? n.map(Yl) : String(n) } function NA(n) { const e = Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = t.exec(n);)e[r[1]] = r[2]; return e } const DA = n => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim()); function zd(n, e, t, r, s) { if (ne.isFunction(r)) return r.call(this, e, t); if (s && (e = t), !!ne.isString(e)) { if (ne.isString(r)) return e.indexOf(r) !== -1; if (ne.isRegExp(r)) return r.test(e) } } function OA(n) { return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r) } function MA(n, e) { const t = ne.toCamelCase(" " + e);["get", "set", "has"].forEach(r => { Object.defineProperty(n, r + t, { value: function (s, i, a) { return this[r].call(this, e, s, i, a) }, configurable: !0 }) }) } let ur = class {
    constructor(e) { e && this.set(e) } set(e, t, r) { const s = this; function i(o, c, u) { const f = Na(c); if (!f) throw new Error("header name must be a non-empty string"); const h = ne.findKey(s, f); (!h || s[h] === void 0 || u === !0 || u === void 0 && s[h] !== !1) && (s[h || c] = Yl(o)) } const a = (o, c) => ne.forEach(o, (u, f) => i(u, f, c)); if (ne.isPlainObject(e) || e instanceof this.constructor) a(e, t); else if (ne.isString(e) && (e = e.trim()) && !DA(e)) a(PA(e), t); else if (ne.isObject(e) && ne.isIterable(e)) { let o = {}, c, u; for (const f of e) { if (!ne.isArray(f)) throw TypeError("Object iterator must return a key-value pair"); o[u = f[0]] = (c = o[u]) ? ne.isArray(c) ? [...c, f[1]] : [c, f[1]] : f[1] } a(o, t) } else e != null && i(t, e, r); return this } get(e, t) { if (e = Na(e), e) { const r = ne.findKey(this, e); if (r) { const s = this[r]; if (!t) return s; if (t === !0) return NA(s); if (ne.isFunction(t)) return t.call(this, s, r); if (ne.isRegExp(t)) return t.exec(s); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = Na(e), e) { const r = ne.findKey(this, e); return !!(r && this[r] !== void 0 && (!t || zd(this, this[r], r, t))) } return !1 } delete(e, t) { const r = this; let s = !1; function i(a) { if (a = Na(a), a) { const o = ne.findKey(r, a); o && (!t || zd(r, r[o], o, t)) && (delete r[o], s = !0) } } return ne.isArray(e) ? e.forEach(i) : i(e), s } clear(e) { const t = Object.keys(this); let r = t.length, s = !1; for (; r--;) { const i = t[r]; (!e || zd(this, this[i], i, e, !0)) && (delete this[i], s = !0) } return s } normalize(e) { const t = this, r = {}; return ne.forEach(this, (s, i) => { const a = ne.findKey(r, i); if (a) { t[a] = Yl(s), delete t[i]; return } const o = e ? OA(i) : String(i).trim(); o !== i && delete t[i], t[o] = Yl(s), r[o] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return ne.forEach(this, (r, s) => { r != null && r !== !1 && (t[s] = e && ne.isArray(r) ? r.join(", ") : r) }), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
      return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`)
    } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const r = new this(e); return t.forEach(s => r.set(s)), r } static accessor(e) { const r = (this[V0] = this[V0] = { accessors: {} }).accessors, s = this.prototype; function i(a) { const o = Na(a); r[o] || (MA(s, a), r[o] = !0) } return ne.isArray(e) ? e.forEach(i) : i(e), this }
  }; ur.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); ne.reduceDescriptors(ur.prototype, ({ value: n }, e) => { let t = e[0].toUpperCase() + e.slice(1); return { get: () => n, set(r) { this[t] = r } } }); ne.freezeMethods(ur); function Vd(n, e) { const t = this || uo, r = e || t, s = ur.from(r.headers); let i = r.data; return ne.forEach(n, function (o) { i = o.call(t, i, s.normalize(), e ? e.status : void 0) }), s.normalize(), i } function Xy(n) { return !!(n && n.__CANCEL__) } function Vi(n, e, t) { $e.call(this, n ?? "canceled", $e.ERR_CANCELED, e, t), this.name = "CanceledError" } ne.inherits(Vi, $e, { __CANCEL__: !0 }); function Qy(n, e, t) { const r = t.config.validateStatus; !t.status || !r || r(t.status) ? n(t) : e(new $e("Request failed with status code " + t.status, [$e.ERR_BAD_REQUEST, $e.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t)) } function jA(n) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n); return e && e[1] || "" } function FA(n, e) { n = n || 10; const t = new Array(n), r = new Array(n); let s = 0, i = 0, a; return e = e !== void 0 ? e : 1e3, function (c) { const u = Date.now(), f = r[i]; a || (a = u), t[s] = c, r[s] = u; let h = i, p = 0; for (; h !== s;)p += t[h++], h = h % n; if (s = (s + 1) % n, s === i && (i = (i + 1) % n), u - a < e) return; const v = f && u - f; return v ? Math.round(p * 1e3 / v) : void 0 } } function $A(n, e) { let t = 0, r = 1e3 / e, s, i; const a = (u, f = Date.now()) => { t = f, s = null, i && (clearTimeout(i), i = null), n(...u) }; return [(...u) => { const f = Date.now(), h = f - t; h >= r ? a(u, f) : (s = u, i || (i = setTimeout(() => { i = null, a(s) }, r - h))) }, () => s && a(s)] } const uc = (n, e, t = 3) => { let r = 0; const s = FA(50, 250); return $A(i => { const a = i.loaded, o = i.lengthComputable ? i.total : void 0, c = a - r, u = s(c), f = a <= o; r = a; const h = { loaded: a, total: o, progress: o ? a / o : void 0, bytes: c, rate: u || void 0, estimated: u && o && f ? (o - a) / u : void 0, event: i, lengthComputable: o != null, [e ? "download" : "upload"]: !0 }; n(h) }, t) }, G0 = (n, e) => { const t = n != null; return [r => e[0]({ lengthComputable: t, total: n, loaded: r }), e[1]] }, H0 = n => (...e) => ne.asap(() => n(...e)), BA = Gt.hasStandardBrowserEnv ? ((n, e) => t => (t = new URL(t, Gt.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(new URL(Gt.origin), Gt.navigator && /(msie|trident)/i.test(Gt.navigator.userAgent)) : () => !0, UA = Gt.hasStandardBrowserEnv ? { write(n, e, t, r, s, i) { const a = [n + "=" + encodeURIComponent(e)]; ne.isNumber(t) && a.push("expires=" + new Date(t).toGMTString()), ne.isString(r) && a.push("path=" + r), ne.isString(s) && a.push("domain=" + s), i === !0 && a.push("secure"), document.cookie = a.join("; ") }, read(n) { const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)")); return e ? decodeURIComponent(e[3]) : null }, remove(n) { this.write(n, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function zA(n) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n) } function VA(n, e) { return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n } function Zy(n, e, t) { let r = !zA(e); return n && (r || t == !1) ? VA(n, e) : e } const W0 = n => n instanceof ur ? { ...n } : n; function Ws(n, e) { e = e || {}; const t = {}; function r(u, f, h, p) { return ne.isPlainObject(u) && ne.isPlainObject(f) ? ne.merge.call({ caseless: p }, u, f) : ne.isPlainObject(f) ? ne.merge({}, f) : ne.isArray(f) ? f.slice() : f } function s(u, f, h, p) { if (ne.isUndefined(f)) { if (!ne.isUndefined(u)) return r(void 0, u, h, p) } else return r(u, f, h, p) } function i(u, f) { if (!ne.isUndefined(f)) return r(void 0, f) } function a(u, f) { if (ne.isUndefined(f)) { if (!ne.isUndefined(u)) return r(void 0, u) } else return r(void 0, f) } function o(u, f, h) { if (h in e) return r(u, f); if (h in n) return r(void 0, u) } const c = { url: i, method: i, data: i, baseURL: a, transformRequest: a, transformResponse: a, paramsSerializer: a, timeout: a, timeoutMessage: a, withCredentials: a, withXSRFToken: a, adapter: a, responseType: a, xsrfCookieName: a, xsrfHeaderName: a, onUploadProgress: a, onDownloadProgress: a, decompress: a, maxContentLength: a, maxBodyLength: a, beforeRedirect: a, transport: a, httpAgent: a, httpsAgent: a, cancelToken: a, socketPath: a, responseEncoding: a, validateStatus: o, headers: (u, f, h) => s(W0(u), W0(f), h, !0) }; return ne.forEach(Object.keys({ ...n, ...e }), function (f) { const h = c[f] || s, p = h(n[f], e[f], f); ne.isUndefined(p) && h !== o || (t[f] = p) }), t } const Jy = n => { const e = Ws({}, n); let { data: t, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: i, headers: a, auth: o } = e; if (e.headers = a = ur.from(a), e.url = Ky(Zy(e.baseURL, e.url, e.allowAbsoluteUrls), n.params, n.paramsSerializer), o && a.set("Authorization", "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))), ne.isFormData(t)) { if (Gt.hasStandardBrowserEnv || Gt.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0); else if (ne.isFunction(t.getHeaders)) { const c = t.getHeaders(), u = ["content-type", "content-length"]; Object.entries(c).forEach(([f, h]) => { u.includes(f.toLowerCase()) && a.set(f, h) }) } } if (Gt.hasStandardBrowserEnv && (r && ne.isFunction(r) && (r = r(e)), r || r !== !1 && BA(e.url))) { const c = s && i && UA.read(i); c && a.set(s, c) } return e }, GA = typeof XMLHttpRequest < "u", HA = GA && function (n) { return new Promise(function (t, r) { const s = Jy(n); let i = s.data; const a = ur.from(s.headers).normalize(); let { responseType: o, onUploadProgress: c, onDownloadProgress: u } = s, f, h, p, v, g; function y() { v && v(), g && g(), s.cancelToken && s.cancelToken.unsubscribe(f), s.signal && s.signal.removeEventListener("abort", f) } let w = new XMLHttpRequest; w.open(s.method.toUpperCase(), s.url, !0), w.timeout = s.timeout; function T() { if (!w) return; const E = ur.from("getAllResponseHeaders" in w && w.getAllResponseHeaders()), C = { data: !o || o === "text" || o === "json" ? w.responseText : w.response, status: w.status, statusText: w.statusText, headers: E, config: n, request: w }; Qy(function (R) { t(R), y() }, function (R) { r(R), y() }, C), w = null } "onloadend" in w ? w.onloadend = T : w.onreadystatechange = function () { !w || w.readyState !== 4 || w.status === 0 && !(w.responseURL && w.responseURL.indexOf("file:") === 0) || setTimeout(T) }, w.onabort = function () { w && (r(new $e("Request aborted", $e.ECONNABORTED, n, w)), w = null) }, w.onerror = function (I) { const C = I && I.message ? I.message : "Network Error", D = new $e(C, $e.ERR_NETWORK, n, w); D.event = I || null, r(D), w = null }, w.ontimeout = function () { let I = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded"; const C = s.transitional || qy; s.timeoutErrorMessage && (I = s.timeoutErrorMessage), r(new $e(I, C.clarifyTimeoutError ? $e.ETIMEDOUT : $e.ECONNABORTED, n, w)), w = null }, i === void 0 && a.setContentType(null), "setRequestHeader" in w && ne.forEach(a.toJSON(), function (I, C) { w.setRequestHeader(C, I) }), ne.isUndefined(s.withCredentials) || (w.withCredentials = !!s.withCredentials), o && o !== "json" && (w.responseType = s.responseType), u && ([p, g] = uc(u, !0), w.addEventListener("progress", p)), c && w.upload && ([h, v] = uc(c), w.upload.addEventListener("progress", h), w.upload.addEventListener("loadend", v)), (s.cancelToken || s.signal) && (f = E => { w && (r(!E || E.type ? new Vi(null, n, w) : E), w.abort(), w = null) }, s.cancelToken && s.cancelToken.subscribe(f), s.signal && (s.signal.aborted ? f() : s.signal.addEventListener("abort", f))); const S = jA(s.url); if (S && Gt.protocols.indexOf(S) === -1) { r(new $e("Unsupported protocol " + S + ":", $e.ERR_BAD_REQUEST, n)); return } w.send(i || null) }) }, WA = (n, e) => { const { length: t } = n = n ? n.filter(Boolean) : []; if (e || t) { let r = new AbortController, s; const i = function (u) { if (!s) { s = !0, o(); const f = u instanceof Error ? u : this.reason; r.abort(f instanceof $e ? f : new Vi(f instanceof Error ? f.message : f)) } }; let a = e && setTimeout(() => { a = null, i(new $e(`timeout ${e} of ms exceeded`, $e.ETIMEDOUT)) }, e); const o = () => { n && (a && clearTimeout(a), a = null, n.forEach(u => { u.unsubscribe ? u.unsubscribe(i) : u.removeEventListener("abort", i) }), n = null) }; n.forEach(u => u.addEventListener("abort", i)); const { signal: c } = r; return c.unsubscribe = () => ne.asap(o), c } }, KA = function* (n, e) { let t = n.byteLength; if (t < e) { yield n; return } let r = 0, s; for (; r < t;)s = r + e, yield n.slice(r, s), r = s }, qA = async function* (n, e) { for await (const t of YA(n)) yield* KA(t, e) }, YA = async function* (n) { if (n[Symbol.asyncIterator]) { yield* n; return } const e = n.getReader(); try { for (; ;) { const { done: t, value: r } = await e.read(); if (t) break; yield r } } finally { await e.cancel() } }, K0 = (n, e, t, r) => { const s = qA(n, e); let i = 0, a, o = c => { a || (a = !0, r && r(c)) }; return new ReadableStream({ async pull(c) { try { const { done: u, value: f } = await s.next(); if (u) { o(), c.close(); return } let h = f.byteLength; if (t) { let p = i += h; t(p) } c.enqueue(new Uint8Array(f)) } catch (u) { throw o(u), u } }, cancel(c) { return o(c), s.return() } }, { highWaterMark: 2 }) }, q0 = 64 * 1024, { isFunction: Il } = ne, XA = (({ Request: n, Response: e }) => ({ Request: n, Response: e }))(ne.global), { ReadableStream: Y0, TextEncoder: X0 } = ne.global, Q0 = (n, ...e) => { try { return !!n(...e) } catch { return !1 } }, QA = n => { n = ne.merge.call({ skipUndefined: !0 }, XA, n); const { fetch: e, Request: t, Response: r } = n, s = e ? Il(e) : typeof fetch == "function", i = Il(t), a = Il(r); if (!s) return !1; const o = s && Il(Y0), c = s && (typeof X0 == "function" ? (g => y => g.encode(y))(new X0) : async g => new Uint8Array(await new t(g).arrayBuffer())), u = i && o && Q0(() => { let g = !1; const y = new t(Gt.origin, { body: new Y0, method: "POST", get duplex() { return g = !0, "half" } }).headers.has("Content-Type"); return g && !y }), f = a && o && Q0(() => ne.isReadableStream(new r("").body)), h = { stream: f && (g => g.body) }; s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(g => { !h[g] && (h[g] = (y, w) => { let T = y && y[g]; if (T) return T.call(y); throw new $e(`Response type '${g}' is not supported`, $e.ERR_NOT_SUPPORT, w) }) }); const p = async g => { if (g == null) return 0; if (ne.isBlob(g)) return g.size; if (ne.isSpecCompliantForm(g)) return (await new t(Gt.origin, { method: "POST", body: g }).arrayBuffer()).byteLength; if (ne.isArrayBufferView(g) || ne.isArrayBuffer(g)) return g.byteLength; if (ne.isURLSearchParams(g) && (g = g + ""), ne.isString(g)) return (await c(g)).byteLength }, v = async (g, y) => { const w = ne.toFiniteNumber(g.getContentLength()); return w ?? p(y) }; return async g => { let { url: y, method: w, data: T, signal: S, cancelToken: E, timeout: I, onDownloadProgress: C, onUploadProgress: D, responseType: R, headers: N, withCredentials: P = "same-origin", fetchOptions: _ } = Jy(g), M = e || fetch; R = R ? (R + "").toLowerCase() : "text"; let $ = WA([S, E && E.toAbortSignal()], I), B = null; const V = $ && $.unsubscribe && (() => { $.unsubscribe() }); let W; try { if (D && u && w !== "get" && w !== "head" && (W = await v(N, T)) !== 0) { let F = new t(y, { method: "POST", body: T, duplex: "half" }), H; if (ne.isFormData(T) && (H = F.headers.get("content-type")) && N.setContentType(H), F.body) { const [ae, he] = G0(W, uc(H0(D))); T = K0(F.body, q0, ae, he) } } ne.isString(P) || (P = P ? "include" : "omit"); const U = i && "credentials" in t.prototype, q = { ..._, signal: $, method: w.toUpperCase(), headers: N.normalize().toJSON(), body: T, duplex: "half", credentials: U ? P : void 0 }; B = i && new t(y, q); let z = await (i ? M(B, _) : M(y, q)); const X = f && (R === "stream" || R === "response"); if (f && (C || X && V)) { const F = {};["status", "statusText", "headers"].forEach(de => { F[de] = z[de] }); const H = ne.toFiniteNumber(z.headers.get("content-length")), [ae, he] = C && G0(H, uc(H0(C), !0)) || []; z = new r(K0(z.body, q0, ae, () => { he && he(), V && V() }), F) } R = R || "text"; let Z = await h[ne.findKey(h, R) || "text"](z, g); return !X && V && V(), await new Promise((F, H) => { Qy(F, H, { data: Z, headers: ur.from(z.headers), status: z.status, statusText: z.statusText, config: g, request: B }) }) } catch (U) { throw V && V(), U && U.name === "TypeError" && /Load failed|fetch/i.test(U.message) ? Object.assign(new $e("Network Error", $e.ERR_NETWORK, g, B), { cause: U.cause || U }) : $e.from(U, U && U.code, g, B) } } }, ZA = new Map, e1 = n => { let e = n ? n.env : {}; const { fetch: t, Request: r, Response: s } = e, i = [r, s, t]; let a = i.length, o = a, c, u, f = ZA; for (; o--;)c = i[o], u = f.get(c), u === void 0 && f.set(c, u = o ? new Map : QA(e)), f = u; return u }; e1(); const zf = { http: mA, xhr: HA, fetch: { get: e1 } }; ne.forEach(zf, (n, e) => { if (n) { try { Object.defineProperty(n, "name", { value: e }) } catch { } Object.defineProperty(n, "adapterName", { value: e }) } }); const Z0 = n => `- ${n}`, JA = n => ne.isFunction(n) || n === null || n === !1, t1 = {
    getAdapter: (n, e) => {
      n = ne.isArray(n) ? n : [n]; const { length: t } = n; let r, s; const i = {}; for (let a = 0; a < t; a++) { r = n[a]; let o; if (s = r, !JA(r) && (s = zf[(o = String(r)).toLowerCase()], s === void 0)) throw new $e(`Unknown adapter '${o}'`); if (s && (ne.isFunction(s) || (s = s.get(e)))) break; i[o || "#" + a] = s } if (!s) {
        const a = Object.entries(i).map(([c, u]) => `adapter ${c} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")); let o = t ? a.length > 1 ? `since :
`+ a.map(Z0).join(`
`) : " " + Z0(a[0]) : "as no adapter specified"; throw new $e("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
      } return s
    }, adapters: zf
  }; function Gd(n) { if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted) throw new Vi(null, n) } function J0(n) { return Gd(n), n.headers = ur.from(n.headers), n.data = Vd.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), t1.getAdapter(n.adapter || uo.adapter, n)(n).then(function (r) { return Gd(n), r.data = Vd.call(n, n.transformResponse, r), r.headers = ur.from(r.headers), r }, function (r) { return Xy(r) || (Gd(n), r && r.response && (r.response.data = Vd.call(n, n.transformResponse, r.response), r.response.headers = ur.from(r.response.headers))), Promise.reject(r) }) } const r1 = "1.12.2", Fc = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => { Fc[n] = function (r) { return typeof r === n || "a" + (e < 1 ? "n " : " ") + n } }); const ex = {}; Fc.transitional = function (e, t, r) { function s(i, a) { return "[Axios v" + r1 + "] Transitional option '" + i + "'" + a + (r ? ". " + r : "") } return (i, a, o) => { if (e === !1) throw new $e(s(a, " has been removed" + (t ? " in " + t : "")), $e.ERR_DEPRECATED); return t && !ex[a] && (ex[a] = !0, console.warn(s(a, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(i, a, o) : !0 } }; Fc.spelling = function (e) { return (t, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0) }; function eI(n, e, t) { if (typeof n != "object") throw new $e("options must be an object", $e.ERR_BAD_OPTION_VALUE); const r = Object.keys(n); let s = r.length; for (; s-- > 0;) { const i = r[s], a = e[i]; if (a) { const o = n[i], c = o === void 0 || a(o, i, n); if (c !== !0) throw new $e("option " + i + " must be " + c, $e.ERR_BAD_OPTION_VALUE); continue } if (t !== !0) throw new $e("Unknown option " + i, $e.ERR_BAD_OPTION) } } const Xl = { assertOptions: eI, validators: Fc }, Qr = Xl.validators; let Gs = class {
    constructor(e) { this.defaults = e || {}, this.interceptors = { request: new z0, response: new z0 } } async request(e, t) {
      try { return await this._request(e, t) } catch (r) {
        if (r instanceof Error) {
          let s = {}; Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error; const i = s.stack ? s.stack.replace(/^.+\n/, "") : ""; try {
            r.stack ? i && !String(r.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ i) : r.stack = i
          } catch { }
        } throw r
      }
    } _request(e, t) { typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Ws(this.defaults, t); const { transitional: r, paramsSerializer: s, headers: i } = t; r !== void 0 && Xl.assertOptions(r, { silentJSONParsing: Qr.transitional(Qr.boolean), forcedJSONParsing: Qr.transitional(Qr.boolean), clarifyTimeoutError: Qr.transitional(Qr.boolean) }, !1), s != null && (ne.isFunction(s) ? t.paramsSerializer = { serialize: s } : Xl.assertOptions(s, { encode: Qr.function, serialize: Qr.function }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Xl.assertOptions(t, { baseUrl: Qr.spelling("baseURL"), withXsrfToken: Qr.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let a = i && ne.merge(i.common, i[t.method]); i && ne.forEach(["delete", "get", "head", "post", "put", "patch", "common"], g => { delete i[g] }), t.headers = ur.concat(a, i); const o = []; let c = !0; this.interceptors.request.forEach(function (y) { typeof y.runWhen == "function" && y.runWhen(t) === !1 || (c = c && y.synchronous, o.unshift(y.fulfilled, y.rejected)) }); const u = []; this.interceptors.response.forEach(function (y) { u.push(y.fulfilled, y.rejected) }); let f, h = 0, p; if (!c) { const g = [J0.bind(this), void 0]; for (g.unshift(...o), g.push(...u), p = g.length, f = Promise.resolve(t); h < p;)f = f.then(g[h++], g[h++]); return f } p = o.length; let v = t; for (; h < p;) { const g = o[h++], y = o[h++]; try { v = g(v) } catch (w) { y.call(this, w); break } } try { f = J0.call(this, v) } catch (g) { return Promise.reject(g) } for (h = 0, p = u.length; h < p;)f = f.then(u[h++], u[h++]); return f } getUri(e) { e = Ws(this.defaults, e); const t = Zy(e.baseURL, e.url, e.allowAbsoluteUrls); return Ky(t, e.params, e.paramsSerializer) }
  }; ne.forEach(["delete", "get", "head", "options"], function (e) { Gs.prototype[e] = function (t, r) { return this.request(Ws(r || {}, { method: e, url: t, data: (r || {}).data })) } }); ne.forEach(["post", "put", "patch"], function (e) { function t(r) { return function (i, a, o) { return this.request(Ws(o || {}, { method: e, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: i, data: a })) } } Gs.prototype[e] = t(), Gs.prototype[e + "Form"] = t(!0) }); let tI = class n1 { constructor(e) { if (typeof e != "function") throw new TypeError("executor must be a function."); let t; this.promise = new Promise(function (i) { t = i }); const r = this; this.promise.then(s => { if (!r._listeners) return; let i = r._listeners.length; for (; i-- > 0;)r._listeners[i](s); r._listeners = null }), this.promise.then = s => { let i; const a = new Promise(o => { r.subscribe(o), i = o }).then(s); return a.cancel = function () { r.unsubscribe(i) }, a }, e(function (i, a, o) { r.reason || (r.reason = new Vi(i, a, o), t(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { if (this.reason) { e(this.reason); return } this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); t !== -1 && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = r => { e.abort(r) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let e; return { token: new n1(function (s) { e = s }), cancel: e } } }; function rI(n) { return function (t) { return n.apply(null, t) } } function nI(n) { return ne.isObject(n) && n.isAxiosError === !0 } const Vf = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Vf).forEach(([n, e]) => { Vf[e] = n }); function s1(n) { const e = new Gs(n), t = Oy(Gs.prototype.request, e); return ne.extend(t, Gs.prototype, e, { allOwnKeys: !0 }), ne.extend(t, e, null, { allOwnKeys: !0 }), t.create = function (s) { return s1(Ws(n, s)) }, t } const Ke = s1(uo); Ke.Axios = Gs; Ke.CanceledError = Vi; Ke.CancelToken = tI; Ke.isCancel = Xy; Ke.VERSION = r1; Ke.toFormData = jc; Ke.AxiosError = $e; Ke.Cancel = Ke.CanceledError; Ke.all = function (e) { return Promise.all(e) }; Ke.spread = rI; Ke.isAxiosError = nI; Ke.mergeConfig = Ws; Ke.AxiosHeaders = ur; Ke.formToJSON = n => Yy(ne.isHTMLForm(n) ? new FormData(n) : n); Ke.getAdapter = t1.getAdapter; Ke.HttpStatusCode = Vf; Ke.default = Ke; const { Axios: S6, AxiosError: E6, CanceledError: T6, isCancel: A6, CancelToken: I6, VERSION: L6, all: C6, Cancel: k6, isAxiosError: R6, spread: _6, toFormData: P6, AxiosHeaders: N6, HttpStatusCode: D6, formToJSON: O6, getAdapter: M6, mergeConfig: j6 } = Ke, tx = "homeInfoCache", sI = 1440 * 60 * 1e3; async function iI() { const n = "https://apii-orcin-theta.vercel.app/api", e = Date.now(), t = JSON.parse(localStorage.getItem(tx)); if (t && e - t.timestamp < sI) return t.data; const r = await Ke.get(`${n}`); if (!r.data.results || Object.keys(r.data.results).length === 0) return null; const { spotlights: s, trending: i, topTen: a, today: o, topAiring: c, mostPopular: u, mostFavorite: f, latestCompleted: h, latestEpisode: p, topUpcoming: v, recentlyAdded: g, genres: y } = r.data.results, w = { data: { spotlights: s, trending: i, topten: a, todaySchedule: o, top_airing: c, most_popular: u, most_favorite: f, latest_completed: h, latest_episode: p, top_upcoming: v, recently_added: g, genres: y }, timestamp: e }; return localStorage.setItem(tx, JSON.stringify(w)), w.data } const i1 = j.createContext(), aI = ({ children: n }) => { const [e, t] = j.useState(null), [r, s] = j.useState(!0), [i, a] = j.useState(null); return j.useEffect(() => { (async () => { try { const c = await iI(); t(c) } catch (c) { console.error("Error fetching home info:", c), a(c) } finally { s(!1) } })() }, []), x.jsx(i1.Provider, { value: { homeInfo: e, homeInfoLoading: r, error: i }, children: n }) }, Vh = () => j.useContext(i1), _n = "Anirox"; function rx(n) { return n !== null && typeof n == "object" && "constructor" in n && n.constructor === Object } function Gh(n, e) { n === void 0 && (n = {}), e === void 0 && (e = {}); const t = ["__proto__", "constructor", "prototype"]; Object.keys(e).filter(r => t.indexOf(r) < 0).forEach(r => { typeof n[r] > "u" ? n[r] = e[r] : rx(e[r]) && rx(n[r]) && Object.keys(e[r]).length > 0 && Gh(n[r], e[r]) }) } const a1 = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function dn() { const n = typeof document < "u" ? document : {}; return Gh(n, a1), n } const oI = { document: a1, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(n) { return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0) }, cancelAnimationFrame(n) { typeof setTimeout > "u" || clearTimeout(n) } }; function Qt() { const n = typeof window < "u" ? window : {}; return Gh(n, oI), n } function lI(n) { return n === void 0 && (n = ""), n.trim().split(" ").filter(e => !!e.trim()) } function cI(n) { const e = n; Object.keys(e).forEach(t => { try { e[t] = null } catch { } try { delete e[t] } catch { } }) } function o1(n, e) { return e === void 0 && (e = 0), setTimeout(n, e) } function dc() { return Date.now() } function uI(n) { const e = Qt(); let t; return e.getComputedStyle && (t = e.getComputedStyle(n, null)), !t && n.currentStyle && (t = n.currentStyle), t || (t = n.style), t } function dI(n, e) { e === void 0 && (e = "x"); const t = Qt(); let r, s, i; const a = uI(n); return t.WebKitCSSMatrix ? (s = a.transform || a.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(o => o.replace(",", ".")).join(", ")), i = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (i = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = i.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? s = i.m41 : r.length === 16 ? s = parseFloat(r[12]) : s = parseFloat(r[4])), e === "y" && (t.WebKitCSSMatrix ? s = i.m42 : r.length === 16 ? s = parseFloat(r[13]) : s = parseFloat(r[5])), s || 0 } function Ll(n) { return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" } function fI(n) { return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11) } function yr() { const n = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"]; for (let t = 1; t < arguments.length; t += 1) { const r = t < 0 || arguments.length <= t ? void 0 : arguments[t]; if (r != null && !fI(r)) { const s = Object.keys(Object(r)).filter(i => e.indexOf(i) < 0); for (let i = 0, a = s.length; i < a; i += 1) { const o = s[i], c = Object.getOwnPropertyDescriptor(r, o); c !== void 0 && c.enumerable && (Ll(n[o]) && Ll(r[o]) ? r[o].__swiper__ ? n[o] = r[o] : yr(n[o], r[o]) : !Ll(n[o]) && Ll(r[o]) ? (n[o] = {}, r[o].__swiper__ ? n[o] = r[o] : yr(n[o], r[o])) : n[o] = r[o]) } } } return n } function Cl(n, e, t) { n.style.setProperty(e, t) } function l1(n) { let { swiper: e, targetPosition: t, side: r } = n; const s = Qt(), i = -e.translate; let a = null, o; const c = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(e.cssModeFrameID); const u = t > i ? "next" : "prev", f = (p, v) => u === "next" && p >= v || u === "prev" && p <= v, h = () => { o = new Date().getTime(), a === null && (a = o); const p = Math.max(Math.min((o - a) / c, 1), 0), v = .5 - Math.cos(p * Math.PI) / 2; let g = i + v * (t - i); if (f(g, t) && (g = t), e.wrapperEl.scrollTo({ [r]: g }), f(g, t)) { e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [r]: g }) }), s.cancelAnimationFrame(e.cssModeFrameID); return } e.cssModeFrameID = s.requestAnimationFrame(h) }; h() } function c1(n) { return n.querySelector(".swiper-slide-transform") || n.shadowRoot && n.shadowRoot.querySelector(".swiper-slide-transform") || n } function an(n, e) { e === void 0 && (e = ""); const t = Qt(), r = [...n.children]; return t.HTMLSlotElement && n instanceof HTMLSlotElement && r.push(...n.assignedElements()), e ? r.filter(s => s.matches(e)) : r } function hI(n, e) { const t = [e]; for (; t.length > 0;) { const r = t.shift(); if (n === r) return !0; t.push(...r.children, ...r.shadowRoot ? r.shadowRoot.children : [], ...r.assignedElements ? r.assignedElements() : []) } } function pI(n, e) { const t = Qt(); let r = e.contains(n); return !r && t.HTMLSlotElement && e instanceof HTMLSlotElement && (r = [...e.assignedElements()].includes(n), r || (r = hI(n, e))), r } function fc(n) { try { console.warn(n); return } catch { } } function hc(n, e) { e === void 0 && (e = []); const t = document.createElement(n); return t.classList.add(...Array.isArray(e) ? e : lI(e)), t } function mI(n, e) { const t = []; for (; n.previousElementSibling;) { const r = n.previousElementSibling; e ? r.matches(e) && t.push(r) : t.push(r), n = r } return t } function gI(n, e) { const t = []; for (; n.nextElementSibling;) { const r = n.nextElementSibling; e ? r.matches(e) && t.push(r) : t.push(r), n = r } return t } function ps(n, e) { return Qt().getComputedStyle(n, null).getPropertyValue(e) } function pc(n) { let e = n, t; if (e) { for (t = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (t += 1); return t } } function u1(n, e) { const t = []; let r = n.parentElement; for (; r;)e ? r.matches(e) && t.push(r) : t.push(r), r = r.parentElement; return t } function xI(n, e) { function t(r) { r.target === n && (e.call(n, r), n.removeEventListener("transitionend", t)) } e && n.addEventListener("transitionend", t) } function Gf(n, e, t) { const r = Qt(); return n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) } function Mt(n) { return (Array.isArray(n) ? n : [n]).filter(e => !!e) } function mc(n, e) { e === void 0 && (e = ""), typeof trustedTypes < "u" ? n.innerHTML = trustedTypes.createPolicy("html", { createHTML: t => t }).createHTML(e) : n.innerHTML = e } let Hd; function vI() { const n = Qt(), e = dn(); return { smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch) } } function d1() { return Hd || (Hd = vI()), Hd } let Wd; function yI(n) { let { userAgent: e } = n === void 0 ? {} : n; const t = d1(), r = Qt(), s = r.navigator.platform, i = e || r.navigator.userAgent, a = { ios: !1, android: !1 }, o = r.screen.width, c = r.screen.height, u = i.match(/(Android);?[\s\/]+([\d.]+)?/); let f = i.match(/(iPad).*OS\s([\d_]+)/); const h = i.match(/(iPod)(.*OS\s([\d_]+))?/), p = !f && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/), v = s === "Win32"; let g = s === "MacIntel"; const y = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !f && g && t.touch && y.indexOf(`${o}x${c}`) >= 0 && (f = i.match(/(Version)\/([\d.]+)/), f || (f = [0, 1, "13_0_0"]), g = !1), u && !v && (a.os = "android", a.android = !0), (f || p || h) && (a.os = "ios", a.ios = !0), a } function f1(n) { return n === void 0 && (n = {}), Wd || (Wd = yI(n)), Wd } let Kd; function bI() { const n = Qt(), e = f1(); let t = !1; function r() { const o = n.navigator.userAgent.toLowerCase(); return o.indexOf("safari") >= 0 && o.indexOf("chrome") < 0 && o.indexOf("android") < 0 } if (r()) { const o = String(n.navigator.userAgent); if (o.includes("Version/")) { const [c, u] = o.split("Version/")[1].split(" ")[0].split(".").map(f => Number(f)); t = c < 16 || c === 16 && u < 2 } } const s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent), i = r(), a = i || s && e.ios; return { isSafari: t || i, needPerspectiveFix: t, need3dFix: a, isWebView: s } } function h1() { return Kd || (Kd = bI()), Kd } function wI(n) { let { swiper: e, on: t, emit: r } = n; const s = Qt(); let i = null, a = null; const o = () => { !e || e.destroyed || !e.initialized || (r("beforeResize"), r("resize")) }, c = () => { !e || e.destroyed || !e.initialized || (i = new ResizeObserver(h => { a = s.requestAnimationFrame(() => { const { width: p, height: v } = e; let g = p, y = v; h.forEach(w => { let { contentBoxSize: T, contentRect: S, target: E } = w; E && E !== e.el || (g = S ? S.width : (T[0] || T).inlineSize, y = S ? S.height : (T[0] || T).blockSize) }), (g !== p || y !== v) && o() }) }), i.observe(e.el)) }, u = () => { a && s.cancelAnimationFrame(a), i && i.unobserve && e.el && (i.unobserve(e.el), i = null) }, f = () => { !e || e.destroyed || !e.initialized || r("orientationchange") }; t("init", () => { if (e.params.resizeObserver && typeof s.ResizeObserver < "u") { c(); return } s.addEventListener("resize", o), s.addEventListener("orientationchange", f) }), t("destroy", () => { u(), s.removeEventListener("resize", o), s.removeEventListener("orientationchange", f) }) } function SI(n) { let { swiper: e, extendParams: t, on: r, emit: s } = n; const i = [], a = Qt(), o = function (f, h) { h === void 0 && (h = {}); const p = a.MutationObserver || a.WebkitMutationObserver, v = new p(g => { if (e.__preventObserver__) return; if (g.length === 1) { s("observerUpdate", g[0]); return } const y = function () { s("observerUpdate", g[0]) }; a.requestAnimationFrame ? a.requestAnimationFrame(y) : a.setTimeout(y, 0) }); v.observe(f, { attributes: typeof h.attributes > "u" ? !0 : h.attributes, childList: e.isElement || (typeof h.childList > "u" ? !0 : h).childList, characterData: typeof h.characterData > "u" ? !0 : h.characterData }), i.push(v) }, c = () => { if (e.params.observer) { if (e.params.observeParents) { const f = u1(e.hostEl); for (let h = 0; h < f.length; h += 1)o(f[h]) } o(e.hostEl, { childList: e.params.observeSlideChildren }), o(e.wrapperEl, { attributes: !1 }) } }, u = () => { i.forEach(f => { f.disconnect() }), i.splice(0, i.length) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), r("init", c), r("destroy", u) } var EI = { on(n, e, t) { const r = this; if (!r.eventsListeners || r.destroyed || typeof e != "function") return r; const s = t ? "unshift" : "push"; return n.split(" ").forEach(i => { r.eventsListeners[i] || (r.eventsListeners[i] = []), r.eventsListeners[i][s](e) }), r }, once(n, e, t) { const r = this; if (!r.eventsListeners || r.destroyed || typeof e != "function") return r; function s() { r.off(n, s), s.__emitterProxy && delete s.__emitterProxy; for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++)a[o] = arguments[o]; e.apply(r, a) } return s.__emitterProxy = e, r.on(n, s, t) }, onAny(n, e) { const t = this; if (!t.eventsListeners || t.destroyed || typeof n != "function") return t; const r = e ? "unshift" : "push"; return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[r](n), t }, offAny(n) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e; const t = e.eventsAnyListeners.indexOf(n); return t >= 0 && e.eventsAnyListeners.splice(t, 1), e }, off(n, e) { const t = this; return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach(r => { typeof e > "u" ? t.eventsListeners[r] = [] : t.eventsListeners[r] && t.eventsListeners[r].forEach((s, i) => { (s === e || s.__emitterProxy && s.__emitterProxy === e) && t.eventsListeners[r].splice(i, 1) }) }), t }, emit() { const n = this; if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n; let e, t, r; for (var s = arguments.length, i = new Array(s), a = 0; a < s; a++)i[a] = arguments[a]; return typeof i[0] == "string" || Array.isArray(i[0]) ? (e = i[0], t = i.slice(1, i.length), r = n) : (e = i[0].events, t = i[0].data, r = i[0].context || n), t.unshift(r), (Array.isArray(e) ? e : e.split(" ")).forEach(c => { n.eventsAnyListeners && n.eventsAnyListeners.length && n.eventsAnyListeners.forEach(u => { u.apply(r, [c, ...t]) }), n.eventsListeners && n.eventsListeners[c] && n.eventsListeners[c].forEach(u => { u.apply(r, t) }) }), n } }; function TI() { const n = this; let e, t; const r = n.el; typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = r.clientWidth, typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = r.clientHeight, !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(ps(r, "padding-left") || 0, 10) - parseInt(ps(r, "padding-right") || 0, 10), t = t - parseInt(ps(r, "padding-top") || 0, 10) - parseInt(ps(r, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, { width: e, height: t, size: n.isHorizontal() ? e : t })) } function AI() { const n = this; function e(_, M) { return parseFloat(_.getPropertyValue(n.getDirectionLabel(M)) || 0) } const t = n.params, { wrapperEl: r, slidesEl: s, size: i, rtlTranslate: a, wrongRTL: o } = n, c = n.virtual && t.virtual.enabled, u = c ? n.virtual.slides.length : n.slides.length, f = an(s, `.${n.params.slideClass}, swiper-slide`), h = c ? n.virtual.slides.length : f.length; let p = []; const v = [], g = []; let y = t.slidesOffsetBefore; typeof y == "function" && (y = t.slidesOffsetBefore.call(n)); let w = t.slidesOffsetAfter; typeof w == "function" && (w = t.slidesOffsetAfter.call(n)); const T = n.snapGrid.length, S = n.slidesGrid.length; let E = t.spaceBetween, I = -y, C = 0, D = 0; if (typeof i > "u") return; typeof E == "string" && E.indexOf("%") >= 0 ? E = parseFloat(E.replace("%", "")) / 100 * i : typeof E == "string" && (E = parseFloat(E)), n.virtualSize = -E, f.forEach(_ => { a ? _.style.marginLeft = "" : _.style.marginRight = "", _.style.marginBottom = "", _.style.marginTop = "" }), t.centeredSlides && t.cssMode && (Cl(r, "--swiper-centered-offset-before", ""), Cl(r, "--swiper-centered-offset-after", "")); const R = t.grid && t.grid.rows > 1 && n.grid; R ? n.grid.initSlides(f) : n.grid && n.grid.unsetSlides(); let N; const P = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter(_ => typeof t.breakpoints[_].slidesPerView < "u").length > 0; for (let _ = 0; _ < h; _ += 1) { N = 0; let M; if (f[_] && (M = f[_]), R && n.grid.updateSlide(_, M, f), !(f[_] && ps(M, "display") === "none")) { if (t.slidesPerView === "auto") { P && (f[_].style[n.getDirectionLabel("width")] = ""); const $ = getComputedStyle(M), B = M.style.transform, V = M.style.webkitTransform; if (B && (M.style.transform = "none"), V && (M.style.webkitTransform = "none"), t.roundLengths) N = n.isHorizontal() ? Gf(M, "width") : Gf(M, "height"); else { const W = e($, "width"), U = e($, "padding-left"), q = e($, "padding-right"), z = e($, "margin-left"), X = e($, "margin-right"), Z = $.getPropertyValue("box-sizing"); if (Z && Z === "border-box") N = W + z + X; else { const { clientWidth: F, offsetWidth: H } = M; N = W + U + q + z + X + (H - F) } } B && (M.style.transform = B), V && (M.style.webkitTransform = V), t.roundLengths && (N = Math.floor(N)) } else N = (i - (t.slidesPerView - 1) * E) / t.slidesPerView, t.roundLengths && (N = Math.floor(N)), f[_] && (f[_].style[n.getDirectionLabel("width")] = `${N}px`); f[_] && (f[_].swiperSlideSize = N), g.push(N), t.centeredSlides ? (I = I + N / 2 + C / 2 + E, C === 0 && _ !== 0 && (I = I - i / 2 - E), _ === 0 && (I = I - i / 2 - E), Math.abs(I) < 1 / 1e3 && (I = 0), t.roundLengths && (I = Math.floor(I)), D % t.slidesPerGroup === 0 && p.push(I), v.push(I)) : (t.roundLengths && (I = Math.floor(I)), (D - Math.min(n.params.slidesPerGroupSkip, D)) % n.params.slidesPerGroup === 0 && p.push(I), v.push(I), I = I + N + E), n.virtualSize += N + E, C = N, D += 1 } } if (n.virtualSize = Math.max(n.virtualSize, i) + w, a && o && (t.effect === "slide" || t.effect === "coverflow") && (r.style.width = `${n.virtualSize + E}px`), t.setWrapperSize && (r.style[n.getDirectionLabel("width")] = `${n.virtualSize + E}px`), R && n.grid.updateWrapperSize(N, p), !t.centeredSlides) { const _ = []; for (let M = 0; M < p.length; M += 1) { let $ = p[M]; t.roundLengths && ($ = Math.floor($)), p[M] <= n.virtualSize - i && _.push($) } p = _, Math.floor(n.virtualSize - i) - Math.floor(p[p.length - 1]) > 1 && p.push(n.virtualSize - i) } if (c && t.loop) { const _ = g[0] + E; if (t.slidesPerGroup > 1) { const M = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / t.slidesPerGroup), $ = _ * t.slidesPerGroup; for (let B = 0; B < M; B += 1)p.push(p[p.length - 1] + $) } for (let M = 0; M < n.virtual.slidesBefore + n.virtual.slidesAfter; M += 1)t.slidesPerGroup === 1 && p.push(p[p.length - 1] + _), v.push(v[v.length - 1] + _), n.virtualSize += _ } if (p.length === 0 && (p = [0]), E !== 0) { const _ = n.isHorizontal() && a ? "marginLeft" : n.getDirectionLabel("marginRight"); f.filter((M, $) => !t.cssMode || t.loop ? !0 : $ !== f.length - 1).forEach(M => { M.style[_] = `${E}px` }) } if (t.centeredSlides && t.centeredSlidesBounds) { let _ = 0; g.forEach($ => { _ += $ + (E || 0) }), _ -= E; const M = _ > i ? _ - i : 0; p = p.map($ => $ <= 0 ? -y : $ > M ? M + w : $) } if (t.centerInsufficientSlides) { let _ = 0; g.forEach($ => { _ += $ + (E || 0) }), _ -= E; const M = (t.slidesOffsetBefore || 0) + (t.slidesOffsetAfter || 0); if (_ + M < i) { const $ = (i - _ - M) / 2; p.forEach((B, V) => { p[V] = B - $ }), v.forEach((B, V) => { v[V] = B + $ }) } } if (Object.assign(n, { slides: f, snapGrid: p, slidesGrid: v, slidesSizesGrid: g }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) { Cl(r, "--swiper-centered-offset-before", `${-p[0]}px`), Cl(r, "--swiper-centered-offset-after", `${n.size / 2 - g[g.length - 1] / 2}px`); const _ = -n.snapGrid[0], M = -n.slidesGrid[0]; n.snapGrid = n.snapGrid.map($ => $ + _), n.slidesGrid = n.slidesGrid.map($ => $ + M) } if (h !== u && n.emit("slidesLengthChange"), p.length !== T && (n.params.watchOverflow && n.checkOverflow(), n.emit("snapGridLengthChange")), v.length !== S && n.emit("slidesGridLengthChange"), t.watchSlidesProgress && n.updateSlidesOffset(), n.emit("slidesUpdated"), !c && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) { const _ = `${t.containerModifierClass}backface-hidden`, M = n.el.classList.contains(_); h <= t.maxBackfaceHiddenSlides ? M || n.el.classList.add(_) : M && n.el.classList.remove(_) } } function II(n) { const e = this, t = [], r = e.virtual && e.params.virtual.enabled; let s = 0, i; typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed); const a = o => r ? e.slides[e.getSlideIndexByData(o)] : e.slides[o]; if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides) (e.visibleSlides || []).forEach(o => { t.push(o) }); else for (i = 0; i < Math.ceil(e.params.slidesPerView); i += 1) { const o = e.activeIndex + i; if (o > e.slides.length && !r) break; t.push(a(o)) } else t.push(a(e.activeIndex)); for (i = 0; i < t.length; i += 1)if (typeof t[i] < "u") { const o = t[i].offsetHeight; s = o > s ? o : s } (s || s === 0) && (e.wrapperEl.style.height = `${s}px`) } function LI() { const n = this, e = n.slides, t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0; for (let r = 0; r < e.length; r += 1)e[r].swiperSlideOffset = (n.isHorizontal() ? e[r].offsetLeft : e[r].offsetTop) - t - n.cssOverflowAdjustment() } const nx = (n, e, t) => { e && !n.classList.contains(t) ? n.classList.add(t) : !e && n.classList.contains(t) && n.classList.remove(t) }; function CI(n) { n === void 0 && (n = this && this.translate || 0); const e = this, t = e.params, { slides: r, rtlTranslate: s, snapGrid: i } = e; if (r.length === 0) return; typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset(); let a = -n; s && (a = n), e.visibleSlidesIndexes = [], e.visibleSlides = []; let o = t.spaceBetween; typeof o == "string" && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : typeof o == "string" && (o = parseFloat(o)); for (let c = 0; c < r.length; c += 1) { const u = r[c]; let f = u.swiperSlideOffset; t.cssMode && t.centeredSlides && (f -= r[0].swiperSlideOffset); const h = (a + (t.centeredSlides ? e.minTranslate() : 0) - f) / (u.swiperSlideSize + o), p = (a - i[0] + (t.centeredSlides ? e.minTranslate() : 0) - f) / (u.swiperSlideSize + o), v = -(a - f), g = v + e.slidesSizesGrid[c], y = v >= 0 && v <= e.size - e.slidesSizesGrid[c], w = v >= 0 && v < e.size - 1 || g > 1 && g <= e.size || v <= 0 && g >= e.size; w && (e.visibleSlides.push(u), e.visibleSlidesIndexes.push(c)), nx(u, w, t.slideVisibleClass), nx(u, y, t.slideFullyVisibleClass), u.progress = s ? -h : h, u.originalProgress = s ? -p : p } } function kI(n) { const e = this; if (typeof n > "u") { const f = e.rtlTranslate ? -1 : 1; n = e && e.translate && e.translate * f || 0 } const t = e.params, r = e.maxTranslate() - e.minTranslate(); let { progress: s, isBeginning: i, isEnd: a, progressLoop: o } = e; const c = i, u = a; if (r === 0) s = 0, i = !0, a = !0; else { s = (n - e.minTranslate()) / r; const f = Math.abs(n - e.minTranslate()) < 1, h = Math.abs(n - e.maxTranslate()) < 1; i = f || s <= 0, a = h || s >= 1, f && (s = 0), h && (s = 1) } if (t.loop) { const f = e.getSlideIndexByData(0), h = e.getSlideIndexByData(e.slides.length - 1), p = e.slidesGrid[f], v = e.slidesGrid[h], g = e.slidesGrid[e.slidesGrid.length - 1], y = Math.abs(n); y >= p ? o = (y - p) / g : o = (y + g - v) / g, o > 1 && (o -= 1) } Object.assign(e, { progress: s, progressLoop: o, isBeginning: i, isEnd: a }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n), i && !c && e.emit("reachBeginning toEdge"), a && !u && e.emit("reachEnd toEdge"), (c && !i || u && !a) && e.emit("fromEdge"), e.emit("progress", s) } const qd = (n, e, t) => { e && !n.classList.contains(t) ? n.classList.add(t) : !e && n.classList.contains(t) && n.classList.remove(t) }; function RI() { const n = this, { slides: e, params: t, slidesEl: r, activeIndex: s } = n, i = n.virtual && t.virtual.enabled, a = n.grid && t.grid && t.grid.rows > 1, o = h => an(r, `.${t.slideClass}${h}, swiper-slide${h}`)[0]; let c, u, f; if (i) if (t.loop) { let h = s - n.virtual.slidesBefore; h < 0 && (h = n.virtual.slides.length + h), h >= n.virtual.slides.length && (h -= n.virtual.slides.length), c = o(`[data-swiper-slide-index="${h}"]`) } else c = o(`[data-swiper-slide-index="${s}"]`); else a ? (c = e.find(h => h.column === s), f = e.find(h => h.column === s + 1), u = e.find(h => h.column === s - 1)) : c = e[s]; c && (a || (f = gI(c, `.${t.slideClass}, swiper-slide`)[0], t.loop && !f && (f = e[0]), u = mI(c, `.${t.slideClass}, swiper-slide`)[0], t.loop && !u === 0 && (u = e[e.length - 1]))), e.forEach(h => { qd(h, h === c, t.slideActiveClass), qd(h, h === f, t.slideNextClass), qd(h, h === u, t.slidePrevClass) }), n.emitSlidesClasses() } const Ql = (n, e) => { if (!n || n.destroyed || !n.params) return; const t = () => n.isElement ? "swiper-slide" : `.${n.params.slideClass}`, r = e.closest(t()); if (r) { let s = r.querySelector(`.${n.params.lazyPreloaderClass}`); !s && n.isElement && (r.shadowRoot ? s = r.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { r.shadowRoot && (s = r.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`), s && s.remove()) })), s && s.remove() } }, Yd = (n, e) => { if (!n.slides[e]) return; const t = n.slides[e].querySelector('[loading="lazy"]'); t && t.removeAttribute("loading") }, Hf = n => { if (!n || n.destroyed || !n.params) return; let e = n.params.lazyPreloadPrevNext; const t = n.slides.length; if (!t || !e || e < 0) return; e = Math.min(e, t); const r = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(n.params.slidesPerView), s = n.activeIndex; if (n.params.grid && n.params.grid.rows > 1) { const a = s, o = [a - e]; o.push(...Array.from({ length: e }).map((c, u) => a + r + u)), n.slides.forEach((c, u) => { o.includes(c.column) && Yd(n, u) }); return } const i = s + r - 1; if (n.params.rewind || n.params.loop) for (let a = s - e; a <= i + e; a += 1) { const o = (a % t + t) % t; (o < s || o > i) && Yd(n, o) } else for (let a = Math.max(s - e, 0); a <= Math.min(i + e, t - 1); a += 1)a !== s && (a > i || a < s) && Yd(n, a) }; function _I(n) { const { slidesGrid: e, params: t } = n, r = n.rtlTranslate ? n.translate : -n.translate; let s; for (let i = 0; i < e.length; i += 1)typeof e[i + 1] < "u" ? r >= e[i] && r < e[i + 1] - (e[i + 1] - e[i]) / 2 ? s = i : r >= e[i] && r < e[i + 1] && (s = i + 1) : r >= e[i] && (s = i); return t.normalizeSlideIndex && (s < 0 || typeof s > "u") && (s = 0), s } function PI(n) { const e = this, t = e.rtlTranslate ? e.translate : -e.translate, { snapGrid: r, params: s, activeIndex: i, realIndex: a, snapIndex: o } = e; let c = n, u; const f = v => { let g = v - e.virtual.slidesBefore; return g < 0 && (g = e.virtual.slides.length + g), g >= e.virtual.slides.length && (g -= e.virtual.slides.length), g }; if (typeof c > "u" && (c = _I(e)), r.indexOf(t) >= 0) u = r.indexOf(t); else { const v = Math.min(s.slidesPerGroupSkip, c); u = v + Math.floor((c - v) / s.slidesPerGroup) } if (u >= r.length && (u = r.length - 1), c === i && !e.params.loop) { u !== o && (e.snapIndex = u, e.emit("snapIndexChange")); return } if (c === i && e.params.loop && e.virtual && e.params.virtual.enabled) { e.realIndex = f(c); return } const h = e.grid && s.grid && s.grid.rows > 1; let p; if (e.virtual && s.virtual.enabled && s.loop) p = f(c); else if (h) { const v = e.slides.find(y => y.column === c); let g = parseInt(v.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(g) && (g = Math.max(e.slides.indexOf(v), 0)), p = Math.floor(g / s.grid.rows) } else if (e.slides[c]) { const v = e.slides[c].getAttribute("data-swiper-slide-index"); v ? p = parseInt(v, 10) : p = c } else p = c; Object.assign(e, { previousSnapIndex: o, snapIndex: u, previousRealIndex: a, realIndex: p, previousIndex: i, activeIndex: c }), e.initialized && Hf(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (a !== p && e.emit("realIndexChange"), e.emit("slideChange")) } function NI(n, e) { const t = this, r = t.params; let s = n.closest(`.${r.slideClass}, swiper-slide`); !s && t.isElement && e && e.length > 1 && e.includes(n) && [...e.slice(e.indexOf(n) + 1, e.length)].forEach(o => { !s && o.matches && o.matches(`.${r.slideClass}, swiper-slide`) && (s = o) }); let i = !1, a; if (s) { for (let o = 0; o < t.slides.length; o += 1)if (t.slides[o] === s) { i = !0, a = o; break } } if (s && i) t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(s.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = a; else { t.clickedSlide = void 0, t.clickedIndex = void 0; return } r.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } var DI = { updateSize: TI, updateSlides: AI, updateAutoHeight: II, updateSlidesOffset: LI, updateSlidesProgress: CI, updateProgress: kI, updateSlidesClasses: RI, updateActiveIndex: PI, updateClickedSlide: NI }; function OI(n) { n === void 0 && (n = this.isHorizontal() ? "x" : "y"); const e = this, { params: t, rtlTranslate: r, translate: s, wrapperEl: i } = e; if (t.virtualTranslate) return r ? -s : s; if (t.cssMode) return s; let a = dI(i, n); return a += e.cssOverflowAdjustment(), r && (a = -a), a || 0 } function MI(n, e) { const t = this, { rtlTranslate: r, params: s, wrapperEl: i, progress: a } = t; let o = 0, c = 0; const u = 0; t.isHorizontal() ? o = r ? -n : n : c = n, s.roundLengths && (o = Math.floor(o), c = Math.floor(c)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? o : c, s.cssMode ? i[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -o : -c : s.virtualTranslate || (t.isHorizontal() ? o -= t.cssOverflowAdjustment() : c -= t.cssOverflowAdjustment(), i.style.transform = `translate3d(${o}px, ${c}px, ${u}px)`); let f; const h = t.maxTranslate() - t.minTranslate(); h === 0 ? f = 0 : f = (n - t.minTranslate()) / h, f !== a && t.updateProgress(n), t.emit("setTranslate", t.translate, e) } function jI() { return -this.snapGrid[0] } function FI() { return -this.snapGrid[this.snapGrid.length - 1] } function $I(n, e, t, r, s) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), r === void 0 && (r = !0); const i = this, { params: a, wrapperEl: o } = i; if (i.animating && a.preventInteractionOnTransition) return !1; const c = i.minTranslate(), u = i.maxTranslate(); let f; if (r && n > c ? f = c : r && n < u ? f = u : f = n, i.updateProgress(f), a.cssMode) { const h = i.isHorizontal(); if (e === 0) o[h ? "scrollLeft" : "scrollTop"] = -f; else { if (!i.support.smoothScroll) return l1({ swiper: i, targetPosition: -f, side: h ? "left" : "top" }), !0; o.scrollTo({ [h ? "left" : "top"]: -f, behavior: "smooth" }) } return !0 } return e === 0 ? (i.setTransition(0), i.setTranslate(f), t && (i.emit("beforeTransitionStart", e, s), i.emit("transitionEnd"))) : (i.setTransition(e), i.setTranslate(f), t && (i.emit("beforeTransitionStart", e, s), i.emit("transitionStart")), i.animating || (i.animating = !0, i.onTranslateToWrapperTransitionEnd || (i.onTranslateToWrapperTransitionEnd = function (p) { !i || i.destroyed || p.target === this && (i.wrapperEl.removeEventListener("transitionend", i.onTranslateToWrapperTransitionEnd), i.onTranslateToWrapperTransitionEnd = null, delete i.onTranslateToWrapperTransitionEnd, i.animating = !1, t && i.emit("transitionEnd")) }), i.wrapperEl.addEventListener("transitionend", i.onTranslateToWrapperTransitionEnd))), !0 } var BI = { getTranslate: OI, setTranslate: MI, minTranslate: jI, maxTranslate: FI, translateTo: $I }; function UI(n, e) { const t = this; t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`, t.wrapperEl.style.transitionDelay = n === 0 ? "0ms" : ""), t.emit("setTransition", n, e) } function p1(n) { let { swiper: e, runCallbacks: t, direction: r, step: s } = n; const { activeIndex: i, previousIndex: a } = e; let o = r; o || (i > a ? o = "next" : i < a ? o = "prev" : o = "reset"), e.emit(`transition${s}`), t && o === "reset" ? e.emit(`slideResetTransition${s}`) : t && i !== a && (e.emit(`slideChangeTransition${s}`), o === "next" ? e.emit(`slideNextTransition${s}`) : e.emit(`slidePrevTransition${s}`)) } function zI(n, e) { n === void 0 && (n = !0); const t = this, { params: r } = t; r.cssMode || (r.autoHeight && t.updateAutoHeight(), p1({ swiper: t, runCallbacks: n, direction: e, step: "Start" })) } function VI(n, e) { n === void 0 && (n = !0); const t = this, { params: r } = t; t.animating = !1, !r.cssMode && (t.setTransition(0), p1({ swiper: t, runCallbacks: n, direction: e, step: "End" })) } var GI = { setTransition: UI, transitionStart: zI, transitionEnd: VI }; function HI(n, e, t, r, s) { n === void 0 && (n = 0), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10)); const i = this; let a = n; a < 0 && (a = 0); const { params: o, snapGrid: c, slidesGrid: u, previousIndex: f, activeIndex: h, rtlTranslate: p, wrapperEl: v, enabled: g } = i; if (!g && !r && !s || i.destroyed || i.animating && o.preventInteractionOnTransition) return !1; typeof e > "u" && (e = i.params.speed); const y = Math.min(i.params.slidesPerGroupSkip, a); let w = y + Math.floor((a - y) / i.params.slidesPerGroup); w >= c.length && (w = c.length - 1); const T = -c[w]; if (o.normalizeSlideIndex) for (let R = 0; R < u.length; R += 1) { const N = -Math.floor(T * 100), P = Math.floor(u[R] * 100), _ = Math.floor(u[R + 1] * 100); typeof u[R + 1] < "u" ? N >= P && N < _ - (_ - P) / 2 ? a = R : N >= P && N < _ && (a = R + 1) : N >= P && (a = R) } if (i.initialized && a !== h && (!i.allowSlideNext && (p ? T > i.translate && T > i.minTranslate() : T < i.translate && T < i.minTranslate()) || !i.allowSlidePrev && T > i.translate && T > i.maxTranslate() && (h || 0) !== a)) return !1; a !== (f || 0) && t && i.emit("beforeSlideChangeStart"), i.updateProgress(T); let S; a > h ? S = "next" : a < h ? S = "prev" : S = "reset"; const E = i.virtual && i.params.virtual.enabled; if (!(E && s) && (p && -T === i.translate || !p && T === i.translate)) return i.updateActiveIndex(a), o.autoHeight && i.updateAutoHeight(), i.updateSlidesClasses(), o.effect !== "slide" && i.setTranslate(T), S !== "reset" && (i.transitionStart(t, S), i.transitionEnd(t, S)), !1; if (o.cssMode) { const R = i.isHorizontal(), N = p ? T : -T; if (e === 0) E && (i.wrapperEl.style.scrollSnapType = "none", i._immediateVirtual = !0), E && !i._cssModeVirtualInitialSet && i.params.initialSlide > 0 ? (i._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { v[R ? "scrollLeft" : "scrollTop"] = N })) : v[R ? "scrollLeft" : "scrollTop"] = N, E && requestAnimationFrame(() => { i.wrapperEl.style.scrollSnapType = "", i._immediateVirtual = !1 }); else { if (!i.support.smoothScroll) return l1({ swiper: i, targetPosition: N, side: R ? "left" : "top" }), !0; v.scrollTo({ [R ? "left" : "top"]: N, behavior: "smooth" }) } return !0 } const D = h1().isSafari; return E && !s && D && i.isElement && i.virtual.update(!1, !1, a), i.setTransition(e), i.setTranslate(T), i.updateActiveIndex(a), i.updateSlidesClasses(), i.emit("beforeTransitionStart", e, r), i.transitionStart(t, S), e === 0 ? i.transitionEnd(t, S) : i.animating || (i.animating = !0, i.onSlideToWrapperTransitionEnd || (i.onSlideToWrapperTransitionEnd = function (N) { !i || i.destroyed || N.target === this && (i.wrapperEl.removeEventListener("transitionend", i.onSlideToWrapperTransitionEnd), i.onSlideToWrapperTransitionEnd = null, delete i.onSlideToWrapperTransitionEnd, i.transitionEnd(t, S)) }), i.wrapperEl.addEventListener("transitionend", i.onSlideToWrapperTransitionEnd)), !0 } function WI(n, e, t, r) { n === void 0 && (n = 0), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10)); const s = this; if (s.destroyed) return; typeof e > "u" && (e = s.params.speed); const i = s.grid && s.params.grid && s.params.grid.rows > 1; let a = n; if (s.params.loop) if (s.virtual && s.params.virtual.enabled) a = a + s.virtual.slidesBefore; else { let o; if (i) { const p = a * s.params.grid.rows; o = s.slides.find(v => v.getAttribute("data-swiper-slide-index") * 1 === p).column } else o = s.getSlideIndexByData(a); const c = i ? Math.ceil(s.slides.length / s.params.grid.rows) : s.slides.length, { centeredSlides: u } = s.params; let f = s.params.slidesPerView; f === "auto" ? f = s.slidesPerViewDynamic() : (f = Math.ceil(parseFloat(s.params.slidesPerView, 10)), u && f % 2 === 0 && (f = f + 1)); let h = c - o < f; if (u && (h = h || o < Math.ceil(f / 2)), r && u && s.params.slidesPerView !== "auto" && !i && (h = !1), h) { const p = u ? o < s.activeIndex ? "prev" : "next" : o - s.activeIndex - 1 < s.params.slidesPerView ? "next" : "prev"; s.loopFix({ direction: p, slideTo: !0, activeSlideIndex: p === "next" ? o + 1 : o - c + 1, slideRealIndex: p === "next" ? s.realIndex : void 0 }) } if (i) { const p = a * s.params.grid.rows; a = s.slides.find(v => v.getAttribute("data-swiper-slide-index") * 1 === p).column } else a = s.getSlideIndexByData(a) } return requestAnimationFrame(() => { s.slideTo(a, e, t, r) }), s } function KI(n, e, t) { e === void 0 && (e = !0); const r = this, { enabled: s, params: i, animating: a } = r; if (!s || r.destroyed) return r; typeof n > "u" && (n = r.params.speed); let o = i.slidesPerGroup; i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (o = Math.max(r.slidesPerViewDynamic("current", !0), 1)); const c = r.activeIndex < i.slidesPerGroupSkip ? 1 : o, u = r.virtual && i.virtual.enabled; if (i.loop) { if (a && !u && i.loopPreventsSliding) return !1; if (r.loopFix({ direction: "next" }), r._clientLeft = r.wrapperEl.clientLeft, r.activeIndex === r.slides.length - 1 && i.cssMode) return requestAnimationFrame(() => { r.slideTo(r.activeIndex + c, n, e, t) }), !0 } return i.rewind && r.isEnd ? r.slideTo(0, n, e, t) : r.slideTo(r.activeIndex + c, n, e, t) } function qI(n, e, t) { e === void 0 && (e = !0); const r = this, { params: s, snapGrid: i, slidesGrid: a, rtlTranslate: o, enabled: c, animating: u } = r; if (!c || r.destroyed) return r; typeof n > "u" && (n = r.params.speed); const f = r.virtual && s.virtual.enabled; if (s.loop) { if (u && !f && s.loopPreventsSliding) return !1; r.loopFix({ direction: "prev" }), r._clientLeft = r.wrapperEl.clientLeft } const h = o ? r.translate : -r.translate; function p(S) { return S < 0 ? -Math.floor(Math.abs(S)) : Math.floor(S) } const v = p(h), g = i.map(S => p(S)), y = s.freeMode && s.freeMode.enabled; let w = i[g.indexOf(v) - 1]; if (typeof w > "u" && (s.cssMode || y)) { let S; i.forEach((E, I) => { v >= E && (S = I) }), typeof S < "u" && (w = y ? i[S] : i[S > 0 ? S - 1 : S]) } let T = 0; if (typeof w < "u" && (T = a.indexOf(w), T < 0 && (T = r.activeIndex - 1), s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (T = T - r.slidesPerViewDynamic("previous", !0) + 1, T = Math.max(T, 0))), s.rewind && r.isBeginning) { const S = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1; return r.slideTo(S, n, e, t) } else if (s.loop && r.activeIndex === 0 && s.cssMode) return requestAnimationFrame(() => { r.slideTo(T, n, e, t) }), !0; return r.slideTo(T, n, e, t) } function YI(n, e, t) { e === void 0 && (e = !0); const r = this; if (!r.destroyed) return typeof n > "u" && (n = r.params.speed), r.slideTo(r.activeIndex, n, e, t) } function XI(n, e, t, r) { e === void 0 && (e = !0), r === void 0 && (r = .5); const s = this; if (s.destroyed) return; typeof n > "u" && (n = s.params.speed); let i = s.activeIndex; const a = Math.min(s.params.slidesPerGroupSkip, i), o = a + Math.floor((i - a) / s.params.slidesPerGroup), c = s.rtlTranslate ? s.translate : -s.translate; if (c >= s.snapGrid[o]) { const u = s.snapGrid[o], f = s.snapGrid[o + 1]; c - u > (f - u) * r && (i += s.params.slidesPerGroup) } else { const u = s.snapGrid[o - 1], f = s.snapGrid[o]; c - u <= (f - u) * r && (i -= s.params.slidesPerGroup) } return i = Math.max(i, 0), i = Math.min(i, s.slidesGrid.length - 1), s.slideTo(i, n, e, t) } function QI() { const n = this; if (n.destroyed) return; const { params: e, slidesEl: t } = n, r = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView; let s = n.getSlideIndexWhenGrid(n.clickedIndex), i; const a = n.isElement ? "swiper-slide" : `.${e.slideClass}`, o = n.grid && n.params.grid && n.params.grid.rows > 1; if (e.loop) { if (n.animating) return; i = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? n.slideToLoop(i) : s > (o ? (n.slides.length - r) / 2 - (n.params.grid.rows - 1) : n.slides.length - r) ? (n.loopFix(), s = n.getSlideIndex(an(t, `${a}[data-swiper-slide-index="${i}"]`)[0]), o1(() => { n.slideTo(s) })) : n.slideTo(s) } else n.slideTo(s) } var ZI = { slideTo: HI, slideToLoop: WI, slideNext: KI, slidePrev: qI, slideReset: YI, slideToClosest: XI, slideToClickedSlide: QI }; function JI(n, e) { const t = this, { params: r, slidesEl: s } = t; if (!r.loop || t.virtual && t.params.virtual.enabled) return; const i = () => { an(s, `.${r.slideClass}, swiper-slide`).forEach((v, g) => { v.setAttribute("data-swiper-slide-index", g) }) }, a = () => { const p = an(s, `.${r.slideBlankClass}`); p.forEach(v => { v.remove() }), p.length > 0 && (t.recalcSlides(), t.updateSlides()) }, o = t.grid && r.grid && r.grid.rows > 1; r.loopAddBlankSlides && (r.slidesPerGroup > 1 || o) && a(); const c = r.slidesPerGroup * (o ? r.grid.rows : 1), u = t.slides.length % c !== 0, f = o && t.slides.length % r.grid.rows !== 0, h = p => { for (let v = 0; v < p; v += 1) { const g = t.isElement ? hc("swiper-slide", [r.slideBlankClass]) : hc("div", [r.slideClass, r.slideBlankClass]); t.slidesEl.append(g) } }; if (u) { if (r.loopAddBlankSlides) { const p = c - t.slides.length % c; h(p), t.recalcSlides(), t.updateSlides() } else fc("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else if (f) { if (r.loopAddBlankSlides) { const p = r.grid.rows - t.slides.length % r.grid.rows; h(p), t.recalcSlides(), t.updateSlides() } else fc("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else i(); t.loopFix({ slideRealIndex: n, direction: r.centeredSlides ? void 0 : "next", initial: e }) } function e3(n) { let { slideRealIndex: e, slideTo: t = !0, direction: r, setTranslate: s, activeSlideIndex: i, initial: a, byController: o, byMousewheel: c } = n === void 0 ? {} : n; const u = this; if (!u.params.loop) return; u.emit("beforeLoopFix"); const { slides: f, allowSlidePrev: h, allowSlideNext: p, slidesEl: v, params: g } = u, { centeredSlides: y, initialSlide: w } = g; if (u.allowSlidePrev = !0, u.allowSlideNext = !0, u.virtual && g.virtual.enabled) { t && (!g.centeredSlides && u.snapIndex === 0 ? u.slideTo(u.virtual.slides.length, 0, !1, !0) : g.centeredSlides && u.snapIndex < g.slidesPerView ? u.slideTo(u.virtual.slides.length + u.snapIndex, 0, !1, !0) : u.snapIndex === u.snapGrid.length - 1 && u.slideTo(u.virtual.slidesBefore, 0, !1, !0)), u.allowSlidePrev = h, u.allowSlideNext = p, u.emit("loopFix"); return } let T = g.slidesPerView; T === "auto" ? T = u.slidesPerViewDynamic() : (T = Math.ceil(parseFloat(g.slidesPerView, 10)), y && T % 2 === 0 && (T = T + 1)); const S = g.slidesPerGroupAuto ? T : g.slidesPerGroup; let E = y ? Math.max(S, Math.ceil(T / 2)) : S; E % S !== 0 && (E += S - E % S), E += g.loopAdditionalSlides, u.loopedSlides = E; const I = u.grid && g.grid && g.grid.rows > 1; f.length < T + E || u.params.effect === "cards" && f.length < T + E * 2 ? fc("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : I && g.grid.fill === "row" && fc("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const C = [], D = [], R = I ? Math.ceil(f.length / g.grid.rows) : f.length, N = a && R - w < T && !y; let P = N ? w : u.activeIndex; typeof i > "u" ? i = u.getSlideIndex(f.find(U => U.classList.contains(g.slideActiveClass))) : P = i; const _ = r === "next" || !r, M = r === "prev" || !r; let $ = 0, B = 0; const W = (I ? f[i].column : i) + (y && typeof s > "u" ? -T / 2 + .5 : 0); if (W < E) { $ = Math.max(E - W, S); for (let U = 0; U < E - W; U += 1) { const q = U - Math.floor(U / R) * R; if (I) { const z = R - q - 1; for (let X = f.length - 1; X >= 0; X -= 1)f[X].column === z && C.push(X) } else C.push(R - q - 1) } } else if (W + T > R - E) { B = Math.max(W - (R - E * 2), S), N && (B = Math.max(B, T - R + w + 1)); for (let U = 0; U < B; U += 1) { const q = U - Math.floor(U / R) * R; I ? f.forEach((z, X) => { z.column === q && D.push(X) }) : D.push(q) } } if (u.__preventObserver__ = !0, requestAnimationFrame(() => { u.__preventObserver__ = !1 }), u.params.effect === "cards" && f.length < T + E * 2 && (D.includes(i) && D.splice(D.indexOf(i), 1), C.includes(i) && C.splice(C.indexOf(i), 1)), M && C.forEach(U => { f[U].swiperLoopMoveDOM = !0, v.prepend(f[U]), f[U].swiperLoopMoveDOM = !1 }), _ && D.forEach(U => { f[U].swiperLoopMoveDOM = !0, v.append(f[U]), f[U].swiperLoopMoveDOM = !1 }), u.recalcSlides(), g.slidesPerView === "auto" ? u.updateSlides() : I && (C.length > 0 && M || D.length > 0 && _) && u.slides.forEach((U, q) => { u.grid.updateSlide(q, U, u.slides) }), g.watchSlidesProgress && u.updateSlidesOffset(), t) { if (C.length > 0 && M) { if (typeof e > "u") { const U = u.slidesGrid[P], z = u.slidesGrid[P + $] - U; c ? u.setTranslate(u.translate - z) : (u.slideTo(P + Math.ceil($), 0, !1, !0), s && (u.touchEventsData.startTranslate = u.touchEventsData.startTranslate - z, u.touchEventsData.currentTranslate = u.touchEventsData.currentTranslate - z)) } else if (s) { const U = I ? C.length / g.grid.rows : C.length; u.slideTo(u.activeIndex + U, 0, !1, !0), u.touchEventsData.currentTranslate = u.translate } } else if (D.length > 0 && _) if (typeof e > "u") { const U = u.slidesGrid[P], z = u.slidesGrid[P - B] - U; c ? u.setTranslate(u.translate - z) : (u.slideTo(P - B, 0, !1, !0), s && (u.touchEventsData.startTranslate = u.touchEventsData.startTranslate - z, u.touchEventsData.currentTranslate = u.touchEventsData.currentTranslate - z)) } else { const U = I ? D.length / g.grid.rows : D.length; u.slideTo(u.activeIndex - U, 0, !1, !0) } } if (u.allowSlidePrev = h, u.allowSlideNext = p, u.controller && u.controller.control && !o) { const U = { slideRealIndex: e, direction: r, setTranslate: s, activeSlideIndex: i, byController: !0 }; Array.isArray(u.controller.control) ? u.controller.control.forEach(q => { !q.destroyed && q.params.loop && q.loopFix({ ...U, slideTo: q.params.slidesPerView === g.slidesPerView ? t : !1 }) }) : u.controller.control instanceof u.constructor && u.controller.control.params.loop && u.controller.control.loopFix({ ...U, slideTo: u.controller.control.params.slidesPerView === g.slidesPerView ? t : !1 }) } u.emit("loopFix") } function t3() { const n = this, { params: e, slidesEl: t } = n; if (!e.loop || !t || n.virtual && n.params.virtual.enabled) return; n.recalcSlides(); const r = []; n.slides.forEach(s => { const i = typeof s.swiperSlideIndex > "u" ? s.getAttribute("data-swiper-slide-index") * 1 : s.swiperSlideIndex; r[i] = s }), n.slides.forEach(s => { s.removeAttribute("data-swiper-slide-index") }), r.forEach(s => { t.append(s) }), n.recalcSlides(), n.slideTo(n.realIndex, 0) } var r3 = { loopCreate: JI, loopFix: e3, loopDestroy: t3 }; function n3(n) { const e = this; if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = n ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 }) } function s3() { const n = this; n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0), n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", n.isElement && requestAnimationFrame(() => { n.__preventObserver__ = !1 })) } var i3 = { setGrabCursor: n3, unsetGrabCursor: s3 }; function a3(n, e) { e === void 0 && (e = this); function t(r) { if (!r || r === dn() || r === Qt()) return null; r.assignedSlot && (r = r.assignedSlot); const s = r.closest(n); return !s && !r.getRootNode ? null : s || t(r.getRootNode().host) } return t(e) } function sx(n, e, t) { const r = Qt(), { params: s } = n, i = s.edgeSwipeDetection, a = s.edgeSwipeThreshold; return i && (t <= a || t >= r.innerWidth - a) ? i === "prevent" ? (e.preventDefault(), !0) : !1 : !0 } function o3(n) { const e = this, t = dn(); let r = n; r.originalEvent && (r = r.originalEvent); const s = e.touchEventsData; if (r.type === "pointerdown") { if (s.pointerId !== null && s.pointerId !== r.pointerId) return; s.pointerId = r.pointerId } else r.type === "touchstart" && r.targetTouches.length === 1 && (s.touchId = r.targetTouches[0].identifier); if (r.type === "touchstart") { sx(e, r, r.targetTouches[0].pageX); return } const { params: i, touches: a, enabled: o } = e; if (!o || !i.simulateTouch && r.pointerType === "mouse" || e.animating && i.preventInteractionOnTransition) return; !e.animating && i.cssMode && i.loop && e.loopFix(); let c = r.target; if (i.touchEventsTarget === "wrapper" && !pI(c, e.wrapperEl) || "which" in r && r.which === 3 || "button" in r && r.button > 0 || s.isTouched && s.isMoved) return; const u = !!i.noSwipingClass && i.noSwipingClass !== "", f = r.composedPath ? r.composedPath() : r.path; u && r.target && r.target.shadowRoot && f && (c = f[0]); const h = i.noSwipingSelector ? i.noSwipingSelector : `.${i.noSwipingClass}`, p = !!(r.target && r.target.shadowRoot); if (i.noSwiping && (p ? a3(h, c) : c.closest(h))) { e.allowClick = !0; return } if (i.swipeHandler && !c.closest(i.swipeHandler)) return; a.currentX = r.pageX, a.currentY = r.pageY; const v = a.currentX, g = a.currentY; if (!sx(e, r, v)) return; Object.assign(s, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), a.startX = v, a.startY = g, s.touchStartTime = dc(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, i.threshold > 0 && (s.allowThresholdMove = !1); let y = !0; c.matches(s.focusableElements) && (y = !1, c.nodeName === "SELECT" && (s.isTouched = !1)), t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== c && (r.pointerType === "mouse" || r.pointerType !== "mouse" && !c.matches(s.focusableElements)) && t.activeElement.blur(); const w = y && e.allowTouchMove && i.touchStartPreventDefault; (i.touchStartForcePreventDefault || w) && !c.isContentEditable && r.preventDefault(), i.freeMode && i.freeMode.enabled && e.freeMode && e.animating && !i.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", r) } function l3(n) { const e = dn(), t = this, r = t.touchEventsData, { params: s, touches: i, rtlTranslate: a, enabled: o } = t; if (!o || !s.simulateTouch && n.pointerType === "mouse") return; let c = n; if (c.originalEvent && (c = c.originalEvent), c.type === "pointermove" && (r.touchId !== null || c.pointerId !== r.pointerId)) return; let u; if (c.type === "touchmove") { if (u = [...c.changedTouches].find(C => C.identifier === r.touchId), !u || u.identifier !== r.touchId) return } else u = c; if (!r.isTouched) { r.startMoving && r.isScrolling && t.emit("touchMoveOpposite", c); return } const f = u.pageX, h = u.pageY; if (c.preventedByNestedSwiper) { i.startX = f, i.startY = h; return } if (!t.allowTouchMove) { c.target.matches(r.focusableElements) || (t.allowClick = !1), r.isTouched && (Object.assign(i, { startX: f, startY: h, currentX: f, currentY: h }), r.touchStartTime = dc()); return } if (s.touchReleaseOnEdges && !s.loop) if (t.isVertical()) { if (h < i.startY && t.translate <= t.maxTranslate() || h > i.startY && t.translate >= t.minTranslate()) { r.isTouched = !1, r.isMoved = !1; return } } else { if (a && (f > i.startX && -t.translate <= t.maxTranslate() || f < i.startX && -t.translate >= t.minTranslate())) return; if (!a && (f < i.startX && t.translate <= t.maxTranslate() || f > i.startX && t.translate >= t.minTranslate())) return } if (e.activeElement && e.activeElement.matches(r.focusableElements) && e.activeElement !== c.target && c.pointerType !== "mouse" && e.activeElement.blur(), e.activeElement && c.target === e.activeElement && c.target.matches(r.focusableElements)) { r.isMoved = !0, t.allowClick = !1; return } r.allowTouchCallbacks && t.emit("touchMove", c), i.previousX = i.currentX, i.previousY = i.currentY, i.currentX = f, i.currentY = h; const p = i.currentX - i.startX, v = i.currentY - i.startY; if (t.params.threshold && Math.sqrt(p ** 2 + v ** 2) < t.params.threshold) return; if (typeof r.isScrolling > "u") { let C; t.isHorizontal() && i.currentY === i.startY || t.isVertical() && i.currentX === i.startX ? r.isScrolling = !1 : p * p + v * v >= 25 && (C = Math.atan2(Math.abs(v), Math.abs(p)) * 180 / Math.PI, r.isScrolling = t.isHorizontal() ? C > s.touchAngle : 90 - C > s.touchAngle) } if (r.isScrolling && t.emit("touchMoveOpposite", c), typeof r.startMoving > "u" && (i.currentX !== i.startX || i.currentY !== i.startY) && (r.startMoving = !0), r.isScrolling || c.type === "touchmove" && r.preventTouchMoveFromPointerMove) { r.isTouched = !1; return } if (!r.startMoving) return; t.allowClick = !1, !s.cssMode && c.cancelable && c.preventDefault(), s.touchMoveStopPropagation && !s.nested && c.stopPropagation(); let g = t.isHorizontal() ? p : v, y = t.isHorizontal() ? i.currentX - i.previousX : i.currentY - i.previousY; s.oneWayMovement && (g = Math.abs(g) * (a ? 1 : -1), y = Math.abs(y) * (a ? 1 : -1)), i.diff = g, g *= s.touchRatio, a && (g = -g, y = -y); const w = t.touchesDirection; t.swipeDirection = g > 0 ? "prev" : "next", t.touchesDirection = y > 0 ? "prev" : "next"; const T = t.params.loop && !s.cssMode, S = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev; if (!r.isMoved) { if (T && S && t.loopFix({ direction: t.swipeDirection }), r.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) { const C = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0, detail: { bySwiperTouchMove: !0 } }); t.wrapperEl.dispatchEvent(C) } r.allowMomentumBounce = !1, s.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", c) } if (new Date().getTime(), s._loopSwapReset !== !1 && r.isMoved && r.allowThresholdMove && w !== t.touchesDirection && T && S && Math.abs(g) >= 1) { Object.assign(i, { startX: f, startY: h, currentX: f, currentY: h, startTranslate: r.currentTranslate }), r.loopSwapReset = !0, r.startTranslate = r.currentTranslate; return } t.emit("sliderMove", c), r.isMoved = !0, r.currentTranslate = g + r.startTranslate; let E = !0, I = s.resistanceRatio; if (s.touchReleaseOnEdges && (I = 0), g > 0 ? (T && S && r.allowThresholdMove && r.currentTranslate > (s.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] - (s.slidesPerView !== "auto" && t.slides.length - s.slidesPerView >= 2 ? t.slidesSizesGrid[t.activeIndex + 1] + t.params.spaceBetween : 0) - t.params.spaceBetween : t.minTranslate()) && t.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > t.minTranslate() && (E = !1, s.resistance && (r.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + r.startTranslate + g) ** I))) : g < 0 && (T && S && r.allowThresholdMove && r.currentTranslate < (s.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] + t.params.spaceBetween + (s.slidesPerView !== "auto" && t.slides.length - s.slidesPerView >= 2 ? t.slidesSizesGrid[t.slidesSizesGrid.length - 1] + t.params.spaceBetween : 0) : t.maxTranslate()) && t.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: t.slides.length - (s.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(s.slidesPerView, 10))) }), r.currentTranslate < t.maxTranslate() && (E = !1, s.resistance && (r.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - r.startTranslate - g) ** I))), E && (c.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (r.currentTranslate = r.startTranslate), s.threshold > 0) if (Math.abs(g) > s.threshold || r.allowThresholdMove) { if (!r.allowThresholdMove) { r.allowThresholdMove = !0, i.startX = i.currentX, i.startY = i.currentY, r.currentTranslate = r.startTranslate, i.diff = t.isHorizontal() ? i.currentX - i.startX : i.currentY - i.startY; return } } else { r.currentTranslate = r.startTranslate; return } !s.followFinger || s.cssMode || ((s.freeMode && s.freeMode.enabled && t.freeMode || s.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), s.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(r.currentTranslate), t.setTranslate(r.currentTranslate)) } function c3(n) { const e = this, t = e.touchEventsData; let r = n; r.originalEvent && (r = r.originalEvent); let s; if (r.type === "touchend" || r.type === "touchcancel") { if (s = [...r.changedTouches].find(C => C.identifier === t.touchId), !s || s.identifier !== t.touchId) return } else { if (t.touchId !== null || r.pointerId !== t.pointerId) return; s = r } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && !(["pointercancel", "contextmenu"].includes(r.type) && (e.browser.isSafari || e.browser.isWebView))) return; t.pointerId = null, t.touchId = null; const { params: a, touches: o, rtlTranslate: c, slidesGrid: u, enabled: f } = e; if (!f || !a.simulateTouch && r.pointerType === "mouse") return; if (t.allowTouchCallbacks && e.emit("touchEnd", r), t.allowTouchCallbacks = !1, !t.isTouched) { t.isMoved && a.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1; return } a.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1); const h = dc(), p = h - t.touchStartTime; if (e.allowClick) { const C = r.path || r.composedPath && r.composedPath(); e.updateClickedSlide(C && C[0] || r.target, C), e.emit("tap click", r), p < 300 && h - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", r) } if (t.lastClickTime = dc(), o1(() => { e.destroyed || (e.allowClick = !0) }), !t.isTouched || !t.isMoved || !e.swipeDirection || o.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) { t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; return } t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; let v; if (a.followFinger ? v = c ? e.translate : -e.translate : v = -t.currentTranslate, a.cssMode) return; if (a.freeMode && a.freeMode.enabled) { e.freeMode.onTouchEnd({ currentPos: v }); return } const g = v >= -e.maxTranslate() && !e.params.loop; let y = 0, w = e.slidesSizesGrid[0]; for (let C = 0; C < u.length; C += C < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const D = C < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; typeof u[C + D] < "u" ? (g || v >= u[C] && v < u[C + D]) && (y = C, w = u[C + D] - u[C]) : (g || v >= u[C]) && (y = C, w = u[u.length - 1] - u[u.length - 2]) } let T = null, S = null; a.rewind && (e.isBeginning ? S = a.virtual && a.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (T = 0)); const E = (v - u[y]) / w, I = y < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (p > a.longSwipesMs) { if (!a.longSwipes) { e.slideTo(e.activeIndex); return } e.swipeDirection === "next" && (E >= a.longSwipesRatio ? e.slideTo(a.rewind && e.isEnd ? T : y + I) : e.slideTo(y)), e.swipeDirection === "prev" && (E > 1 - a.longSwipesRatio ? e.slideTo(y + I) : S !== null && E < 0 && Math.abs(E) > a.longSwipesRatio ? e.slideTo(S) : e.slideTo(y)) } else { if (!a.shortSwipes) { e.slideTo(e.activeIndex); return } e.navigation && (r.target === e.navigation.nextEl || r.target === e.navigation.prevEl) ? r.target === e.navigation.nextEl ? e.slideTo(y + I) : e.slideTo(y) : (e.swipeDirection === "next" && e.slideTo(T !== null ? T : y + I), e.swipeDirection === "prev" && e.slideTo(S !== null ? S : y)) } } function ix() { const n = this, { params: e, el: t } = n; if (t && t.offsetWidth === 0) return; e.breakpoints && n.setBreakpoint(); const { allowSlideNext: r, allowSlidePrev: s, snapGrid: i } = n, a = n.virtual && n.params.virtual.enabled; n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses(); const o = a && e.loop; (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !o ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !a ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(n.autoplay.resizeTimeout), n.autoplay.resizeTimeout = setTimeout(() => { n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume() }, 500)), n.allowSlidePrev = s, n.allowSlideNext = r, n.params.watchOverflow && i !== n.snapGrid && n.checkOverflow() } function u3(n) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(), e.params.preventClicksPropagation && e.animating && (n.stopPropagation(), n.stopImmediatePropagation()))) } function d3() { const n = this, { wrapperEl: e, rtlTranslate: t, enabled: r } = n; if (!r) return; n.previousTranslate = n.translate, n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop, n.translate === 0 && (n.translate = 0), n.updateActiveIndex(), n.updateSlidesClasses(); let s; const i = n.maxTranslate() - n.minTranslate(); i === 0 ? s = 0 : s = (n.translate - n.minTranslate()) / i, s !== n.progress && n.updateProgress(t ? -n.translate : n.translate), n.emit("setTranslate", n.translate, !1) } function f3(n) { const e = this; Ql(e, n.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update() } function h3() { const n = this; n.documentTouchHandlerProceeded || (n.documentTouchHandlerProceeded = !0, n.params.touchReleaseOnEdges && (n.el.style.touchAction = "auto")) } const m1 = (n, e) => { const t = dn(), { params: r, el: s, wrapperEl: i, device: a } = n, o = !!r.nested, c = e === "on" ? "addEventListener" : "removeEventListener", u = e; !s || typeof s == "string" || (t[c]("touchstart", n.onDocumentTouchStart, { passive: !1, capture: o }), s[c]("touchstart", n.onTouchStart, { passive: !1 }), s[c]("pointerdown", n.onTouchStart, { passive: !1 }), t[c]("touchmove", n.onTouchMove, { passive: !1, capture: o }), t[c]("pointermove", n.onTouchMove, { passive: !1, capture: o }), t[c]("touchend", n.onTouchEnd, { passive: !0 }), t[c]("pointerup", n.onTouchEnd, { passive: !0 }), t[c]("pointercancel", n.onTouchEnd, { passive: !0 }), t[c]("touchcancel", n.onTouchEnd, { passive: !0 }), t[c]("pointerout", n.onTouchEnd, { passive: !0 }), t[c]("pointerleave", n.onTouchEnd, { passive: !0 }), t[c]("contextmenu", n.onTouchEnd, { passive: !0 }), (r.preventClicks || r.preventClicksPropagation) && s[c]("click", n.onClick, !0), r.cssMode && i[c]("scroll", n.onScroll), r.updateOnWindowResize ? n[u](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", ix, !0) : n[u]("observerUpdate", ix, !0), s[c]("load", n.onLoad, { capture: !0 })) }; function p3() { const n = this, { params: e } = n; n.onTouchStart = o3.bind(n), n.onTouchMove = l3.bind(n), n.onTouchEnd = c3.bind(n), n.onDocumentTouchStart = h3.bind(n), e.cssMode && (n.onScroll = d3.bind(n)), n.onClick = u3.bind(n), n.onLoad = f3.bind(n), m1(n, "on") } function m3() { m1(this, "off") } var g3 = { attachEvents: p3, detachEvents: m3 }; const ax = (n, e) => n.grid && e.grid && e.grid.rows > 1; function x3() { const n = this, { realIndex: e, initialized: t, params: r, el: s } = n, i = r.breakpoints; if (!i || i && Object.keys(i).length === 0) return; const a = dn(), o = r.breakpointsBase === "window" || !r.breakpointsBase ? r.breakpointsBase : "container", c = ["window", "container"].includes(r.breakpointsBase) || !r.breakpointsBase ? n.el : a.querySelector(r.breakpointsBase), u = n.getBreakpoint(i, o, c); if (!u || n.currentBreakpoint === u) return; const h = (u in i ? i[u] : void 0) || n.originalParams, p = ax(n, r), v = ax(n, h), g = n.params.grabCursor, y = h.grabCursor, w = r.enabled; p && !v ? (s.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`), n.emitContainerClasses()) : !p && v && (s.classList.add(`${r.containerModifierClass}grid`), (h.grid.fill && h.grid.fill === "column" || !h.grid.fill && r.grid.fill === "column") && s.classList.add(`${r.containerModifierClass}grid-column`), n.emitContainerClasses()), g && !y ? n.unsetGrabCursor() : !g && y && n.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(D => { if (typeof h[D] > "u") return; const R = r[D] && r[D].enabled, N = h[D] && h[D].enabled; R && !N && n[D].disable(), !R && N && n[D].enable() }); const T = h.direction && h.direction !== r.direction, S = r.loop && (h.slidesPerView !== r.slidesPerView || T), E = r.loop; T && t && n.changeDirection(), yr(n.params, h); const I = n.params.enabled, C = n.params.loop; Object.assign(n, { allowTouchMove: n.params.allowTouchMove, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev }), w && !I ? n.disable() : !w && I && n.enable(), n.currentBreakpoint = u, n.emit("_beforeBreakpoint", h), t && (S ? (n.loopDestroy(), n.loopCreate(e), n.updateSlides()) : !E && C ? (n.loopCreate(e), n.updateSlides()) : E && !C && n.loopDestroy()), n.emit("breakpoint", h) } function v3(n, e, t) { if (e === void 0 && (e = "window"), !n || e === "container" && !t) return; let r = !1; const s = Qt(), i = e === "window" ? s.innerHeight : t.clientHeight, a = Object.keys(n).map(o => { if (typeof o == "string" && o.indexOf("@") === 0) { const c = parseFloat(o.substr(1)); return { value: i * c, point: o } } return { value: o, point: o } }); a.sort((o, c) => parseInt(o.value, 10) - parseInt(c.value, 10)); for (let o = 0; o < a.length; o += 1) { const { point: c, value: u } = a[o]; e === "window" ? s.matchMedia(`(min-width: ${u}px)`).matches && (r = c) : u <= t.clientWidth && (r = c) } return r || "max" } var y3 = { setBreakpoint: x3, getBreakpoint: v3 }; function b3(n, e) { const t = []; return n.forEach(r => { typeof r == "object" ? Object.keys(r).forEach(s => { r[s] && t.push(e + s) }) : typeof r == "string" && t.push(e + r) }), t } function w3() { const n = this, { classNames: e, params: t, rtl: r, el: s, device: i } = n, a = b3(["initialized", t.direction, { "free-mode": n.params.freeMode && t.freeMode.enabled }, { autoheight: t.autoHeight }, { rtl: r }, { grid: t.grid && t.grid.rows > 1 }, { "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column" }, { android: i.android }, { ios: i.ios }, { "css-mode": t.cssMode }, { centered: t.cssMode && t.centeredSlides }, { "watch-progress": t.watchSlidesProgress }], t.containerModifierClass); e.push(...a), s.classList.add(...e), n.emitContainerClasses() } function S3() { const n = this, { el: e, classNames: t } = n; !e || typeof e == "string" || (e.classList.remove(...t), n.emitContainerClasses()) } var E3 = { addClasses: w3, removeClasses: S3 }; function T3() { const n = this, { isLocked: e, params: t } = n, { slidesOffsetBefore: r } = t; if (r) { const s = n.slides.length - 1, i = n.slidesGrid[s] + n.slidesSizesGrid[s] + r * 2; n.isLocked = n.size > i } else n.isLocked = n.snapGrid.length === 1; t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked), t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked), e && e !== n.isLocked && (n.isEnd = !1), e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock") } var A3 = { checkOverflow: T3 }, Wf = { init: !0, direction: "horizontal", oneWayMovement: !1, swiperElementNodeName: "SWIPER-CONTAINER", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function I3(n, e) { return function (r) { r === void 0 && (r = {}); const s = Object.keys(r)[0], i = r[s]; if (typeof i != "object" || i === null) { yr(e, r); return } if (n[s] === !0 && (n[s] = { enabled: !0 }), s === "navigation" && n[s] && n[s].enabled && !n[s].prevEl && !n[s].nextEl && (n[s].auto = !0), ["pagination", "scrollbar"].indexOf(s) >= 0 && n[s] && n[s].enabled && !n[s].el && (n[s].auto = !0), !(s in n && "enabled" in i)) { yr(e, r); return } typeof n[s] == "object" && !("enabled" in n[s]) && (n[s].enabled = !0), n[s] || (n[s] = { enabled: !1 }), yr(e, r) } } const Xd = { eventsEmitter: EI, update: DI, translate: BI, transition: GI, slide: ZI, loop: r3, grabCursor: i3, events: g3, breakpoints: y3, checkOverflow: A3, classes: E3 }, Qd = {}; let Hh = class Ln { constructor() { let e, t; for (var r = arguments.length, s = new Array(r), i = 0; i < r; i++)s[i] = arguments[i]; s.length === 1 && s[0].constructor && Object.prototype.toString.call(s[0]).slice(8, -1) === "Object" ? t = s[0] : [e, t] = s, t || (t = {}), t = yr({}, t), e && !t.el && (t.el = e); const a = dn(); if (t.el && typeof t.el == "string" && a.querySelectorAll(t.el).length > 1) { const f = []; return a.querySelectorAll(t.el).forEach(h => { const p = yr({}, t, { el: h }); f.push(new Ln(p)) }), f } const o = this; o.__swiper__ = !0, o.support = d1(), o.device = f1({ userAgent: t.userAgent }), o.browser = h1(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules); const c = {}; o.modules.forEach(f => { f({ params: t, swiper: o, extendParams: I3(t, c), on: o.on.bind(o), once: o.once.bind(o), off: o.off.bind(o), emit: o.emit.bind(o) }) }); const u = yr({}, Wf, c); return o.params = yr({}, u, Qd, t), o.originalParams = yr({}, o.params), o.passedParams = yr({}, t), o.params && o.params.on && Object.keys(o.params.on).forEach(f => { o.on(f, o.params.on[f]) }), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, { enabled: o.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return o.params.direction === "horizontal" }, isVertical() { return o.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: o.params.allowSlideNext, allowSlidePrev: o.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: o.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: o.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), o.emit("_swiper"), o.params.init && o.init(), o } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: t, params: r } = this, s = an(t, `.${r.slideClass}, swiper-slide`), i = pc(s[0]); return pc(e) - i } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.find(t => t.getAttribute("data-swiper-slide-index") * 1 === e)) } getSlideIndexWhenGrid(e) { return this.grid && this.params.grid && this.params.grid.rows > 1 && (this.params.grid.fill === "column" ? e = Math.floor(e / this.params.grid.rows) : this.params.grid.fill === "row" && (e = e % Math.ceil(this.slides.length / this.params.grid.rows))), e } recalcSlides() { const e = this, { slidesEl: t, params: r } = e; e.slides = an(t, `.${r.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const r = this; e = Math.min(Math.max(e, 0), 1); const s = r.minTranslate(), a = (r.maxTranslate() - s) * e + s; r.translateTo(a, typeof t > "u" ? 0 : t), r.updateActiveIndex(), r.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter(r => r.indexOf("swiper") === 0 || r.indexOf(e.params.containerModifierClass) === 0); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter(r => r.indexOf("swiper-slide") === 0 || r.indexOf(t.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach(r => { const s = e.getSlideClasses(r); t.push({ slideEl: r, classNames: s }), e.emit("_slideClass", r, s) }), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { e === void 0 && (e = "current"), t === void 0 && (t = !1); const r = this, { params: s, slides: i, slidesGrid: a, slidesSizesGrid: o, size: c, activeIndex: u } = r; let f = 1; if (typeof s.slidesPerView == "number") return s.slidesPerView; if (s.centeredSlides) { let h = i[u] ? Math.ceil(i[u].swiperSlideSize) : 0, p; for (let v = u + 1; v < i.length; v += 1)i[v] && !p && (h += Math.ceil(i[v].swiperSlideSize), f += 1, h > c && (p = !0)); for (let v = u - 1; v >= 0; v -= 1)i[v] && !p && (h += i[v].swiperSlideSize, f += 1, h > c && (p = !0)) } else if (e === "current") for (let h = u + 1; h < i.length; h += 1)(t ? a[h] + o[h] - a[u] < c : a[h] - a[u] < c) && (f += 1); else for (let h = u - 1; h >= 0; h -= 1)a[u] - a[h] < c && (f += 1); return f } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: r } = e; r.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(a => { a.complete && Ql(e, a) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(); function s() { const a = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate()); e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses() } let i; if (r.freeMode && r.freeMode.enabled && !r.cssMode) s(), r.autoHeight && e.updateAutoHeight(); else { if ((r.slidesPerView === "auto" || r.slidesPerView > 1) && e.isEnd && !r.centeredSlides) { const a = e.virtual && r.virtual.enabled ? e.virtual.slides : e.slides; i = e.slideTo(a.length - 1, 0, !1, !0) } else i = e.slideTo(e.activeIndex, 0, !1, !0); i || s() } r.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { t === void 0 && (t = !0); const r = this, s = r.params.direction; return e || (e = s === "horizontal" ? "vertical" : "horizontal"), e === s || e !== "horizontal" && e !== "vertical" || (r.el.classList.remove(`${r.params.containerModifierClass}${s}`), r.el.classList.add(`${r.params.containerModifierClass}${e}`), r.emitContainerClasses(), r.params.direction = e, r.slides.forEach(i => { e === "vertical" ? i.style.width = "" : i.style.height = "" }), r.emit("changeDirection"), t && r.update()), r } changeLanguageDirection(e) { const t = this; t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let r = e || t.params.el; if (typeof r == "string" && (r = document.querySelector(r)), !r) return !1; r.swiper = t, r.parentNode && r.parentNode.host && r.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0); const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let a = r && r.shadowRoot && r.shadowRoot.querySelector ? r.shadowRoot.querySelector(s()) : an(r, s())[0]; return !a && t.params.createElements && (a = hc("div", t.params.wrapperClass), r.append(a), an(r, `.${t.params.slideClass}`).forEach(o => { a.append(o) })), Object.assign(t, { el: r, wrapperEl: a, slidesEl: t.isElement && !r.parentNode.host.slideSlots ? r.parentNode.host : a, hostEl: t.isElement ? r.parentNode.host : r, mounted: !0, rtl: r.dir.toLowerCase() === "rtl" || ps(r, "direction") === "rtl", rtlTranslate: t.params.direction === "horizontal" && (r.dir.toLowerCase() === "rtl" || ps(r, "direction") === "rtl"), wrongRTL: ps(a, "display") === "-webkit-box" }), !0 } init(e) { const t = this; if (t.initialized || t.mount(e) === !1) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(void 0, !0), t.attachEvents(); const s = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach(i => { i.complete ? Ql(t, i) : i.addEventListener("load", a => { Ql(t, a.target) }) }), Hf(t), t.initialized = !0, Hf(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { e === void 0 && (e = !0), t === void 0 && (t = !0); const r = this, { params: s, el: i, wrapperEl: a, slides: o } = r; return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"), r.initialized = !1, r.detachEvents(), s.loop && r.loopDestroy(), t && (r.removeClasses(), i && typeof i != "string" && i.removeAttribute("style"), a && a.removeAttribute("style"), o && o.length && o.forEach(c => { c.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass), c.removeAttribute("style"), c.removeAttribute("data-swiper-slide-index") })), r.emit("destroy"), Object.keys(r.eventsListeners).forEach(c => { r.off(c) }), e !== !1 && (r.el && typeof r.el != "string" && (r.el.swiper = null), cI(r)), r.destroyed = !0), null } static extendDefaults(e) { yr(Qd, e) } static get extendedDefaults() { return Qd } static get defaults() { return Wf } static installModule(e) { Ln.prototype.__modules__ || (Ln.prototype.__modules__ = []); const t = Ln.prototype.__modules__; typeof e == "function" && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(t => Ln.installModule(t)), Ln) : (Ln.installModule(e), Ln) } }; Object.keys(Xd).forEach(n => { Object.keys(Xd[n]).forEach(e => { Hh.prototype[e] = Xd[n][e] }) }); Hh.use([wI, SI]); const g1 = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function Ks(n) { return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" && !n.__swiper__ } function Ri(n, e) { const t = ["__proto__", "constructor", "prototype"]; Object.keys(e).filter(r => t.indexOf(r) < 0).forEach(r => { typeof n[r] > "u" ? n[r] = e[r] : Ks(e[r]) && Ks(n[r]) && Object.keys(e[r]).length > 0 ? e[r].__swiper__ ? n[r] = e[r] : Ri(n[r], e[r]) : n[r] = e[r] }) } function x1(n) { return n === void 0 && (n = {}), n.navigation && typeof n.navigation.nextEl > "u" && typeof n.navigation.prevEl > "u" } function v1(n) { return n === void 0 && (n = {}), n.pagination && typeof n.pagination.el > "u" } function y1(n) { return n === void 0 && (n = {}), n.scrollbar && typeof n.scrollbar.el > "u" } function b1(n) { n === void 0 && (n = ""); const e = n.split(" ").map(r => r.trim()).filter(r => !!r), t = []; return e.forEach(r => { t.indexOf(r) < 0 && t.push(r) }), t.join(" ") } function L3(n) { return n === void 0 && (n = ""), n ? n.includes("swiper-wrapper") ? n : `swiper-wrapper ${n}` : "swiper-wrapper" } function C3(n) { let { swiper: e, slides: t, passedParams: r, changedParams: s, nextEl: i, prevEl: a, scrollbarEl: o, paginationEl: c } = n; const u = s.filter(P => P !== "children" && P !== "direction" && P !== "wrapperClass"), { params: f, pagination: h, navigation: p, scrollbar: v, virtual: g, thumbs: y } = e; let w, T, S, E, I, C, D, R; s.includes("thumbs") && r.thumbs && r.thumbs.swiper && !r.thumbs.swiper.destroyed && f.thumbs && (!f.thumbs.swiper || f.thumbs.swiper.destroyed) && (w = !0), s.includes("controller") && r.controller && r.controller.control && f.controller && !f.controller.control && (T = !0), s.includes("pagination") && r.pagination && (r.pagination.el || c) && (f.pagination || f.pagination === !1) && h && !h.el && (S = !0), s.includes("scrollbar") && r.scrollbar && (r.scrollbar.el || o) && (f.scrollbar || f.scrollbar === !1) && v && !v.el && (E = !0), s.includes("navigation") && r.navigation && (r.navigation.prevEl || a) && (r.navigation.nextEl || i) && (f.navigation || f.navigation === !1) && p && !p.prevEl && !p.nextEl && (I = !0); const N = P => { e[P] && (e[P].destroy(), P === "navigation" ? (e.isElement && (e[P].prevEl.remove(), e[P].nextEl.remove()), f[P].prevEl = void 0, f[P].nextEl = void 0, e[P].prevEl = void 0, e[P].nextEl = void 0) : (e.isElement && e[P].el.remove(), f[P].el = void 0, e[P].el = void 0)) }; s.includes("loop") && e.isElement && (f.loop && !r.loop ? C = !0 : !f.loop && r.loop ? D = !0 : R = !0), u.forEach(P => { if (Ks(f[P]) && Ks(r[P])) Object.assign(f[P], r[P]), (P === "navigation" || P === "pagination" || P === "scrollbar") && "enabled" in r[P] && !r[P].enabled && N(P); else { const _ = r[P]; (_ === !0 || _ === !1) && (P === "navigation" || P === "pagination" || P === "scrollbar") ? _ === !1 && N(P) : f[P] = r[P] } }), u.includes("controller") && !T && e.controller && e.controller.control && f.controller && f.controller.control && (e.controller.control = f.controller.control), s.includes("children") && t && g && f.virtual.enabled ? (g.slides = t, g.update(!0)) : s.includes("virtual") && g && f.virtual.enabled && (t && (g.slides = t), g.update(!0)), s.includes("children") && t && f.loop && (R = !0), w && y.init() && y.update(!0), T && (e.controller.control = f.controller.control), S && (e.isElement && (!c || typeof c == "string") && (c = document.createElement("div"), c.classList.add("swiper-pagination"), c.part.add("pagination"), e.el.appendChild(c)), c && (f.pagination.el = c), h.init(), h.render(), h.update()), E && (e.isElement && (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-scrollbar"), o.part.add("scrollbar"), e.el.appendChild(o)), o && (f.scrollbar.el = o), v.init(), v.updateSize(), v.setTranslate()), I && (e.isElement && ((!i || typeof i == "string") && (i = document.createElement("div"), i.classList.add("swiper-button-next"), mc(i, e.hostEl.constructor.nextButtonSvg), i.part.add("button-next"), e.el.appendChild(i)), (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-button-prev"), mc(a, e.hostEl.constructor.prevButtonSvg), a.part.add("button-prev"), e.el.appendChild(a))), i && (f.navigation.nextEl = i), a && (f.navigation.prevEl = a), p.init(), p.update()), s.includes("allowSlideNext") && (e.allowSlideNext = r.allowSlideNext), s.includes("allowSlidePrev") && (e.allowSlidePrev = r.allowSlidePrev), s.includes("direction") && e.changeDirection(r.direction, !1), (C || R) && e.loopDestroy(), (D || R) && e.loopCreate(), e.update() } function k3(n, e) { n === void 0 && (n = {}), e === void 0 && (e = !0); const t = { on: {} }, r = {}, s = {}; Ri(t, Wf), t._emitClasses = !0, t.init = !1; const i = {}, a = g1.map(c => c.replace(/_/, "")), o = Object.assign({}, n); return Object.keys(o).forEach(c => { typeof n[c] > "u" || (a.indexOf(c) >= 0 ? Ks(n[c]) ? (t[c] = {}, s[c] = {}, Ri(t[c], n[c]), Ri(s[c], n[c])) : (t[c] = n[c], s[c] = n[c]) : c.search(/on[A-Z]/) === 0 && typeof n[c] == "function" ? e ? r[`${c[2].toLowerCase()}${c.substr(3)}`] = n[c] : t.on[`${c[2].toLowerCase()}${c.substr(3)}`] = n[c] : i[c] = n[c]) }), ["navigation", "pagination", "scrollbar"].forEach(c => { t[c] === !0 && (t[c] = {}), t[c] === !1 && delete t[c] }), { params: t, passedParams: s, rest: i, events: r } } function R3(n, e) { let { el: t, nextEl: r, prevEl: s, paginationEl: i, scrollbarEl: a, swiper: o } = n; x1(e) && r && s && (o.params.navigation.nextEl = r, o.originalParams.navigation.nextEl = r, o.params.navigation.prevEl = s, o.originalParams.navigation.prevEl = s), v1(e) && i && (o.params.pagination.el = i, o.originalParams.pagination.el = i), y1(e) && a && (o.params.scrollbar.el = a, o.originalParams.scrollbar.el = a), o.init(t) } function _3(n, e, t, r, s) { const i = []; if (!e) return i; const a = c => { i.indexOf(c) < 0 && i.push(c) }; if (t && r) { const c = r.map(s), u = t.map(s); c.join("") !== u.join("") && a("children"), r.length !== t.length && a("children") } return g1.filter(c => c[0] === "_").map(c => c.replace(/_/, "")).forEach(c => { if (c in n && c in e) if (Ks(n[c]) && Ks(e[c])) { const u = Object.keys(n[c]), f = Object.keys(e[c]); u.length !== f.length ? a(c) : (u.forEach(h => { n[c][h] !== e[c][h] && a(c) }), f.forEach(h => { n[c][h] !== e[c][h] && a(c) })) } else n[c] !== e[c] && a(c) }), i } const P3 = n => { !n || n.destroyed || !n.params.virtual || n.params.virtual && !n.params.virtual.enabled || (n.updateSlides(), n.updateProgress(), n.updateSlidesClasses(), n.emit("_virtualUpdated"), n.parallax && n.params.parallax && n.params.parallax.enabled && n.parallax.setTranslate()) }; function gc() { return gc = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, gc.apply(this, arguments) } function w1(n) { return n.type && n.type.displayName && n.type.displayName.includes("SwiperSlide") } function S1(n) { const e = []; return Qe.Children.toArray(n).forEach(t => { w1(t) ? e.push(t) : t.props && t.props.children && S1(t.props.children).forEach(r => e.push(r)) }), e } function N3(n) { const e = [], t = { "container-start": [], "container-end": [], "wrapper-start": [], "wrapper-end": [] }; return Qe.Children.toArray(n).forEach(r => { if (w1(r)) e.push(r); else if (r.props && r.props.slot && t[r.props.slot]) t[r.props.slot].push(r); else if (r.props && r.props.children) { const s = S1(r.props.children); s.length > 0 ? s.forEach(i => e.push(i)) : t["container-end"].push(r) } else t["container-end"].push(r) }), { slides: e, slots: t } } function D3(n, e, t) { if (!t) return null; const r = f => { let h = f; return f < 0 ? h = e.length + f : h >= e.length && (h = h - e.length), h }, s = n.isHorizontal() ? { [n.rtlTranslate ? "right" : "left"]: `${t.offset}px` } : { top: `${t.offset}px` }, { from: i, to: a } = t, o = n.params.loop ? -e.length : 0, c = n.params.loop ? e.length * 2 : e.length, u = []; for (let f = o; f < c; f += 1)f >= i && f <= a && u.push(e[r(f)]); return u.map((f, h) => Qe.cloneElement(f, { swiper: n, style: s, key: f.props.virtualIndex || f.key || `slide-${h}` })) } function Ua(n, e) { return typeof window > "u" ? j.useEffect(n, e) : j.useLayoutEffect(n, e) } const ox = j.createContext(null), O3 = j.createContext(null), $c = j.forwardRef(function (n, e) { let { className: t, tag: r = "div", wrapperTag: s = "div", children: i, onSwiper: a, ...o } = n === void 0 ? {} : n, c = !1; const [u, f] = j.useState("swiper"), [h, p] = j.useState(null), [v, g] = j.useState(!1), y = j.useRef(!1), w = j.useRef(null), T = j.useRef(null), S = j.useRef(null), E = j.useRef(null), I = j.useRef(null), C = j.useRef(null), D = j.useRef(null), R = j.useRef(null), { params: N, passedParams: P, rest: _, events: M } = k3(o), { slides: $, slots: B } = N3(i), V = () => { g(!v) }; Object.assign(N.on, { _containerClasses(X, Z) { f(Z) } }); const W = () => { Object.assign(N.on, M), c = !0; const X = { ...N }; if (delete X.wrapperClass, T.current = new Hh(X), T.current.virtual && T.current.params.virtual.enabled) { T.current.virtual.slides = $; const Z = { cache: !1, slides: $, renderExternal: p, renderExternalUpdate: !1 }; Ri(T.current.params.virtual, Z), Ri(T.current.originalParams.virtual, Z) } }; w.current || W(), T.current && T.current.on("_beforeBreakpoint", V); const U = () => { c || !M || !T.current || Object.keys(M).forEach(X => { T.current.on(X, M[X]) }) }, q = () => { !M || !T.current || Object.keys(M).forEach(X => { T.current.off(X, M[X]) }) }; j.useEffect(() => () => { T.current && T.current.off("_beforeBreakpoint", V) }), j.useEffect(() => { !y.current && T.current && (T.current.emitSlidesClasses(), y.current = !0) }), Ua(() => { if (e && (e.current = w.current), !!w.current) return T.current.destroyed && W(), R3({ el: w.current, nextEl: I.current, prevEl: C.current, paginationEl: D.current, scrollbarEl: R.current, swiper: T.current }, N), a && !T.current.destroyed && a(T.current), () => { T.current && !T.current.destroyed && T.current.destroy(!0, !1) } }, []), Ua(() => { U(); const X = _3(P, S.current, $, E.current, Z => Z.key); return S.current = P, E.current = $, X.length && T.current && !T.current.destroyed && C3({ swiper: T.current, slides: $, passedParams: P, changedParams: X, nextEl: I.current, prevEl: C.current, scrollbarEl: R.current, paginationEl: D.current }), () => { q() } }), Ua(() => { P3(T.current) }, [h]); function z() { return N.virtual ? D3(T.current, $, h) : $.map((X, Z) => Qe.cloneElement(X, { swiper: T.current, swiperSlideIndex: Z })) } return Qe.createElement(r, gc({ ref: w, className: b1(`${u}${t ? ` ${t}` : ""}`) }, _), Qe.createElement(O3.Provider, { value: T.current }, B["container-start"], Qe.createElement(s, { className: L3(N.wrapperClass) }, B["wrapper-start"], z(), B["wrapper-end"]), x1(N) && Qe.createElement(Qe.Fragment, null, Qe.createElement("div", { ref: C, className: "swiper-button-prev" }), Qe.createElement("div", { ref: I, className: "swiper-button-next" })), y1(N) && Qe.createElement("div", { ref: R, className: "swiper-scrollbar" }), v1(N) && Qe.createElement("div", { ref: D, className: "swiper-pagination" }), B["container-end"])) }); $c.displayName = "Swiper"; const Bc = j.forwardRef(function (n, e) { let { tag: t = "div", children: r, className: s = "", swiper: i, zoom: a, lazy: o, virtualIndex: c, swiperSlideIndex: u, ...f } = n === void 0 ? {} : n; const h = j.useRef(null), [p, v] = j.useState("swiper-slide"), [g, y] = j.useState(!1); function w(I, C, D) { C === h.current && v(D) } Ua(() => { if (typeof u < "u" && (h.current.swiperSlideIndex = u), e && (e.current = h.current), !(!h.current || !i)) { if (i.destroyed) { p !== "swiper-slide" && v("swiper-slide"); return } return i.on("_slideClass", w), () => { i && i.off("_slideClass", w) } } }), Ua(() => { i && h.current && !i.destroyed && v(i.getSlideClasses(h.current)) }, [i]); const T = { isActive: p.indexOf("swiper-slide-active") >= 0, isVisible: p.indexOf("swiper-slide-visible") >= 0, isPrev: p.indexOf("swiper-slide-prev") >= 0, isNext: p.indexOf("swiper-slide-next") >= 0 }, S = () => typeof r == "function" ? r(T) : r, E = () => { y(!0) }; return Qe.createElement(t, gc({ ref: h, className: b1(`${p}${s ? ` ${s}` : ""}`), "data-swiper-slide-index": c, onLoad: E }, f), a && Qe.createElement(ox.Provider, { value: T }, Qe.createElement("div", { className: "swiper-zoom-container", "data-swiper-zoom": typeof a == "number" ? a : void 0 }, S(), o && !g && Qe.createElement("div", { className: "swiper-lazy-preloader" }))), !a && Qe.createElement(ox.Provider, { value: T }, S(), o && !g && Qe.createElement("div", { className: "swiper-lazy-preloader" }))) }); Bc.displayName = "SwiperSlide"; function E1(n, e, t, r) { return n.params.createElements && Object.keys(r).forEach(s => { if (!t[s] && t.auto === !0) { let i = an(n.el, `.${r[s]}`)[0]; i || (i = hc("div", r[s]), i.className = r[s], n.el.append(i)), t[s] = i, e[s] = i } }), t } function Wh(n) { let { swiper: e, extendParams: t, on: r, emit: s } = n; t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, prevEl: null }; function i(g) { let y; return g && typeof g == "string" && e.isElement && (y = e.el.querySelector(g) || e.hostEl.querySelector(g), y) ? y : (g && (typeof g == "string" && (y = [...document.querySelectorAll(g)]), e.params.uniqueNavElements && typeof g == "string" && y && y.length > 1 && e.el.querySelectorAll(g).length === 1 ? y = e.el.querySelector(g) : y && y.length === 1 && (y = y[0])), g && !y ? g : y) } function a(g, y) { const w = e.params.navigation; g = Mt(g), g.forEach(T => { T && (T.classList[y ? "add" : "remove"](...w.disabledClass.split(" ")), T.tagName === "BUTTON" && (T.disabled = y), e.params.watchOverflow && e.enabled && T.classList[e.isLocked ? "add" : "remove"](w.lockClass)) }) } function o() { const { nextEl: g, prevEl: y } = e.navigation; if (e.params.loop) { a(y, !1), a(g, !1); return } a(y, e.isBeginning && !e.params.rewind), a(g, e.isEnd && !e.params.rewind) } function c(g) { g.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), s("navigationPrev")) } function u(g) { g.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), s("navigationNext")) } function f() { const g = e.params.navigation; if (e.params.navigation = E1(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(g.nextEl || g.prevEl)) return; let y = i(g.nextEl), w = i(g.prevEl); Object.assign(e.navigation, { nextEl: y, prevEl: w }), y = Mt(y), w = Mt(w); const T = (S, E) => { S && S.addEventListener("click", E === "next" ? u : c), !e.enabled && S && S.classList.add(...g.lockClass.split(" ")) }; y.forEach(S => T(S, "next")), w.forEach(S => T(S, "prev")) } function h() { let { nextEl: g, prevEl: y } = e.navigation; g = Mt(g), y = Mt(y); const w = (T, S) => { T.removeEventListener("click", S === "next" ? u : c), T.classList.remove(...e.params.navigation.disabledClass.split(" ")) }; g.forEach(T => w(T, "next")), y.forEach(T => w(T, "prev")) } r("init", () => { e.params.navigation.enabled === !1 ? v() : (f(), o()) }), r("toEdge fromEdge lock unlock", () => { o() }), r("destroy", () => { h() }), r("enable disable", () => { let { nextEl: g, prevEl: y } = e.navigation; if (g = Mt(g), y = Mt(y), e.enabled) { o(); return } [...g, ...y].filter(w => !!w).forEach(w => w.classList.add(e.params.navigation.lockClass)) }), r("click", (g, y) => { let { nextEl: w, prevEl: T } = e.navigation; w = Mt(w), T = Mt(T); const S = y.target; let E = T.includes(S) || w.includes(S); if (e.isElement && !E) { const I = y.path || y.composedPath && y.composedPath(); I && (E = I.find(C => w.includes(C) || T.includes(C))) } if (e.params.navigation.hideOnClick && !E) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === S || e.pagination.el.contains(S))) return; let I; w.length ? I = w[0].classList.contains(e.params.navigation.hiddenClass) : T.length && (I = T[0].classList.contains(e.params.navigation.hiddenClass)), s(I === !0 ? "navigationShow" : "navigationHide"), [...w, ...T].filter(C => !!C).forEach(C => C.classList.toggle(e.params.navigation.hiddenClass)) } }); const p = () => { e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), f(), o() }, v = () => { e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), h() }; Object.assign(e.navigation, { enable: p, disable: v, update: o, init: f, destroy: h }) } function Da(n) { return n === void 0 && (n = ""), `.${n.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, ".")}` } function T1(n) { let { swiper: e, extendParams: t, on: r, emit: s } = n; const i = "swiper-pagination"; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: S => S, formatFractionTotal: S => S, bulletClass: `${i}-bullet`, bulletActiveClass: `${i}-bullet-active`, modifierClass: `${i}-`, currentClass: `${i}-current`, totalClass: `${i}-total`, hiddenClass: `${i}-hidden`, progressbarFillClass: `${i}-progressbar-fill`, progressbarOppositeClass: `${i}-progressbar-opposite`, clickableClass: `${i}-clickable`, lockClass: `${i}-lock`, horizontalClass: `${i}-horizontal`, verticalClass: `${i}-vertical`, paginationDisabledClass: `${i}-disabled` } }), e.pagination = { el: null, bullets: [] }; let a, o = 0; function c() { return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0 } function u(S, E) { const { bulletActiveClass: I } = e.params.pagination; S && (S = S[`${E === "prev" ? "previous" : "next"}ElementSibling`], S && (S.classList.add(`${I}-${E}`), S = S[`${E === "prev" ? "previous" : "next"}ElementSibling`], S && S.classList.add(`${I}-${E}-${E}`))) } function f(S, E, I) { if (S = S % I, E = E % I, E === S + 1) return "next"; if (E === S - 1) return "previous" } function h(S) { const E = S.target.closest(Da(e.params.pagination.bulletClass)); if (!E) return; S.preventDefault(); const I = pc(E) * e.params.slidesPerGroup; if (e.params.loop) { if (e.realIndex === I) return; const C = f(e.realIndex, I, e.slides.length); C === "next" ? e.slideNext() : C === "previous" ? e.slidePrev() : e.slideToLoop(I) } else e.slideTo(I) } function p() { const S = e.rtl, E = e.params.pagination; if (c()) return; let I = e.pagination.el; I = Mt(I); let C, D; const R = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, N = e.params.loop ? Math.ceil(R / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (D = e.previousRealIndex || 0, C = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (C = e.snapIndex, D = e.previousSnapIndex) : (D = e.previousIndex || 0, C = e.activeIndex || 0), E.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) { const P = e.pagination.bullets; let _, M, $; if (E.dynamicBullets && (a = Gf(P[0], e.isHorizontal() ? "width" : "height"), I.forEach(B => { B.style[e.isHorizontal() ? "width" : "height"] = `${a * (E.dynamicMainBullets + 4)}px` }), E.dynamicMainBullets > 1 && D !== void 0 && (o += C - (D || 0), o > E.dynamicMainBullets - 1 ? o = E.dynamicMainBullets - 1 : o < 0 && (o = 0)), _ = Math.max(C - o, 0), M = _ + (Math.min(P.length, E.dynamicMainBullets) - 1), $ = (M + _) / 2), P.forEach(B => { const V = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(W => `${E.bulletActiveClass}${W}`)].map(W => typeof W == "string" && W.includes(" ") ? W.split(" ") : W).flat(); B.classList.remove(...V) }), I.length > 1) P.forEach(B => { const V = pc(B); V === C ? B.classList.add(...E.bulletActiveClass.split(" ")) : e.isElement && B.setAttribute("part", "bullet"), E.dynamicBullets && (V >= _ && V <= M && B.classList.add(...`${E.bulletActiveClass}-main`.split(" ")), V === _ && u(B, "prev"), V === M && u(B, "next")) }); else { const B = P[C]; if (B && B.classList.add(...E.bulletActiveClass.split(" ")), e.isElement && P.forEach((V, W) => { V.setAttribute("part", W === C ? "bullet-active" : "bullet") }), E.dynamicBullets) { const V = P[_], W = P[M]; for (let U = _; U <= M; U += 1)P[U] && P[U].classList.add(...`${E.bulletActiveClass}-main`.split(" ")); u(V, "prev"), u(W, "next") } } if (E.dynamicBullets) { const B = Math.min(P.length, E.dynamicMainBullets + 4), V = (a * B - a) / 2 - $ * a, W = S ? "right" : "left"; P.forEach(U => { U.style[e.isHorizontal() ? W : "top"] = `${V}px` }) } } I.forEach((P, _) => { if (E.type === "fraction" && (P.querySelectorAll(Da(E.currentClass)).forEach(M => { M.textContent = E.formatFractionCurrent(C + 1) }), P.querySelectorAll(Da(E.totalClass)).forEach(M => { M.textContent = E.formatFractionTotal(N) })), E.type === "progressbar") { let M; E.progressbarOpposite ? M = e.isHorizontal() ? "vertical" : "horizontal" : M = e.isHorizontal() ? "horizontal" : "vertical"; const $ = (C + 1) / N; let B = 1, V = 1; M === "horizontal" ? B = $ : V = $, P.querySelectorAll(Da(E.progressbarFillClass)).forEach(W => { W.style.transform = `translate3d(0,0,0) scaleX(${B}) scaleY(${V})`, W.style.transitionDuration = `${e.params.speed}ms` }) } E.type === "custom" && E.renderCustom ? (mc(P, E.renderCustom(e, C + 1, N)), _ === 0 && s("paginationRender", P)) : (_ === 0 && s("paginationRender", P), s("paginationUpdate", P)), e.params.watchOverflow && e.enabled && P.classList[e.isLocked ? "add" : "remove"](E.lockClass) }) } function v() { const S = e.params.pagination; if (c()) return; const E = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length; let I = e.pagination.el; I = Mt(I); let C = ""; if (S.type === "bullets") { let D = e.params.loop ? Math.ceil(E / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && D > E && (D = E); for (let R = 0; R < D; R += 1)S.renderBullet ? C += S.renderBullet.call(e, R, S.bulletClass) : C += `<${S.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${S.bulletClass}"></${S.bulletElement}>` } S.type === "fraction" && (S.renderFraction ? C = S.renderFraction.call(e, S.currentClass, S.totalClass) : C = `<span class="${S.currentClass}"></span> / <span class="${S.totalClass}"></span>`), S.type === "progressbar" && (S.renderProgressbar ? C = S.renderProgressbar.call(e, S.progressbarFillClass) : C = `<span class="${S.progressbarFillClass}"></span>`), e.pagination.bullets = [], I.forEach(D => { S.type !== "custom" && mc(D, C || ""), S.type === "bullets" && e.pagination.bullets.push(...D.querySelectorAll(Da(S.bulletClass))) }), S.type !== "custom" && s("paginationRender", I[0]) } function g() { e.params.pagination = E1(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const S = e.params.pagination; if (!S.el) return; let E; typeof S.el == "string" && e.isElement && (E = e.el.querySelector(S.el)), !E && typeof S.el == "string" && (E = [...document.querySelectorAll(S.el)]), E || (E = S.el), !(!E || E.length === 0) && (e.params.uniqueNavElements && typeof S.el == "string" && Array.isArray(E) && E.length > 1 && (E = [...e.el.querySelectorAll(S.el)], E.length > 1 && (E = E.find(I => u1(I, ".swiper")[0] === e.el))), Array.isArray(E) && E.length === 1 && (E = E[0]), Object.assign(e.pagination, { el: E }), E = Mt(E), E.forEach(I => { S.type === "bullets" && S.clickable && I.classList.add(...(S.clickableClass || "").split(" ")), I.classList.add(S.modifierClass + S.type), I.classList.add(e.isHorizontal() ? S.horizontalClass : S.verticalClass), S.type === "bullets" && S.dynamicBullets && (I.classList.add(`${S.modifierClass}${S.type}-dynamic`), o = 0, S.dynamicMainBullets < 1 && (S.dynamicMainBullets = 1)), S.type === "progressbar" && S.progressbarOpposite && I.classList.add(S.progressbarOppositeClass), S.clickable && I.addEventListener("click", h), e.enabled || I.classList.add(S.lockClass) })) } function y() { const S = e.params.pagination; if (c()) return; let E = e.pagination.el; E && (E = Mt(E), E.forEach(I => { I.classList.remove(S.hiddenClass), I.classList.remove(S.modifierClass + S.type), I.classList.remove(e.isHorizontal() ? S.horizontalClass : S.verticalClass), S.clickable && (I.classList.remove(...(S.clickableClass || "").split(" ")), I.removeEventListener("click", h)) })), e.pagination.bullets && e.pagination.bullets.forEach(I => I.classList.remove(...S.bulletActiveClass.split(" "))) } r("changeDirection", () => { if (!e.pagination || !e.pagination.el) return; const S = e.params.pagination; let { el: E } = e.pagination; E = Mt(E), E.forEach(I => { I.classList.remove(S.horizontalClass, S.verticalClass), I.classList.add(e.isHorizontal() ? S.horizontalClass : S.verticalClass) }) }), r("init", () => { e.params.pagination.enabled === !1 ? T() : (g(), v(), p()) }), r("activeIndexChange", () => { typeof e.snapIndex > "u" && p() }), r("snapIndexChange", () => { p() }), r("snapGridLengthChange", () => { v(), p() }), r("destroy", () => { y() }), r("enable disable", () => { let { el: S } = e.pagination; S && (S = Mt(S), S.forEach(E => E.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass))) }), r("lock unlock", () => { p() }), r("click", (S, E) => { const I = E.target, C = Mt(e.pagination.el); if (e.params.pagination.el && e.params.pagination.hideOnClick && C && C.length > 0 && !I.classList.contains(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && I === e.navigation.nextEl || e.navigation.prevEl && I === e.navigation.prevEl)) return; const D = C[0].classList.contains(e.params.pagination.hiddenClass); s(D === !0 ? "paginationShow" : "paginationHide"), C.forEach(R => R.classList.toggle(e.params.pagination.hiddenClass)) } }); const w = () => { e.el.classList.remove(e.params.pagination.paginationDisabledClass); let { el: S } = e.pagination; S && (S = Mt(S), S.forEach(E => E.classList.remove(e.params.pagination.paginationDisabledClass))), g(), v(), p() }, T = () => { e.el.classList.add(e.params.pagination.paginationDisabledClass); let { el: S } = e.pagination; S && (S = Mt(S), S.forEach(E => E.classList.add(e.params.pagination.paginationDisabledClass))), y() }; Object.assign(e.pagination, { enable: w, disable: T, render: v, update: p, init: g, destroy: y }) } function M3(n) { let { swiper: e, extendParams: t, on: r, emit: s, params: i } = n; e.autoplay = { running: !1, paused: !1, timeLeft: 0 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let a, o, c = i && i.autoplay ? i.autoplay.delay : 3e3, u = i && i.autoplay ? i.autoplay.delay : 3e3, f, h = new Date().getTime(), p, v, g, y, w, T, S; function E(z) { !e || e.destroyed || !e.wrapperEl || z.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", E), !(S || z.detail && z.detail.bySwiperTouchMove) && _()) } const I = () => { if (e.destroyed || !e.autoplay.running) return; e.autoplay.paused ? p = !0 : p && (u = f, p = !1); const z = e.autoplay.paused ? f : h + u - new Date().getTime(); e.autoplay.timeLeft = z, s("autoplayTimeLeft", z, z / c), o = requestAnimationFrame(() => { I() }) }, C = () => { let z; return e.virtual && e.params.virtual.enabled ? z = e.slides.find(Z => Z.classList.contains("swiper-slide-active")) : z = e.slides[e.activeIndex], z ? parseInt(z.getAttribute("data-swiper-autoplay"), 10) : void 0 }, D = z => { if (e.destroyed || !e.autoplay.running) return; cancelAnimationFrame(o), I(); let X = typeof z > "u" ? e.params.autoplay.delay : z; c = e.params.autoplay.delay, u = e.params.autoplay.delay; const Z = C(); !Number.isNaN(Z) && Z > 0 && typeof z > "u" && (X = Z, c = Z, u = Z), f = X; const F = e.params.speed, H = () => { !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(F, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, F, !0, !0), s("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(F, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, F, !0, !0), s("autoplay")), e.params.cssMode && (h = new Date().getTime(), requestAnimationFrame(() => { D() }))) }; return X > 0 ? (clearTimeout(a), a = setTimeout(() => { H() }, X)) : requestAnimationFrame(() => { H() }), X }, R = () => { h = new Date().getTime(), e.autoplay.running = !0, D(), s("autoplayStart") }, N = () => { e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(o), s("autoplayStop") }, P = (z, X) => { if (e.destroyed || !e.autoplay.running) return; clearTimeout(a), z || (T = !0); const Z = () => { s("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", E) : _() }; if (e.autoplay.paused = !0, X) { w && (f = e.params.autoplay.delay), w = !1, Z(); return } f = (f || e.params.autoplay.delay) - (new Date().getTime() - h), !(e.isEnd && f < 0 && !e.params.loop) && (f < 0 && (f = 0), Z()) }, _ = () => { e.isEnd && f < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (h = new Date().getTime(), T ? (T = !1, D(f)) : D(), e.autoplay.paused = !1, s("autoplayResume")) }, M = () => { if (e.destroyed || !e.autoplay.running) return; const z = dn(); z.visibilityState === "hidden" && (T = !0, P(!0)), z.visibilityState === "visible" && _() }, $ = z => { z.pointerType === "mouse" && (T = !0, S = !0, !(e.animating || e.autoplay.paused) && P(!0)) }, B = z => { z.pointerType === "mouse" && (S = !1, e.autoplay.paused && _()) }, V = () => { e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", $), e.el.addEventListener("pointerleave", B)) }, W = () => { e.el && typeof e.el != "string" && (e.el.removeEventListener("pointerenter", $), e.el.removeEventListener("pointerleave", B)) }, U = () => { dn().addEventListener("visibilitychange", M) }, q = () => { dn().removeEventListener("visibilitychange", M) }; r("init", () => { e.params.autoplay.enabled && (V(), U(), R()) }), r("destroy", () => { W(), q(), e.autoplay.running && N() }), r("_freeModeStaticRelease", () => { (g || T) && _() }), r("_freeModeNoMomentumRelease", () => { e.params.autoplay.disableOnInteraction ? N() : P(!0, !0) }), r("beforeTransitionStart", (z, X, Z) => { e.destroyed || !e.autoplay.running || (Z || !e.params.autoplay.disableOnInteraction ? P(!0, !0) : N()) }), r("sliderFirstMove", () => { if (!(e.destroyed || !e.autoplay.running)) { if (e.params.autoplay.disableOnInteraction) { N(); return } v = !0, g = !1, T = !1, y = setTimeout(() => { T = !0, g = !0, P(!0) }, 200) } }), r("touchEnd", () => { if (!(e.destroyed || !e.autoplay.running || !v)) { if (clearTimeout(y), clearTimeout(a), e.params.autoplay.disableOnInteraction) { g = !1, v = !1; return } g && e.params.cssMode && _(), g = !1, v = !1 } }), r("slideChange", () => { e.destroyed || !e.autoplay.running || (w = !0) }), Object.assign(e.autoplay, { start: R, stop: N, pause: P, resume: _ }) } function j3(n) { const { effect: e, swiper: t, on: r, setTranslate: s, setTransition: i, overwriteParams: a, perspective: o, recreateShadows: c, getEffectParams: u } = n; r("beforeInit", () => { if (t.params.effect !== e) return; t.classNames.push(`${t.params.containerModifierClass}${e}`), o && o() && t.classNames.push(`${t.params.containerModifierClass}3d`); const h = a ? a() : {}; Object.assign(t.params, h), Object.assign(t.originalParams, h) }), r("setTranslate _virtualUpdated", () => { t.params.effect === e && s() }), r("setTransition", (h, p) => { t.params.effect === e && i(p) }), r("transitionEnd", () => { if (t.params.effect === e && c) { if (!u || !u().slideShadows) return; t.slides.forEach(h => { h.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(p => p.remove()) }), c() } }); let f; r("virtualUpdate", () => { t.params.effect === e && (t.slides.length || (f = !0), requestAnimationFrame(() => { f && t.slides && t.slides.length && (s(), f = !1) })) }) } function F3(n, e) { const t = c1(e); return t !== e && (t.style.backfaceVisibility = "hidden", t.style["-webkit-backface-visibility"] = "hidden"), t } function $3(n) { let { swiper: e, duration: t, transformElements: r } = n; const { activeIndex: s } = e; if (e.params.virtualTranslate && t !== 0) { let i = !1, a; a = r, a.forEach(o => { xI(o, () => { if (i || !e || e.destroyed) return; i = !0, e.animating = !1; const c = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); e.wrapperEl.dispatchEvent(c) }) }) } } function B3(n) { let { swiper: e, extendParams: t, on: r } = n; t({ fadeEffect: { crossFade: !1 } }), j3({ effect: "fade", swiper: e, on: r, setTranslate: () => { const { slides: a } = e, o = e.params.fadeEffect; for (let c = 0; c < a.length; c += 1) { const u = e.slides[c]; let h = -u.swiperSlideOffset; e.params.virtualTranslate || (h -= e.translate); let p = 0; e.isHorizontal() || (p = h, h = 0); const v = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(u.progress), 0) : 1 + Math.min(Math.max(u.progress, -1), 0), g = F3(o, u); g.style.opacity = v, g.style.transform = `translate3d(${h}px, ${p}px, 0px)` } }, setTransition: a => { const o = e.slides.map(c => c1(c)); o.forEach(c => { c.style.transitionDuration = `${a}ms` }), $3({ swiper: e, duration: a, transformElements: o }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */function U3(n, e, t) { return (e = V3(e)) in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function lx(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(n, s).enumerable })), t.push.apply(t, r) } return t } function ue(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? lx(Object(t), !0).forEach(function (r) { U3(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : lx(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function z3(n, e) { if (typeof n != "object" || !n) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var r = t.call(n, e); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function V3(n) { var e = z3(n, "string"); return typeof e == "symbol" ? e : e + "" } const cx = () => { }; let Kh = {}, A1 = {}, I1 = null, L1 = { mark: cx, measure: cx }; try { typeof window < "u" && (Kh = window), typeof document < "u" && (A1 = document), typeof MutationObserver < "u" && (I1 = MutationObserver), typeof performance < "u" && (L1 = performance) } catch { } const { userAgent: ux = "" } = Kh.navigator || {}, xs = Kh, dt = A1, dx = I1, kl = L1; xs.document; const jn = !!dt.documentElement && !!dt.head && typeof dt.addEventListener == "function" && typeof dt.createElement == "function", C1 = ~ux.indexOf("MSIE") || ~ux.indexOf("Trident/"); var G3 = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, H3 = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, k1 = { classic: { fa: "solid", fas: "solid", "fa-solid": "solid", far: "regular", "fa-regular": "regular", fal: "light", "fa-light": "light", fat: "thin", "fa-thin": "thin", fab: "brands", "fa-brands": "brands" }, duotone: { fa: "solid", fad: "solid", "fa-solid": "solid", "fa-duotone": "solid", fadr: "regular", "fa-regular": "regular", fadl: "light", "fa-light": "light", fadt: "thin", "fa-thin": "thin" }, sharp: { fa: "solid", fass: "solid", "fa-solid": "solid", fasr: "regular", "fa-regular": "regular", fasl: "light", "fa-light": "light", fast: "thin", "fa-thin": "thin" }, "sharp-duotone": { fa: "solid", fasds: "solid", "fa-solid": "solid", fasdr: "regular", "fa-regular": "regular", fasdl: "light", "fa-light": "light", fasdt: "thin", "fa-thin": "thin" } }, W3 = { GROUP: "duotone-group", PRIMARY: "primary", SECONDARY: "secondary" }, R1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], Ht = "classic", Uc = "duotone", K3 = "sharp", q3 = "sharp-duotone", _1 = [Ht, Uc, K3, q3], Y3 = { classic: { 900: "fas", 400: "far", normal: "far", 300: "fal", 100: "fat" }, duotone: { 900: "fad", 400: "fadr", 300: "fadl", 100: "fadt" }, sharp: { 900: "fass", 400: "fasr", 300: "fasl", 100: "fast" }, "sharp-duotone": { 900: "fasds", 400: "fasdr", 300: "fasdl", 100: "fasdt" } }, X3 = { "Font Awesome 6 Free": { 900: "fas", 400: "far" }, "Font Awesome 6 Pro": { 900: "fas", 400: "far", normal: "far", 300: "fal", 100: "fat" }, "Font Awesome 6 Brands": { 400: "fab", normal: "fab" }, "Font Awesome 6 Duotone": { 900: "fad", 400: "fadr", normal: "fadr", 300: "fadl", 100: "fadt" }, "Font Awesome 6 Sharp": { 900: "fass", 400: "fasr", normal: "fasr", 300: "fasl", 100: "fast" }, "Font Awesome 6 Sharp Duotone": { 900: "fasds", 400: "fasdr", normal: "fasdr", 300: "fasdl", 100: "fasdt" } }, Q3 = new Map([["classic", { defaultShortPrefixId: "fas", defaultStyleId: "solid", styleIds: ["solid", "regular", "light", "thin", "brands"], futureStyleIds: [], defaultFontWeight: 900 }], ["sharp", { defaultShortPrefixId: "fass", defaultStyleId: "solid", styleIds: ["solid", "regular", "light", "thin"], futureStyleIds: [], defaultFontWeight: 900 }], ["duotone", { defaultShortPrefixId: "fad", defaultStyleId: "solid", styleIds: ["solid", "regular", "light", "thin"], futureStyleIds: [], defaultFontWeight: 900 }], ["sharp-duotone", { defaultShortPrefixId: "fasds", defaultStyleId: "solid", styleIds: ["solid", "regular", "light", "thin"], futureStyleIds: [], defaultFontWeight: 900 }]]), Z3 = { classic: { solid: "fas", regular: "far", light: "fal", thin: "fat", brands: "fab" }, duotone: { solid: "fad", regular: "fadr", light: "fadl", thin: "fadt" }, sharp: { solid: "fass", regular: "fasr", light: "fasl", thin: "fast" }, "sharp-duotone": { solid: "fasds", regular: "fasdr", light: "fasdl", thin: "fasdt" } }, J3 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], fx = { kit: { fak: "kit", "fa-kit": "kit" }, "kit-duotone": { fakd: "kit-duotone", "fa-kit-duotone": "kit-duotone" } }, eL = ["kit"], tL = { kit: { "fa-kit": "fak" } }, rL = ["fak", "fakd"], nL = { kit: { fak: "fa-kit" } }, hx = { kit: { kit: "fak" }, "kit-duotone": { "kit-duotone": "fakd" } }, Rl = { GROUP: "duotone-group", SWAP_OPACITY: "swap-opacity", PRIMARY: "primary", SECONDARY: "secondary" }, sL = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], iL = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], aL = { "Font Awesome Kit": { 400: "fak", normal: "fak" }, "Font Awesome Kit Duotone": { 400: "fakd", normal: "fakd" } }, oL = { classic: { "fa-brands": "fab", "fa-duotone": "fad", "fa-light": "fal", "fa-regular": "far", "fa-solid": "fas", "fa-thin": "fat" }, duotone: { "fa-regular": "fadr", "fa-light": "fadl", "fa-thin": "fadt" }, sharp: { "fa-solid": "fass", "fa-regular": "fasr", "fa-light": "fasl", "fa-thin": "fast" }, "sharp-duotone": { "fa-solid": "fasds", "fa-regular": "fasdr", "fa-light": "fasdl", "fa-thin": "fasdt" } }, lL = { classic: ["fas", "far", "fal", "fat", "fad"], duotone: ["fadr", "fadl", "fadt"], sharp: ["fass", "fasr", "fasl", "fast"], "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"] }, Kf = { classic: { fab: "fa-brands", fad: "fa-duotone", fal: "fa-light", far: "fa-regular", fas: "fa-solid", fat: "fa-thin" }, duotone: { fadr: "fa-regular", fadl: "fa-light", fadt: "fa-thin" }, sharp: { fass: "fa-solid", fasr: "fa-regular", fasl: "fa-light", fast: "fa-thin" }, "sharp-duotone": { fasds: "fa-solid", fasdr: "fa-regular", fasdl: "fa-light", fasdt: "fa-thin" } }, cL = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], qf = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...sL, ...cL], uL = ["solid", "regular", "light", "thin", "duotone", "brands"], P1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], dL = P1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), fL = [...Object.keys(lL), ...uL, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Rl.GROUP, Rl.SWAP_OPACITY, Rl.PRIMARY, Rl.SECONDARY].concat(P1.map(n => "".concat(n, "x"))).concat(dL.map(n => "w-".concat(n))), hL = { "Font Awesome 5 Free": { 900: "fas", 400: "far" }, "Font Awesome 5 Pro": { 900: "fas", 400: "far", normal: "far", 300: "fal" }, "Font Awesome 5 Brands": { 400: "fab", normal: "fab" }, "Font Awesome 5 Duotone": { 900: "fad" } }; const Nn = "___FONT_AWESOME___", Yf = 16, N1 = "fa", D1 = "svg-inline--fa", qs = "data-fa-i2svg", Xf = "data-fa-pseudo-element", pL = "data-fa-pseudo-element-pending", qh = "data-prefix", Yh = "data-icon", px = "fontawesome-i2svg", mL = "async", gL = ["HTML", "HEAD", "STYLE", "SCRIPT"], O1 = (() => { try { return !0 } catch { return !1 } })(); function fo(n) { return new Proxy(n, { get(e, t) { return t in e ? e[t] : e[Ht] } }) } const M1 = ue({}, k1); M1[Ht] = ue(ue(ue(ue({}, { "fa-duotone": "duotone" }), k1[Ht]), fx.kit), fx["kit-duotone"]); const xL = fo(M1), Qf = ue({}, Z3); Qf[Ht] = ue(ue(ue(ue({}, { duotone: "fad" }), Qf[Ht]), hx.kit), hx["kit-duotone"]); const mx = fo(Qf), Zf = ue({}, Kf); Zf[Ht] = ue(ue({}, Zf[Ht]), nL.kit); const Xh = fo(Zf), Jf = ue({}, oL); Jf[Ht] = ue(ue({}, Jf[Ht]), tL.kit); fo(Jf); const vL = G3, j1 = "fa-layers-text", yL = H3, bL = ue({}, Y3); fo(bL); const wL = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], Zd = W3, SL = [...eL, ...fL], za = xs.FontAwesomeConfig || {}; function EL(n) { var e = dt.querySelector("script[" + n + "]"); if (e) return e.getAttribute(n) } function TL(n) { return n === "" ? !0 : n === "false" ? !1 : n === "true" ? !0 : n } dt && typeof dt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach(e => { let [t, r] = e; const s = TL(EL(t)); s != null && (za[r] = s) }); const F1 = { styleDefault: "solid", familyDefault: Ht, cssPrefix: N1, replacementClass: D1, autoReplaceSvg: !0, autoAddCss: !0, autoA11y: !0, searchPseudoElements: !1, observeMutations: !0, mutateApproach: "async", keepOriginalSource: !0, measurePerformance: !1, showMissingIcons: !0 }; za.familyPrefix && (za.cssPrefix = za.familyPrefix); const Fi = ue(ue({}, F1), za); Fi.autoReplaceSvg || (Fi.observeMutations = !1); const Ae = {}; Object.keys(F1).forEach(n => { Object.defineProperty(Ae, n, { enumerable: !0, set: function (e) { Fi[n] = e, Va.forEach(t => t(Ae)) }, get: function () { return Fi[n] } }) }); Object.defineProperty(Ae, "familyPrefix", { enumerable: !0, set: function (n) { Fi.cssPrefix = n, Va.forEach(e => e(Ae)) }, get: function () { return Fi.cssPrefix } }); xs.FontAwesomeConfig = Ae; const Va = []; function AL(n) { return Va.push(n), () => { Va.splice(Va.indexOf(n), 1) } } const is = Yf, on = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 }; function IL(n) { if (!n || !jn) return; const e = dt.createElement("style"); e.setAttribute("type", "text/css"), e.innerHTML = n; const t = dt.head.childNodes; let r = null; for (let s = t.length - 1; s > -1; s--) { const i = t[s], a = (i.tagName || "").toUpperCase();["STYLE", "LINK"].indexOf(a) > -1 && (r = i) } return dt.head.insertBefore(e, r), n } const LL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; function Ya() { let n = 12, e = ""; for (; n-- > 0;)e += LL[Math.random() * 62 | 0]; return e } function Gi(n) { const e = []; for (let t = (n || []).length >>> 0; t--;)e[t] = n[t]; return e } function Qh(n) { return n.classList ? Gi(n.classList) : (n.getAttribute("class") || "").split(" ").filter(e => e) } function $1(n) { return "".concat(n).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function CL(n) { return Object.keys(n || {}).reduce((e, t) => e + "".concat(t, '="').concat($1(n[t]), '" '), "").trim() } function zc(n) { return Object.keys(n || {}).reduce((e, t) => e + "".concat(t, ": ").concat(n[t].trim(), ";"), "") } function Zh(n) { return n.size !== on.size || n.x !== on.x || n.y !== on.y || n.rotate !== on.rotate || n.flipX || n.flipY } function kL(n) { let { transform: e, containerWidth: t, iconWidth: r } = n; const s = { transform: "translate(".concat(t / 2, " 256)") }, i = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "), a = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), o = "rotate(".concat(e.rotate, " 0 0)"), c = { transform: "".concat(i, " ").concat(a, " ").concat(o) }, u = { transform: "translate(".concat(r / 2 * -1, " -256)") }; return { outer: s, inner: c, path: u } } function RL(n) { let { transform: e, width: t = Yf, height: r = Yf, startCentered: s = !1 } = n, i = ""; return s && C1 ? i += "translate(".concat(e.x / is - t / 2, "em, ").concat(e.y / is - r / 2, "em) ") : s ? i += "translate(calc(-50% + ".concat(e.x / is, "em), calc(-50% + ").concat(e.y / is, "em)) ") : i += "translate(".concat(e.x / is, "em, ").concat(e.y / is, "em) "), i += "scale(".concat(e.size / is * (e.flipX ? -1 : 1), ", ").concat(e.size / is * (e.flipY ? -1 : 1), ") "), i += "rotate(".concat(e.rotate, "deg) "), i } var _L = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`; function B1() { const n = N1, e = D1, t = Ae.cssPrefix, r = Ae.replacementClass; let s = _L; if (t !== n || r !== e) { const i = new RegExp("\\.".concat(n, "\\-"), "g"), a = new RegExp("\\--".concat(n, "\\-"), "g"), o = new RegExp("\\.".concat(e), "g"); s = s.replace(i, ".".concat(t, "-")).replace(a, "--".concat(t, "-")).replace(o, ".".concat(r)) } return s } let gx = !1; function Jd() { Ae.autoAddCss && !gx && (IL(B1()), gx = !0) } var PL = { mixout() { return { dom: { css: B1, insertCss: Jd } } }, hooks() { return { beforeDOMElementCreation() { Jd() }, beforeI2svg() { Jd() } } } }; const Dn = xs || {}; Dn[Nn] || (Dn[Nn] = {}); Dn[Nn].styles || (Dn[Nn].styles = {}); Dn[Nn].hooks || (Dn[Nn].hooks = {}); Dn[Nn].shims || (Dn[Nn].shims = []); var ln = Dn[Nn]; const U1 = [], z1 = function () { dt.removeEventListener("DOMContentLoaded", z1), xc = 1, U1.map(n => n()) }; let xc = !1; jn && (xc = (dt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(dt.readyState), xc || dt.addEventListener("DOMContentLoaded", z1)); function NL(n) { jn && (xc ? setTimeout(n, 0) : U1.push(n)) } function ho(n) { const { tag: e, attributes: t = {}, children: r = [] } = n; return typeof n == "string" ? $1(n) : "<".concat(e, " ").concat(CL(t), ">").concat(r.map(ho).join(""), "</").concat(e, ">") } function xx(n, e, t) { if (n && n[e] && n[e][t]) return { prefix: e, iconName: t, icon: n[e][t] } } var ef = function (e, t, r, s) { var i = Object.keys(e), a = i.length, o = t, c, u, f; for (r === void 0 ? (c = 1, f = e[i[0]]) : (c = 0, f = r); c < a; c++)u = i[c], f = o(f, e[u], u, e); return f }; function DL(n) { const e = []; let t = 0; const r = n.length; for (; t < r;) { const s = n.charCodeAt(t++); if (s >= 55296 && s <= 56319 && t < r) { const i = n.charCodeAt(t++); (i & 64512) == 56320 ? e.push(((s & 1023) << 10) + (i & 1023) + 65536) : (e.push(s), t--) } else e.push(s) } return e } function eh(n) { const e = DL(n); return e.length === 1 ? e[0].toString(16) : null } function OL(n, e) { const t = n.length; let r = n.charCodeAt(e), s; return r >= 55296 && r <= 56319 && t > e + 1 && (s = n.charCodeAt(e + 1), s >= 56320 && s <= 57343) ? (r - 55296) * 1024 + s - 56320 + 65536 : r } function vx(n) { return Object.keys(n).reduce((e, t) => { const r = n[t]; return !!r.icon ? e[r.iconName] = r.icon : e[t] = r, e }, {}) } function th(n, e) { let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; const { skipHooks: r = !1 } = t, s = vx(e); typeof ln.hooks.addPack == "function" && !r ? ln.hooks.addPack(n, vx(e)) : ln.styles[n] = ue(ue({}, ln.styles[n] || {}), s), n === "fas" && th("fa", e) } const { styles: Xa, shims: ML } = ln, V1 = Object.keys(Xh), jL = V1.reduce((n, e) => (n[e] = Object.keys(Xh[e]), n), {}); let Jh = null, G1 = {}, H1 = {}, W1 = {}, K1 = {}, q1 = {}; function FL(n) { return ~SL.indexOf(n) } function $L(n, e) { const t = e.split("-"), r = t[0], s = t.slice(1).join("-"); return r === n && s !== "" && !FL(s) ? s : null } const Y1 = () => { const n = r => ef(Xa, (s, i, a) => (s[a] = ef(i, r, {}), s), {}); G1 = n((r, s, i) => (s[3] && (r[s[3]] = i), s[2] && s[2].filter(o => typeof o == "number").forEach(o => { r[o.toString(16)] = i }), r)), H1 = n((r, s, i) => (r[i] = i, s[2] && s[2].filter(o => typeof o == "string").forEach(o => { r[o] = i }), r)), q1 = n((r, s, i) => { const a = s[2]; return r[i] = i, a.forEach(o => { r[o] = i }), r }); const e = "far" in Xa || Ae.autoFetchSvg, t = ef(ML, (r, s) => { const i = s[0]; let a = s[1]; const o = s[2]; return a === "far" && !e && (a = "fas"), typeof i == "string" && (r.names[i] = { prefix: a, iconName: o }), typeof i == "number" && (r.unicodes[i.toString(16)] = { prefix: a, iconName: o }), r }, { names: {}, unicodes: {} }); W1 = t.names, K1 = t.unicodes, Jh = Vc(Ae.styleDefault, { family: Ae.familyDefault }) }; AL(n => { Jh = Vc(n.styleDefault, { family: Ae.familyDefault }) }); Y1(); function ep(n, e) { return (G1[n] || {})[e] } function BL(n, e) { return (H1[n] || {})[e] } function Vs(n, e) { return (q1[n] || {})[e] } function X1(n) { return W1[n] || { prefix: null, iconName: null } } function UL(n) { const e = K1[n], t = ep("fas", n); return e || (t ? { prefix: "fas", iconName: t } : null) || { prefix: null, iconName: null } } function vs() { return Jh } const Q1 = () => ({ prefix: null, iconName: null, rest: [] }); function zL(n) { let e = Ht; const t = V1.reduce((r, s) => (r[s] = "".concat(Ae.cssPrefix, "-").concat(s), r), {}); return _1.forEach(r => { (n.includes(t[r]) || n.some(s => jL[r].includes(s))) && (e = r) }), e } function Vc(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { family: t = Ht } = e, r = xL[t][n]; if (t === Uc && !n) return "fad"; const s = mx[t][n] || mx[t][r], i = n in ln.styles ? n : null; return s || i || null } function VL(n) { let e = [], t = null; return n.forEach(r => { const s = $L(Ae.cssPrefix, r); s ? t = s : r && e.push(r) }), { iconName: t, rest: e } } function yx(n) { return n.sort().filter((e, t, r) => r.indexOf(e) === t) } function Gc(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { skipLookups: t = !1 } = e; let r = null; const s = qf.concat(iL), i = yx(n.filter(h => s.includes(h))), a = yx(n.filter(h => !qf.includes(h))), o = i.filter(h => (r = h, !R1.includes(h))), [c = null] = o, u = zL(i), f = ue(ue({}, VL(a)), {}, { prefix: Vc(c, { family: u }) }); return ue(ue(ue({}, f), KL({ values: n, family: u, styles: Xa, config: Ae, canonical: f, givenPrefix: r })), GL(t, r, f)) } function GL(n, e, t) { let { prefix: r, iconName: s } = t; if (n || !r || !s) return { prefix: r, iconName: s }; const i = e === "fa" ? X1(s) : {}, a = Vs(r, s); return s = i.iconName || a || s, r = i.prefix || r, r === "far" && !Xa.far && Xa.fas && !Ae.autoFetchSvg && (r = "fas"), { prefix: r, iconName: s } } const HL = _1.filter(n => n !== Ht || n !== Uc), WL = Object.keys(Kf).filter(n => n !== Ht).map(n => Object.keys(Kf[n])).flat(); function KL(n) { const { values: e, family: t, canonical: r, givenPrefix: s = "", styles: i = {}, config: a = {} } = n, o = t === Uc, c = e.includes("fa-duotone") || e.includes("fad"), u = a.familyDefault === "duotone", f = r.prefix === "fad" || r.prefix === "fa-duotone"; if (!o && (c || u || f) && (r.prefix = "fad"), (e.includes("fa-brands") || e.includes("fab")) && (r.prefix = "fab"), !r.prefix && HL.includes(t) && (Object.keys(i).find(p => WL.includes(p)) || a.autoFetchSvg)) { const p = Q3.get(t).defaultShortPrefixId; r.prefix = p, r.iconName = Vs(r.prefix, r.iconName) || r.iconName } return (r.prefix === "fa" || s === "fa") && (r.prefix = vs() || "fas"), r } class qL { constructor() { this.definitions = {} } add() { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; const s = t.reduce(this._pullDefinitions, {}); Object.keys(s).forEach(i => { this.definitions[i] = ue(ue({}, this.definitions[i] || {}), s[i]), th(i, s[i]); const a = Xh[Ht][i]; a && th(a, s[i]), Y1() }) } reset() { this.definitions = {} } _pullDefinitions(e, t) { const r = t.prefix && t.iconName && t.icon ? { 0: t } : t; return Object.keys(r).map(s => { const { prefix: i, iconName: a, icon: o } = r[s], c = o[2]; e[i] || (e[i] = {}), c.length > 0 && c.forEach(u => { typeof u == "string" && (e[i][u] = o) }), e[i][a] = o }), e } } let bx = [], Ci = {}; const _i = {}, YL = Object.keys(_i); function XL(n, e) { let { mixoutsTo: t } = e; return bx = n, Ci = {}, Object.keys(_i).forEach(r => { YL.indexOf(r) === -1 && delete _i[r] }), bx.forEach(r => { const s = r.mixout ? r.mixout() : {}; if (Object.keys(s).forEach(i => { typeof s[i] == "function" && (t[i] = s[i]), typeof s[i] == "object" && Object.keys(s[i]).forEach(a => { t[i] || (t[i] = {}), t[i][a] = s[i][a] }) }), r.hooks) { const i = r.hooks(); Object.keys(i).forEach(a => { Ci[a] || (Ci[a] = []), Ci[a].push(i[a]) }) } r.provides && r.provides(_i) }), t } function rh(n, e) { for (var t = arguments.length, r = new Array(t > 2 ? t - 2 : 0), s = 2; s < t; s++)r[s - 2] = arguments[s]; return (Ci[n] || []).forEach(a => { e = a.apply(null, [e, ...r]) }), e } function Ys(n) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; (Ci[n] || []).forEach(i => { i.apply(null, t) }) } function ys() { const n = arguments[0], e = Array.prototype.slice.call(arguments, 1); return _i[n] ? _i[n].apply(null, e) : void 0 } function nh(n) { n.prefix === "fa" && (n.prefix = "fas"); let { iconName: e } = n; const t = n.prefix || vs(); if (e) return e = Vs(t, e) || e, xx(Z1.definitions, t, e) || xx(ln.styles, t, e) } const Z1 = new qL, QL = () => { Ae.autoReplaceSvg = !1, Ae.observeMutations = !1, Ys("noAuto") }, ZL = { i2svg: function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return jn ? (Ys("beforeI2svg", n), ys("pseudoElements2svg", n), ys("i2svg", n)) : Promise.reject(new Error("Operation requires a DOM of some kind.")) }, watch: function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { autoReplaceSvgRoot: e } = n; Ae.autoReplaceSvg === !1 && (Ae.autoReplaceSvg = !0), Ae.observeMutations = !0, NL(() => { e4({ autoReplaceSvgRoot: e }), Ys("watch", n) }) } }, JL = { icon: n => { if (n === null) return null; if (typeof n == "object" && n.prefix && n.iconName) return { prefix: n.prefix, iconName: Vs(n.prefix, n.iconName) || n.iconName }; if (Array.isArray(n) && n.length === 2) { const e = n[1].indexOf("fa-") === 0 ? n[1].slice(3) : n[1], t = Vc(n[0]); return { prefix: t, iconName: Vs(t, e) || e } } if (typeof n == "string" && (n.indexOf("".concat(Ae.cssPrefix, "-")) > -1 || n.match(vL))) { const e = Gc(n.split(" "), { skipLookups: !0 }); return { prefix: e.prefix || vs(), iconName: Vs(e.prefix, e.iconName) || e.iconName } } if (typeof n == "string") { const e = vs(); return { prefix: e, iconName: Vs(e, n) || n } } } }, Sr = { noAuto: QL, config: Ae, dom: ZL, parse: JL, library: Z1, findIconDefinition: nh, toHtml: ho }, e4 = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { autoReplaceSvgRoot: e = dt } = n; (Object.keys(ln.styles).length > 0 || Ae.autoFetchSvg) && jn && Ae.autoReplaceSvg && Sr.dom.i2svg({ node: e }) }; function Hc(n, e) { return Object.defineProperty(n, "abstract", { get: e }), Object.defineProperty(n, "html", { get: function () { return n.abstract.map(t => ho(t)) } }), Object.defineProperty(n, "node", { get: function () { if (!jn) return; const t = dt.createElement("div"); return t.innerHTML = n.html, t.children } }), n } function t4(n) { let { children: e, main: t, mask: r, attributes: s, styles: i, transform: a } = n; if (Zh(a) && t.found && !r.found) { const { width: o, height: c } = t, u = { x: o / c / 2, y: .5 }; s.style = zc(ue(ue({}, i), {}, { "transform-origin": "".concat(u.x + a.x / 16, "em ").concat(u.y + a.y / 16, "em") })) } return [{ tag: "svg", attributes: s, children: e }] } function r4(n) { let { prefix: e, iconName: t, children: r, attributes: s, symbol: i } = n; const a = i === !0 ? "".concat(e, "-").concat(Ae.cssPrefix, "-").concat(t) : i; return [{ tag: "svg", attributes: { style: "display: none;" }, children: [{ tag: "symbol", attributes: ue(ue({}, s), {}, { id: a }), children: r }] }] } function tp(n) { const { icons: { main: e, mask: t }, prefix: r, iconName: s, transform: i, symbol: a, title: o, maskId: c, titleId: u, extra: f, watchable: h = !1 } = n, { width: p, height: v } = t.found ? t : e, g = rL.includes(r), y = [Ae.replacementClass, s ? "".concat(Ae.cssPrefix, "-").concat(s) : ""].filter(C => f.classes.indexOf(C) === -1).filter(C => C !== "" || !!C).concat(f.classes).join(" "); let w = { children: [], attributes: ue(ue({}, f.attributes), {}, { "data-prefix": r, "data-icon": s, class: y, role: f.attributes.role || "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 ".concat(p, " ").concat(v) }) }; const T = g && !~f.classes.indexOf("fa-fw") ? { width: "".concat(p / v * 16 * .0625, "em") } : {}; h && (w.attributes[qs] = ""), o && (w.children.push({ tag: "title", attributes: { id: w.attributes["aria-labelledby"] || "title-".concat(u || Ya()) }, children: [o] }), delete w.attributes.title); const S = ue(ue({}, w), {}, { prefix: r, iconName: s, main: e, mask: t, maskId: c, transform: i, symbol: a, styles: ue(ue({}, T), f.styles) }), { children: E, attributes: I } = t.found && e.found ? ys("generateAbstractMask", S) || { children: [], attributes: {} } : ys("generateAbstractIcon", S) || { children: [], attributes: {} }; return S.children = E, S.attributes = I, a ? r4(S) : t4(S) } function wx(n) { const { content: e, width: t, height: r, transform: s, title: i, extra: a, watchable: o = !1 } = n, c = ue(ue(ue({}, a.attributes), i ? { title: i } : {}), {}, { class: a.classes.join(" ") }); o && (c[qs] = ""); const u = ue({}, a.styles); Zh(s) && (u.transform = RL({ transform: s, startCentered: !0, width: t, height: r }), u["-webkit-transform"] = u.transform); const f = zc(u); f.length > 0 && (c.style = f); const h = []; return h.push({ tag: "span", attributes: c, children: [e] }), i && h.push({ tag: "span", attributes: { class: "sr-only" }, children: [i] }), h } function n4(n) { const { content: e, title: t, extra: r } = n, s = ue(ue(ue({}, r.attributes), t ? { title: t } : {}), {}, { class: r.classes.join(" ") }), i = zc(r.styles); i.length > 0 && (s.style = i); const a = []; return a.push({ tag: "span", attributes: s, children: [e] }), t && a.push({ tag: "span", attributes: { class: "sr-only" }, children: [t] }), a } const { styles: tf } = ln; function sh(n) { const e = n[0], t = n[1], [r] = n.slice(4); let s = null; return Array.isArray(r) ? s = { tag: "g", attributes: { class: "".concat(Ae.cssPrefix, "-").concat(Zd.GROUP) }, children: [{ tag: "path", attributes: { class: "".concat(Ae.cssPrefix, "-").concat(Zd.SECONDARY), fill: "currentColor", d: r[0] } }, { tag: "path", attributes: { class: "".concat(Ae.cssPrefix, "-").concat(Zd.PRIMARY), fill: "currentColor", d: r[1] } }] } : s = { tag: "path", attributes: { fill: "currentColor", d: r } }, { found: !0, width: e, height: t, icon: s } } const s4 = { found: !1, width: 512, height: 512 }; function i4(n, e) { !O1 && !Ae.showMissingIcons && n && console.error('Icon with name "'.concat(n, '" and prefix "').concat(e, '" is missing.')) } function ih(n, e) { let t = e; return e === "fa" && Ae.styleDefault !== null && (e = vs()), new Promise((r, s) => { if (t === "fa") { const i = X1(n) || {}; n = i.iconName || n, e = i.prefix || e } if (n && e && tf[e] && tf[e][n]) { const i = tf[e][n]; return r(sh(i)) } i4(n, e), r(ue(ue({}, s4), {}, { icon: Ae.showMissingIcons && n ? ys("missingIconAbstract") || {} : {} })) }) } const Sx = () => { }, ah = Ae.measurePerformance && kl && kl.mark && kl.measure ? kl : { mark: Sx, measure: Sx }, Fa = 'FA "6.7.2"', a4 = n => (ah.mark("".concat(Fa, " ").concat(n, " begins")), () => J1(n)), J1 = n => { ah.mark("".concat(Fa, " ").concat(n, " ends")), ah.measure("".concat(Fa, " ").concat(n), "".concat(Fa, " ").concat(n, " begins"), "".concat(Fa, " ").concat(n, " ends")) }; var rp = { begin: a4, end: J1 }; const Zl = () => { }; function Ex(n) { return typeof (n.getAttribute ? n.getAttribute(qs) : null) == "string" } function o4(n) { const e = n.getAttribute ? n.getAttribute(qh) : null, t = n.getAttribute ? n.getAttribute(Yh) : null; return e && t } function l4(n) { return n && n.classList && n.classList.contains && n.classList.contains(Ae.replacementClass) } function c4() { return Ae.autoReplaceSvg === !0 ? Jl.replace : Jl[Ae.autoReplaceSvg] || Jl.replace } function u4(n) { return dt.createElementNS("http://www.w3.org/2000/svg", n) } function d4(n) { return dt.createElement(n) } function eb(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { ceFn: t = n.tag === "svg" ? u4 : d4 } = e; if (typeof n == "string") return dt.createTextNode(n); const r = t(n.tag); return Object.keys(n.attributes || []).forEach(function (i) { r.setAttribute(i, n.attributes[i]) }), (n.children || []).forEach(function (i) { r.appendChild(eb(i, { ceFn: t })) }), r } function f4(n) { let e = " ".concat(n.outerHTML, " "); return e = "".concat(e, "Font Awesome fontawesome.com "), e } const Jl = {
    replace: function (n) { const e = n[0]; if (e.parentNode) if (n[1].forEach(t => { e.parentNode.insertBefore(eb(t), e) }), e.getAttribute(qs) === null && Ae.keepOriginalSource) { let t = dt.createComment(f4(e)); e.parentNode.replaceChild(t, e) } else e.remove() }, nest: function (n) {
      const e = n[0], t = n[1]; if (~Qh(e).indexOf(Ae.replacementClass)) return Jl.replace(n); const r = new RegExp("".concat(Ae.cssPrefix, "-.*")); if (delete t[0].attributes.id, t[0].attributes.class) { const i = t[0].attributes.class.split(" ").reduce((a, o) => (o === Ae.replacementClass || o.match(r) ? a.toSvg.push(o) : a.toNode.push(o), a), { toNode: [], toSvg: [] }); t[0].attributes.class = i.toSvg.join(" "), i.toNode.length === 0 ? e.removeAttribute("class") : e.setAttribute("class", i.toNode.join(" ")) } const s = t.map(i => ho(i)).join(`
`); e.setAttribute(qs, ""), e.innerHTML = s
    }
  }; function Tx(n) { n() } function tb(n, e) { const t = typeof e == "function" ? e : Zl; if (n.length === 0) t(); else { let r = Tx; Ae.mutateApproach === mL && (r = xs.requestAnimationFrame || Tx), r(() => { const s = c4(), i = rp.begin("mutate"); n.map(s), i(), t() }) } } let np = !1; function rb() { np = !0 } function oh() { np = !1 } let vc = null; function Ax(n) { if (!dx || !Ae.observeMutations) return; const { treeCallback: e = Zl, nodeCallback: t = Zl, pseudoElementsCallback: r = Zl, observeMutationsRoot: s = dt } = n; vc = new dx(i => { if (np) return; const a = vs(); Gi(i).forEach(o => { if (o.type === "childList" && o.addedNodes.length > 0 && !Ex(o.addedNodes[0]) && (Ae.searchPseudoElements && r(o.target), e(o.target)), o.type === "attributes" && o.target.parentNode && Ae.searchPseudoElements && r(o.target.parentNode), o.type === "attributes" && Ex(o.target) && ~wL.indexOf(o.attributeName)) if (o.attributeName === "class" && o4(o.target)) { const { prefix: c, iconName: u } = Gc(Qh(o.target)); o.target.setAttribute(qh, c || a), u && o.target.setAttribute(Yh, u) } else l4(o.target) && t(o.target) }) }), jn && vc.observe(s, { childList: !0, attributes: !0, characterData: !0, subtree: !0 }) } function h4() { vc && vc.disconnect() } function p4(n) { const e = n.getAttribute("style"); let t = []; return e && (t = e.split(";").reduce((r, s) => { const i = s.split(":"), a = i[0], o = i.slice(1); return a && o.length > 0 && (r[a] = o.join(":").trim()), r }, {})), t } function m4(n) { const e = n.getAttribute("data-prefix"), t = n.getAttribute("data-icon"), r = n.innerText !== void 0 ? n.innerText.trim() : ""; let s = Gc(Qh(n)); return s.prefix || (s.prefix = vs()), e && t && (s.prefix = e, s.iconName = t), s.iconName && s.prefix || (s.prefix && r.length > 0 && (s.iconName = BL(s.prefix, n.innerText) || ep(s.prefix, eh(n.innerText))), !s.iconName && Ae.autoFetchSvg && n.firstChild && n.firstChild.nodeType === Node.TEXT_NODE && (s.iconName = n.firstChild.data)), s } function g4(n) { const e = Gi(n.attributes).reduce((s, i) => (s.name !== "class" && s.name !== "style" && (s[i.name] = i.value), s), {}), t = n.getAttribute("title"), r = n.getAttribute("data-fa-title-id"); return Ae.autoA11y && (t ? e["aria-labelledby"] = "".concat(Ae.replacementClass, "-title-").concat(r || Ya()) : (e["aria-hidden"] = "true", e.focusable = "false")), e } function x4() { return { iconName: null, title: null, titleId: null, prefix: null, transform: on, symbol: !1, mask: { iconName: null, prefix: null, rest: [] }, maskId: null, extra: { classes: [], styles: {}, attributes: {} } } } function Ix(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { styleParser: !0 }; const { iconName: t, prefix: r, rest: s } = m4(n), i = g4(n), a = rh("parseNodeAttributes", {}, n); let o = e.styleParser ? p4(n) : []; return ue({ iconName: t, title: n.getAttribute("title"), titleId: n.getAttribute("data-fa-title-id"), prefix: r, transform: on, mask: { iconName: null, prefix: null, rest: [] }, maskId: null, symbol: !1, extra: { classes: s, styles: o, attributes: i } }, a) } const { styles: v4 } = ln; function nb(n) { const e = Ae.autoReplaceSvg === "nest" ? Ix(n, { styleParser: !1 }) : Ix(n); return ~e.extra.classes.indexOf(j1) ? ys("generateLayersText", n, e) : ys("generateSvgReplacementMutation", n, e) } function y4() { return [...J3, ...qf] } function Lx(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; if (!jn) return Promise.resolve(); const t = dt.documentElement.classList, r = f => t.add("".concat(px, "-").concat(f)), s = f => t.remove("".concat(px, "-").concat(f)), i = Ae.autoFetchSvg ? y4() : R1.concat(Object.keys(v4)); i.includes("fa") || i.push("fa"); const a = [".".concat(j1, ":not([").concat(qs, "])")].concat(i.map(f => ".".concat(f, ":not([").concat(qs, "])"))).join(", "); if (a.length === 0) return Promise.resolve(); let o = []; try { o = Gi(n.querySelectorAll(a)) } catch { } if (o.length > 0) r("pending"), s("complete"); else return Promise.resolve(); const c = rp.begin("onTree"), u = o.reduce((f, h) => { try { const p = nb(h); p && f.push(p) } catch (p) { O1 || p.name === "MissingIcon" && console.error(p) } return f }, []); return new Promise((f, h) => { Promise.all(u).then(p => { tb(p, () => { r("active"), r("complete"), s("pending"), typeof e == "function" && e(), c(), f() }) }).catch(p => { c(), h(p) }) }) } function b4(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; nb(n).then(t => { t && tb([t], e) }) } function w4(n) { return function (e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const r = (e || {}).icon ? e : nh(e || {}); let { mask: s } = t; return s && (s = (s || {}).icon ? s : nh(s || {})), n(r, ue(ue({}, t), {}, { mask: s })) } } const S4 = function (n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { transform: t = on, symbol: r = !1, mask: s = null, maskId: i = null, title: a = null, titleId: o = null, classes: c = [], attributes: u = {}, styles: f = {} } = e; if (!n) return; const { prefix: h, iconName: p, icon: v } = n; return Hc(ue({ type: "icon" }, n), () => (Ys("beforeDOMElementCreation", { iconDefinition: n, params: e }), Ae.autoA11y && (a ? u["aria-labelledby"] = "".concat(Ae.replacementClass, "-title-").concat(o || Ya()) : (u["aria-hidden"] = "true", u.focusable = "false")), tp({ icons: { main: sh(v), mask: s ? sh(s.icon) : { found: !1, width: null, height: null, icon: {} } }, prefix: h, iconName: p, transform: ue(ue({}, on), t), symbol: r, title: a, maskId: i, titleId: o, extra: { attributes: u, styles: f, classes: c } }))) }; var E4 = { mixout() { return { icon: w4(S4) } }, hooks() { return { mutationObserverCallbacks(n) { return n.treeCallback = Lx, n.nodeCallback = b4, n } } }, provides(n) { n.i2svg = function (e) { const { node: t = dt, callback: r = () => { } } = e; return Lx(t, r) }, n.generateSvgReplacementMutation = function (e, t) { const { iconName: r, title: s, titleId: i, prefix: a, transform: o, symbol: c, mask: u, maskId: f, extra: h } = t; return new Promise((p, v) => { Promise.all([ih(r, a), u.iconName ? ih(u.iconName, u.prefix) : Promise.resolve({ found: !1, width: 512, height: 512, icon: {} })]).then(g => { let [y, w] = g; p([e, tp({ icons: { main: y, mask: w }, prefix: a, iconName: r, transform: o, symbol: c, maskId: f, title: s, titleId: i, extra: h, watchable: !0 })]) }).catch(v) }) }, n.generateAbstractIcon = function (e) { let { children: t, attributes: r, main: s, transform: i, styles: a } = e; const o = zc(a); o.length > 0 && (r.style = o); let c; return Zh(i) && (c = ys("generateAbstractTransformGrouping", { main: s, transform: i, containerWidth: s.width, iconWidth: s.width })), t.push(c || s.icon), { children: t, attributes: r } } } }, T4 = { mixout() { return { layer(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { classes: t = [] } = e; return Hc({ type: "layer" }, () => { Ys("beforeDOMElementCreation", { assembler: n, params: e }); let r = []; return n(s => { Array.isArray(s) ? s.map(i => { r = r.concat(i.abstract) }) : r = r.concat(s.abstract) }), [{ tag: "span", attributes: { class: ["".concat(Ae.cssPrefix, "-layers"), ...t].join(" ") }, children: r }] }) } } } }, A4 = { mixout() { return { counter(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { title: t = null, classes: r = [], attributes: s = {}, styles: i = {} } = e; return Hc({ type: "counter", content: n }, () => (Ys("beforeDOMElementCreation", { content: n, params: e }), n4({ content: n.toString(), title: t, extra: { attributes: s, styles: i, classes: ["".concat(Ae.cssPrefix, "-layers-counter"), ...r] } }))) } } } }, I4 = { mixout() { return { text(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; const { transform: t = on, title: r = null, classes: s = [], attributes: i = {}, styles: a = {} } = e; return Hc({ type: "text", content: n }, () => (Ys("beforeDOMElementCreation", { content: n, params: e }), wx({ content: n, transform: ue(ue({}, on), t), title: r, extra: { attributes: i, styles: a, classes: ["".concat(Ae.cssPrefix, "-layers-text"), ...s] } }))) } } }, provides(n) { n.generateLayersText = function (e, t) { const { title: r, transform: s, extra: i } = t; let a = null, o = null; if (C1) { const c = parseInt(getComputedStyle(e).fontSize, 10), u = e.getBoundingClientRect(); a = u.width / c, o = u.height / c } return Ae.autoA11y && !r && (i.attributes["aria-hidden"] = "true"), Promise.resolve([e, wx({ content: e.innerHTML, width: a, height: o, transform: s, title: r, extra: i, watchable: !0 })]) } } }; const L4 = new RegExp('"', "ug"), Cx = [1105920, 1112319], kx = ue(ue(ue(ue({}, { FontAwesome: { normal: "fas", 400: "fas" } }), X3), hL), aL), lh = Object.keys(kx).reduce((n, e) => (n[e.toLowerCase()] = kx[e], n), {}), C4 = Object.keys(lh).reduce((n, e) => { const t = lh[e]; return n[e] = t[900] || [...Object.entries(t)][0][1], n }, {}); function k4(n) { const e = n.replace(L4, ""), t = OL(e, 0), r = t >= Cx[0] && t <= Cx[1], s = e.length === 2 ? e[0] === e[1] : !1; return { value: eh(s ? e[0] : e), isSecondary: r || s } } function R4(n, e) { const t = n.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(e), s = isNaN(r) ? "normal" : r; return (lh[t] || {})[s] || C4[t] } function Rx(n, e) {
    const t = "".concat(pL).concat(e.replace(":", "-")); return new Promise((r, s) => {
      if (n.getAttribute(t) !== null) return r(); const a = Gi(n.children).filter(p => p.getAttribute(Xf) === e)[0], o = xs.getComputedStyle(n, e), c = o.getPropertyValue("font-family"), u = c.match(yL), f = o.getPropertyValue("font-weight"), h = o.getPropertyValue("content"); if (a && !u) return n.removeChild(a), r(); if (u && h !== "none" && h !== "") {
        const p = o.getPropertyValue("content"); let v = R4(c, f); const { value: g, isSecondary: y } = k4(p), w = u[0].startsWith("FontAwesome"); let T = ep(v, g), S = T; if (w) { const E = UL(g); E.iconName && E.prefix && (T = E.iconName, v = E.prefix) } if (T && !y && (!a || a.getAttribute(qh) !== v || a.getAttribute(Yh) !== S)) {
          n.setAttribute(t, S), a && n.removeChild(a); const E = x4(), { extra: I } = E; I.attributes[Xf] = e, ih(T, v).then(C => {
            const D = tp(ue(ue({}, E), {}, { icons: { main: C, mask: Q1() }, prefix: v, iconName: S, extra: I, watchable: !0 })), R = dt.createElementNS("http://www.w3.org/2000/svg", "svg"); e === "::before" ? n.insertBefore(R, n.firstChild) : n.appendChild(R), R.outerHTML = D.map(N => ho(N)).join(`
`), n.removeAttribute(t), r()
          }).catch(s)
        } else r()
      } else r()
    })
  } function _4(n) { return Promise.all([Rx(n, "::before"), Rx(n, "::after")]) } function P4(n) { return n.parentNode !== document.head && !~gL.indexOf(n.tagName.toUpperCase()) && !n.getAttribute(Xf) && (!n.parentNode || n.parentNode.tagName !== "svg") } function _x(n) { if (jn) return new Promise((e, t) => { const r = Gi(n.querySelectorAll("*")).filter(P4).map(_4), s = rp.begin("searchPseudoElements"); rb(), Promise.all(r).then(() => { s(), oh(), e() }).catch(() => { s(), oh(), t() }) }) } var N4 = { hooks() { return { mutationObserverCallbacks(n) { return n.pseudoElementsCallback = _x, n } } }, provides(n) { n.pseudoElements2svg = function (e) { const { node: t = dt } = e; Ae.searchPseudoElements && _x(t) } } }; let Px = !1; var D4 = { mixout() { return { dom: { unwatch() { rb(), Px = !0 } } } }, hooks() { return { bootstrap() { Ax(rh("mutationObserverCallbacks", {})) }, noAuto() { h4() }, watch(n) { const { observeMutationsRoot: e } = n; Px ? oh() : Ax(rh("mutationObserverCallbacks", { observeMutationsRoot: e })) } } } }; const Nx = n => { let e = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }; return n.toLowerCase().split(" ").reduce((t, r) => { const s = r.toLowerCase().split("-"), i = s[0]; let a = s.slice(1).join("-"); if (i && a === "h") return t.flipX = !0, t; if (i && a === "v") return t.flipY = !0, t; if (a = parseFloat(a), isNaN(a)) return t; switch (i) { case "grow": t.size = t.size + a; break; case "shrink": t.size = t.size - a; break; case "left": t.x = t.x - a; break; case "right": t.x = t.x + a; break; case "up": t.y = t.y - a; break; case "down": t.y = t.y + a; break; case "rotate": t.rotate = t.rotate + a; break }return t }, e) }; var O4 = { mixout() { return { parse: { transform: n => Nx(n) } } }, hooks() { return { parseNodeAttributes(n, e) { const t = e.getAttribute("data-fa-transform"); return t && (n.transform = Nx(t)), n } } }, provides(n) { n.generateAbstractTransformGrouping = function (e) { let { main: t, transform: r, containerWidth: s, iconWidth: i } = e; const a = { transform: "translate(".concat(s / 2, " 256)") }, o = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), c = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), u = "rotate(".concat(r.rotate, " 0 0)"), f = { transform: "".concat(o, " ").concat(c, " ").concat(u) }, h = { transform: "translate(".concat(i / 2 * -1, " -256)") }, p = { outer: a, inner: f, path: h }; return { tag: "g", attributes: ue({}, p.outer), children: [{ tag: "g", attributes: ue({}, p.inner), children: [{ tag: t.icon.tag, children: t.icon.children, attributes: ue(ue({}, t.icon.attributes), p.path) }] }] } } } }; const rf = { x: 0, y: 0, width: "100%", height: "100%" }; function Dx(n) { let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; return n.attributes && (n.attributes.fill || e) && (n.attributes.fill = "black"), n } function M4(n) { return n.tag === "g" ? n.children : [n] } var j4 = { hooks() { return { parseNodeAttributes(n, e) { const t = e.getAttribute("data-fa-mask"), r = t ? Gc(t.split(" ").map(s => s.trim())) : Q1(); return r.prefix || (r.prefix = vs()), n.mask = r, n.maskId = e.getAttribute("data-fa-mask-id"), n } } }, provides(n) { n.generateAbstractMask = function (e) { let { children: t, attributes: r, main: s, mask: i, maskId: a, transform: o } = e; const { width: c, icon: u } = s, { width: f, icon: h } = i, p = kL({ transform: o, containerWidth: f, iconWidth: c }), v = { tag: "rect", attributes: ue(ue({}, rf), {}, { fill: "white" }) }, g = u.children ? { children: u.children.map(Dx) } : {}, y = { tag: "g", attributes: ue({}, p.inner), children: [Dx(ue({ tag: u.tag, attributes: ue(ue({}, u.attributes), p.path) }, g))] }, w = { tag: "g", attributes: ue({}, p.outer), children: [y] }, T = "mask-".concat(a || Ya()), S = "clip-".concat(a || Ya()), E = { tag: "mask", attributes: ue(ue({}, rf), {}, { id: T, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [v, w] }, I = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: S }, children: M4(h) }, E] }; return t.push(I, { tag: "rect", attributes: ue({ fill: "currentColor", "clip-path": "url(#".concat(S, ")"), mask: "url(#".concat(T, ")") }, rf) }), { children: t, attributes: r } } } }, F4 = { provides(n) { let e = !1; xs.matchMedia && (e = xs.matchMedia("(prefers-reduced-motion: reduce)").matches), n.missingIconAbstract = function () { const t = [], r = { fill: "currentColor" }, s = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" }; t.push({ tag: "path", attributes: ue(ue({}, r), {}, { d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z" }) }); const i = ue(ue({}, s), {}, { attributeName: "opacity" }), a = { tag: "circle", attributes: ue(ue({}, r), {}, { cx: "256", cy: "364", r: "28" }), children: [] }; return e || a.children.push({ tag: "animate", attributes: ue(ue({}, s), {}, { attributeName: "r", values: "28;14;28;28;14;28;" }) }, { tag: "animate", attributes: ue(ue({}, i), {}, { values: "1;0;1;1;0;1;" }) }), t.push(a), t.push({ tag: "path", attributes: ue(ue({}, r), {}, { opacity: "1", d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z" }), children: e ? [] : [{ tag: "animate", attributes: ue(ue({}, i), {}, { values: "1;0;0;0;0;1;" }) }] }), e || t.push({ tag: "path", attributes: ue(ue({}, r), {}, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z" }), children: [{ tag: "animate", attributes: ue(ue({}, i), {}, { values: "0;0;1;1;0;0;" }) }] }), { tag: "g", attributes: { class: "missing" }, children: t } } } }, $4 = { hooks() { return { parseNodeAttributes(n, e) { const t = e.getAttribute("data-fa-symbol"), r = t === null ? !1 : t === "" ? !0 : t; return n.symbol = r, n } } } }, B4 = [PL, E4, T4, A4, I4, N4, D4, O4, j4, F4, $4]; XL(B4, { mixoutsTo: Sr }); Sr.noAuto; Sr.config; Sr.library; Sr.dom; const ch = Sr.parse; Sr.findIconDefinition; Sr.toHtml; const U4 = Sr.icon; Sr.layer; Sr.text; Sr.counter; var nf = { exports: {} }, sf, Ox; function z4() { if (Ox) return sf; Ox = 1; var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"; return sf = n, sf } var af, Mx; function V4() { if (Mx) return af; Mx = 1; var n = z4(); function e() { } function t() { } return t.resetWarningCache = e, af = function () { function r(a, o, c, u, f, h) { if (h !== n) { var p = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw p.name = "Invariant Violation", p } } r.isRequired = r; function s() { return r } var i = { array: r, bigint: r, bool: r, func: r, number: r, object: r, string: r, symbol: r, any: r, arrayOf: s, element: r, elementType: r, instanceOf: s, node: r, objectOf: s, oneOf: s, oneOfType: s, shape: s, exact: s, checkPropTypes: t, resetWarningCache: e }; return i.PropTypes = i, i }, af } var jx; function G4() { return jx || (jx = 1, nf.exports = V4()()), nf.exports } var H4 = G4(); const Fe = Mh(H4); var W4 = {}; function uh(n, e) { (e == null || e > n.length) && (e = n.length); for (var t = 0, r = Array(e); t < e; t++)r[t] = n[t]; return r } function K4(n) { if (Array.isArray(n)) return n } function q4(n) { if (Array.isArray(n)) return uh(n) } function us(n, e, t) { return (e = rC(e)) in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function Y4(n) { if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n) } function X4(n, e) { var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"]; if (t != null) { var r, s, i, a, o = [], c = !0, u = !1; try { if (i = (t = t.call(n)).next, e !== 0) for (; !(c = (r = i.call(t)).done) && (o.push(r.value), o.length !== e); c = !0); } catch (f) { u = !0, s = f } finally { try { if (!c && t.return != null && (a = t.return(), Object(a) !== a)) return } finally { if (u) throw s } } return o } } function Q4() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function Z4() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function Fx(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(n, s).enumerable })), t.push.apply(t, r) } return t } function nn(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? Fx(Object(t), !0).forEach(function (r) { us(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Fx(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function J4(n, e) { if (n == null) return {}; var t, r, s = eC(n, e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(n); for (r = 0; r < i.length; r++)t = i[r], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(n, t) && (s[t] = n[t]) } return s } function eC(n, e) { if (n == null) return {}; var t = {}; for (var r in n) if ({}.hasOwnProperty.call(n, r)) { if (e.indexOf(r) !== -1) continue; t[r] = n[r] } return t } function $x(n, e) { return K4(n) || X4(n, e) || sb(n, e) || Q4() } function dh(n) { return q4(n) || Y4(n) || sb(n) || Z4() } function tC(n, e) { if (typeof n != "object" || !n) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var r = t.call(n, e); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function rC(n) { var e = tC(n, "string"); return typeof e == "symbol" ? e : e + "" } function yc(n) { "@babel/helpers - typeof"; return yc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, yc(n) } function sb(n, e) { if (n) { if (typeof n == "string") return uh(n, e); var t = {}.toString.call(n).slice(8, -1); return t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set" ? Array.from(n) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? uh(n, e) : void 0 } } var nC = "7.0.0", fh; try { var sC = require("@fortawesome/fontawesome-svg-core/package.json"); fh = sC.version } catch { fh = typeof process < "u" && W4.FA_VERSION || "7.0.0" } function iC(n) { var e = n.beat, t = n.fade, r = n.beatFade, s = n.bounce, i = n.shake, a = n.flash, o = n.spin, c = n.spinPulse, u = n.spinReverse, f = n.pulse, h = n.fixedWidth, p = n.inverse, v = n.border, g = n.listItem, y = n.flip, w = n.size, T = n.rotation, S = n.pull, E = n.swapOpacity, I = n.rotateBy, C = n.widthAuto, D = aC(fh, nC), R = us(us(us(us(us(us({ "fa-beat": e, "fa-fade": t, "fa-beat-fade": r, "fa-bounce": s, "fa-shake": i, "fa-flash": a, "fa-spin": o, "fa-spin-reverse": u, "fa-spin-pulse": c, "fa-pulse": f, "fa-fw": h, "fa-inverse": p, "fa-border": v, "fa-li": g, "fa-flip": y === !0, "fa-flip-horizontal": y === "horizontal" || y === "both", "fa-flip-vertical": y === "vertical" || y === "both" }, "fa-".concat(w), typeof w < "u" && w !== null), "fa-rotate-".concat(T), typeof T < "u" && T !== null && T !== 0), "fa-pull-".concat(S), typeof S < "u" && S !== null), "fa-swap-opacity", E), "fa-rotate-by", D && I), "fa-width-auto", D && C); return Object.keys(R).map(function (N) { return R[N] ? N : null }).filter(function (N) { return N }) } function aC(n, e) { for (var t = n.split("-"), r = $x(t, 2), s = r[0], i = r[1], a = e.split("-"), o = $x(a, 2), c = o[0], u = o[1], f = s.split("."), h = c.split("."), p = 0; p < Math.max(f.length, h.length); p++) { var v = f[p] || "0", g = h[p] || "0", y = parseInt(v, 10), w = parseInt(g, 10); if (y !== w) return y > w } for (var T = 0; T < Math.max(f.length, h.length); T++) { var S = f[T] || "0", E = h[T] || "0"; if (S !== E && S.length !== E.length) return S.length < E.length } return !(i && !u) } function oC(n) { return n = n - 0, n === n } function ib(n) { return oC(n) ? n : (n = n.replace(/[\-_\s]+(.)?/g, function (e, t) { return t ? t.toUpperCase() : "" }), n.substr(0, 1).toLowerCase() + n.substr(1)) } var lC = ["style"]; function cC(n) { return n.charAt(0).toUpperCase() + n.slice(1) } function uC(n) { return n.split(";").map(function (e) { return e.trim() }).filter(function (e) { return e }).reduce(function (e, t) { var r = t.indexOf(":"), s = ib(t.slice(0, r)), i = t.slice(r + 1).trim(); return s.startsWith("webkit") ? e[cC(s)] = i : e[s] = i, e }, {}) } function ab(n, e) { var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; if (typeof e == "string") return e; var r = (e.children || []).map(function (c) { return ab(n, c) }), s = Object.keys(e.attributes || {}).reduce(function (c, u) { var f = e.attributes[u]; switch (u) { case "class": c.attrs.className = f, delete e.attributes.class; break; case "style": c.attrs.style = uC(f); break; default: u.indexOf("aria-") === 0 || u.indexOf("data-") === 0 ? c.attrs[u.toLowerCase()] = f : c.attrs[ib(u)] = f }return c }, { attrs: {} }), i = t.style, a = i === void 0 ? {} : i, o = J4(t, lC); return s.attrs.style = nn(nn({}, s.attrs.style), a), n.apply(void 0, [e.tag, nn(nn({}, s.attrs), o)].concat(dh(r))) } var ob = !1; try { ob = !0 } catch { } function dC() { if (!ob && console && typeof console.error == "function") { var n; (n = console).error.apply(n, arguments) } } function Bx(n) { if (n && yc(n) === "object" && n.prefix && n.iconName && n.icon) return n; if (ch.icon) return ch.icon(n); if (n === null) return null; if (n && yc(n) === "object" && n.prefix && n.iconName) return n; if (Array.isArray(n) && n.length === 2) return { prefix: n[0], iconName: n[1] }; if (typeof n == "string") return { prefix: "fas", iconName: n } } function of(n, e) { return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? us({}, n, e) : {} } var Ux = { border: !1, className: "", mask: null, maskId: null, fixedWidth: !1, inverse: !1, flip: !1, icon: null, listItem: !1, pull: null, pulse: !1, rotation: null, rotateBy: !1, size: null, spin: !1, spinPulse: !1, spinReverse: !1, beat: !1, fade: !1, beatFade: !1, bounce: !1, shake: !1, symbol: !1, title: "", titleId: null, transform: null, swapOpacity: !1, widthAuto: !1 }, me = Qe.forwardRef(function (n, e) { var t = nn(nn({}, Ux), n), r = t.icon, s = t.mask, i = t.symbol, a = t.className, o = t.title, c = t.titleId, u = t.maskId, f = Bx(r), h = of("classes", [].concat(dh(iC(t)), dh((a || "").split(" ")))), p = of("transform", typeof t.transform == "string" ? ch.transform(t.transform) : t.transform), v = of("mask", Bx(s)), g = U4(f, nn(nn(nn(nn({}, h), p), v), {}, { symbol: i, title: o, titleId: c, maskId: u })); if (!g) return dC("Could not find icon", f), null; var y = g.abstract, w = { ref: e }; return Object.keys(t).forEach(function (T) { Ux.hasOwnProperty(T) || (w[T] = t[T]) }), fC(y[0], w) }); me.displayName = "FontAwesomeIcon"; me.propTypes = { beat: Fe.bool, border: Fe.bool, beatFade: Fe.bool, bounce: Fe.bool, className: Fe.string, fade: Fe.bool, flash: Fe.bool, mask: Fe.oneOfType([Fe.object, Fe.array, Fe.string]), maskId: Fe.string, fixedWidth: Fe.bool, inverse: Fe.bool, flip: Fe.oneOf([!0, !1, "horizontal", "vertical", "both"]), icon: Fe.oneOfType([Fe.object, Fe.array, Fe.string]), listItem: Fe.bool, pull: Fe.oneOf(["right", "left"]), pulse: Fe.bool, rotation: Fe.oneOf([0, 90, 180, 270]), rotateBy: Fe.bool, shake: Fe.bool, size: Fe.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]), spin: Fe.bool, spinPulse: Fe.bool, spinReverse: Fe.bool, symbol: Fe.oneOfType([Fe.bool, Fe.string]), title: Fe.string, titleId: Fe.string, transform: Fe.oneOfType([Fe.string, Fe.object]), swapOpacity: Fe.bool, widthAuto: Fe.bool }; var fC = ab.bind(null, Qe.createElement);/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */const hC = { prefix: "fas", iconName: "info", icon: [192, 512, [], "f129", "M48 80a48 48 0 1 1 96 0A48 48 0 1 1 48 80zM0 224c0-17.7 14.3-32 32-32l64 0c17.7 0 32 14.3 32 32l0 224 32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 512c-17.7 0-32-14.3-32-32s14.3-32 32-32l32 0 0-192-32 0c-17.7 0-32-14.3-32-32z"] }, pC = { prefix: "fas", iconName: "backward", icon: [512, 512, [9194], "f04a", "M459.5 440.6c9.5 7.9 22.8 9.7 34.1 4.4s18.4-16.6 18.4-29l0-320c0-12.4-7.2-23.7-18.4-29s-24.5-3.6-34.1 4.4L288 214.3l0 41.7 0 41.7L459.5 440.6zM256 352l0-96 0-128 0-32c0-12.4-7.2-23.7-18.4-29s-24.5-3.6-34.1 4.4l-192 160C4.2 237.5 0 246.5 0 256s4.2 18.5 11.5 24.6l192 160c9.5 7.9 22.8 9.7 34.1 4.4s18.4-16.6 18.4-29l0-64z"] }, mC = { prefix: "fas", iconName: "bars", icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"] }, lb = { prefix: "fas", iconName: "film", icon: [512, 512, [127902], "f008", "M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM48 368l0 32c0 8.8 7.2 16 16 16l32 0c8.8 0 16-7.2 16-16l0-32c0-8.8-7.2-16-16-16l-32 0c-8.8 0-16 7.2-16 16zm368-16c-8.8 0-16 7.2-16 16l0 32c0 8.8 7.2 16 16 16l32 0c8.8 0 16-7.2 16-16l0-32c0-8.8-7.2-16-16-16l-32 0zM48 240l0 32c0 8.8 7.2 16 16 16l32 0c8.8 0 16-7.2 16-16l0-32c0-8.8-7.2-16-16-16l-32 0c-8.8 0-16 7.2-16 16zm368-16c-8.8 0-16 7.2-16 16l0 32c0 8.8 7.2 16 16 16l32 0c8.8 0 16-7.2 16-16l0-32c0-8.8-7.2-16-16-16l-32 0zM48 112l0 32c0 8.8 7.2 16 16 16l32 0c8.8 0 16-7.2 16-16l0-32c0-8.8-7.2-16-16-16L64 96c-8.8 0-16 7.2-16 16zM416 96c-8.8 0-16 7.2-16 16l0 32c0 8.8 7.2 16 16 16l32 0c8.8 0 16-7.2 16-16l0-32c0-8.8-7.2-16-16-16l-32 0zM160 128l0 64c0 17.7 14.3 32 32 32l128 0c17.7 0 32-14.3 32-32l0-64c0-17.7-14.3-32-32-32L192 96c-17.7 0-32 14.3-32 32zm32 160c-17.7 0-32 14.3-32 32l0 64c0 17.7 14.3 32 32 32l128 0c17.7 0 32-14.3 32-32l0-64c0-17.7-14.3-32-32-32l-128 0z"] }, gC = { prefix: "fas", iconName: "compress", icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"] }, xC = { prefix: "fas", iconName: "list", icon: [512, 512, ["list-squares"], "f03a", "M40 48C26.7 48 16 58.7 16 72l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24L40 48zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM16 232l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24zM40 368c-13.3 0-24 10.7-24 24l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0z"] }, vC = { prefix: "fas", iconName: "eye-slash", icon: [640, 512, [], "f070", "M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c8.4-19.3 10.6-41.4 4.8-63.3c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zM373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5L373 389.9z"] }, yC = { prefix: "fas", iconName: "bookmark", icon: [384, 512, [128278, 61591], "f02e", "M0 48V487.7C0 501.1 10.9 512 24.3 512c5 0 9.9-1.5 14-4.4L192 400 345.7 507.6c4.1 2.9 9 4.4 14 4.4c13.4 0 24.3-10.9 24.3-24.3V48c0-26.5-21.5-48-48-48H48C21.5 0 0 21.5 0 48z"] }, sp = { prefix: "fas", iconName: "star", icon: [576, 512, [11088, 61446], "f005", "M316.9 18C311.6 7 300.4 0 288.1 0s-23.4 7-28.8 18L195 150.3 51.4 171.5c-12 1.8-22 10.2-25.7 21.7s-.7 24.2 7.9 32.7L137.8 329 113.2 474.7c-2 12 3 24.2 12.9 31.3s23 8 33.8 2.3l128.3-68.5 128.3 68.5c10.8 5.7 23.9 4.9 33.8-2.3s14.9-19.3 12.9-31.3L438.5 329 542.7 225.9c8.6-8.5 11.7-21.2 7.9-32.7s-13.7-19.9-25.7-21.7L381.2 150.3 316.9 18z"] }, bC = { prefix: "fas", iconName: "shuffle", icon: [512, 512, [128256, "random"], "f074", "M403.8 34.4c12-5 25.7-2.2 34.9 6.9l64 64c6 6 9.4 14.1 9.4 22.6s-3.4 16.6-9.4 22.6l-64 64c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6l0-32-32 0c-10.1 0-19.6 4.7-25.6 12.8L284 229.3 244 176l31.2-41.6C293.3 110.2 321.8 96 352 96l32 0 0-32c0-12.9 7.8-24.6 19.8-29.6zM164 282.7L204 336l-31.2 41.6C154.7 401.8 126.2 416 96 416l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64 0c10.1 0 19.6-4.7 25.6-12.8L164 282.7zm274.6 188c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6l0-32-32 0c-30.2 0-58.7-14.2-76.8-38.4L121.6 172.8c-6-8.1-15.5-12.8-25.6-12.8l-64 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l64 0c30.2 0 58.7 14.2 76.8 38.4L326.4 339.2c6 8.1 15.5 12.8 25.6 12.8l32 0 0-32c0-12.9 7.8-24.6 19.8-29.6s25.7-2.2 34.9 6.9l64 64c6 6 9.4 14.1 9.4 22.6s-3.4 16.6-9.4 22.6l-64 64z"] }, ip = bC, cb = { prefix: "fas", iconName: "fire", icon: [448, 512, [128293], "f06d", "M159.3 5.4c7.8-7.3 19.9-7.2 27.7 .1c27.6 25.9 53.5 53.8 77.7 84c11-14.4 23.5-30.1 37-42.9c7.9-7.4 20.1-7.4 28 .1c34.6 33 63.9 76.6 84.5 118c20.3 40.8 33.8 82.5 33.8 111.9C448 404.2 348.2 512 224 512C98.4 512 0 404.1 0 276.5c0-38.4 17.8-85.3 45.4-131.7C73.3 97.7 112.7 48.6 159.3 5.4zM225.7 416c25.3 0 47.7-7 68.8-21c42.1-29.4 53.4-88.2 28.1-134.4c-4.5-9-16-9.6-22.5-2l-25.2 29.3c-6.6 7.6-18.5 7.4-24.7-.5c-16.5-21-46-58.5-62.8-79.8c-6.3-8-18.3-8.1-24.7-.1c-33.8 42.5-50.8 69.3-50.8 99.4C112 375.4 162.6 416 225.7 416z"] }, On = { prefix: "fas", iconName: "microphone", icon: [384, 512, [], "f130", "M192 0C139 0 96 43 96 96l0 160c0 53 43 96 96 96s96-43 96-96l0-160c0-53-43-96-96-96zM64 216c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40c0 89.1 66.2 162.7 152 174.4l0 33.6-48 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l72 0 72 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-48 0 0-33.6c85.8-11.7 152-85.3 152-174.4l0-40c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40c0 70.7-57.3 128-128 128s-128-57.3-128-128l0-40z"] }, wC = { prefix: "fas", iconName: "angles-right", icon: [512, 512, [187, "angle-double-right"], "f101", "M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"] }, SC = wC, hh = { prefix: "fas", iconName: "circle-play", icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"] }, EC = { prefix: "fas", iconName: "circle-check", icon: [512, 512, [61533, "check-circle"], "f058", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM369 209L241 337c-9.4 9.4-24.6 9.4-33.9 0l-64-64c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l47 47L335 175c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9z"] }, TC = EC, AC = { prefix: "fas", iconName: "filter", icon: [512, 512, [], "f0b0", "M3.9 54.9C10.5 40.9 24.5 32 40 32l432 0c15.5 0 29.5 8.9 36.1 22.9s4.6 30.5-5.2 42.5L320 320.9 320 448c0 12.1-6.8 23.2-17.7 28.6s-23.8 4.3-33.5-3l-64-48c-8.1-6-12.8-15.5-12.8-25.6l0-79.1L9 97.3C-.7 85.4-2.8 68.8 3.9 54.9z"] }, IC = { prefix: "fas", iconName: "heart", icon: [512, 512, [128153, 128154, 128155, 128156, 128420, 129293, 129294, 129505, 9829, 10084, 61578], "f004", "M47.6 300.4L228.3 469.1c7.5 7 17.4 10.9 27.7 10.9s20.2-3.9 27.7-10.9L464.4 300.4c30.4-28.3 47.6-68 47.6-109.5v-5.8c0-69.9-50.5-129.5-119.4-141C347 36.5 300.6 51.4 268 84L256 96 244 84c-32.6-32.6-79-47.5-124.6-39.9C50.5 55.6 0 115.2 0 185.1v5.8c0 41.5 17.2 81.2 47.6 109.5z"] }, ph = { prefix: "fas", iconName: "eye", icon: [576, 512, [128065], "f06e", "M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"] }, zx = { prefix: "fas", iconName: "trash", icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z"] }, LC = { prefix: "fas", iconName: "envelope", icon: [512, 512, [128386, 9993, 61443], "f0e0", "M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48L48 64zM0 176L0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-208L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"] }, ap = { prefix: "fas", iconName: "clock", icon: [512, 512, [128339, "clock-four"], "f017", "M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"] }, Mn = { prefix: "fas", iconName: "closed-captioning", icon: [576, 512, [], "f20a", "M0 96C0 60.7 28.7 32 64 32l448 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM200 208c14.2 0 27 6.1 35.8 16c8.8 9.9 24 10.7 33.9 1.9s10.7-24 1.9-33.9c-17.5-19.6-43.1-32-71.5-32c-53 0-96 43-96 96s43 96 96 96c28.4 0 54-12.4 71.5-32c8.8-9.9 8-25-1.9-33.9s-25-8-33.9 1.9c-8.8 9.9-21.6 16-35.8 16c-26.5 0-48-21.5-48-48s21.5-48 48-48zm144 48c0-26.5 21.5-48 48-48c14.2 0 27 6.1 35.8 16c8.8 9.9 24 10.7 33.9 1.9s10.7-24 1.9-33.9c-17.5-19.6-43.1-32-71.5-32c-53 0-96 43-96 96s43 96 96 96c28.4 0 54-12.4 71.5-32c8.8-9.9 8-25-1.9-33.9s-25-8-33.9 1.9c-8.8 9.9-21.6 16-35.8 16c-26.5 0-48-21.5-48-48z"] }, CC = { prefix: "fas", iconName: "forward", icon: [512, 512, [9193], "f04e", "M52.5 440.6c-9.5 7.9-22.8 9.7-34.1 4.4S0 428.4 0 416L0 96C0 83.6 7.2 72.3 18.4 67s24.5-3.6 34.1 4.4L224 214.3l0 41.7 0 41.7L52.5 440.6zM256 352l0-96 0-128 0-32c0-12.4 7.2-23.7 18.4-29s24.5-3.6 34.1 4.4l192 160c7.3 6.1 11.5 15.1 11.5 24.6s-4.2 18.5-11.5 24.6l-192 160c-9.5 7.9-22.8 9.7-34.1 4.4s-18.4-16.6-18.4-29l0-64z"] }, kC = { prefix: "fas", iconName: "house", icon: [576, 512, [127968, 63498, 63500, "home", "home-alt", "home-lg-alt"], "f015", "M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"] }, RC = kC, _C = { prefix: "fas", iconName: "angle-down", icon: [448, 512, [8964], "f107", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"] }, PC = { prefix: "fas", iconName: "file", icon: [384, 512, [128196, 128459, 61462], "f15b", "M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 288c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128z"] }, Xt = { prefix: "fas", iconName: "play", icon: [384, 512, [9654], "f04b", "M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80L0 432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"] }, po = { prefix: "fas", iconName: "magnifying-glass", icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"] }, Vx = { prefix: "fas", iconName: "file-pen", icon: [576, 512, [128221, "file-edit"], "f31c", "M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 125.7-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9 0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6 0zM311.9 417L441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"] }, NC = { prefix: "fas", iconName: "tv", icon: [640, 512, [63717, "television", "tv-alt"], "f26c", "M64 64l0 288 512 0 0-288L64 64zM0 64C0 28.7 28.7 0 64 0L576 0c35.3 0 64 28.7 64 64l0 288c0 35.3-28.7 64-64 64L64 416c-35.3 0-64-28.7-64-64L0 64zM128 448l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-384 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"] }, DC = { prefix: "fas", iconName: "expand", icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"] }, OC = { prefix: "fas", iconName: "xmark", icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"] }, MC = { prefix: "fas", iconName: "chevron-left", icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"] }, jC = { prefix: "fas", iconName: "chevron-right", icon: [320, 512, [9002], "f054", "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"] }, FC = { prefix: "fas", iconName: "angles-left", icon: [512, 512, [171, "angle-double-left"], "f100", "M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"] }, $C = FC, BC = { prefix: "fas", iconName: "clock-rotate-left", icon: [512, 512, ["history"], "f1da", "M75 75L41 41C25.9 25.9 0 36.6 0 57.9L0 168c0 13.3 10.7 24 24 24l110.1 0c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24l0 104c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65 0-94.1c0-13.3-10.7-24-24-24z"] }, mh = BC, ub = { prefix: "fas", iconName: "calendar", icon: [448, 512, [128197, 128198], "f133", "M96 32l0 32L48 64C21.5 64 0 85.5 0 112l0 48 448 0 0-48c0-26.5-21.5-48-48-48l-48 0 0-32c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 32L160 64l0-32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192L0 192 0 464c0 26.5 21.5 48 48 48l352 0c26.5 0 48-21.5 48-48l0-272z"] }, db = { prefix: "fas", iconName: "check", icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"] }, UC = { prefix: "fas", iconName: "share", icon: [512, 512, ["mail-forward"], "f064", "M307 34.8c-11.5 5.1-19 16.6-19 29.2l0 64-112 0C78.8 128 0 206.8 0 304C0 417.3 81.5 467.9 100.2 478.1c2.5 1.4 5.3 1.9 8.1 1.9c10.9 0 19.7-8.9 19.7-19.7c0-7.5-4.3-14.4-9.8-19.5C108.8 431.9 96 414.4 96 384c0-53 43-96 96-96l96 0 0 64c0 12.6 7.4 24.1 19 29.2s25 3 34.4-5.4l160-144c6.7-6.1 10.6-14.7 10.6-23.8s-3.8-17.7-10.6-23.8l-160-144c-9.4-8.5-22.9-10.6-34.4-5.4z"] }, zC = { prefix: "fas", iconName: "paper-plane", icon: [512, 512, [61913], "f1d8", "M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480l0-83.6c0-4 1.5-7.8 4.2-10.8L331.8 202.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8 17.7 316.6C7.1 311.3 .3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4z"] }; function VC({ item: n, index: e }) { const { language: t } = pn(); return x.jsxs("section", { className: "spotlight w-full h-full relative rounded-2xl overflow-hidden", children: [x.jsx("img", { src: `${n.poster}`, alt: n.title, loading: "eager", className: "absolute inset-0 object-cover w-full h-full rounded-2xl smooth-transition" }), x.jsx("div", { className: "spotlight-overlay absolute inset-0 z-[1] rounded-2xl" }), x.jsxs("div", { className: "absolute flex flex-col left-0 bottom-[40px] w-[55%] p-4 z-[2] max-[1390px]:w-[45%] max-[1390px]:bottom-[40px] max-[1300px]:w-[600px] max-[1120px]:w-[60%] max-md:w-[90%] max-md:bottom-[20px] max-[300px]:w-full spotlight-content-animate", children: [x.jsxs("p", { className: "text-[#ffbade] font-semibold text-[20px] w-fit max-[1300px]:text-[15px] animate-fade-in-up stagger-1 animate-stagger spotlight-tag", children: ["#", e + 1, " Spotlight"] }), x.jsx("h3", { className: "text-white line-clamp-2 text-5xl font-bold mt-4 text-left max-[1390px]:text-[45px] max-[1300px]:text-3xl max-[1300px]:mt-3 max-md:text-2xl max-md:mt-1 max-[575px]:text-[22px] max-sm:leading-6 max-sm:w-[80%] max-[320px]:w-full animate-fade-in-up stagger-2 animate-stagger spotlight-title", children: t === "EN" ? n.title : n.japanese_title }), x.jsxs("div", { className: "hidden max-md:flex max-md:mt-3 max-md:gap-x-3 max-md:w-full animate-fade-in-up stagger-3 animate-stagger", children: [x.jsxs(We, { to: `/watch/${n.id}`, className: "bg-white/90 hover:bg-white text-black font-medium px-5 py-1.5 rounded-lg smooth-transition hover-scale hover-glow flex items-center gap-x-2 text-sm", children: [x.jsx(me, { icon: Xt, className: "text-[10px]" }), x.jsx("span", { children: "Watch Now" })] }), x.jsx(We, { to: `/${n.id}`, className: "bg-white/5 hover:bg-white/10 border border-white/10 hover:border-white/20 text-white font-medium px-5 py-1.5 rounded-lg smooth-transition hover-scale hover-glow flex items-center gap-x-2 text-sm", children: x.jsx("span", { children: "Details" }) })] }), x.jsx("div", { className: "flex h-fit justify-start items-center w-fit space-x-5 mt-5 max-[1300px]:mt-4 max-md:hidden", children: n.tvInfo && x.jsxs(x.Fragment, { children: [n.tvInfo.showType && x.jsxs("div", { className: "flex space-x-1 justify-center items-center", children: [x.jsx(me, { icon: Xt, className: "text-[8px] bg-white/10 text-white px-[4px] py-[3px] rounded-full" }), x.jsx("p", { className: "text-white/70 text-[16px]", children: n.tvInfo.showType })] }), n.tvInfo.duration && x.jsxs("div", { className: "flex space-x-1 justify-center items-center", children: [x.jsx(me, { icon: ap, className: "text-white/70 text-[14px]" }), x.jsx("p", { className: "text-white/70 text-[17px]", children: n.tvInfo.duration })] }), n.tvInfo.releaseDate && x.jsxs("div", { className: "flex space-x-1 justify-center items-center", children: [x.jsx(me, { icon: ub, className: "text-white/70 text-[14px]" }), x.jsx("p", { className: "text-white/70 text-[16px]", children: n.tvInfo.releaseDate })] }), x.jsxs("div", { className: "flex space-x-3 w-fit", children: [n.tvInfo.quality && x.jsx("div", { className: "bg-white/10 py-[1px] px-[6px] rounded-md w-fit text-[11px] font-bold h-fit text-white", children: n.tvInfo.quality }), x.jsxs("div", { className: "flex space-x-[1px] rounded-r-[5px] rounded-l-[5px] w-fit py-[1px] overflow-hidden", children: [n.tvInfo.episodeInfo?.sub && x.jsxs("div", { className: "flex space-x-1 justify-center items-center bg-white/10 px-[4px]", children: [x.jsx(me, { icon: Mn, className: "text-[12px] text-white" }), x.jsx("p", { className: "text-[12px] font-bold text-white", children: n.tvInfo.episodeInfo.sub })] }), n.tvInfo.episodeInfo?.dub && x.jsxs("div", { className: "flex space-x-1 justify-center items-center bg-white/20 px-[4px]", children: [x.jsx(me, { icon: On, className: "text-[12px] text-white" }), x.jsx("p", { className: "text-[12px] font-semibold text-white", children: n.tvInfo.episodeInfo.dub })] })] })] })] }) }), x.jsx("p", { className: "text-white/70 text-[17px] font-sm mt-4 text-left line-clamp-3 max-[1200px]:line-clamp-2 max-[1300px]:w-[500px] max-[1120px]:w-[90%] max-md:hidden", children: n.description })] }), x.jsxs("div", { className: "absolute bottom-[50px] right-[40px] flex gap-x-5 z-[2] max-md:hidden", children: [x.jsxs(We, { to: `/watch/${n.id}`, className: "bg-white/90 hover:bg-white text-black font-medium px-7 py-2 rounded-lg transition-all duration-200 flex items-center gap-x-2.5 shadow-lg shadow-black/10 backdrop-blur-sm hover:translate-y-[-1px]", children: [x.jsx(me, { icon: Xt, className: "text-[10px]" }), x.jsx("span", { children: "Watch Now" })] }), x.jsx(We, { to: `/${n.id}`, className: "bg-white/5 hover:bg-white/10 border border-white/10 hover:border-white/20 text-white font-medium px-7 py-2 rounded-lg transition-all duration-200 flex items-center gap-x-2.5 backdrop-blur-sm hover:translate-y-[-1px]", children: x.jsx("span", { children: "Details" }) })] })] }) } const GC = ({ spotlights: n }) => x.jsx(x.Fragment, { children: x.jsx("div", { className: "relative h-[480px] max-[1390px]:h-[420px] max-[1300px]:h-[370px] max-md:h-[320px] pt-[20px] animate-fade-in-scale spotlight-entrance", children: n && n.length > 0 ? x.jsx(x.Fragment, { children: x.jsxs($c, { spaceBetween: 0, slidesPerView: 1, loop: !0, allowTouchMove: !0, navigation: { nextEl: ".button-next", prevEl: ".button-prev" }, pagination: { clickable: !0, dynamicBullets: !1 }, autoplay: { delay: 5e3, disableOnInteraction: !1, pauseOnMouseEnter: !0 }, speed: 1200, effect: "fade", fadeEffect: { crossFade: !0 }, modules: [Wh, M3, T1, B3], className: "h-[480px] max-[1390px]:h-full rounded-3xl overflow-hidden relative shadow-2xl spotlight-swiper", style: { "--swiper-pagination-bullet-inactive-color": "rgba(255, 255, 255, 0.4)", "--swiper-pagination-bullet-inactive-opacity": "1" }, children: [x.jsxs("div", { className: "absolute right-[20px] top-[20px] flex space-x-2 z-[5] animate-fade-in stagger-1 animate-stagger", children: [x.jsx("div", { className: "button-prev hover-scale" }), x.jsx("div", { className: "button-next hover-scale" })] }), n.map((e, t) => x.jsx(Bc, { className: "text-black relative group spotlight-slide", children: x.jsx(VC, { item: e, index: t }) }, t))] }) }) : x.jsx("div", { className: "flex items-center justify-center h-full bg-gradient-to-br from-gray-900 to-gray-800 rounded-3xl", children: x.jsx("p", { className: "text-white/60 text-lg", children: "No spotlights to show." }) }) }) }); var fb = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, Gx = Qe.createContext && Qe.createContext(fb), HC = ["attr", "size", "title"]; function WC(n, e) { if (n == null) return {}; var t = KC(n, e), r, s; if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(n); for (s = 0; s < i.length; s++)r = i[s], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]) } return t } function KC(n, e) { if (n == null) return {}; var t = {}; for (var r in n) if (Object.prototype.hasOwnProperty.call(n, r)) { if (e.indexOf(r) >= 0) continue; t[r] = n[r] } return t } function bc() { return bc = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, bc.apply(this, arguments) } function Hx(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(n, s).enumerable })), t.push.apply(t, r) } return t } function wc(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? Hx(Object(t), !0).forEach(function (r) { qC(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Hx(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function qC(n, e, t) { return e = YC(e), e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function YC(n) { var e = XC(n, "string"); return typeof e == "symbol" ? e : e + "" } function XC(n, e) { if (typeof n != "object" || !n) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var r = t.call(n, e); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function hb(n) { return n && n.map((e, t) => Qe.createElement(e.tag, wc({ key: t }, e.attr), hb(e.child))) } function op(n) { return e => Qe.createElement(QC, bc({ attr: wc({}, n.attr) }, e), hb(n.child)) } function QC(n) { var e = t => { var { attr: r, size: s, title: i } = n, a = WC(n, HC), o = s || t.size || "1em", c; return t.className && (c = t.className), n.className && (c = (c ? c + " " : "") + n.className), Qe.createElement("svg", bc({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, t.attr, r, a, { className: c, style: wc(wc({ color: n.color || t.color }, t.style), n.style), height: o, width: o, xmlns: "http://www.w3.org/2000/svg" }), i && Qe.createElement("title", null, i), n.children) }; return Gx !== void 0 ? Qe.createElement(Gx.Consumer, null, t => e(t)) : e(fb) } function Wc(n) { return op({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z" }, child: [] }] })(n) } function Hi(n) { return op({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z" }, child: [] }] })(n) } function ZC(n) { return op({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M504 255.531c.253 136.64-111.18 248.372-247.82 248.468-59.015.042-113.223-20.53-155.822-54.911-11.077-8.94-11.905-25.541-1.839-35.607l11.267-11.267c8.609-8.609 22.353-9.551 31.891-1.984C173.062 425.135 212.781 440 256 440c101.705 0 184-82.311 184-184 0-101.705-82.311-184-184-184-48.814 0-93.149 18.969-126.068 49.932l50.754 50.754c10.08 10.08 2.941 27.314-11.313 27.314H24c-8.837 0-16-7.163-16-16V38.627c0-14.254 17.234-21.393 27.314-11.314l49.372 49.372C129.209 34.136 189.552 8 256 8c136.81 0 247.747 110.78 248 247.531zm-180.912 78.784l9.823-12.63c8.138-10.463 6.253-25.542-4.21-33.679L288 256.349V152c0-13.255-10.745-24-24-24h-16c-13.255 0-24 10.745-24 24v135.651l65.409 50.874c10.463 8.137 25.541 6.253 33.679-4.21z" }, child: [] }] })(n) } const lp = (n = {}) => { const e = j.useRef(null), [t, r] = j.useState(!1), [s, i] = j.useState(!1), a = { threshold: .1, rootMargin: "50px", triggerOnce: !0, ...n }; return j.useEffect(() => { const o = e.current; if (!o) return; const c = new IntersectionObserver(u => { u.forEach(f => { f.isIntersecting ? (r(!0), a.triggerOnce && !s && i(!0)) : a.triggerOnce || r(!1) }) }, { threshold: a.threshold, rootMargin: a.rootMargin }); return c.observe(o), () => { o && c.unobserve(o) } }, [a.threshold, a.rootMargin, a.triggerOnce, s]), { elementRef: e, isVisible: a.triggerOnce && s || t, hasAnimated: s } }, Es = Qe.memo(({ label: n, data: e, showViewMore: t = !0, className: r, categoryPage: s = !1, cardStyle: i, path: a, limit: o }) => {
    const { language: c } = pn(), u = _r(); o && (e = e.slice(0, o)); const [f, h] = j.useState({ firstRow: [], remainingItems: [] }), p = j.useCallback(() => { if (s) { const y = window.innerWidth > 758 && e.length > 4 ? e.slice(0, 4) : [], w = window.innerWidth > 758 && e.length > 4 ? e.slice(4) : e.slice(0); return { firstRow: y, remainingItems: w } } return { firstRow: [], remainingItems: e.slice(0) } }, [s, e]); j.useEffect(() => { const y = () => { h(p()) }, w = p(); return h(T => JSON.stringify(T.firstRow) !== JSON.stringify(w.firstRow) || JSON.stringify(T.remainingItems) !== JSON.stringify(w.remainingItems) ? w : T), window.addEventListener("resize", y), () => { window.removeEventListener("resize", y) } }, [p]); const { elementRef: v, isVisible: g } = lp({ threshold: .1, rootMargin: "100px" }); return x.jsxs("div", {
      ref: v, className: `w-full ${r} ${g ? "scroll-animate animate-in" : "scroll-animate"}`, children: [x.jsxs("div", {
        className: "flex items-center justify-between mb-8", children: [x.jsx("h1", { className: "font-semibold text-2xl text-white max-[478px]:text-[18px] capitalize tracking-wide", children: n }), t && x.jsxs(We, {
          to: `/${a}`, className: `flex items-center gap-x-1 py-1 px-2 -mr-2 rounded-md
                text-[13px] font-medium text-[#ffffff80] hover:text-white
                transition-all duration-300 group`, children: ["View all", x.jsx(Hi, {
            className: `text-[10px] transform transition-transform duration-300 
                group-hover:translate-x-0.5`})]
        })]
      }), x.jsxs(x.Fragment, { children: [s && x.jsx("div", { className: `grid grid-cols-4 gap-x-3 gap-y-8 transition-all duration-300 ease-in-out ${s && f.firstRow.length > 0 ? "mt-8 max-[758px]:hidden" : ""}`, children: f.firstRow.map((y, w) => x.jsxs("div", { className: `flex flex-col category-card-container ${g ? `scroll-slide-up scroll-stagger-${Math.min(w + 1, 6)}` : "opacity-0"}`, style: { height: "fit-content" }, children: [x.jsxs("div", { className: "w-full h-auto pb-[140%] relative inline-block overflow-hidden rounded-lg shadow-lg group", children: [x.jsxs("div", { className: "inline-block bg-gray-900 absolute left-0 top-0 w-full h-full group hover:cursor-pointer", onClick: () => u(`${a === "top-upcoming" ? `/${y.id}` : `/watch/${y.id}`}`), children: [x.jsx("img", { src: `${y.poster}`, alt: y.title, loading: "lazy", className: "block w-full h-full object-cover smooth-transition-slow group-hover:scale-105 group-hover:blur-sm" }), x.jsx("div", { className: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-all duration-300 flex items-center justify-center", children: x.jsx("div", { className: "transform translate-y-4 group-hover:translate-y-0 transition-transform duration-300", children: x.jsx(me, { icon: Xt, className: "text-[50px] text-white drop-shadow-lg max-[450px]:text-[36px]" }) }) })] }), (y.tvInfo?.rating === "18+" || y?.adultContent === !0) && x.jsx("div", { className: "text-white px-2 py-0.5 rounded-lg bg-red-600 absolute top-3 left-3 flex items-center justify-center text-[12px] font-bold", children: "18+" }), x.jsx("div", { className: "absolute bottom-0 left-0 right-0 p-3 pb-2 bg-gradient-to-t from-black/80 via-black/50 to-transparent", children: x.jsxs("div", { className: "flex items-center justify-start w-full space-x-1.5 z-[100] flex-wrap gap-y-1.5", children: [y.tvInfo?.sub && x.jsxs("div", { className: "flex space-x-0.5 justify-center items-center bg-[#2a2a2a] rounded-[2px] px-2 text-white py-1", children: [x.jsx(me, { icon: Mn, className: "text-[11px]" }), x.jsx("p", { className: "text-[11px] font-medium", children: y.tvInfo.sub })] }), y.tvInfo?.dub && x.jsxs("div", { className: "flex space-x-0.5 justify-center items-center bg-[#2a2a2a] rounded-[2px] px-2 text-white py-1", children: [x.jsx(me, { icon: On, className: "text-[11px]" }), x.jsx("p", { className: "text-[11px] font-medium", children: y.tvInfo.dub })] }), y.tvInfo?.showType && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-2 py-1 text-[11px] font-medium", children: y.tvInfo.showType.split(" ").shift() }), y.releaseDate && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-2 py-1 text-[11px] font-medium", children: y.releaseDate }), !y.tvInfo?.showType && y.type && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-2 py-1 text-[11px] font-medium", children: y.type }), (y.tvInfo?.duration || y.duration) && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-2 py-1 text-[11px] font-medium", children: y.tvInfo?.duration === "m" || y.tvInfo?.duration === "?" || y.duration === "m" || y.duration === "?" ? "N/A" : y.tvInfo?.duration || y.duration || "N/A" })] }) })] }), x.jsx(We, { to: `/${y.id}`, className: "text-white font-semibold mt-3 item-title hover:text-white hover:cursor-pointer line-clamp-1", children: c === "EN" ? y.title : y.japanese_title }), y.description && x.jsx("div", { className: "line-clamp-3 text-[13px] font-light text-gray-400 mt-3 max-[1200px]:hidden", children: y.description })] }, w)) }), x.jsx("div", { className: `grid ${i || "grid-cols-6 max-[1400px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3"} gap-x-3 gap-y-8 mt-6 transition-all duration-300 ease-in-out max-[478px]:gap-x-2`, children: f.remainingItems.map((y, w) => x.jsxs("div", { className: `flex flex-col transition-transform duration-300 ease-in-out ${g ? `scroll-slide-up scroll-stagger-${Math.min(w % 6 + 1, 6)}` : "opacity-0"}`, style: { height: "fit-content" }, children: [x.jsxs("div", { className: "w-full h-auto pb-[140%] relative inline-block overflow-hidden rounded-lg shadow-lg group", children: [x.jsxs("div", { className: "inline-block bg-gray-900 absolute left-0 top-0 w-full h-full group hover:cursor-pointer", onClick: () => u(`${a === "top-upcoming" ? `/${y.id}` : `/watch/${y.id}`}`), children: [x.jsx("img", { src: `${y.poster}`, alt: y.title, className: "block w-full h-full object-cover transition-all duration-500 ease-in-out group-hover:scale-105 group-hover:blur-sm" }), x.jsx("div", { className: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-all duration-300 flex items-center justify-center", children: x.jsx("div", { className: "transform translate-y-4 group-hover:translate-y-0 transition-transform duration-300", children: x.jsx(me, { icon: Xt, className: "text-[50px] text-white drop-shadow-lg max-[450px]:text-[36px]" }) }) })] }), (y.tvInfo?.rating === "18+" || y?.adultContent === !0) && x.jsx("div", { className: "text-white px-2 py-0.5 rounded-lg bg-red-600 absolute top-3 left-3 flex items-center justify-center text-[12px] font-bold", children: "18+" }), x.jsx("div", { className: "absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 via-black/50 to-transparent", children: x.jsxs("div", { className: "flex items-center justify-start w-full space-x-1 max-[478px]:space-x-0.5 z-[100] flex-wrap gap-y-1", children: [y.tvInfo?.sub && x.jsxs("div", { className: "flex space-x-0.5 justify-center items-center bg-[#2a2a2a] rounded-[2px] px-1.5 text-white py-0.5 max-[478px]:py-0.5 max-[478px]:px-1", children: [x.jsx(me, { icon: Mn, className: "text-[10px]" }), x.jsx("p", { className: "text-[10px] font-medium", children: y.tvInfo.sub })] }), y.tvInfo?.dub && x.jsxs("div", { className: "flex space-x-0.5 justify-center items-center bg-[#2a2a2a] rounded-[2px] px-1.5 text-white py-0.5 max-[478px]:py-0.5 max-[478px]:px-1", children: [x.jsx(me, { icon: On, className: "text-[10px]" }), x.jsx("p", { className: "text-[10px] font-medium", children: y.tvInfo.dub })] }), y.tvInfo?.showType && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-1.5 py-0.5 text-[10px] font-medium max-[478px]:py-0.5 max-[478px]:px-1 max-[478px]:hidden", children: y.tvInfo.showType.split(" ").shift() }), y.releaseDate && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-1.5 py-0.5 text-[10px] font-medium max-[478px]:py-0.5 max-[478px]:px-1", children: y.releaseDate }), !y.tvInfo?.showType && y.type && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-1.5 py-0.5 text-[10px] font-medium max-[478px]:py-0.5 max-[478px]:px-1", children: y.type }), (y.tvInfo?.duration || y.duration) && x.jsx("div", { className: "bg-[#2a2a2a] text-white rounded-[2px] px-1.5 py-0.5 text-[10px] font-medium max-[478px]:py-0.5 max-[478px]:px-1 max-[478px]:hidden", children: y.tvInfo?.duration === "m" || y.tvInfo?.duration === "?" || y.duration === "m" || y.duration === "?" ? "N/A" : y.tvInfo?.duration || y.duration || "N/A" })] }) })] }), x.jsx(We, { to: `/${y.id}`, className: "text-white font-semibold mt-3 item-title hover:text-white hover:cursor-pointer line-clamp-1", children: c === "EN" ? y.title : y.japanese_title })] }, w)) })] })]
    })
  }); Es.displayName = "CategoryCard"; const JC = ({ trending: n, topten: e, className: t }) => { const { language: r } = pn(), [s, i] = j.useState("trending"), [a, o] = j.useState("today"), { elementRef: c, isVisible: u } = lp({ threshold: .1, rootMargin: "50px" }), f = g => { i(g) }, h = g => { o(g) }, v = s === "trending" ? n || [] : s === "topten" && e ? a === "today" ? e.today || [] : a === "week" ? e.week || [] : e.month || [] : []; return x.jsxs("div", { ref: c, className: `bg-black rounded-xl p-4 border border-white/5 hover-lift ${u ? "scroll-fade-right" : "opacity-0"} ${t}`, children: [x.jsx("div", { className: "flex flex-col space-y-4 mb-4", children: x.jsxs("div", { className: "flex items-center justify-between", children: [x.jsx("div", { className: "flex items-center gap-3", children: x.jsxs("div", { className: "flex bg-[#1a1a1a] rounded-lg p-1", children: [x.jsxs("button", { onClick: () => f("trending"), className: `flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium smooth-transition ${s === "trending" ? "bg-white text-black shadow-lg" : "text-gray-400 hover:text-white hover:bg-[#2a2a2a]"}`, children: [x.jsx(me, { icon: cb, className: `text-xs ${s === "trending" ? "animate-pulse" : ""}` }), "Trending"] }), x.jsxs("button", { onClick: () => f("topten"), className: `flex items-center gap-2 px-3 py-2 rounded-md text-sm font-medium smooth-transition ${s === "topten" ? "bg-white text-black shadow-lg" : "text-gray-400 hover:text-white hover:bg-[#2a2a2a]"}`, children: [x.jsx(me, { icon: sp, className: `text-xs ${s === "topten" ? "animate-pulse" : ""}` }), "Top 10"] })] }) }), s === "topten" && x.jsx("div", { className: "flex bg-[#1a1a1a] rounded-lg overflow-hidden animate-fade-in", children: ["today", "week", "month"].map(g => x.jsx("button", { onClick: () => h(g), className: `px-3 py-1.5 text-xs font-medium smooth-transition ${a === g ? "bg-white text-black" : "text-gray-400 hover:text-white hover:bg-[#2a2a2a]"}`, children: g.charAt(0).toUpperCase() + g.slice(1) }, g)) })] }) }), x.jsx("div", { className: "flex flex-col space-y-2 max-h-[600px] overflow-y-auto pr-2 scrollbar-thin scrollbar-track-[#1a1a1a] scrollbar-thumb-[#2a2a2a] hover:scrollbar-thumb-[#333] scrollbar-thumb-rounded", children: v.length > 0 ? v.map((g, y) => x.jsx("div", { className: `group ${u ? `scroll-slide-up scroll-stagger-${Math.min(y + 1, 6)}` : "opacity-0"}`, children: x.jsx(We, { to: `/${g.id}`, onClick: () => window.scrollTo({ top: 0, behavior: "smooth" }), className: "block", children: x.jsxs("div", { className: "flex items-start gap-3 p-2 rounded-lg smooth-transition hover:bg-[#1a1a1a] hover:scale-[1.02] hover:shadow-lg", children: [x.jsxs("div", { className: "relative", children: [x.jsx("img", { src: g.poster, alt: g.title, loading: "lazy", className: "w-[50px] h-[70px] rounded object-cover smooth-transition group-hover:scale-105" }), x.jsxs("div", { className: `absolute top-0 left-0 text-black text-xs font-bold px-1.5 py-0.5 rounded-br ${s === "trending" ? "bg-white animate-glow" : "bg-white/80"}`, children: ["#", y + 1] })] }), x.jsxs("div", { className: "flex flex-col gap-1.5 flex-1 min-w-0", children: [x.jsx("span", { className: "text-sm font-medium text-gray-200 group-hover:text-white smooth-transition line-clamp-2", children: r === "EN" ? g.title : g.japanese_title }), x.jsxs("div", { className: "flex flex-wrap items-center gap-1.5", children: [g.tvInfo?.sub && x.jsxs("div", { className: "flex items-center gap-1 px-1.5 py-0.5 bg-[#2a2a2a] rounded text-gray-300", children: [x.jsx(me, { icon: Mn, className: "text-[10px]" }), x.jsx("span", { className: "text-[10px] font-medium", children: g.tvInfo.sub })] }), g.tvInfo?.dub && x.jsxs("div", { className: "flex items-center gap-1 px-1.5 py-0.5 bg-[#2a2a2a] rounded text-gray-300", children: [x.jsx(me, { icon: On, className: "text-[10px]" }), x.jsx("span", { className: "text-[10px] font-medium", children: g.tvInfo.dub })] }), g.tvInfo?.showType && x.jsx("span", { className: "text-xs text-gray-400", children: g.tvInfo.showType })] })] })] }) }) }, `${s}-${a}-${y}`)) : x.jsxs("div", { className: "flex flex-col items-center justify-center py-8 text-center", children: [x.jsx("div", { className: "text-gray-500 text-4xl mb-2", children: s === "trending" ? "" : "" }), x.jsxs("p", { className: "text-gray-400 text-sm", children: ["No ", s === "trending" ? "trending" : "top 10", " anime available"] })] }) })] }) }; function pb(n) { var e, t, r = ""; if (typeof n == "string" || typeof n == "number") r += n; else if (typeof n == "object") if (Array.isArray(n)) { var s = n.length; for (e = 0; e < s; e++)n[e] && (t = pb(n[e])) && (r && (r += " "), r += t) } else for (t in n) n[t] && (r && (r += " "), r += t); return r } function ek() { for (var n, e, t = 0, r = "", s = arguments.length; t < s; t++)(n = arguments[t]) && (e = pb(n)) && (r && (r += " "), r += e); return r } const cp = "-", tk = n => { const e = nk(n), { conflictingClassGroups: t, conflictingClassGroupModifiers: r } = n; return { getClassGroupId: a => { const o = a.split(cp); return o[0] === "" && o.length !== 1 && o.shift(), mb(o, e) || rk(a) }, getConflictingClassGroupIds: (a, o) => { const c = t[a] || []; return o && r[a] ? [...c, ...r[a]] : c } } }, mb = (n, e) => { if (n.length === 0) return e.classGroupId; const t = n[0], r = e.nextPart.get(t), s = r ? mb(n.slice(1), r) : void 0; if (s) return s; if (e.validators.length === 0) return; const i = n.join(cp); return e.validators.find(({ validator: a }) => a(i))?.classGroupId }, Wx = /^\[(.+)\]$/, rk = n => { if (Wx.test(n)) { const e = Wx.exec(n)[1], t = e?.substring(0, e.indexOf(":")); if (t) return "arbitrary.." + t } }, nk = n => { const { theme: e, prefix: t } = n, r = { nextPart: new Map, validators: [] }; return ik(Object.entries(n.classGroups), t).forEach(([i, a]) => { gh(a, r, i, e) }), r }, gh = (n, e, t, r) => { n.forEach(s => { if (typeof s == "string") { const i = s === "" ? e : Kx(e, s); i.classGroupId = t; return } if (typeof s == "function") { if (sk(s)) { gh(s(r), e, t, r); return } e.validators.push({ validator: s, classGroupId: t }); return } Object.entries(s).forEach(([i, a]) => { gh(a, Kx(e, i), t, r) }) }) }, Kx = (n, e) => { let t = n; return e.split(cp).forEach(r => { t.nextPart.has(r) || t.nextPart.set(r, { nextPart: new Map, validators: [] }), t = t.nextPart.get(r) }), t }, sk = n => n.isThemeGetter, ik = (n, e) => e ? n.map(([t, r]) => { const s = r.map(i => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([a, o]) => [e + a, o])) : i); return [t, s] }) : n, ak = n => { if (n < 1) return { get: () => { }, set: () => { } }; let e = 0, t = new Map, r = new Map; const s = (i, a) => { t.set(i, a), e++, e > n && (e = 0, r = t, t = new Map) }; return { get(i) { let a = t.get(i); if (a !== void 0) return a; if ((a = r.get(i)) !== void 0) return s(i, a), a }, set(i, a) { t.has(i) ? t.set(i, a) : s(i, a) } } }, gb = "!", ok = n => { const { separator: e, experimentalParseClassName: t } = n, r = e.length === 1, s = e[0], i = e.length, a = o => { const c = []; let u = 0, f = 0, h; for (let w = 0; w < o.length; w++) { let T = o[w]; if (u === 0) { if (T === s && (r || o.slice(w, w + i) === e)) { c.push(o.slice(f, w)), f = w + i; continue } if (T === "/") { h = w; continue } } T === "[" ? u++ : T === "]" && u-- } const p = c.length === 0 ? o : o.substring(f), v = p.startsWith(gb), g = v ? p.substring(1) : p, y = h && h > f ? h - f : void 0; return { modifiers: c, hasImportantModifier: v, baseClassName: g, maybePostfixModifierPosition: y } }; return t ? o => t({ className: o, parseClassName: a }) : a }, lk = n => { if (n.length <= 1) return n; const e = []; let t = []; return n.forEach(r => { r[0] === "[" ? (e.push(...t.sort(), r), t = []) : t.push(r) }), e.push(...t.sort()), e }, ck = n => ({ cache: ak(n.cacheSize), parseClassName: ok(n), ...tk(n) }), uk = /\s+/, dk = (n, e) => { const { parseClassName: t, getClassGroupId: r, getConflictingClassGroupIds: s } = e, i = [], a = n.trim().split(uk); let o = ""; for (let c = a.length - 1; c >= 0; c -= 1) { const u = a[c], { modifiers: f, hasImportantModifier: h, baseClassName: p, maybePostfixModifierPosition: v } = t(u); let g = !!v, y = r(g ? p.substring(0, v) : p); if (!y) { if (!g) { o = u + (o.length > 0 ? " " + o : o); continue } if (y = r(p), !y) { o = u + (o.length > 0 ? " " + o : o); continue } g = !1 } const w = lk(f).join(":"), T = h ? w + gb : w, S = T + y; if (i.includes(S)) continue; i.push(S); const E = s(y, g); for (let I = 0; I < E.length; ++I) { const C = E[I]; i.push(T + C) } o = u + (o.length > 0 ? " " + o : o) } return o }; function fk() { let n = 0, e, t, r = ""; for (; n < arguments.length;)(e = arguments[n++]) && (t = xb(e)) && (r && (r += " "), r += t); return r } const xb = n => { if (typeof n == "string") return n; let e, t = ""; for (let r = 0; r < n.length; r++)n[r] && (e = xb(n[r])) && (t && (t += " "), t += e); return t }; function hk(n, ...e) { let t, r, s, i = a; function a(c) { const u = e.reduce((f, h) => h(f), n()); return t = ck(u), r = t.cache.get, s = t.cache.set, i = o, o(c) } function o(c) { const u = r(c); if (u) return u; const f = dk(c, t); return s(c, f), f } return function () { return i(fk.apply(null, arguments)) } } const ut = n => { const e = t => t[n] || []; return e.isThemeGetter = !0, e }, vb = /^\[(?:([a-z-]+):)?(.+)\]$/i, pk = /^\d+\/\d+$/, mk = new Set(["px", "full", "screen"]), gk = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, xk = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, vk = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, yk = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, bk = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, En = n => Pi(n) || mk.has(n) || pk.test(n), as = n => Wi(n, "length", Ck), Pi = n => !!n && !Number.isNaN(Number(n)), lf = n => Wi(n, "number", Pi), Oa = n => !!n && Number.isInteger(Number(n)), wk = n => n.endsWith("%") && Pi(n.slice(0, -1)), Be = n => vb.test(n), os = n => gk.test(n), Sk = new Set(["length", "size", "percentage"]), Ek = n => Wi(n, Sk, yb), Tk = n => Wi(n, "position", yb), Ak = new Set(["image", "url"]), Ik = n => Wi(n, Ak, Rk), Lk = n => Wi(n, "", kk), Ma = () => !0, Wi = (n, e, t) => { const r = vb.exec(n); return r ? r[1] ? typeof e == "string" ? r[1] === e : e.has(r[1]) : t(r[2]) : !1 }, Ck = n => xk.test(n) && !vk.test(n), yb = () => !1, kk = n => yk.test(n), Rk = n => bk.test(n), _k = () => { const n = ut("colors"), e = ut("spacing"), t = ut("blur"), r = ut("brightness"), s = ut("borderColor"), i = ut("borderRadius"), a = ut("borderSpacing"), o = ut("borderWidth"), c = ut("contrast"), u = ut("grayscale"), f = ut("hueRotate"), h = ut("invert"), p = ut("gap"), v = ut("gradientColorStops"), g = ut("gradientColorStopPositions"), y = ut("inset"), w = ut("margin"), T = ut("opacity"), S = ut("padding"), E = ut("saturate"), I = ut("scale"), C = ut("sepia"), D = ut("skew"), R = ut("space"), N = ut("translate"), P = () => ["auto", "contain", "none"], _ = () => ["auto", "hidden", "clip", "visible", "scroll"], M = () => ["auto", Be, e], $ = () => [Be, e], B = () => ["", En, as], V = () => ["auto", Pi, Be], W = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], U = () => ["solid", "dashed", "dotted", "double", "none"], q = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], z = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], X = () => ["", "0", Be], Z = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], F = () => [Pi, Be]; return { cacheSize: 500, separator: ":", theme: { colors: [Ma], spacing: [En, as], blur: ["none", "", os, Be], brightness: F(), borderColor: [n], borderRadius: ["none", "", "full", os, Be], borderSpacing: $(), borderWidth: B(), contrast: F(), grayscale: X(), hueRotate: F(), invert: X(), gap: $(), gradientColorStops: [n], gradientColorStopPositions: [wk, as], inset: M(), margin: M(), opacity: F(), padding: $(), saturate: F(), scale: F(), sepia: X(), skew: F(), space: $(), translate: $() }, classGroups: { aspect: [{ aspect: ["auto", "square", "video", Be] }], container: ["container"], columns: [{ columns: [os] }], "break-after": [{ "break-after": Z() }], "break-before": [{ "break-before": Z() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: [...W(), Be] }], overflow: [{ overflow: _() }], "overflow-x": [{ "overflow-x": _() }], "overflow-y": [{ "overflow-y": _() }], overscroll: [{ overscroll: P() }], "overscroll-x": [{ "overscroll-x": P() }], "overscroll-y": [{ "overscroll-y": P() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: [y] }], "inset-x": [{ "inset-x": [y] }], "inset-y": [{ "inset-y": [y] }], start: [{ start: [y] }], end: [{ end: [y] }], top: [{ top: [y] }], right: [{ right: [y] }], bottom: [{ bottom: [y] }], left: [{ left: [y] }], visibility: ["visible", "invisible", "collapse"], z: [{ z: ["auto", Oa, Be] }], basis: [{ basis: M() }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }], flex: [{ flex: ["1", "auto", "initial", "none", Be] }], grow: [{ grow: X() }], shrink: [{ shrink: X() }], order: [{ order: ["first", "last", "none", Oa, Be] }], "grid-cols": [{ "grid-cols": [Ma] }], "col-start-end": [{ col: ["auto", { span: ["full", Oa, Be] }, Be] }], "col-start": [{ "col-start": V() }], "col-end": [{ "col-end": V() }], "grid-rows": [{ "grid-rows": [Ma] }], "row-start-end": [{ row: ["auto", { span: [Oa, Be] }, Be] }], "row-start": [{ "row-start": V() }], "row-end": [{ "row-end": V() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Be] }], "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Be] }], gap: [{ gap: [p] }], "gap-x": [{ "gap-x": [p] }], "gap-y": [{ "gap-y": [p] }], "justify-content": [{ justify: ["normal", ...z()] }], "justify-items": [{ "justify-items": ["start", "end", "center", "stretch"] }], "justify-self": [{ "justify-self": ["auto", "start", "end", "center", "stretch"] }], "align-content": [{ content: ["normal", ...z(), "baseline"] }], "align-items": [{ items: ["start", "end", "center", "baseline", "stretch"] }], "align-self": [{ self: ["auto", "start", "end", "center", "stretch", "baseline"] }], "place-content": [{ "place-content": [...z(), "baseline"] }], "place-items": [{ "place-items": ["start", "end", "center", "baseline", "stretch"] }], "place-self": [{ "place-self": ["auto", "start", "end", "center", "stretch"] }], p: [{ p: [S] }], px: [{ px: [S] }], py: [{ py: [S] }], ps: [{ ps: [S] }], pe: [{ pe: [S] }], pt: [{ pt: [S] }], pr: [{ pr: [S] }], pb: [{ pb: [S] }], pl: [{ pl: [S] }], m: [{ m: [w] }], mx: [{ mx: [w] }], my: [{ my: [w] }], ms: [{ ms: [w] }], me: [{ me: [w] }], mt: [{ mt: [w] }], mr: [{ mr: [w] }], mb: [{ mb: [w] }], ml: [{ ml: [w] }], "space-x": [{ "space-x": [R] }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": [R] }], "space-y-reverse": ["space-y-reverse"], w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Be, e] }], "min-w": [{ "min-w": [Be, e, "min", "max", "fit"] }], "max-w": [{ "max-w": [Be, e, "none", "full", "min", "max", "fit", "prose", { screen: [os] }, os] }], h: [{ h: [Be, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }], "min-h": [{ "min-h": [Be, e, "min", "max", "fit", "svh", "lvh", "dvh"] }], "max-h": [{ "max-h": [Be, e, "min", "max", "fit", "svh", "lvh", "dvh"] }], size: [{ size: [Be, e, "auto", "min", "max", "fit"] }], "font-size": [{ text: ["base", os, as] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", lf] }], "font-family": [{ font: [Ma] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Be] }], "line-clamp": [{ "line-clamp": ["none", Pi, lf] }], leading: [{ leading: ["none", "tight", "snug", "normal", "relaxed", "loose", En, Be] }], "list-image": [{ "list-image": ["none", Be] }], "list-style-type": [{ list: ["none", "disc", "decimal", Be] }], "list-style-position": [{ list: ["inside", "outside"] }], "placeholder-color": [{ placeholder: [n] }], "placeholder-opacity": [{ "placeholder-opacity": [T] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "text-color": [{ text: [n] }], "text-opacity": [{ "text-opacity": [T] }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...U(), "wavy"] }], "text-decoration-thickness": [{ decoration: ["auto", "from-font", En, as] }], "underline-offset": [{ "underline-offset": ["auto", En, Be] }], "text-decoration-color": [{ decoration: [n] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: $() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Be] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", Be] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-opacity": [{ "bg-opacity": [T] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: [...W(), Tk] }], "bg-repeat": [{ bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }], "bg-size": [{ bg: ["auto", "cover", "contain", Ek] }], "bg-image": [{ bg: ["none", { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Ik] }], "bg-color": [{ bg: [n] }], "gradient-from-pos": [{ from: [g] }], "gradient-via-pos": [{ via: [g] }], "gradient-to-pos": [{ to: [g] }], "gradient-from": [{ from: [v] }], "gradient-via": [{ via: [v] }], "gradient-to": [{ to: [v] }], rounded: [{ rounded: [i] }], "rounded-s": [{ "rounded-s": [i] }], "rounded-e": [{ "rounded-e": [i] }], "rounded-t": [{ "rounded-t": [i] }], "rounded-r": [{ "rounded-r": [i] }], "rounded-b": [{ "rounded-b": [i] }], "rounded-l": [{ "rounded-l": [i] }], "rounded-ss": [{ "rounded-ss": [i] }], "rounded-se": [{ "rounded-se": [i] }], "rounded-ee": [{ "rounded-ee": [i] }], "rounded-es": [{ "rounded-es": [i] }], "rounded-tl": [{ "rounded-tl": [i] }], "rounded-tr": [{ "rounded-tr": [i] }], "rounded-br": [{ "rounded-br": [i] }], "rounded-bl": [{ "rounded-bl": [i] }], "border-w": [{ border: [o] }], "border-w-x": [{ "border-x": [o] }], "border-w-y": [{ "border-y": [o] }], "border-w-s": [{ "border-s": [o] }], "border-w-e": [{ "border-e": [o] }], "border-w-t": [{ "border-t": [o] }], "border-w-r": [{ "border-r": [o] }], "border-w-b": [{ "border-b": [o] }], "border-w-l": [{ "border-l": [o] }], "border-opacity": [{ "border-opacity": [T] }], "border-style": [{ border: [...U(), "hidden"] }], "divide-x": [{ "divide-x": [o] }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": [o] }], "divide-y-reverse": ["divide-y-reverse"], "divide-opacity": [{ "divide-opacity": [T] }], "divide-style": [{ divide: U() }], "border-color": [{ border: [s] }], "border-color-x": [{ "border-x": [s] }], "border-color-y": [{ "border-y": [s] }], "border-color-s": [{ "border-s": [s] }], "border-color-e": [{ "border-e": [s] }], "border-color-t": [{ "border-t": [s] }], "border-color-r": [{ "border-r": [s] }], "border-color-b": [{ "border-b": [s] }], "border-color-l": [{ "border-l": [s] }], "divide-color": [{ divide: [s] }], "outline-style": [{ outline: ["", ...U()] }], "outline-offset": [{ "outline-offset": [En, Be] }], "outline-w": [{ outline: [En, as] }], "outline-color": [{ outline: [n] }], "ring-w": [{ ring: B() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: [n] }], "ring-opacity": [{ "ring-opacity": [T] }], "ring-offset-w": [{ "ring-offset": [En, as] }], "ring-offset-color": [{ "ring-offset": [n] }], shadow: [{ shadow: ["", "inner", "none", os, Lk] }], "shadow-color": [{ shadow: [Ma] }], opacity: [{ opacity: [T] }], "mix-blend": [{ "mix-blend": [...q(), "plus-lighter", "plus-darker"] }], "bg-blend": [{ "bg-blend": q() }], filter: [{ filter: ["", "none"] }], blur: [{ blur: [t] }], brightness: [{ brightness: [r] }], contrast: [{ contrast: [c] }], "drop-shadow": [{ "drop-shadow": ["", "none", os, Be] }], grayscale: [{ grayscale: [u] }], "hue-rotate": [{ "hue-rotate": [f] }], invert: [{ invert: [h] }], saturate: [{ saturate: [E] }], sepia: [{ sepia: [C] }], "backdrop-filter": [{ "backdrop-filter": ["", "none"] }], "backdrop-blur": [{ "backdrop-blur": [t] }], "backdrop-brightness": [{ "backdrop-brightness": [r] }], "backdrop-contrast": [{ "backdrop-contrast": [c] }], "backdrop-grayscale": [{ "backdrop-grayscale": [u] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [f] }], "backdrop-invert": [{ "backdrop-invert": [h] }], "backdrop-opacity": [{ "backdrop-opacity": [T] }], "backdrop-saturate": [{ "backdrop-saturate": [E] }], "backdrop-sepia": [{ "backdrop-sepia": [C] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": [a] }], "border-spacing-x": [{ "border-spacing-x": [a] }], "border-spacing-y": [{ "border-spacing-y": [a] }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Be] }], duration: [{ duration: F() }], ease: [{ ease: ["linear", "in", "out", "in-out", Be] }], delay: [{ delay: F() }], animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Be] }], transform: [{ transform: ["", "gpu", "none"] }], scale: [{ scale: [I] }], "scale-x": [{ "scale-x": [I] }], "scale-y": [{ "scale-y": [I] }], rotate: [{ rotate: [Oa, Be] }], "translate-x": [{ "translate-x": [N] }], "translate-y": [{ "translate-y": [N] }], "skew-x": [{ "skew-x": [D] }], "skew-y": [{ "skew-y": [D] }], "transform-origin": [{ origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Be] }], accent: [{ accent: ["auto", n] }], appearance: [{ appearance: ["none", "auto"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Be] }], "caret-color": [{ caret: [n] }], "pointer-events": [{ "pointer-events": ["none", "auto"] }], resize: [{ resize: ["none", "y", "x", ""] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": $() }], "scroll-mx": [{ "scroll-mx": $() }], "scroll-my": [{ "scroll-my": $() }], "scroll-ms": [{ "scroll-ms": $() }], "scroll-me": [{ "scroll-me": $() }], "scroll-mt": [{ "scroll-mt": $() }], "scroll-mr": [{ "scroll-mr": $() }], "scroll-mb": [{ "scroll-mb": $() }], "scroll-ml": [{ "scroll-ml": $() }], "scroll-p": [{ "scroll-p": $() }], "scroll-px": [{ "scroll-px": $() }], "scroll-py": [{ "scroll-py": $() }], "scroll-ps": [{ "scroll-ps": $() }], "scroll-pe": [{ "scroll-pe": $() }], "scroll-pt": [{ "scroll-pt": $() }], "scroll-pr": [{ "scroll-pr": $() }], "scroll-pb": [{ "scroll-pb": $() }], "scroll-pl": [{ "scroll-pl": $() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", Be] }], fill: [{ fill: [n, "none"] }], "stroke-w": [{ stroke: [En, as, lf] }], stroke: [{ stroke: [n, "none"] }], sr: ["sr-only", "not-sr-only"], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] } } }, Pk = hk(_k); function Nk(...n) { return Pk(ek(n)) } function Se({ className: n, animation: e = !0, ...t }) { return x.jsx("div", { className: Nk("bg-white/5 backdrop-blur-sm rounded-lg", e ? "shimmer-effect" : "", n), ...t }) } function Zs({ className: n, showLabelSkeleton: e = !0, gridClass: t }) { return x.jsxs("div", { className: `w-full ${n}`, children: [e && x.jsx(Se, { className: "w-[200px] h-[20px] max-[320px]:w-[70px]" }), x.jsx("div", { className: `grid ${t || "grid-cols-6 max-[1400px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-2"} gap-x-3 gap-y-8 mt-6`, children: [...Array(24)].map((r, s) => x.jsxs("div", { className: "flex flex-col", style: { height: "fit-content" }, children: [x.jsxs("div", { className: "w-full relative", children: [x.jsx(Se, { className: "w-full pb-[140%] rounded-lg" }), x.jsxs("div", { className: "absolute left-3 bottom-3 flex items-center gap-1.5 flex-wrap", children: [x.jsx(Se, { className: "w-[40px] h-[20px] rounded-[2px]" }), x.jsx(Se, { className: "w-[40px] h-[20px] rounded-[2px]" }), x.jsx(Se, { className: "w-[40px] h-[20px] rounded-[2px]" })] })] }), x.jsx(Se, { className: "mt-3 w-[90%] h-[20px] rounded-md" })] }, s)) })] }) } function up({ className: n }) { return x.jsxs("div", { className: `bg-[#141414] rounded-lg p-6 ${n}`, children: [x.jsx("h2", { className: "text-xl font-semibold mb-4 text-white", children: "Related Anime" }), x.jsx("div", { className: "flex flex-col space-y-2 max-h-[600px] overflow-y-auto pr-2 scrollbar-thin scrollbar-track-[#1a1a1a] scrollbar-thumb-[#2a2a2a] hover:scrollbar-thumb-[#333] scrollbar-thumb-rounded", children: [...Array(8)].map((e, t) => x.jsx("div", { className: "group", children: x.jsxs("div", { className: "flex items-start gap-3 p-2 rounded-lg transition-colors hover:bg-[#1f1f1f]", children: [x.jsx(Se, { className: "w-[50px] h-[70px] rounded object-cover flex-shrink-0" }), x.jsxs("div", { className: "flex flex-col gap-1.5 flex-1 min-w-0", children: [x.jsx(Se, { className: "w-[85%] h-[14px]" }), x.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [x.jsx(Se, { className: "w-[45px] h-[18px] rounded" }), x.jsx(Se, { className: "w-[45px] h-[18px] rounded" }), x.jsx(Se, { className: "w-[60px] h-[16px] rounded" })] })] })] }) }, t)) })] }) } const Zr = ({ count: n, className: e }) => [...Array(n)].map((t, r) => x.jsx(Se, { className: e }, r)); function Dk() { return x.jsx(x.Fragment, { children: x.jsxs("div", { className: "min-h-screen bg-[#0a0a0a] text-white", children: [x.jsx("div", { className: "relative w-full overflow-hidden mt-[74px] max-md:mt-[60px]", children: x.jsxs("div", { className: "relative z-10 container mx-auto py-4 sm:py-6 lg:py-12", children: [x.jsxs("div", { className: "block md:hidden", children: [x.jsxs("div", { className: "flex flex-row gap-4", children: [x.jsx("div", { className: "flex-shrink-0", children: x.jsx(Se, { className: "w-[130px] xs:w-[150px] aspect-[2/3] rounded-xl" }) }), x.jsxs("div", { className: "flex-1 min-w-0 space-y-2", children: [x.jsxs("div", { className: "space-y-1", children: [x.jsx(Se, { className: "h-6 w-[80%]" }), x.jsx(Se, { className: "h-3 w-[60%]" })] }), x.jsx("div", { className: "flex flex-wrap gap-1.5", children: x.jsx(Zr, { count: 4, className: "w-[40px] h-[20px] rounded-md" }) }), x.jsx("div", { className: "space-y-1", children: x.jsx(Zr, { count: 3, className: "h-3 w-full" }) })] })] }), x.jsx("div", { className: "mt-6", children: x.jsx(Se, { className: "w-full h-12 rounded-lg" }) }), x.jsxs("div", { className: "mt-6 space-y-3 py-3 backdrop-blur-md bg-white/5 rounded-lg px-3", children: [x.jsx("div", { className: "grid grid-cols-2 gap-2", children: x.jsx(Zr, { count: 6, className: "h-4 w-[90%]" }) }), x.jsxs("div", { className: "pt-2 border-t border-white/10", children: [x.jsx(Se, { className: "h-4 w-[60px] mb-2" }), x.jsx("div", { className: "flex flex-wrap gap-1", children: x.jsx(Zr, { count: 6, className: "w-[60px] h-[22px] rounded-md" }) })] }), x.jsx("div", { className: "space-y-2 pt-2 border-t border-white/10", children: x.jsx(Zr, { count: 2, className: "h-4 w-[80%]" }) })] })] }), x.jsx("div", { className: "hidden md:block", children: x.jsxs("div", { className: "flex flex-row gap-6 lg:gap-10", children: [x.jsx("div", { className: "flex-shrink-0", children: x.jsx(Se, { className: "w-[220px] lg:w-[260px] aspect-[2/3] rounded-2xl" }) }), x.jsxs("div", { className: "flex-1 space-y-4 lg:space-y-5 min-w-0", children: [x.jsxs("div", { className: "space-y-2", children: [x.jsx(Se, { className: "h-10 w-[70%]" }), x.jsx(Se, { className: "h-5 w-[50%]" })] }), x.jsx("div", { className: "flex flex-wrap gap-2", children: x.jsx(Zr, { count: 4, className: "w-[60px] h-[30px] rounded-xl" }) }), x.jsx("div", { className: "space-y-2", children: x.jsx(Zr, { count: 3, className: "h-5 w-full max-w-3xl" }) }), x.jsx(Se, { className: "w-[150px] h-[42px] rounded-xl" }), x.jsxs("div", { className: "space-y-4 py-4 backdrop-blur-md bg-white/5 rounded-xl px-5", children: [x.jsx("div", { className: "grid grid-cols-2 gap-3", children: x.jsx(Zr, { count: 6, className: "h-5 w-[90%]" }) }), x.jsxs("div", { className: "pt-3 border-t border-white/10", children: [x.jsx(Se, { className: "h-5 w-[80px] mb-2" }), x.jsx("div", { className: "flex flex-wrap gap-1.5", children: x.jsx(Zr, { count: 8, className: "w-[80px] h-[30px] rounded-lg" }) })] }), x.jsx("div", { className: "space-y-3 pt-3 border-t border-white/10", children: x.jsx(Zr, { count: 2, className: "h-5 w-[80%]" }) })] })] })] }) })] }) }), x.jsx("div", { className: "container mx-auto py-12", children: x.jsx(Zs, {}) })] }) }) } const qx = ({ count: n, className: e }) => [...Array(n)].map((t, r) => x.jsx(Se, { className: e }, r)); function Ok() { return x.jsxs("section", { className: "w-full h-[600px] max-[1390px]:h-[530px] max-[1300px]:h-[500px] max-md:h-[420px] relative", children: [x.jsx(Se, { className: "absolute inset-0 w-full h-full rounded-none" }), x.jsxs("div", { className: "absolute flex flex-col left-0 bottom-[100px] w-[55%] p-4 z-10 max-[1390px]:w-[45%] max-[1390px]:bottom-[10px] max-[1300px]:w-[600px] max-[1120px]:w-[60%] max-md:w-[90%] max-[300px]:w-full", children: [x.jsx(Se, { className: "w-[450px] h-[32px] max-md:w-[200px] max-md:h-[24px]" }), x.jsx(Se, { className: "w-[70%] h-[24px] mt-6 text-left max-[1300px]:mt-4 max-sm:w-[80%] max-[320px]:w-full max-md:h-[20px]" }), x.jsxs("div", { className: "flex h-fit justify-center items-center w-fit space-x-5 mt-8 max-[1300px]:mt-6 max-md:hidden", children: [x.jsx(qx, { count: 2, className: "w-[40px] h-[20px]" }), x.jsxs("div", { className: "flex space-x-3 w-fit", children: [x.jsx(Se, { className: "w-[90px] h-[20px]" }), x.jsx("div", { className: "flex space-x-[2px] rounded-r-[5px] rounded-l-[5px] w-fit py-[1px] overflow-hidden", children: x.jsx(qx, { count: 2, className: "w-[35px] h-[20px]" }) })] })] }), x.jsxs("div", { className: "mt-6 max-[1300px]:w-[500px] flex flex-col gap-y-3 max-[1120px]:w-[90%] max-md:hidden", children: [x.jsx(Se, { className: "w-full h-[16px]" }), x.jsx(Se, { className: "w-[85%] h-[16px]" }), x.jsx(Se, { className: "w-[70%] h-[16px]" })] }), x.jsxs("div", { className: "flex gap-x-5 mt-10 max-md:mt-6 max-sm:w-full max-[320px]:flex-col max-[320px]:space-y-3", children: [x.jsx(Se, { className: "w-[180px] h-[45px] max-[575px]:w-[130px] max-[575px]:h-[35px]" }), x.jsx(Se, { className: "w-[160px] h-[45px] max-[575px]:w-[130px] max-[575px]:h-[35px]" })] })] })] }) } function Mk() { const [n, e] = j.useState(() => window.innerWidth < 720 ? 3 : window.innerWidth < 1300 ? 4 : 6); return j.useEffect(() => { const t = () => { window.innerWidth < 720 ? e(3) : window.innerWidth < 1300 ? e(4) : e(6) }; return t(), window.addEventListener("resize", t), () => window.removeEventListener("resize", t) }, []), x.jsxs("div", { className: "flex flex-col w-full mt-10", children: [x.jsx(Se, { className: "w-[180px] h-[28px] max-[400px]:w-[120px] max-[400px]:h-[24px]" }), x.jsx("div", { className: "w-full h-[250px] overflow-hidden flex mt-6 justify-around max-[1300px]:h-fit gap-x-4", children: [...Array(n)].map((t, r) => x.jsxs("div", { className: "flex flex-col gap-y-2", children: [x.jsx(Se, { className: "w-[200px] h-[250px] rounded-md max-[1300px]:w-[22vw] max-[1300px]:h-[30vw] max-[720px]:w-[25vw] max-[720px]:h-[35vw]" }), x.jsx(Se, { className: "w-[180px] h-[20px] max-[1300px]:w-[20vw] max-[720px]:w-[22vw]" }), x.jsx(Se, { className: "w-[140px] h-[16px] max-[1300px]:w-[15vw] max-[720px]:w-[18vw]" })] }, r)) })] }) } const jk = () => x.jsx("div", { className: "flex flex-wrap gap-3", children: [...Array(8)].map((n, e) => x.jsx(Se, { className: "h-[35px] w-[120px] rounded-full" }, e)) }), Fk = () => x.jsxs("div", { className: "mt-6", children: [x.jsx(Se, { className: "w-[200px] h-7 mb-4" }), x.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4", children: [...Array(6)].map((n, e) => x.jsxs("div", { className: "flex flex-col gap-2", children: [x.jsx(Se, { className: "w-full aspect-[2/3] rounded-xl" }), x.jsx(Se, { className: "w-3/4 h-4" })] }, e)) })] }), $k = () => x.jsxs("div", { className: "mt-8", children: [x.jsx(Se, { className: "w-[150px] h-7 mb-4" }), x.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4", children: [...Array(6)].map((n, e) => x.jsxs("div", { className: "flex gap-3", children: [x.jsx(Se, { className: "w-[100px] aspect-[2/3] rounded-lg" }), x.jsxs("div", { className: "flex-1 flex flex-col gap-2", children: [x.jsx(Se, { className: "w-3/4 h-4" }), x.jsx(Se, { className: "w-1/2 h-4" }), x.jsx(Se, { className: "w-1/3 h-4" })] })] }, e)) })] }), Bk = () => x.jsxs("div", { className: "mt-8", children: [x.jsx("div", { className: "flex gap-4 mb-4", children: [...Array(3)].map((n, e) => x.jsx(Se, { className: "w-[100px] h-8 rounded-full" }, e)) }), x.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4", children: [...Array(12)].map((n, e) => x.jsxs("div", { className: "flex flex-col gap-2", children: [x.jsx(Se, { className: "w-full aspect-[2/3] rounded-xl" }), x.jsx(Se, { className: "w-3/4 h-4" })] }, e)) })] }); function Uk() { return x.jsxs("div", { className: "pt-16 w-full bg-[#0a0a0a]", children: [x.jsx(Ok, {}), x.jsx("div", { className: "mt-6", children: x.jsx(jk, {}) }), x.jsx(Fk, {}), x.jsxs("div", { className: "w-full grid grid-cols-[minmax(0,75%),minmax(0,25%)] gap-x-6 max-[1200px]:flex flex-col", children: [x.jsxs("div", { children: [x.jsx(Zs, { className: "mt-[60px]", title: "Latest Episode" }), x.jsx($k, {}), x.jsx(Bk, {})] }), x.jsxs("div", { className: "w-full mt-[60px]", children: [x.jsx(Mk, {}), x.jsx("div", { className: "mt-12", children: x.jsx(up, { title: "Top 10" }) })] })] })] }) } const zk = () => x.jsx("div", { className: "flex flex-wrap gap-3", children: [...Array(8)].map((n, e) => x.jsx(Se, { className: "h-[35px] w-[120px] rounded-full" }, e)) }); function Vk() { return x.jsx("div", { className: "w-full flex flex-col gap-y-4 mt-[64px] max-md:mt-[50px]", children: x.jsxs("div", { className: "w-full px-4 grid grid-cols-[minmax(0,75%),minmax(0,25%)] gap-x-6 max-[1200px]:flex max-[1200px]:flex-col max-[1200px]:gap-y-10 max-[478px]:px-2", children: [x.jsxs("div", { children: [x.jsx("div", { className: "flex items-center mb-6", children: x.jsx(Se, { className: "h-8 w-[200px]" }) }), x.jsx(Zs, { className: "mt-0" }), x.jsx("div", { className: "flex justify-center items-center gap-2 mt-8", children: [...Array(5)].map((n, e) => x.jsx(Se, { className: "w-10 h-10 rounded-lg" }, e)) })] }), x.jsxs("div", { className: "w-full flex flex-col gap-y-10", children: [x.jsx(up, { title: "Top 10" }), x.jsx(zk, {})] })] }) }) } function Gk() { return x.jsxs("div", { className: "max-w-[1600px] mx-auto flex flex-col mt-[64px] max-md:mt-[50px]", children: [x.jsxs("div", { className: "flex flex-col gap-y-5 mt-6", children: [x.jsx(Se, { className: "w-[200px] h-8" }), x.jsx("div", { className: "flex gap-x-[7px] flex-wrap justify-start gap-y-2 max-md:justify-start", children: [...Array(38)].map((e, t) => x.jsx(Se, { className: "h-[34px] w-[40px] rounded-md" }, t)) })] }), x.jsx("div", { className: "w-full flex flex-col gap-y-8", children: x.jsxs("div", { children: [x.jsx(Zs, { showLabelSkeleton: !1, className: "mt-8", gridClass: "grid-cols-8 max-[1600px]:grid-cols-6 max-[1200px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3 max-[478px]:gap-x-2" }), x.jsx("div", { className: "flex justify-center items-center gap-2 mt-8", children: [...Array(5)].map((e, t) => x.jsx(Se, { className: "w-10 h-10 rounded-lg" }, t)) })] }) })] }) } function Hk() { return x.jsx("div", { className: "max-w-[1600px] mx-auto flex flex-col mt-[64px] max-md:mt-[50px]", children: x.jsx("div", { className: "w-full flex flex-col gap-y-8 mt-6", children: x.jsxs("div", { className: "flex flex-col gap-y-2", children: [x.jsx(Se, { className: "w-[250px] h-8" }), x.jsx(Zs, { showLabelSkeleton: !1, className: "mt-4", gridClass: "grid-cols-8 max-[1600px]:grid-cols-6 max-[1200px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3 max-[478px]:gap-x-2" }), x.jsx("div", { className: "flex justify-center items-center gap-2 mt-8", children: [...Array(5)].map((e, t) => x.jsx(Se, { className: "w-10 h-10 rounded-lg" }, t)) })] }) }) }) } const Qa = ({ type: n }) => { switch (n) { case "home": return x.jsx(Uk, {}); case "animeInfo": return x.jsx(Dk, {}); case "category": return x.jsx(Vk, {}); case "producer": return x.jsx(Hk, {}); case "AtoZ": return x.jsx(Gk, {}); default: return x.jsx("div", { className: "loading-skeleton default-skeleton" }) } }; function Pn({ error: n }) { const e = _r(); return x.jsx("div", { className: "w-full h-screen flex justify-center items-center", children: x.jsxs("div", { className: "flex flex-col w-fit h-fit items-center justify-center", children: [x.jsxs("div", { className: "w-[300px] h-[300px] max-[500px]:w-[200px] max-[500px]:h-[200px] relative overflow-hidden rounded-lg", children: [x.jsx("img", { src: "https://64.media.tumblr.com/tumblr_lhnjv52vzw1qcrzkko1_500.gif", alt: "404 Error", className: "w-full h-full object-cover grayscale" }), x.jsx("div", { className: "absolute inset-0 bg-black/20" })] }), x.jsx("h1", { className: "font-bold text-white text-[48px] mt-8 tracking-tight", children: n === "404" ? "404 Error" : "Error" }), x.jsx("p", { className: "text-gray-400 text-lg mt-2", children: "Oops! we couldn't find this page." }), x.jsxs("button", { onClick: () => e("/home"), className: "mt-8 bg-gray-200 hover:bg-gray-300 transition-colors text-gray-800 py-2 px-4 w-fit rounded-3xl flex items-center gap-x-2", children: [x.jsx(Wc, { className: "text-gray-800 w-[20px] h-[20px] rounded-full p-1" }), x.jsx("span", { className: "text-[18px]", children: "Back to homepage" })] })] }) }) } async function Wk(n) { try { return (await Ke.get(`https://apii-orcin-theta.vercel.app/api/schedule?date=${n}`)).data.results } catch (e) { return console.error(e), e } } const gs = () => x.jsxs("div", { className: "bouncing-loading flex gap-x-[5px]", children: [x.jsx("div", { className: "span1" }), x.jsx("div", { className: "span2" }), x.jsx("div", { className: "span3" })] }), Kk = () => { const [n, e] = j.useState([]), [t, r] = j.useState(!1), [s, i] = j.useState(null), [a, o] = j.useState(!1), [c, u] = j.useState(null), [f, h] = j.useState([]), [p, v] = j.useState(new Date), g = j.useRef([]), y = j.useRef(null), w = new Date, T = w.getFullYear(), S = w.getMonth(), E = w.toLocaleString("default", { month: "short" }), I = new Date(T, S + 1, 0).getDate(), C = `GMT ${new Date().getTimezoneOffset() > 0 ? "-" : "+"}${String(Math.floor(Math.abs(new Date().getTimezoneOffset()) / 60)).padStart(2, "0")}:${String(Math.abs(new Date().getTimezoneOffset()) % 60).padStart(2, "0")}`, D = []; j.useEffect(() => { for (let M = 1; M <= I; M++) { const $ = new Date(T, S, M), B = $.toLocaleString("default", { weekday: "short" }), V = $.getFullYear(), W = String($.getMonth() + 1).padStart(2, "0"), U = String($.getDate()).padStart(2, "0"), q = `${V}-${W}-${U}`; D.push({ day: M, monthName: E, dayname: B, fulldate: q }) } e(D); const _ = setInterval(() => { v(new Date) }, 1e3); return () => clearInterval(_) }, []), j.useEffect(() => { const _ = n.findIndex(M => M.fulldate === `${w.getFullYear()}-${String(w.getMonth() + 1).padStart(2, "0")}-${String(w.getDate()).padStart(2, "0")}`); _ !== -1 && (u(_), N(_)) }, [n]); const R = async _ => { try { r(!0); const M = localStorage.getItem(`schedule-${_}`); if (M) { const $ = JSON.parse(M); h(Array.isArray($) ? $ : []) } else { const $ = await Wk(_); h(Array.isArray($) ? $ : []), localStorage.setItem(`schedule-${_}`, JSON.stringify($ || [])) } } catch (M) { console.error("Error fetching schedule info:", M), i(M) } finally { r(!1) } }, N = _ => { g.current.forEach(M => { M && M.classList.remove("active") }), g.current[_] && (g.current[_].classList.add("active"), n[_] && n[_].fulldate && R(n[_].fulldate), u(_)) }, P = () => { o(!a) }; return j.useEffect(() => { o(!1), c !== null && y.current && y.current.slideTo(c) }, [c]), x.jsxs(x.Fragment, { children: [x.jsx("div", { className: "w-full mt-8 max-[480px]:mt-6 animate-fade-in", children: x.jsxs("div", { className: "flex items-center justify-between max-[570px]:flex-col max-[570px]:items-start max-[570px]:gap-y-3", children: [x.jsx("div", { className: "font-bold text-2xl text-white max-[478px]:text-[18px] tracking-wide", children: " Estimated Schedule" }), x.jsxs("div", { className: "flex items-center gap-2 px-4 py-2 bg-black text-white rounded-full text-[13px] font-medium max-[478px]:text-[12px] max-[275px]:text-[10px] border border-white animate-fade-in", children: [x.jsx("div", { className: "w-2 h-2 bg-white rounded-full" }), x.jsxs("span", { children: ["(", C, ") ", p.toLocaleDateString(), " ", p.toLocaleTimeString()] })] })] }) }), x.jsx("div", { className: "w-full overflow-x-scroll space-x-4 scrollbar-hide pt-6 px-4 max-[480px]:px-2 max-[478px]:pt-4", children: x.jsxs("div", { className: "relative w-full", children: [x.jsx($c, { slidesPerView: 3, spaceBetween: 2, breakpoints: { 250: { slidesPerView: 3, spaceBetween: 8 }, 640: { slidesPerView: 4, spaceBetween: 8 }, 768: { slidesPerView: 5, spaceBetween: 8 }, 1024: { slidesPerView: 7, spaceBetween: 8 }, 1300: { slidesPerView: 7, spaceBetween: 8 } }, modules: [T1, Wh], navigation: { nextEl: ".next", prevEl: ".prev" }, onSwiper: _ => y.current = _, children: n && n.map((_, M) => x.jsx(Bc, { children: x.jsxs("div", { ref: $ => g.current[M] = $, onClick: () => N(M), className: `h-[65px] flex flex-col justify-center items-center w-full text-center rounded-xl cursor-pointer smooth-transition hover-scale ${c === M ? "bg-white text-black transform scale-105" : "bg-black text-white hover:bg-black border border-white"}`, children: [x.jsx("div", { className: "text-[16px] font-bold max-[400px]:text-[14px] max-[350px]:text-[12px] tracking-wide", children: _.dayname }), x.jsxs("div", { className: `text-[13px] max-[400px]:text-[11px] font-medium ${c === M ? "text-black" : "text-white"} max-[350px]:text-[10px]`, children: [_.monthName, " ", _.day] })] }) }, M)) }), x.jsx("button", { className: "next absolute top-1/2 right-[-12px] transform -translate-y-1/2 flex justify-center items-center cursor-pointer hover-scale", children: x.jsx(Hi, { className: "text-[12px]" }) }), x.jsx("button", { className: "prev absolute top-1/2 left-[-12px] transform -translate-y-1/2 flex justify-center items-center cursor-pointer hover-scale", children: x.jsx(Wc, { className: "text-[12px]" }) })] }) }), t ? x.jsx("div", { className: "w-full h-[60px] flex justify-center items-center", children: x.jsx(gs, {}) }) : !f || f.length === 0 ? x.jsx("div", { className: "w-full h-[60px] flex justify-center items-center mt-4 text-lg text-white", children: "No data to display" }) : s ? x.jsx("div", { className: "w-full h-[60px] flex justify-center items-center mt-4 text-lg text-white", children: "Something went wrong" }) : x.jsxs("div", { className: "flex flex-col mt-6 items-start bg-black rounded-xl p-4 border border-white backdrop-blur-sm animate-fade-in-up", children: [(a ? f : Array.isArray(f) ? f.slice(0, 7) : []).map((_, M) => x.jsxs(We, { to: `/${_.id}`, className: `w-full flex justify-between py-4 border-white border-b-[1px] group cursor-pointer hover:bg-black px-3 rounded-lg smooth-transition hover-scale max-[325px]:py-3 animate-stagger stagger-${Math.min(M + 1, 8)}`, children: [x.jsxs("div", { className: "flex items-center max-w-[500px] gap-x-4 max-[400px]:gap-x-2", children: [x.jsxs("div", { className: "flex items-center gap-2", children: [x.jsx("div", { className: "w-2 h-2 bg-white rounded-full" }), x.jsx("div", { className: "text-base font-semibold text-white group-hover:text-white smooth-transition max-[600px]:text-[14px] max-[275px]:text-[12px]", children: _.time || "N/A" })] }), x.jsx("h3", { className: "text-[16px] font-medium line-clamp-1 text-white group-hover:text-white smooth-transition max-[600px]:text-[14px] max-[275px]:text-[12px]", children: _.title || "N/A" })] }), x.jsxs("div", { className: "flex items-center gap-x-2 py-2 px-4 rounded-full bg-black border border-white group-hover:bg-white smooth-transition", children: [x.jsx(me, { icon: Xt, className: "text-[10px] max-[320px]:text-[8px] text-white group-hover:text-black smooth-transition" }), x.jsxs("p", { className: "text-[13px] font-medium text-white group-hover:text-black smooth-transition max-[275px]:text-[12px]", children: ["EP ", _.episode_no || "N/A"] })] })] }, M)), f.length > 7 && x.jsx("button", { onClick: P, className: "self-center mt-4 px-6 py-2 bg-black hover:bg-white text-white hover:text-black font-medium rounded-full smooth-transition hover-scale border border-white max-sm:text-[13px]", children: a ? "Show Less" : "Show More" })] })] }) }, qk = () => { const [n, e] = j.useState([]), { language: t } = pn(), r = j.useRef(null); j.useEffect(() => { const a = JSON.parse(localStorage.getItem("continueWatching") || "[]"); e(a) }, []); const s = j.useMemo(() => n, [n]), i = a => { e(o => { const c = o.filter(u => u.episodeId !== a); return localStorage.setItem("continueWatching", JSON.stringify(c)), c }) }; return s.length === 0 ? null : x.jsxs("div", { className: "mt-8", children: [x.jsxs("div", { className: "flex items-center justify-between max-md:pl-4 mb-6", children: [x.jsxs("div", { className: "flex items-center gap-x-3 justify-center", children: [x.jsx(ZC, { className: "text-gray-200 text-xl" }), x.jsx("h1", { className: "text-gray-200 text-2xl font-bold tracking-tight max-[450px]:text-xl max-[450px]:mb-1 max-[350px]:text-lg", children: "Continue Watching" })] }), x.jsxs("div", { className: "flex gap-x-3 pr-2 max-[350px]:hidden", children: [x.jsx("button", { className: "continue-btn-prev bg-gray-800 text-gray-300 p-3 rounded-lg hover:bg-gray-700 hover:text-white transition-all duration-300 shadow-lg", children: x.jsx(Wc, { className: "text-sm" }) }), x.jsx("button", { className: "continue-btn-next bg-gray-800 text-gray-300 p-3 rounded-lg hover:bg-gray-700 hover:text-white transition-all duration-300 shadow-lg", children: x.jsx(Hi, { className: "text-sm" }) })] })] }), x.jsx("div", { className: "relative mx-auto overflow-hidden z-[1]", children: x.jsx($c, { ref: r, className: "w-full h-full", slidesPerView: 3, spaceBetween: 20, breakpoints: { 640: { slidesPerView: 4, spaceBetween: 20 }, 768: { slidesPerView: 4, spaceBetween: 20 }, 1024: { slidesPerView: 5, spaceBetween: 24 }, 1300: { slidesPerView: 6, spaceBetween: 24 }, 1600: { slidesPerView: 7, spaceBetween: 28 } }, modules: [Wh], navigation: { nextEl: ".continue-btn-next", prevEl: ".continue-btn-prev" }, children: s.slice().reverse().map((a, o) => x.jsx(Bc, { className: "text-center flex justify-center items-center", children: x.jsxs("div", { className: "w-full h-auto pb-[140%] relative inline-block overflow-hidden rounded-lg shadow-lg group", children: [x.jsx("button", { className: "absolute top-3 right-3 bg-black/70 text-gray-300 w-8 h-8 flex items-center justify-center rounded-lg text-sm z-10 font-medium hover:bg-white hover:text-black transition-all duration-300", onClick: () => i(a.episodeId), children: "" }), x.jsxs(We, { to: `/watch/${a?.id}?ep=${a.episodeId}`, className: "inline-block bg-gray-900 absolute left-0 top-0 w-full h-full group", children: [x.jsx("img", { src: `${a?.poster}`, alt: a?.title, className: "block w-full h-full object-cover transition-all duration-500 ease-in-out group-hover:scale-105 group-hover:blur-sm", title: a?.title, loading: "lazy" }), x.jsx("div", { className: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-all duration-300 flex items-center justify-center", children: x.jsx("div", { className: "transform translate-y-4 group-hover:translate-y-0 transition-transform duration-300", children: x.jsx(me, { icon: Xt, className: "text-[50px] text-white drop-shadow-lg max-[450px]:text-[36px]" }) }) })] }), a?.adultContent === !0 && x.jsx("div", { className: "text-white px-2 py-0.5 rounded-lg bg-red-600 absolute top-3 left-3 flex items-center justify-center text-[12px] font-bold", children: "18+" }), x.jsxs("div", { className: "absolute bottom-0 left-0 right-0 p-3 pb-2 bg-gradient-to-t from-black/90 via-black/60 to-transparent", children: [x.jsx("p", { className: "text-white text-[15px] font-bold text-left truncate mb-1.5 max-[450px]:text-sm drop-shadow-lg", children: t === "EN" ? a?.title : a?.japanese_title }), x.jsxs("p", { className: "text-gray-200 text-[13px] font-semibold text-left max-[450px]:text-[12px] drop-shadow-md", children: ["Episode ", a.episodeNum] })] })] }) }, o)) }) })] }) }; function bb({ topAiring: n, mostFavorite: e, latestCompleted: t, className: r = "" }) {
    const [s, i] = j.useState("airing"), a = [{ id: "airing", label: "Top Airing", data: n, path: "top-airing" }, { id: "favorite", label: "Most Favorite", data: e, path: "most-favorite" }, { id: "completed", label: "Latest Completed", data: t, path: "completed" }], o = a.find(c => c.id === s); return x.jsxs("div", {
      className: `w-full ${r}`, children: [x.jsxs("div", {
        className: "flex justify-between items-center border-b border-[#ffffff1a] relative", children: [x.jsx("div", {
          className: "flex", children: a.map(c => x.jsx("button", {
            onClick: () => i(c.id), className: `relative px-6 py-4 text-[15px] font-medium transition-all duration-300 
                ${s === c.id ? "text-white after:absolute after:bottom-0 after:left-0 after:w-full after:h-[2px] after:bg-primary after:rounded-t-full" : "text-[#ffffff80] hover:text-white"}
                before:absolute before:bottom-0 before:left-1/2 before:w-0 before:h-[2px] before:bg-[#ffffff40]
                before:transition-all before:duration-300 before:-translate-x-1/2
                hover:before:w-full
                group
              `, children: x.jsx("span", { className: "relative z-10 transition-transform duration-300 group-hover:transform group-hover:translate-y-[-1px]", children: c.label })
          }, c.id))
        }), x.jsxs(We, {
          to: `/${o.path}`, className: `flex items-center gap-x-1 py-1 px-2 -mr-2 rounded-md
            text-[13px] font-medium text-[#ffffff80] hover:text-white
            transition-all duration-300 group`, children: ["View all", x.jsx(Hi, {
            className: `text-[10px] transform transition-transform duration-300 
            group-hover:translate-x-0.5`})]
        })]
      }), x.jsx(Es, { data: o.data, path: o.path, limit: 12, showViewMore: !1 })]
    })
  } bb.propTypes = { topAiring: Fe.array.isRequired, mostFavorite: Fe.array.isRequired, latestCompleted: Fe.array.isRequired, className: Fe.string }; function Yk() { const { homeInfo: n, homeInfoLoading: e, error: t } = Vh(); return e ? x.jsx(Qa, { type: "home" }) : t ? x.jsx(Pn, {}) : n ? x.jsx(x.Fragment, { children: x.jsxs("div", { className: "pt-16 w-full home-enter-animation", children: [x.jsx("div", { className: "animate-fade-in-scale stagger-1", children: x.jsx(GC, { spotlights: n.spotlights }) }), x.jsx("div", { className: "animate-fade-in-up stagger-3", children: x.jsx(qk, {}) }), x.jsxs("div", { className: "w-full grid grid-cols-[minmax(0,75%),minmax(0,25%)] gap-x-6 max-[1200px]:flex flex-col", children: [x.jsxs("div", { className: "animate-slide-in-left stagger-4", children: [x.jsx(Es, { label: "Latest Episode", data: n.latest_episode, className: "mt-[60px]", path: "recently-updated", limit: 12 }), x.jsx("div", { className: "animate-fade-in-up stagger-5", children: x.jsx(Kk, { className: "mt-8" }) }), x.jsx("div", { className: "animate-fade-in-up stagger-6", children: x.jsx(bb, { topAiring: n.top_airing, mostFavorite: n.most_favorite, latestCompleted: n.latest_completed, className: "mt-8" }) })] }), x.jsx("div", { className: "w-full mt-[60px] animate-slide-in-right stagger-4", children: x.jsx("div", { className: "animate-fade-in-up stagger-5", children: x.jsx(JC, { trending: n.trending, topten: n.topten }) }) })] })] }) }) : x.jsx(Pn, { error: "404" }) } async function wb(n, e = !1) { const t = "https://apii-orcin-theta.vercel.app/api"; try { if (e) { const r = await Ke.get(`${t}/random/id`); return (await Ke.get(`${t}/info?id=${r.data.results}`)).data.results } else return (await Ke.get(`${t}/info?id=${n}`)).data.results } catch (r) { return console.error("Error fetching anime info:", r), r } } const Xk = (n, e) => { const t = j.useRef([]), [r, s] = j.useState("top-1/2"), [i, a] = j.useState("left-1/2"), o = () => { if (n !== null) { const c = e.findIndex((f, h) => f.id + h === n), u = t.current[c]; if (u) { const { top: f, height: h, left: p, width: v } = u.getBoundingClientRect(), g = f + h / 2 - 64, y = window.innerHeight - g; g < y ? s("top-1/2") : s("bottom-1/2"); const w = p + v / 2; window.innerWidth - w > 320 ? a("left-1/2") : a("right-1/2") } } }; return j.useEffect(() => { o(); const c = () => { o() }; return window.addEventListener("scroll", c), () => { window.removeEventListener("scroll", c) } }, [n, e]), { tooltipPosition: r, tooltipHorizontalPosition: i, cardRefs: t } }, Qk = async n => { try { let e = "https://worker1.workers.dev,https://worker2.workers.dev,https://worker3.workers.dev,...".split(","), t = e?.length ? e[Math.floor(Math.random() * e.length)] : "https://apii-orcin-theta.vercel.app/api"; if (!t) throw new Error("No API endpoint defined."); return (await Ke.get(`${t}/qtip/${n.split("-").pop()}`)).data.results } catch (e) { return console.error("Error fetching genre info:", e), null } }; function Zk({ id: n }) { const [e, t] = j.useState(null), [r, s] = j.useState(!0), [i, a] = j.useState(null); return j.useEffect(() => { (async () => { s(!0); try { const c = await Qk(n); t(c) } catch (c) { console.error("Error fetching anime info:", c), a(c) } finally { s(!1) } })() }, [n]), x.jsx("div", { className: "w-[320px] h-fit rounded-xl p-4 flex justify-center items-center bg-[#3e3c50] bg-opacity-70 backdrop-blur-[10px] z-50", children: r || i || !e ? x.jsx(gs, {}) : x.jsxs("div", { className: "w-full flex flex-col justify-start gap-y-2", children: [x.jsx("h1", { className: "text-xl font-semibold text-white text-[13px] leading-6", children: e.title }), x.jsxs("div", { className: "w-full flex items-center relative mt-2", children: [e?.rating && x.jsxs("div", { className: "flex gap-x-2 items-center", children: [x.jsx(me, { icon: sp, className: "text-[#ffc107]" }), x.jsx("p", { className: "text-[#b7b7b8]", children: e.rating })] }), x.jsxs("div", { className: "flex ml-4 gap-x-[1px] overflow-hidden rounded-md items-center h-fit", children: [e?.quality && x.jsx("div", { className: "bg-[#ffbade] px-[7px] w-fit flex justify-center items-center py-[1px] text-black", children: x.jsx("p", { className: "text-[12px] font-semibold", children: e.quality }) }), x.jsxs("div", { className: "flex gap-x-[1px] w-fit items-center py-[1px]", children: [e?.subCount && x.jsxs("div", { className: "flex gap-x-1 justify-center items-center bg-[#B0E3AF] px-[7px] text-black", children: [x.jsx(me, { icon: Mn, className: "text-[13px]" }), x.jsx("p", { className: "text-[13px] font-semibold", children: e.subCount })] }), e?.dubCount && x.jsxs("div", { className: "flex gap-x-1 justify-center items-center bg-[#B9E7FF] px-[7px] text-black", children: [x.jsx(me, { icon: On, className: "text-[13px]" }), x.jsx("p", { className: "text-[13px] font-semibold", children: e.dubCount })] }), e?.episodeCount && x.jsx("div", { className: "flex gap-x-1 justify-center items-center bg-[#a199a3] px-[7px] text-black", children: x.jsx("p", { className: "text-[13px] font-semibold", children: e.episodeCount }) })] }), e?.type && x.jsx("div", { className: "absolute right-0 top-0 justify-center items-center rounded-sm bg-[#ffbade] px-[6px] text-black", children: x.jsx("p", { className: "font-semibold text-[13px]", children: e.type }) })] })] }), e?.description && x.jsx("p", { className: "text-[#d7d7d8] text-[13px] leading-4 font-light line-clamp-3 mt-1", children: e.description }), x.jsxs("div", { className: "flex flex-col mt-1", children: [e?.japaneseTitle && x.jsxs("div", { className: "leading-4", children: [x.jsx("span", { className: "text-[#b7b7b8] text-[13px]", children: "Japanese:" }), x.jsx("span", { className: "text-[13px]", children: e.japaneseTitle })] }), e?.Synonyms && x.jsxs("div", { className: "leading-4", children: [x.jsx("span", { className: "text-[#b7b7b8] text-[13px]", children: "Synonyms:" }), x.jsx("span", { className: "text-[13px]", children: e.Synonyms })] }), e?.airedDate && x.jsxs("div", { className: "leading-4", children: [x.jsx("span", { className: "text-[#b7b7b8] text-[13px]", children: "Aired:" }), x.jsx("span", { className: "text-[13px]", children: e.airedDate })] }), e?.status && x.jsxs("div", { className: "leading-4", children: [x.jsx("span", { className: "text-[#b7b7b8] text-[13px]", children: "Status:" }), x.jsx("span", { className: "text-[13px]", children: e.status })] }), e?.genres && x.jsxs("div", { className: "leading-4 flex flex-wrap text-wrap", children: [x.jsx("span", { className: "text-[#b7b7b8] text-[13px]", children: "Genres:" }), e.genres.map((o, c) => x.jsx(We, { to: `/genre/${o}`, className: "text-[13px] hover:text-[#ffbade]", children: x.jsxs("span", { children: [o, c === e.genres.length - 1 ? "" : ",", ""] }) }, c))] })] }), x.jsxs(We, { to: e.watchLink, className: "w-[80%] flex mt-4 justify-center items-center gap-x-2 bg-[#ffbade] py-[9px] rounded-3xl", children: [x.jsx(me, { icon: Xt, className: "text-[14px] text-black" }), x.jsx("p", { className: "text-[14px] font-semibold text-black", children: "Watch Now" })] })] }) }) } function Jk({ data: n, label: e, className: t }) { const { language: r } = pn(), { elementRef: s, isVisible: i } = lp({ threshold: .1, rootMargin: "50px" }), [a, o] = j.useState(null), c = (y, w) => { const T = setTimeout(() => { h(y.id + w) }, 400); o(T) }, u = () => { clearTimeout(a), h(null) }, [f, h] = j.useState(null), { tooltipPosition: p, tooltipHorizontalPosition: v, cardRefs: g } = Xk(f, n); return x.jsxs("div", { ref: s, className: `flex flex-col ${i ? "scroll-animate animate-in" : "scroll-animate"} ${t}`, children: [e && x.jsx("h2", { className: "font-medium text-lg text-neutral-200 mb-4", children: e }), x.jsx("div", { className: "flex flex-col space-y-2 max-h-[600px] overflow-y-auto pr-2 scrollbar-thin scrollbar-track-[#1a1a1a] scrollbar-thumb-[#2a2a2a] hover:scrollbar-thumb-[#333] scrollbar-thumb-rounded", children: n && n.map((y, w) => x.jsx("div", { className: "group", ref: T => g.current[w] = T, onMouseEnter: () => c(y, w), onMouseLeave: u, children: x.jsx(We, { to: `/${y.id}`, onClick: () => window.scrollTo({ top: 0, behavior: "smooth" }), className: "block", children: x.jsxs("div", { className: "flex items-start gap-3 p-2 rounded-lg transition-colors hover:bg-[#1f1f1f]", children: [f === y.id + w && window.innerWidth > 1024 && x.jsx("div", { className: `absolute ${p} ${v} ${p === "top-1/2" ? "translate-y-[50px]" : "translate-y-[-50px]"} z-[100000] transform transition-all duration-300 ease-in-out ${f === y.id + w ? "opacity-100 translate-y-0" : "opacity-0 translate-y-2"}`, children: x.jsx(Zk, { id: y.id }) }), x.jsx("img", { src: `${y.poster}`, alt: y.title, className: "w-[50px] h-[70px] rounded object-cover" }), x.jsxs("div", { className: "flex flex-col gap-1.5 flex-1 min-w-0", children: [x.jsx("span", { className: "text-sm font-medium text-gray-200 group-hover:text-white transition-colors line-clamp-1", children: r === "EN" ? y.title : y.japanese_title }), x.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [y.tvInfo?.sub && x.jsxs("div", { className: "flex items-center gap-1 px-1.5 py-0.5 bg-[#2a2a2a] rounded text-gray-300", children: [x.jsx(me, { icon: Mn, className: "text-[10px]" }), x.jsx("span", { className: "text-[10px] font-medium", children: y.tvInfo.sub })] }), y.tvInfo?.dub && x.jsxs("div", { className: "flex items-center gap-1 px-1.5 py-0.5 bg-[#2a2a2a] rounded text-gray-300", children: [x.jsx(me, { icon: On, className: "text-[10px]" }), x.jsx("span", { className: "text-[10px] font-medium", children: y.tvInfo.dub })] }), y.tvInfo?.showType && x.jsx("span", { className: "text-xs text-gray-400", children: y.tvInfo.showType })] })] })] }) }) }, w)) })] }) } const Yx = Qe.memo(Jk); async function eR(n, e) { const t = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${t}/character/list/${n}?page=${e}`)).data.results } catch (r) { return console.error("Error fetching anime info:", r), r } } function tR() { return x.jsx("div", { className: "w-full h-fit grid grid-cols-2 gap-4 overflow-y-hidden max-sm:gap-2 max-md:h-[400px] max-md:flex max-md:flex-col", children: [...Array(10)].map((n, e) => x.jsx("div", { className: "h-[90px] p-4 rounded-md bg-[#444445] hover:bg-[#4f4f50] transition-colors", children: x.jsxs("div", { className: "flex h-full items-center gap-x-3", children: [x.jsx(Se, { className: "w-[55px] h-[55px] rounded-full max-sm:w-[40px] max-sm:h-[40px]" }), x.jsxs("div", { className: "flex flex-col gap-y-2", children: [x.jsx(Se, { className: "h-[16px] w-[120px] rounded-md max-[300px]:w-[80px] max-[300px]:h-[14px]" }), x.jsx(Se, { className: "h-[14px] w-[80px] rounded-md max-[300px]:w-[60px] max-[300px]:h-[12px]" })] })] }) }, e)) }) } function rR(n) { const e = () => window.innerWidth - document.documentElement.clientWidth, t = document.body; if (n) { const r = e(); t.style.paddingRight = `${r}px`, t.classList.add("overflow-y-hidden"); const s = document.createElement("style"); s.id = "hide-scrollbar", s.innerHTML = "::-webkit-scrollbar { display: none; }", document.head.appendChild(s) } else { t.style.paddingRight = "0", t.classList.remove("overflow-y-hidden"); const r = document.getElementById("hide-scrollbar"); r && r.remove() } } function nR() { const n = document.body; n.style.paddingRight = "0", n.classList.remove("overflow-y-hidden"); const e = document.getElementById("hide-scrollbar"); e && e.remove() } function mo({ page: n, totalPages: e, handlePageChange: t, start: r = !1, style: s }) { const i = () => { const a = []; if (e === 1) return null; if (e <= 3) for (let o = 1; o <= e; o++)a.push(o); else n === 1 ? a.push(1, 2, 3) : n === 2 ? a.push(1, 2, 3, 4) : n === e ? a.push(e - 2, e - 1, e) : n === e - 1 ? a.push(e - 3, e - 2, e - 1, e) : a.push(n - 2, n - 1, n, n + 1, n + 2); return a.map(o => x.jsx("button", { onClick: () => t(o), className: `w-9 h-9 mx-1 flex justify-center items-center rounded-lg text-sm font-medium transition-all duration-300 ${n === o ? "bg-zinc-100 text-zinc-900 cursor-default" : "bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-200"}`, children: o }, o)) }; return x.jsx("div", { className: `w-full flex ${r ? "justify-start" : "justify-center"} items-center overflow-hidden`, style: s, children: x.jsxs("div", { className: "flex justify-center items-center w-fit", children: [n > 1 && e > 2 && x.jsx("button", { onClick: () => t(1), className: "w-9 h-9 mx-1 flex justify-center items-center rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-200 transition-all duration-300", children: x.jsx(me, { icon: $C, className: "text-xs" }) }), n > 1 && x.jsx("button", { onClick: () => { n > 0 && t(n - 1) }, className: "w-9 h-9 mx-1 flex justify-center items-center rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-200 transition-all duration-300", children: x.jsx(me, { icon: MC, className: "text-xs" }) }), i(), n < e && x.jsx("button", { onClick: () => { n < e && t(n + 1) }, className: "w-9 h-9 mx-1 flex justify-center items-center rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-200 transition-all duration-300", children: x.jsx(me, { icon: jC, className: "text-xs" }) }), n < e && e > 2 && x.jsx("button", { onClick: () => t(e), className: "w-9 h-9 mx-1 flex justify-center items-center rounded-lg bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-200 transition-all duration-300", children: x.jsx(me, { icon: SC, className: "text-xs" }) })] }) }) } function sR({ id: n, isOpen: e, onClose: t }) { const [r, s] = j.useState(!0), [i, a] = j.useState(1), [o, c] = j.useState(1), [u, f] = j.useState(null), [h, p] = j.useState([]), v = _r(); return j.useEffect(() => (rR(e), () => { nR() }), [e]), j.useEffect(() => { (async () => { s(!0); try { const y = await eR(n, i); p(y.data), c(y.totalPages), s(!1) } catch (y) { f(y), console.error("Error fetching category info:", y) } })() }, [i]), u ? (v("/error-page"), x.jsx(Pn, {})) : h ? x.jsx("div", { className: "fixed inset-0 flex items-center justify-center bg-black/90 backdrop-blur-sm z-[1000000]", onClick: g => { g.target === g.currentTarget && t() }, children: x.jsx("div", { className: "min-h-screen w-full py-4 sm:py-8 px-2 sm:px-4 flex items-center justify-center", children: x.jsxs("div", { className: "w-full max-w-[920px] bg-zinc-900/80 backdrop-blur-xl rounded-xl border border-zinc-800 shadow-2xl max-h-[85vh] flex flex-col mx-auto max-sm:max-h-[80vh] max-sm:w-[92%] max-sm:my-auto", onClick: g => g.stopPropagation(), children: [x.jsxs("div", { className: "relative flex items-center justify-between p-3 sm:p-6 border-b border-zinc-800/50 flex-shrink-0", children: [!r && x.jsx("h2", { className: "text-base sm:text-xl font-bold text-zinc-100", children: "Characters & Voice Actors" }), x.jsx("button", { onClick: t, className: "absolute right-2 sm:right-4 top-2 sm:top-4 w-7 h-7 sm:w-8 sm:h-8 flex items-center justify-center rounded-lg bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-zinc-200 transition-all duration-300", children: x.jsx("span", { className: "text-lg sm:text-xl leading-none mb-0.5", children: "" }) })] }), x.jsx("div", { className: "flex-1 overflow-y-auto p-2 sm:p-6 scrollbar-thin scrollbar-thumb-zinc-800 scrollbar-track-transparent", children: r ? x.jsx(tR, {}) : x.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-2 sm:gap-3", children: h.map((g, y) => x.jsxs("div", { className: "flex items-center justify-between p-2 sm:p-3 bg-zinc-800/50 hover:bg-zinc-800/70 rounded-lg border border-zinc-700/30 transition-all duration-300", children: [x.jsxs("div", { className: "flex items-center gap-2 sm:gap-3 w-[48%]", children: [x.jsx("img", { src: g.character.poster, className: "w-9 h-9 sm:w-12 sm:h-12 rounded-full object-cover border-2 border-zinc-700 hover:border-zinc-500 transition-all duration-300", loading: "lazy", onError: w => { w.target.src = "https://i.postimg.cc/HnHKvHpz/no-avatar.jpg" } }), x.jsxs("div", { className: "min-w-0", children: [g.character.name && x.jsx("h3", { className: "text-xs sm:text-sm text-zinc-100 font-medium truncate", children: g.character.name }), g.character.cast && x.jsx("p", { className: "text-[10px] sm:text-xs text-zinc-400 truncate", children: g.character.cast })] })] }), g.voiceActors && g.voiceActors.length > 0 && x.jsx("div", { className: "flex items-center justify-end gap-2 sm:gap-3 w-[48%]", children: g.voiceActors.length > 1 ? x.jsx("div", { className: "flex items-center justify-end gap-1 sm:gap-2 w-full overflow-x-auto py-1 sm:py-2", children: g.voiceActors.map((w, T) => x.jsx("img", { src: w.poster, className: "w-7 h-7 sm:w-10 sm:h-10 rounded-full object-cover flex-shrink-0 opacity-60 hover:opacity-100 border-2 border-zinc-700 hover:border-zinc-500 transition-all duration-300", title: w.name, onError: S => { S.target.src = "https://i.postimg.cc/HnHKvHpz/no-avatar.jpg" } }, T)) }) : x.jsxs(x.Fragment, { children: [x.jsx("div", { className: "text-right min-w-0", children: x.jsx("p", { className: "text-xs sm:text-sm text-zinc-300 truncate", children: g.voiceActors[0].name }) }), x.jsx("img", { src: g.voiceActors[0].poster, className: "w-9 h-9 sm:w-12 sm:h-12 rounded-full object-cover flex-shrink-0 opacity-60 hover:opacity-100 border-2 border-zinc-700 hover:border-zinc-500 transition-all duration-300", title: g.voiceActors[0].name, onError: w => { w.target.src = "https://i.postimg.cc/HnHKvHpz/no-avatar.jpg" } })] }) })] }, y)) }) }), x.jsx("div", { className: "p-2 sm:p-6 sm:pt-2 border-t border-zinc-800/50 flex-shrink-0", children: x.jsx(mo, { page: i, totalPages: o, handlePageChange: a, start: !0 }) })] }) }) }) : (v("/404-not-found-page"), null) } function iR({ animeInfo: n, className: e }) { const [t, r] = j.useState(!1); return x.jsxs("div", { className: `w-full flex flex-col gap-y-5 ${e}`, children: [x.jsxs("div", { className: "flex justify-between items-center", children: [x.jsx("h1", { className: "font-bold text-2xl text-zinc-100 max-[478px]:text-[18px] capitalize", children: "Characters & Voice Actors" }), x.jsxs("button", { onClick: () => r(!0), className: "flex items-center px-3 py-1.5 rounded-lg bg-zinc-800/80 hover:bg-zinc-700/80 transition-all duration-300 group", children: [x.jsx("span", { className: "text-zinc-300 text-sm font-medium group-hover:text-zinc-100", children: "View more" }), x.jsx(Hi, { className: "text-zinc-400 text-xs ml-1.5 group-hover:text-zinc-300" })] })] }), x.jsx("div", { className: "grid grid-cols-3 gap-3 max-lg:grid-cols-2 max-md:grid-cols-1", children: n.charactersVoiceActors.slice(0, 6).map((s, i) => x.jsxs("div", { className: "flex justify-between items-center px-4 py-3 rounded-lg bg-zinc-800/50 hover:bg-zinc-800/70 transition-all duration-300 border border-zinc-700/30", children: [s.character && x.jsx("div", { className: "w-[50%] float-left overflow-hidden max-[350px]:w-[45%]", children: x.jsxs("div", { className: "w-full flex gap-x-3", children: [s.character.poster && x.jsx("img", { src: s.character.poster, title: s.character.name || "Character", alt: s.character.name || "Character", onError: a => { a.target.src = "https://i.postimg.cc/HnHKvHpz/no-avatar.jpg" }, className: "w-[48px] h-[48px] flex-shrink-0 rounded-full object-cover border-2 border-zinc-700 hover:border-zinc-500 transition-all duration-300 max-[480px]:w-[36px] max-[480px]:h-[36px]", loading: "lazy" }), x.jsxs("div", { className: "flex justify-center flex-col", children: [s.character.name && x.jsx("h4", { className: "text-[13px] text-zinc-100 font-medium leading-snug mb-1 overflow-hidden -webkit-box -webkit-line-clamp-2 -webkit-box-orient-vertical", children: s.character.name }), s.character.cast && x.jsx("p", { className: "text-[12px] text-zinc-400", children: s.character.cast })] })] }) }), s.voiceActors.length > 0 && s.voiceActors[0] && x.jsx("div", { className: "w-[50%] float-right overflow-hidden max-[350px]:w-[45%]", children: x.jsxs("div", { className: "w-full flex justify-end gap-x-3", children: [x.jsx("div", { className: "flex flex-col justify-center", children: s.voiceActors[0].name && x.jsx("span", { className: "text-[13px] text-zinc-300 text-right leading-snug mb-0 overflow-hidden -webkit-box -webkit-line-clamp-2 -webkit-box-orient-vertical w-fit", children: s.voiceActors[0].name }) }), s.voiceActors[0].poster && x.jsx("img", { src: s.voiceActors[0].poster, title: s.voiceActors[0].name || "Voice Actor", alt: s.voiceActors[0].name || "Voice Actor", loading: "lazy", onError: a => { a.target.src = "https://i.postimg.cc/HnHKvHpz/no-avatar.jpg" }, className: "w-[48px] h-[48px] rounded-full object-cover opacity-60 hover:opacity-100 cursor-pointer flex-shrink-0 transition-all duration-300 border-2 border-zinc-700 hover:border-zinc-500 max-[480px]:w-[36px] max-[480px]:h-[36px]" })] }) })] }, i)) }), t && x.jsx(sR, { id: n.id, isOpen: t, onClose: () => r(!1) })] }) } function _l({ label: n, value: e, isProducer: t = !0 }) { return e && x.jsxs("div", { className: "text-[11px] sm:text-[14px] font-medium transition-all duration-300", children: [x.jsx("span", { className: "text-gray-400", children: `${n}: ` }), x.jsx("span", { className: "font-light text-white/90", children: Array.isArray(e) ? e.map((r, s) => t ? x.jsxs(We, { to: `/producer/${r.replace(/[&'"^%$#@!()+=<>:;,.?/\\|{}[\]`~*_]/g, "").split(" ").join("-").replace(/-+/g, "-")}`, className: "cursor-pointer transition-colors duration-300 hover:text-gray-300", children: [r, s < e.length - 1 && ", "] }, s) : x.jsxs("span", { children: [r, s < e.length - 1 && ", "] }, s)) : t ? x.jsx(We, { to: `/producer/${e.replace(/[&'"^%$#@!()+=<>:;,.?/\\|{}[\]`~*_]/g, "").split(" ").join("-").replace(/-+/g, "-")}`, className: "cursor-pointer transition-colors duration-300 hover:text-gray-300", children: e }) : x.jsx("span", { children: e }) })] }) } function Xx({ bgColor: n, index: e, icon: t, text: r }) { return x.jsxs("div", { className: "flex space-x-1 justify-center items-center px-2 sm:px-3 py-0.5 sm:py-1 text-white backdrop-blur-md bg-white/10 font-medium text-[10px] sm:text-[13px] rounded-md sm:rounded-full transition-all duration-300 hover:bg-white/20", children: [t && x.jsx(me, { icon: t, className: "text-[10px] sm:text-[12px] mr-1" }), x.jsx("p", { className: "text-[10px] sm:text-[12px]", children: r })] }) } function Qx({ random: n = !1 }) { const { language: e } = pn(), { id: t } = cc(), r = n ? null : t, [s, i] = j.useState(!1), [a, o] = j.useState(null), [c, u] = j.useState(null), [f, h] = j.useState(!0), [p, v] = j.useState(null), { homeInfo: g } = Vh(), { id: y } = cc(), w = _r(); if (j.useEffect(() => { if (r === "404-not-found-page") return console.log("404 got!"), null; (async () => { h(!0); try { const R = await wb(r, n); u(R?.seasons), o(R.data) } catch (R) { console.error("Error fetching anime info:", R), v(R) } finally { h(!1) } })(), window.scrollTo({ top: 0, behavior: "smooth" }) }, [r, n]), j.useEffect(() => (a && location.pathname === `/${a.id}` && (document.title = `Watch ${a.title} English Sub/Dub online Free on ${_n}`), () => { document.title = `${_n} | Free anime streaming platform` }), [a]), f) return x.jsx(Qa, { type: "animeInfo" }); if (p) return x.jsx(Pn, {}); if (!a) { w("/404-not-found-page"); return } const { title: T, japanese_title: S, poster: E, animeInfo: I } = a, C = [{ condition: I.tvInfo?.rating, bgColor: "#ffffff", text: I.tvInfo.rating }, { condition: I.tvInfo?.quality, bgColor: "#FFBADE", text: I.tvInfo.quality }, { condition: I.tvInfo?.sub, icon: Mn, bgColor: "#B0E3AF", text: I.tvInfo.sub }, { condition: I.tvInfo?.dub, icon: On, bgColor: "#B9E7FF", text: I.tvInfo.dub }]; return x.jsxs("div", { className: "min-h-screen bg-[#0a0a0a] text-white", children: [x.jsx("div", { className: "relative w-full overflow-hidden mt-[74px] max-md:mt-[60px]", children: x.jsxs("div", { className: "relative z-10 container mx-auto py-4 sm:py-6 lg:py-12", children: [x.jsxs("div", { className: "block md:hidden", children: [x.jsxs("div", { className: "flex flex-row gap-4", children: [x.jsx("div", { className: "flex-shrink-0", children: x.jsxs("div", { className: "relative w-[130px] xs:w-[150px] aspect-[2/3] rounded-xl overflow-hidden shadow-[0_8px_32px_rgba(0,0,0,0.3)]", children: [x.jsx("img", { src: `${E}`, alt: `${T} Poster`, className: "w-full h-full object-cover" }), a.adultContent && x.jsx("div", { className: "absolute top-2 left-2 px-2 py-0.5 bg-red-500/90 backdrop-blur-sm rounded-md text-[10px] font-medium", children: "18+" })] }) }), x.jsxs("div", { className: "flex-1 min-w-0 space-y-2", children: [x.jsxs("div", { className: "space-y-0.5", children: [x.jsx("h1", { className: "text-lg xs:text-xl font-bold tracking-tight truncate", children: e === "EN" ? T : S }), e === "EN" && S && x.jsxs("p", { className: "text-white/50 text-[11px] xs:text-xs truncate", children: ["JP Title: ", S] })] }), x.jsx("div", { className: "flex flex-wrap gap-1.5", children: C.map(({ condition: D, icon: R, text: N }, P) => D && x.jsx(Xx, { index: P, icon: R, text: N }, P)) }), I?.Overview && x.jsx("div", { className: "text-gray-300 leading-relaxed text-xs", children: I.Overview.length > 150 ? x.jsxs(x.Fragment, { children: [s ? I.Overview : x.jsx("div", { className: "line-clamp-3", children: I.Overview }), x.jsx("button", { className: "mt-1 text-white/70 hover:text-white transition-colors text-[10px] font-medium", onClick: () => i(!s), children: s ? "Show Less" : "Read More" })] }) : I.Overview })] })] }), x.jsx("div", { className: "mt-6", children: a?.animeInfo?.Status?.toLowerCase() !== "not-yet-aired" ? x.jsxs(We, { to: `/watch/${a.id}`, className: "flex justify-center items-center w-full px-4 py-3 bg-white/10 backdrop-blur-md rounded-lg text-white transition-all duration-300 hover:bg-white/20 group", children: [x.jsx(me, { icon: Xt, className: "mr-2 text-xs group-hover:text-white" }), x.jsx("span", { className: "font-medium text-sm", children: "Watch Now" })] }) : x.jsx("div", { className: "flex justify-center items-center w-full px-4 py-3 bg-gray-700/50 rounded-lg", children: x.jsx("span", { className: "font-medium text-sm", children: "Not released" }) }) }), x.jsxs("div", { className: "mt-6 space-y-3 py-3 backdrop-blur-md bg-white/5 rounded-lg px-3 text-xs", children: [x.jsx("div", { className: "grid grid-cols-2 gap-2", children: [{ label: "Japanese", value: I?.Japanese }, { label: "Synonyms", value: I?.Synonyms }, { label: "Aired", value: I?.Aired }, { label: "Premiered", value: I?.Premiered }, { label: "Duration", value: I?.Duration }, { label: "Status", value: I?.Status }, { label: "MAL Score", value: I?.["MAL Score"] }].map((D, R) => x.jsx(_l, { label: D.label, value: D.value, isProducer: !1 }, R)) }), I?.Genres && x.jsxs("div", { className: "pt-2 border-t border-white/10", children: [x.jsx("p", { className: "text-gray-400 text-xs mb-1.5", children: "Genres" }), x.jsx("div", { className: "flex flex-wrap gap-1", children: I.Genres.map((D, R) => x.jsx(We, { to: `/genre/${D.split(" ").join("-")}`, className: "px-2 py-0.5 text-[10px] bg-white/5 rounded-md hover:bg-white/10 transition-colors", children: D }, R)) })] }), x.jsx("div", { className: "space-y-2 pt-2 border-t border-white/10", children: [{ label: "Studios", value: I?.Studios }, { label: "Producers", value: I?.Producers }].map((D, R) => x.jsx(_l, { label: D.label, value: D.value }, R)) })] })] }), x.jsx("div", { className: "hidden md:block", children: x.jsxs("div", { className: "flex flex-row gap-6 lg:gap-10", children: [x.jsx("div", { className: "flex-shrink-0", children: x.jsxs("div", { className: "relative w-[220px] lg:w-[260px] aspect-[2/3] rounded-2xl overflow-hidden shadow-[0_8px_32px_rgba(0,0,0,0.3)]", children: [x.jsx("img", { src: `${E}`, alt: `${T} Poster`, className: "w-full h-full object-cover" }), a.adultContent && x.jsx("div", { className: "absolute top-3 left-3 px-2.5 py-0.5 bg-red-500/90 backdrop-blur-sm rounded-lg text-xs font-medium", children: "18+" })] }) }), x.jsxs("div", { className: "flex-1 space-y-4 lg:space-y-5 min-w-0", children: [x.jsxs("div", { className: "space-y-1", children: [x.jsx("h1", { className: "text-3xl lg:text-4xl font-bold tracking-tight truncate", children: e === "EN" ? T : S }), e === "EN" && S && x.jsxs("p", { className: "text-white/50 text-sm lg:text-base truncate", children: ["JP Title: ", S] })] }), x.jsx("div", { className: "flex flex-wrap gap-2", children: C.map(({ condition: D, icon: R, text: N }, P) => D && x.jsx(Xx, { index: P, icon: R, text: N }, P)) }), I?.Overview && x.jsx("div", { className: "text-gray-300 leading-relaxed max-w-3xl text-sm lg:text-base", children: I.Overview.length > 270 ? x.jsxs(x.Fragment, { children: [s ? I.Overview : `${I.Overview.slice(0, 270)}...`, x.jsx("button", { className: "ml-2 text-white/70 hover:text-white transition-colors text-sm font-medium", onClick: () => i(!s), children: s ? "Show Less" : "Read More" })] }) : I.Overview }), a?.animeInfo?.Status?.toLowerCase() !== "not-yet-aired" ? x.jsxs(We, { to: `/watch/${a.id}`, className: "inline-flex items-center px-5 py-2.5 bg-white/10 backdrop-blur-md rounded-xl text-white transition-all duration-300 hover:bg-white/20 hover:scale-[1.02] group", children: [x.jsx(me, { icon: Xt, className: "mr-2 text-sm group-hover:text-white" }), x.jsx("span", { className: "font-medium", children: "Watch Now" })] }) : x.jsx("div", { className: "inline-flex items-center px-5 py-2.5 bg-gray-700/50 rounded-xl", children: x.jsx("span", { className: "font-medium", children: "Not released" }) }), x.jsxs("div", { className: "space-y-4 py-4 backdrop-blur-md bg-white/5 rounded-xl px-5", children: [x.jsx("div", { className: "grid grid-cols-2 gap-3", children: [{ label: "Japanese", value: I?.Japanese }, { label: "Synonyms", value: I?.Synonyms }, { label: "Aired", value: I?.Aired }, { label: "Premiered", value: I?.Premiered }, { label: "Duration", value: I?.Duration }, { label: "Status", value: I?.Status }, { label: "MAL Score", value: I?.["MAL Score"] }].map((D, R) => x.jsx(_l, { label: D.label, value: D.value, isProducer: !1 }, R)) }), I?.Genres && x.jsxs("div", { className: "pt-3 border-t border-white/10", children: [x.jsx("p", { className: "text-gray-400 text-sm mb-2", children: "Genres" }), x.jsx("div", { className: "flex flex-wrap gap-1.5", children: I.Genres.map((D, R) => x.jsx(We, { to: `/genre/${D.split(" ").join("-")}`, className: "px-3 py-1 text-xs bg-white/5 rounded-lg hover:bg-white/10 transition-colors", children: D }, R)) })] }), x.jsx("div", { className: "space-y-3 pt-3 border-t border-white/10", children: [{ label: "Studios", value: I?.Studios }, { label: "Producers", value: I?.Producers }].map((D, R) => x.jsx(_l, { label: D.label, value: D.value }, R)) })] })] })] }) })] }) }), c?.length > 0 && x.jsxs("div", { className: "container mx-auto py-8 sm:py-12", children: [x.jsx("h2", { className: "text-2xl font-bold mb-6 sm:mb-8 px-1", children: "More Seasons" }), x.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 sm:gap-4", children: c.map((D, R) => x.jsxs(We, { to: `/${D.id}`, className: `relative w-full aspect-[3/1] sm:aspect-[3/1] rounded-lg overflow-hidden cursor-pointer group ${y === String(D.id) ? "ring-2 ring-white/40 shadow-lg shadow-white/10" : ""}`, children: [x.jsx("img", { src: D.season_poster, alt: D.season, className: `w-full h-full object-cover scale-150 ${y === String(D.id) ? "opacity-50" : "opacity-40"}` }), x.jsx("div", { className: "absolute inset-0 z-10", style: { backgroundImage: `url('data:image/svg+xml,<svg width="3" height="3" viewBox="0 0 3 3" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="1.5" cy="1.5" r="0.5" fill="white" fill-opacity="0.25"/></svg>')`, backgroundSize: "3px 3px" } }), x.jsx("div", { className: `absolute inset-0 z-20 bg-gradient-to-r ${y === String(D.id) ? "from-black/50 to-transparent" : "from-black/40 to-transparent"}` }), x.jsx("div", { className: "absolute inset-0 z-30 flex items-center justify-center", children: x.jsx("p", { className: `text-[14px] sm:text-[16px] md:text-[18px] font-bold text-center px-2 sm:px-4 transition-colors duration-300 ${y === String(D.id) ? "text-white" : "text-white/90 group-hover:text-white"}`, children: D.season }) })] }, R)) })] }), a?.charactersVoiceActors.length > 0 && x.jsx("div", { className: "container mx-auto py-12", children: x.jsx(iR, { animeInfo: a }) }), a.recommended_data.length > 0 && x.jsx("div", { className: "container mx-auto py-12", children: x.jsx(Es, { label: "Recommended for you", data: a.recommended_data, limit: a.recommended_data.length, showViewMore: !1 }) })] }) } const aR = [{ name: "Home", path: "/home", icon: RC }, { name: "Recently Added", path: "/recently-added", icon: hh }, { name: "Top Upcoming", path: "/top-upcoming", icon: Vx }, { name: "Subbed Anime", path: "/subbed-anime", icon: Vx }, { name: "Dubbed Anime", path: "/dubbed-anime", icon: Xt }, { name: "Most Popular", path: "/most-popular", icon: cb }, { name: "Movies", path: "/movie", icon: lb }, { name: "TV Series", path: "/tv", icon: NC }, { name: "OVAs", path: "/ova", icon: hh }, { name: "ONAs", path: "/ona", icon: Xt }, { name: "Specials", path: "/special", icon: ap }], oR = ({ isOpen: n, onClose: e }) => { const { language: t, toggleLanguage: r } = pn(), s = zr(), i = j.useRef(0); return j.useEffect(() => { const a = () => { n || (i.current = window.scrollY) }; return window.addEventListener("scroll", a), () => window.removeEventListener("scroll", a) }, [n]), j.useEffect(() => (n ? (i.current = window.scrollY, document.body.style.position = "fixed", document.body.style.top = `-${i.current}px`, document.body.style.width = "100%") : (document.body.style.position = "", document.body.style.top = "", document.body.style.width = "", window.scrollTo(0, i.current)), () => { document.body.style.position = "", document.body.style.top = "", document.body.style.width = "" }), [n]), j.useEffect(() => { e() }, [s]), x.jsxs("div", { className: "sidebar-container", "aria-hidden": !n, children: [n && x.jsx("div", { className: "sidebar-overlay", onClick: e }), x.jsx("aside", { className: `sidebar-main ${n ? "sidebar-open" : ""}`, role: "dialog", "aria-modal": "true", children: x.jsxs("div", { className: "sidebar-content", children: [x.jsx("div", { className: "sidebar-header", children: x.jsxs("button", { onClick: e, className: "close-button", children: [x.jsx(Wc, { className: "text-sm" }), x.jsx("span", { className: "text-sm font-medium", children: "Close Menu" })] }) }), x.jsx("div", { className: "quick-actions", children: x.jsxs("div", { className: "quick-actions-grid", children: [x.jsxs(We, { to: "/random", className: "quick-action-item", children: [x.jsx(me, { icon: ip, className: "text-lg" }), x.jsx("span", { className: "text-xs font-medium", children: "Random" })] }), x.jsxs(We, { to: "/movie", className: "quick-action-item", children: [x.jsx(me, { icon: lb, className: "text-lg" }), x.jsx("span", { className: "text-xs font-medium", children: "Movie" })] }), x.jsxs("div", { className: "quick-action-item", children: [x.jsx("div", { className: "language-switcher", children: ["EN", "JP"].map(a => x.jsx("button", { onClick: () => r(a), className: `lang-button ${t === a ? "active" : ""}`, children: a }, a)) }), x.jsx("span", { className: "text-xs font-medium text-white/60", children: "Language" })] })] }) }), x.jsx("nav", { className: "menu-items", children: aR.map((a, o) => x.jsxs(We, { to: a.path, className: "menu-item", children: [x.jsx(me, { icon: a.icon, className: "text-lg w-5" }), x.jsx("span", { className: "font-medium", children: a.name })] }, o)) })] }) })] }) }, Sb = j.createContext(); function lR({ children: n }) { const [e, t] = j.useState(!1); return x.jsx(Sb.Provider, { value: { isSearchVisible: e, setIsSearchVisible: t }, children: n }) } const cR = () => j.useContext(Sb), uR = async n => { const e = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${e}/search/suggest?keyword=${n}`)).data.results } catch (t) { return console.error("Error fetching genre info:", t), t } }; function Eb({ keyword: n, className: e, onSuggestionClick: t }) { const [r, s] = j.useState([]), [i, a] = j.useState(!1), [o, c] = j.useState(null), [u, f] = j.useState(!1); return j.useEffect(() => { (async () => { if (n) { a(!0), f(!1); try { const p = await uR(n); s(p), f(!0) } catch (p) { console.error("Error fetching search suggestion info:", p), c(p) } finally { a(!1) } } })() }, [n]), x.jsx("div", { className: `bg-zinc-900 ${e} flex ${i ? "justify-center py-4" : "justify-start"} ${r ? "justify-start" : "p-2"} items-center rounded-lg`, style: { boxShadow: "0 8px 32px rgba(0, 0, 0, 0.2)", border: "1px solid rgba(255, 255, 255, 0.05)" }, children: i ? x.jsx(gs, {}) : o && !r ? x.jsx("div", { className: "text-gray-400 p-3", children: "Error loading suggestions" }) : r && u ? x.jsxs("div", { className: "w-full flex flex-col pt-1 overflow-y-auto", children: [r.map((h, p) => x.jsxs(We, { to: `/${h.id}`, onClick: t, className: "group py-2 flex items-start gap-x-3 hover:bg-zinc-800 transition-all duration-200 cursor-pointer px-3", style: { borderBottom: p === r.length - 1 ? "none" : "1px solid rgba(255, 255, 255, 0.05)" }, children: [x.jsx("img", { src: `${h.poster}`, className: "w-[45px] h-[65px] flex-shrink-0 object-cover rounded-md shadow-lg", alt: "", onError: v => { v.target.src = "https://i.postimg.cc/HnHKvHpz/no-avatar.jpg" } }), x.jsxs("div", { className: "flex flex-col gap-y-[2px]", children: [h?.title && x.jsx("h1", { className: "line-clamp-1 leading-5 font-semibold text-[14px] text-gray-100 group-hover:text-white", children: h.title || "N/A" }), h?.japanese_title && x.jsx("h1", { className: "line-clamp-1 leading-4 text-[12px] font-normal text-gray-400", children: h.japanese_title || "N/A" }), (h?.releaseDate || h?.showType || h?.duration) && x.jsxs("div", { className: "flex gap-x-2 items-center w-full justify-start mt-[2px]", children: [x.jsx("p", { className: "leading-4 text-[12px] font-normal text-gray-400", children: h.releaseDate || "N/A" }), x.jsx("span", { className: "w-1 h-1 rounded-full bg-gray-600" }), x.jsx("p", { className: "leading-4 text-[12px] font-medium text-gray-300 group-hover:text-white", children: h.showType || "N/A" }), x.jsx("span", { className: "w-1 h-1 rounded-full bg-gray-600" }), x.jsx("p", { className: "leading-4 text-[12px] font-normal text-gray-400", children: h.duration || "N/A" })] })] })] }, p)), !i && u && x.jsx(We, { className: "w-full flex py-2.5 justify-center items-center bg-zinc-800 hover:bg-zinc-700 transition-all duration-200 rounded-b-lg", to: `/search?keyword=${encodeURIComponent(n)}`, onClick: t, children: x.jsxs("div", { className: "flex w-fit items-center gap-x-2", children: [x.jsx("p", { className: "text-[14px] font-medium text-gray-200", children: "View all results" }), x.jsx(Hi, { className: "text-gray-200 text-[11px] mt-[1px]" })] }) })] }) : u ? x.jsx("p", { className: "text-gray-300 p-3", children: "No results found!" }) : null }) } const Tb = () => { const { isSearchVisible: n, setIsSearchVisible: e } = cR(), [t, r] = j.useState(""), [s, i] = j.useState(!1), [a, o] = j.useState(""), c = j.useRef([]), u = zr(); j.useEffect(() => { const h = setTimeout(() => { o(t) }, 500); return () => { clearTimeout(h) } }, [t]), j.useEffect(() => { e(!1), r(""), o("") }, [u, e]), j.useEffect(() => { const h = p => { const v = c.current.some(y => y && y.contains(p.target)), g = document.activeElement === p.target; !v && !g && i(!1) }; return document.addEventListener("mousedown", h), () => { document.removeEventListener("mousedown", h) } }, []); const f = j.useCallback(h => { h && !c.current.includes(h) && c.current.push(h) }, []); return { isSearchVisible: n, setIsSearchVisible: e, searchValue: t, setSearchValue: r, isFocused: s, setIsFocused: i, debouncedValue: a, suggestionRefs: c, addSuggestionRef: f } }; function dR() { const n = _r(), { setIsSearchVisible: e, searchValue: t, setSearchValue: r, isFocused: s, setIsFocused: i, debouncedValue: a, suggestionRefs: o, addSuggestionRef: c } = Tb(), u = () => { window.innerWidth <= 600 && e(f => !f), t.trim() && window.innerWidth > 600 && n(`/search?keyword=${encodeURIComponent(t)}`) }; return x.jsxs("div", { className: "flex items-center relative w-[450px] max-[600px]:w-fit", children: [x.jsx("input", { type: "text", className: "w-full px-5 py-2 bg-[#2a2a2a]/75 text-white rounded-lg focus:outline-none transition-colors placeholder-white/50 max-[600px]:hidden", placeholder: "Search anime...", value: t, onChange: f => r(f.target.value), onFocus: () => i(!0), onBlur: () => { setTimeout(() => { o.current.some(h => h && h.contains(document.activeElement)) || i(!1) }, 100) }, onKeyDown: f => { f.key === "Enter" && t.trim() && n(`/search?keyword=${encodeURIComponent(t)}`) } }), x.jsx("button", { className: "absolute right-4 text-white/50 hover:text-white transition-colors max-[600px]:static max-[600px]:bg-transparent focus:outline-none max-[600px]:p-0", onClick: u, children: x.jsx(me, { icon: po, className: "text-lg max-[600px]:text-white max-[600px]:text-2xl max-[575px]:text-xl max-[600px]:mt-[7px]" }) }), t.trim() && s && x.jsx("div", { ref: c, className: "absolute z-[100000] top-full w-full", children: x.jsx(Eb, { keyword: a, className: "w-full" }) })] }) } function fR({ onClose: n }) { const e = _r(), t = zr(), { searchValue: r, setSearchValue: s, isFocused: i, setIsFocused: a, debouncedValue: o, suggestionRefs: c, addSuggestionRef: u } = Tb(), f = () => { r.trim() && (e(`/search?keyword=${encodeURIComponent(r)}`), n?.()) }, h = () => { t.pathname === "/random" && window.location.reload(), n?.() }; return x.jsxs("div", { className: "w-full p-4 flex flex-col gap-4", children: [x.jsxs("div", { className: "flex items-center gap-2", children: [x.jsxs("div", { className: "relative flex-1", children: [x.jsx("input", { type: "text", className: "w-full px-5 py-2 bg-[#2a2a2a]/75 text-white rounded-lg focus:outline-none transition-colors placeholder-white/50", placeholder: "Search anime...", value: r, onChange: p => s(p.target.value), onFocus: () => a(!0), onBlur: () => { setTimeout(() => { c.current.some(v => v && v.contains(document.activeElement)) || a(!1) }, 100) }, onKeyDown: p => { p.key === "Enter" && f() } }), x.jsx("button", { className: "absolute right-4 top-1/2 -translate-y-1/2 text-white/50 hover:text-white transition-colors", onClick: f, children: x.jsx(me, { icon: po, className: "text-lg" }) })] }), x.jsx(We, { to: t.pathname === "/random" ? "#" : "/random", onClick: h, className: "p-[10px] aspect-square bg-[#2a2a2a]/75 text-white/50 hover:text-white rounded-lg transition-colors flex items-center justify-center shrink-0", title: "Random Anime", children: x.jsx(me, { icon: ip, className: "text-lg" }) })] }), r.trim() && i && x.jsx("div", { ref: u, className: "absolute z-[100000] left-0 right-0 px-4 mt-[60px]", children: x.jsx(Eb, { keyword: o, className: "w-full", onSuggestionClick: n }) })] }) } function hR() {
    const n = zr(), { language: e, toggleLanguage: t } = pn(), [r, s] = j.useState(n.pathname !== "/" && n.pathname !== "/home"), [i, a] = j.useState(!1), [o, c] = j.useState(!1), [u, f] = j.useState(!1); j.useEffect(() => { const g = () => { a(window.scrollY > 0) }; return window.addEventListener("scroll", g), () => { window.removeEventListener("scroll", g) } }, []); const h = () => { c(!0) }, p = () => { c(!1) }, v = () => { n.pathname === "/random" && window.location.reload() }; return j.useEffect(() => { s(n.pathname !== "/" && n.pathname !== "/home") }, [n.pathname]), x.jsx(lR, {
      children: x.jsxs("nav", {
        className: `fixed top-0 left-0 w-full z-[1000000] smooth-transition-slow bg-[#0a0a0a] animate-fade-in
          ${i ? "bg-opacity-80 backdrop-blur-md shadow-lg hover-glow" : "bg-opacity-100"}`, children: [x.jsxs("div", { className: "max-w-[1920px] mx-auto px-4 h-16 flex items-center justify-between", children: [x.jsx("div", { className: "flex items-center gap-8", children: x.jsxs("div", { className: "flex items-center gap-4 animate-slide-in-left", children: [x.jsx(me, { icon: mC, className: "text-xl text-gray-200 cursor-pointer hover:text-white smooth-transition hover-scale", onClick: h }), x.jsx(We, { to: "/home", className: "flex items-center hover-scale", children: x.jsx("img", { src: "/logo.jpg", alt: "AniRock Logo", className: "h-9 w-auto smooth-transition" }) })] }) }), x.jsx("div", { className: "flex-1 flex justify-center items-center max-w-none mx-8 hidden md:flex", children: x.jsxs("div", { className: "flex items-center gap-2 w-[600px]", children: [x.jsx(dR, {}), x.jsx(We, { to: n.pathname === "/random" ? "#" : "/random", onClick: v, className: "p-[10px] aspect-square bg-[#2a2a2a]/75 text-white/50 hover:text-white rounded-lg smooth-transition hover-scale hover-glow flex items-center justify-center", title: "Random Anime", children: x.jsx(me, { icon: ip, className: "text-lg" }) })] }) }), x.jsx("div", { className: "hidden md:flex items-center gap-2 bg-[#27272A] rounded-md p-1 animate-slide-in-right", children: ["EN", "JP"].map(g => x.jsx("button", { onClick: () => t(g), className: `px-3 py-1 text-sm font-medium rounded smooth-transition hover-scale ${e === g ? "bg-[#3F3F46] text-white animate-glow" : "text-gray-400 hover:text-white hover-glow"}`, children: g }, g)) }), x.jsx("div", { className: "md:hidden flex items-center", children: x.jsx("button", { onClick: () => f(!u), className: "p-[10px] aspect-square bg-[#2a2a2a]/75 text-white/50 hover:text-white rounded-lg smooth-transition hover-scale hover-glow flex items-center justify-center w-[38px] h-[38px]", title: u ? "Close Search" : "Search Anime", children: x.jsx(me, { icon: u ? OC : po, className: "w-[18px] h-[18px] transition-transform duration-200", style: { transform: u ? "rotate(90deg)" : "rotate(0deg)" } }) }) })] }), u && x.jsx("div", { className: "md:hidden bg-[#18181B] shadow-lg animate-fade-in-up", children: x.jsx(fR, { onClose: () => f(!1) }) }), x.jsx(oR, { isOpen: o, onClose: p })]
      })
    })
  } const Ab = "AniRock"; function pR() { return x.jsx("footer", { className: "w-full mt-20", children: x.jsx("div", { className: "max-w-[1920px] mx-auto px-4 py-12", children: x.jsxs("div", { className: "flex flex-col items-center text-center space-y-8", children: [x.jsx("div", { className: "animate-fade-in", children: x.jsx("img", { src: "/logo.jpg", alt: Ab, className: "h-[60px] w-[120px] object-contain opacity-80 hover:opacity-100 smooth-transition" }) }), x.jsxs("div", { className: "animate-fade-in-up stagger-1 animate-stagger", children: [x.jsx("h3", { className: "text-white/80 text-sm font-medium mb-4 tracking-wide", children: "BROWSE BY LETTER" }), x.jsx("div", { className: "flex flex-wrap gap-2 justify-center max-w-2xl", children: ["All", "#", "0-9", ...Array.from({ length: 26 }, (n, e) => String.fromCharCode(65 + e))].map((n, e) => x.jsx(We, { to: `az-list/${n === "All" ? "" : n}`, className: "w-8 h-8 flex items-center justify-center text-xs bg-white/5 hover:bg-white/15 text-white/60 hover:text-white rounded-md smooth-transition hover-scale border border-white/10 hover:border-white/20", children: n }, e)) })] }), x.jsx("div", { className: "animate-fade-in-up stagger-2 animate-stagger", children: x.jsx(We, { to: "/contact", className: "inline-flex items-center px-6 py-2 bg-white/5 hover:bg-white/10 text-white/70 hover:text-white text-sm rounded-full smooth-transition hover-scale border border-white/10 hover:border-white/20", children: "Get in Touch" }) }), x.jsx("div", { className: "w-full max-w-lg h-px bg-gradient-to-r from-transparent via-white/20 to-transparent animate-fade-in" }), x.jsxs("div", { className: "animate-fade-in-up stagger-3 animate-stagger space-y-3", children: [x.jsxs("p", { className: "text-white/40 text-xs max-w-2xl leading-relaxed", children: [_n, " does not host any content. All anime streams are provided by third-party services."] }), x.jsxs("p", { className: "text-white/30 text-xs", children: [" 2025 ", _n, ". All rights reserved."] })] })] }) }) }) } const Ib = async (n, e) => { const t = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${t}/${n}?page=${e}`)).data.results } catch (r) { return console.error("Error fetching genre info:", r), r } }; function mR({ path: n, label: e }) { const [t, r] = Nc(), [s, i] = j.useState(null), [a, o] = j.useState(!0), [c, u] = j.useState(null), [f, h] = j.useState(0), p = parseInt(t.get("page")) || 1; _r(), j.useEffect(() => { (async () => { o(!0); try { const w = await Ib(n, p); i(w.data), h(w.totalPages), o(!1) } catch (w) { u(w), console.error("Error fetching category info:", w), o(!1) } })(), window.scrollTo({ top: 0, behavior: "smooth" }) }, [n, p]); const v = y => { r({ page: y }) }, g = "grid-cols-8 max-[1600px]:grid-cols-6 max-[1200px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3 max-[478px]:gap-x-2"; return x.jsx("div", { className: "max-w-[1600px] mx-auto flex flex-col mt-[64px] max-md:mt-[50px]", children: x.jsx("div", { className: "w-full flex flex-col gap-y-8 mt-6", children: a ? x.jsx(Zs, { className: "max-[478px]:mt-2", gridClass: g }) : p > f ? x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: e.split("/").pop() }), x.jsxs("p", { className: "text-white text-lg max-[478px]:text-[16px] max-[300px]:leading-6", children: ["You came a long way, go back ", x.jsx("br", { className: "max-[300px]:hidden" }), "nothing is here"] })] }) : s && s.length > 0 ? x.jsxs("div", { className: "flex flex-col gap-y-2 max-[478px]:gap-y-0", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: e.split("/").pop() }), x.jsx(Es, { data: s, showViewMore: !1, className: "mt-0", gridClass: g, categoryPage: !0, path: n }), x.jsx("div", { className: "flex justify-center w-full mt-8", children: x.jsx(mo, { page: p, totalPages: f, handlePageChange: v }) })] }) : c ? x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: e.split("/").pop() }), x.jsxs("p", { className: "text-white text-lg max-[478px]:text-[16px]", children: ["Couldn't get ", e.split("/").pop(), " results, please try again"] })] }) : x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: e.split("/").pop() }), x.jsxs("p", { className: "text-white text-lg max-[478px]:text-[16px]", children: ["No results found for: ", e.split("/").pop()] })] }) }) }) } function gR({ path: n }) { const [e, t] = Nc(), [r, s] = j.useState(null), [i, a] = j.useState(!0), [o, c] = j.useState(null), [u, f] = j.useState(0), h = parseInt(e.get("page")) || 1, p = n.split("/").pop() || ""; if (j.useEffect(() => { (async () => { a(!0); try { const y = await Ib(n, h); s(y.data), f(y.totalPages), a(!1) } catch (y) { c(y), a(!1), console.error("Error fetching category info:", y) } })(), window.scrollTo(0, 0) }, [n, h]), i) return x.jsx(Qa, { type: "AtoZ" }); if (o) return x.jsx(Pn, {}); if (!r) return null; const v = g => { t({ page: g }) }; return x.jsxs("div", { className: "max-w-[1600px] mx-auto flex flex-col mt-[64px] max-md:mt-[50px]", children: [x.jsxs("div", { className: "flex flex-col gap-y-2 max-[478px]:gap-y-0 mt-6", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: "Sort By Letters" }), x.jsx("div", { className: "flex gap-x-[7px] flex-wrap justify-start gap-y-2 max-md:justify-start", children: ["All", "#", "0-9", ...Array.from({ length: 26 }, (g, y) => String.fromCharCode(65 + y))].map((g, y) => { const w = g.toLowerCase() === "all" ? "" : g === "#" ? "other" : g, T = p === "az-list" && g.toLowerCase() === "all" || p === "other" && g === "#" || p === g.toLowerCase(); return x.jsx(We, { to: `/az-list/${w}`, className: `text-md bg-[#373646] py-1 px-4 rounded-md font-bold hover:text-black hover:bg-white hover:cursor-pointer transition-all ease-out ${T ? "text-black bg-white" : ""}`, children: g }, y) }) })] }), x.jsx("div", { className: "w-full flex flex-col gap-y-8", children: x.jsxs("div", { children: [r && r.length > 0 && x.jsx(Es, { data: r, limit: r.length, showViewMore: !1, className: "mt-8", cardStyle: "grid-cols-8 max-[1600px]:grid-cols-6 max-[1200px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3 max-[478px]:gap-x-2" }), x.jsx("div", { className: "flex justify-center w-full mt-8", children: x.jsx(mo, { page: h, totalPages: u, handlePageChange: v }) })] }) })] }) } const xR = ["genre/action", "genre/adventure", "genre/cars", "genre/comedy", "genre/dementia", "genre/demons", "genre/drama", "genre/ecchi", "genre/fantasy", "genre/game", "genre/harem", "genre/historical", "genre/horror", "genre/isekai", "genre/josei", "genre/kids", "genre/magic", "genre/martial-arts", "genre/mecha", "genre/military", "genre/music", "genre/mystery", "genre/parody", "genre/police", "genre/psychological", "genre/romance", "genre/samurai", "genre/school", "genre/sci-fi", "genre/seinen", "genre/shoujo", "genre/shoujo-ai", "genre/shounen", "genre/shounen-ai", "genre/slice-of-life", "genre/space", "genre/sports", "genre/super-power", "genre/supernatural", "genre/thriller", "genre/vampire", "top-airing", "most-popular", "most-favorite", "completed", "recently-updated", "recently-added", "top-upcoming", "subbed-anime", "dubbed-anime", "movie", "special", "ova", "ona", "tv"], vR = ["az-list", "az-list/other", "az-list/0-9", "az-list/a", "az-list/b", "az-list/c", "az-list/d", "az-list/e", "az-list/f", "az-list/g", "az-list/h", "az-list/i", "az-list/j", "az-list/k", "az-list/l", "az-list/m", "az-list/n", "az-list/o", "az-list/p", "az-list/q", "az-list/r", "az-list/s", "az-list/t", "az-list/u", "az-list/v", "az-list/w", "az-list/x", "az-list/y", "az-list/z"], yR = async (n, e) => { const t = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${t}/search?keyword=${n}&page=${e}`)).data.results } catch (r) { return console.error("Error fetching genre info:", r), r } }; function bR() { const [n, e] = Nc(), t = n.get("keyword"), r = parseInt(n.get("page"), 10) || 1, [s, i] = j.useState(null), [a, o] = j.useState(0), [c, u] = j.useState(!0), [f, h] = j.useState(null); j.useEffect(() => { (async () => { u(!0); try { const y = await yR(t, r); i(y.data), o(y.totalPage), u(!1) } catch (y) { console.error("Error fetching anime info:", y), h(y), u(!1) } })(), window.scrollTo({ top: 0, behavior: "smooth" }) }, [t, r]); const p = g => { e({ keyword: t, page: g }) }, v = "grid-cols-8 max-[1600px]:grid-cols-6 max-[1200px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3 max-[478px]:gap-x-2"; return x.jsx("div", { className: "max-w-[1600px] mx-auto flex flex-col mt-[64px] max-md:mt-[50px]", children: x.jsx("div", { className: "w-full flex flex-col gap-y-8 mt-6", children: c ? x.jsx(Zs, { className: "max-[478px]:mt-2", gridClass: v }) : r > a ? x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: "Search Results" }), x.jsxs("p", { className: "text-white text-lg max-[478px]:text-[16px] max-[300px]:leading-6", children: ["You came a long way, go back ", x.jsx("br", { className: "max-[300px]:hidden" }), "nothing is here"] })] }) : s && s.length > 0 ? x.jsxs("div", { className: "flex flex-col gap-y-2 max-[478px]:gap-y-0", children: [x.jsxs("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: ["Search Results for: ", t] }), x.jsx(Es, { data: s, showViewMore: !1, className: "mt-0", gridClass: v }), x.jsx("div", { className: "flex justify-center w-full mt-8", children: x.jsx(mo, { page: r, totalPages: a, handlePageChange: p }) })] }) : f ? x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: "Search Results" }), x.jsx("p", { className: "text-white text-lg max-[478px]:text-[16px]", children: "Couldn't get search results, please try again" })] }) : x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsx("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: "Search Results" }), x.jsxs("p", { className: "text-white text-lg max-[478px]:text-[16px]", children: ["No results found for: ", t] })] }) }) }) } async function wR(n) { const e = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${e}/episodes/${n}`)).data.results } catch (t) { return console.error("Error fetching anime info:", t), t } } const SR = async n => { const e = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${e}/schedule/${n}`)).data.results } catch (t) { return console.error("Error fetching next episode schedule:", t), t } }; async function ER(n, e) { try { return (await Ke.get(`https://apii-orcin-theta.vercel.app/api/servers/${n}?ep=${e}`)).data.results } catch (t) { return console.error(t), t } } async function TR(n, e, t, r) { const s = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${s}/stream?id=${n}?ep=${e}&server=${t}&type=${r}`)).data.results } catch (i) { return console.error("Error fetching stream info:", i), i } } const AR = (n, e) => { const [t, r] = j.useState(null), [s, i] = j.useState(!0), [a, o] = j.useState(null), [c, u] = j.useState(null), [f, h] = j.useState(null), [p, v] = j.useState(!1), [g, y] = j.useState(null), [w, T] = j.useState(null), [S, E] = j.useState(null), [I, C] = j.useState(null), [D, R] = j.useState(!1), [N, P] = j.useState([]), [_, M] = j.useState(null), [$, B] = j.useState(null), [V, W] = j.useState(null), [U, q] = j.useState(null), [z, X] = j.useState(null), [Z, F] = j.useState(null), [H, ae] = j.useState(null), [he, de] = j.useState(null), [pe, Ce] = j.useState(!0), [Ie, Pe] = j.useState(null), Ve = j.useRef(!1), rt = j.useRef(!1); return j.useEffect(() => { h(null), q(null), X(null), E(null), F(null), o(null), C(null), P([]), M(null), B(null), W(null), i(!0), Ce(!0), r(null), u(null), T(null), y(null), v(!0), Ve.current = !1, rt.current = !1 }, [n]), j.useEffect(() => { (async () => { try { v(!0); const [je, Oe] = await Promise.all([wb(n, !1), wR(n)]); u(je?.data), T(je?.seasons), h(Oe?.episodes), y(Oe?.totalEpisodes); const ot = e || (Oe?.episodes?.length > 0 ? Oe.episodes[0].id.match(/ep=(\d+)/)?.[1] : null); q(ot) } catch (je) { console.error("Error fetching initial data:", je), r(je.message || "An error occurred.") } finally { v(!1) } })() }, [n]), j.useEffect(() => { (async () => { try { const je = await SR(n); Pe(je) } catch (je) { console.error("Error fetching next episode schedule:", je) } })() }, [n]), j.useEffect(() => { if (!f || !U) { X(null); return } const ft = f.find(Oe => { const ot = Oe.id.match(/ep=(\d+)/); return ot && ot[1] === U }), je = ft ? ft.episode_no : null; z !== je && X(je) }, [U, f]), j.useEffect(() => { if (!U || !f || Ve.current) return; (async () => { Ve.current = !0, Ce(!0); try { const je = await ER(n, U); console.log(je); const Oe = je?.filter(_e => _e.serverName === "HD-1" || _e.serverName === "HD-2" || _e.serverName === "HD-3"); Oe.some(_e => _e.type === "sub") && Oe.push({ type: "sub", data_id: "69696969", server_id: "41", serverName: "HD-4" }), Oe.some(_e => _e.type === "dub") && Oe.push({ type: "dub", data_id: "96969696", server_id: "42", serverName: "HD-4" }); const ot = localStorage.getItem("server_name"), Le = localStorage.getItem("server_type"), ie = Oe.find(_e => _e.serverName === ot && _e.type === Le) || Oe.find(_e => _e.serverName === ot) || Oe.find(_e => _e.type === Le && ["HD-1", "HD-2", "HD-3", "HD-4"].includes(_e.serverName)) || Oe[0]; E(Oe), ae(ie?.type), de(ie?.serverName), F(ie?.data_id) } catch (je) { console.error("Error fetching servers:", je), r(je.message || "An error occurred.") } finally { Ce(!1), Ve.current = !1 } })() }, [U, f]), j.useEffect(() => { if (!U || !Z || !S || Ve.current || rt.current) return; if ((he?.toLowerCase() === "hd-1" || he?.toLowerCase() === "hd-4") && !pe) { i(!1); return } (async () => { rt.current = !0, i(!0); try { const je = S.find(Oe => Oe.data_id === Z); if (je) { const Oe = await TR(n, U, je.serverName.toLowerCase() === "hd-3" ? "hd-1" : je.serverName.toLowerCase(), je.type.toLowerCase()); o(Oe), C(Oe?.streamingLink?.link?.file || null), B(Oe?.streamingLink?.intro || null), W(Oe?.streamingLink?.outro || null); const ot = Oe?.streamingLink?.tracks?.filter(ie => ie.kind === "captions").map(({ file: ie, label: _e }) => ({ file: ie, label: _e })) || []; P(ot); const Le = Oe?.streamingLink?.tracks?.find(ie => ie.kind === "thumbnails" && ie.file); Le && M(Le.file) } else r("No server found with the activeServerId.") } catch (je) { console.error("Error fetching stream info:", je), r(je.message || "An error occurred.") } finally { i(!1), rt.current = !1 } })() }, [U, Z, S]), { error: t, buffering: s, serverLoading: pe, streamInfo: a, animeInfo: c, episodes: f, nextEpisodeSchedule: Ie, animeInfoLoading: p, totalEpisodes: g, seasons: w, servers: S, streamUrl: I, isFullOverview: D, setIsFullOverview: R, subtitles: N, thumbnail: _, intro: $, outro: V, episodeId: U, setEpisodeId: q, activeEpisodeNum: z, setActiveEpisodeNum: X, activeServerId: Z, setActiveServerId: F, activeServerType: H, setActiveServerType: ae, activeServerName: he, setActiveServerName: de } }; function IR({ episodeId: n, serverName: e, servertype: t, animeInfo: r, episodeNum: s, episodes: i, playNext: a, autoNext: o }) { const c = e.toLowerCase() === "hd-1" ? "https://megaplay.buzz/stream/s-2" : e.toLowerCase() === "hd-4" ? "https://vidwish.live/stream/s-2" : void 0, [u, f] = j.useState(!0), [h, p] = j.useState(!1), [v, g] = j.useState(""), [y, w] = j.useState(i?.findIndex(T => T.id.match(/ep=(\d+)/)?.[1] === n)); return j.useEffect(() => { (async () => { f(!0), p(!1), g(""), g(`${c}/${n}/${t}`) })() }, [n, t, e, r]), j.useEffect(() => { if (i?.length > 0) { const T = i.findIndex(S => S.id.match(/ep=(\d+)/)?.[1] === n); w(T) } }, [n, i]), j.useEffect(() => { const T = S => { const { currentTime: E, duration: I } = S.data; typeof E == "number" && typeof I == "number" && E >= I && y < i?.length - 1 && o && a(i[y + 1].id.match(/ep=(\d+)/)?.[1]) }; return window.addEventListener("message", T), () => { window.removeEventListener("message", T) } }, [o, y, i, a]), j.useEffect(() => (f(!0), p(!1), () => { const T = JSON.parse(localStorage.getItem("continueWatching")) || [], S = { id: r?.id, data_id: r?.data_id, episodeId: n, episodeNum: s, adultContent: r?.adultContent, poster: r?.poster, title: r?.title, japanese_title: r?.japanese_title }; if (!S.data_id) return; const E = T.findIndex(I => I.data_id === S.data_id); E !== -1 ? T[E] = S : T.push(S), localStorage.setItem("continueWatching", JSON.stringify(T)) }), [n, t]), x.jsxs("div", { className: "relative w-full h-full overflow-hidden", children: [x.jsx("div", { className: `absolute inset-0 flex justify-center items-center bg-black bg-opacity-50 z-10 transition-opacity duration-500 ${u ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none"}`, children: x.jsx(gs, {}) }), x.jsx("iframe", { src: v, allowFullScreen: !0, className: `w-full h-full transition-opacity duration-500 ${h ? "opacity-100" : "opacity-0"}`, onLoad: () => { p(!0), setTimeout(() => f(!1), 1e3) } }, `${n}-${t}-${e}-${v}`)] }) } function Zx({ episodes: n, onEpisodeClick: e, currentEpisode: t, totalEpisodes: r }) {
    const [s, i] = j.useState(t), { language: a } = pn(), o = j.useRef(null), c = j.useRef(null), [u, f] = j.useState(!1), [h, p] = j.useState([1, 100]), [v, g] = j.useState("1-100"), [y, w] = j.useState(t), T = j.useRef(null), [S, E] = j.useState(null), I = () => { if (c.current && o.current) { const P = o.current, _ = c.current, M = P.getBoundingClientRect().top, $ = P.clientHeight, B = _.getBoundingClientRect().top, V = _.clientHeight, W = B - M; P.scrollTop = P.scrollTop + W - $ / 2 + V / 2 } }; j.useEffect(() => { i(y) }, [y]), j.useEffect(() => { I() }, [s]), j.useEffect(() => { const P = _ => { T.current && !T.current.contains(_.target) && f(!1) }; return document.addEventListener("mousedown", P), () => { document.removeEventListener("mousedown", P) } }, []); function C(P) { const _ = P.target.value; if (_.trim() === "") { const M = D(1); p(M), g(`${M[0]}-${M[1]}`), E(null) } else if (!_ || isNaN(_)) E(null); else if (!isNaN(_) && parseInt(_, 10) > r && y !== null) { const M = D(y); p(M), g(`${M[0]}-${M[1]}`), E(null) } else if (!isNaN(_) && _.trim() !== "") { const M = parseInt(_, 10), $ = n.find(B => B?.episode_no === M); if ($) { const B = D(M); p(B), g(`${B[0]}-${B[1]}`), E($?.id) } } else E(null) } function D(P) { const M = Math.floor((P - 1) / 100) * 100 + 1, $ = Math.min(M + 100 - 1, r); return [M, $] } function R(P) { const _ = []; for (let $ = 0; $ < P; $ += 100) { const B = $ + 1, V = Math.min($ + 100, P); _.push(`${B}-${V}`) } return _ } j.useEffect(() => { if (t && y && (y < h[0] || y > h[1])) { const P = D(y); p(P), g(`${P[0]}-${P[1]}`) } }, [t, r, y]); const N = P => { const [_, M] = P.split("-").map(Number); p([_, M]) }; return j.useEffect(() => { const P = n.find(_ => _?.id.match(/ep=(\d+)/)?.[1] === s); P && w(P?.episode_no) }, [s, n]), x.jsxs("div", {
      className: "flex flex-col w-full h-full", children: [x.jsxs("div", { className: "sticky top-0 z-10 flex items-center justify-between px-4 py-2.5 bg-[#1a1a1a] border-b border-[#2a2a2a] max-[600px]:px-2", children: [x.jsxs("div", { className: "flex items-center gap-4 max-[600px]:gap-2", children: [x.jsx("h1", { className: "text-[14px] font-semibold text-white max-[600px]:text-[13px]", children: "Episodes" }), r > 100 && x.jsx("div", { className: "flex items-center", children: x.jsxs("div", { onClick: () => f(P => !P), className: "text-gray-300 relative cursor-pointer flex items-center gap-2 hover:text-white transition-colors max-[600px]:gap-1", ref: T, children: [x.jsx(me, { icon: xC, className: "text-gray-400" }), x.jsxs("p", { className: "text-[12px] max-[600px]:text-[11px]", children: [h[0], "-", h[1]] }), x.jsx(me, { icon: _C, className: "text-[10px]" }), u && x.jsx("div", { className: "absolute top-full mt-2 left-0 z-30 bg-[#2a2a2a] w-[150px] max-h-[200px] overflow-y-auto rounded-lg border border-[#3a3a3a] shadow-lg", children: R(r).map((P, _) => x.jsx("div", { onClick: () => { N(P), g(P) }, className: `hover:bg-[#3a3a3a] cursor-pointer transition-colors ${P === v ? "bg-[#404040]" : ""}`, children: x.jsxs("p", { className: "font-medium text-[12px] p-2.5 flex justify-between items-center text-gray-300 hover:text-white max-[600px]:text-[11px] max-[600px]:p-2", children: [P, P === v ? x.jsx(me, { icon: db, className: "text-white" }) : null] }) }, _)) })] }) })] }), r > 100 && x.jsx("div", { className: "flex items-center min-w-[180px] max-[600px]:min-w-[120px]", children: x.jsxs("div", { className: "w-full flex items-center gap-2 px-3 py-1.5 bg-[#2a2a2a] rounded-lg border border-[#3a3a3a] focus-within:border-gray-500 transition-colors max-[600px]:px-2 max-[600px]:py-1", children: [x.jsx(me, { icon: po, className: "text-[12px] text-gray-400" }), x.jsx("input", { type: "text", className: "w-full bg-transparent focus:outline-none text-[13px] text-white placeholder:text-gray-500 max-[600px]:text-[12px]", placeholder: "Go to episode...", onChange: C })] }) })] }), x.jsx("div", {
        ref: o, className: "w-full flex-1 overflow-y-auto bg-[#1a1a1a] max-h-[calc(100vh-200px)] max-[1200px]:max-h-[400px]", children: x.jsx("div", {
          className: `${r > 30 ? "p-4 grid gap-2 max-[600px]:p-2 max-[600px]:gap-1.5" + (r > 100 ? " grid-cols-5" : " grid-cols-5 max-[1200px]:grid-cols-12 max-[860px]:grid-cols-10 max-[575px]:grid-cols-8 max-[478px]:grid-cols-6 max-[350px]:grid-cols-5") : ""}`, children: r > 30 ? n.slice(h[0] - 1, h[1]).map((P, _) => {
            const M = P?.id.match(/ep=(\d+)/)?.[1], $ = s === M || t === M, B = S === P?.id; return x.jsx("div", {
              ref: $ ? c : null, className: `flex items-center justify-center rounded-lg h-[35px] text-[13px] font-medium cursor-pointer transition-all max-[600px]:h-[30px] max-[600px]:text-[12px] ${P?.filler ? $ ? "bg-white text-black" : "bg-[#2a2a2a] text-gray-400" : ""} hover:bg-[#404040] 
                          hover:text-white
                       ${$ ? "bg-white text-black ring-1 ring-white" : "bg-[#2a2a2a] text-gray-400"} ${B ? "ring-2 ring-white" : ""}`, onClick: () => { M && (e(M), i(M), E(null)) }, children: x.jsx("span", { className: "transition-colors", children: _ + h[0] })
            }, P?.id)
          }) : n?.map((P, _) => { const M = P?.id.match(/ep=(\d+)/)?.[1], $ = s === M || t === M, B = S === P?.id; return x.jsxs("div", { ref: $ ? c : null, className: `w-full px-4 py-2.5 flex items-center justify-start gap-x-4 cursor-pointer transition-all max-[600px]:px-3 max-[600px]:py-2 max-[600px]:gap-x-3 ${(_ + 1) % 2 && !$ ? "bg-[#202020]" : "bg-[#1a1a1a]"} hover:bg-[#2a2a2a] ${$ ? "bg-[#2a2a2a]" : ""} ${B ? "ring-1 ring-white" : ""}`, onClick: () => { M && (e(M), i(M), E(null)) }, children: [x.jsx("p", { className: `text-[14px] font-medium max-[600px]:text-[13px] ${$ ? "text-white" : "text-gray-400"}`, children: _ + 1 }), x.jsxs("div", { className: "w-full flex items-center justify-between gap-x-[5px]", children: [x.jsx("h1", { className: `line-clamp-1 text-[14px] transition-colors max-[600px]:text-[13px] ${$ ? "text-white font-medium" : "text-gray-400 font-normal"}`, children: a === "EN" ? P?.title : P?.japanese_title }), $ && x.jsx(me, { icon: hh, className: "w-[18px] h-[18px] text-white max-[600px]:w-[16px] max-[600px]:h-[16px]" })] })] }, P?.id) })
        })
      })]
    })
  } function LR({ servers: n, activeEpisodeNum: e, activeServerId: t, setActiveServerId: r, serverLoading: s, setActiveServerType: i, setActiveServerName: a }) { const o = n?.filter(h => h.type === "sub") || [], c = n?.filter(h => h.type === "dub") || [], u = n?.filter(h => h.type === "raw") || []; j.useEffect(() => { const h = localStorage.getItem("server_name"); if (h) { const p = n?.find(v => v.serverName === h); p ? (r(p.data_id), i(p.type)) : n && n.length > 0 && (r(n[0].data_id), i(n[0].type)) } else n && n.length > 0 && (r(n[0].data_id), i(n[0].type)) }, [n]); const f = h => { r(h.data_id), i(h.type), a(h.serverName), localStorage.setItem("server_name", h.serverName), localStorage.setItem("server_type", h.type) }; return x.jsx("div", { className: "relative bg-[#111111] p-4 w-full min-h-[100px] flex justify-center items-center max-[1200px]:bg-[#151515] max-[600px]:p-2", children: s ? x.jsx("div", { className: "w-full h-full rounded-lg flex justify-center items-center max-[600px]:rounded-none", children: x.jsx(gs, {}) }) : n ? x.jsxs("div", { className: "w-full h-full rounded-lg grid grid-cols-[minmax(0,30%),minmax(0,70%)] overflow-hidden max-[800px]:grid-cols-[minmax(0,40%),minmax(0,60%)] max-[600px]:flex max-[600px]:flex-col max-[600px]:rounded-none max-[600px]:gap-2", children: [x.jsxs("div", { className: "h-full bg-[#e0e0e0] px-6 text-black flex flex-col justify-center items-center gap-y-2 max-[600px]:bg-transparent max-[600px]:h-auto max-[600px]:text-white max-[600px]:py-1 max-[600px]:px-2", children: [x.jsxs("p", { className: "text-center leading-5 font-medium text-[14px] max-[600px]:text-[13px] max-[600px]:mb-0", children: ["You are watching:", " ", x.jsx("br", { className: "max-[600px]:hidden" }), x.jsxs("span", { className: "font-semibold max-[600px]:text-[#e0e0e0] max-[600px]:ml-1", children: ["Episode ", e] })] }), x.jsx("p", { className: "leading-5 text-[14px] font-medium text-center max-[600px]:text-[12px] max-[600px]:hidden", children: "If the current server doesn't work, please try other servers beside." })] }), x.jsxs("div", { className: "bg-[#1f1f1f] flex flex-col max-[600px]:rounded-lg max-[600px]:p-2", children: [u.length > 0 && x.jsxs("div", { className: `servers px-2 flex items-center flex-wrap gap-y-1 ml-2 max-[600px]:py-1.5 max-[600px]:px-1 max-[600px]:ml-0 ${c.length === 0 || o.length === 0 ? "h-1/2" : "h-full"}`, children: [x.jsxs("div", { className: "flex items-center gap-x-2 min-w-[65px]", children: [x.jsx(me, { icon: PC, className: "text-[#e0e0e0] text-[13px]" }), x.jsx("p", { className: "font-bold text-[14px] max-[600px]:text-[12px]", children: "RAW:" })] }), x.jsx("div", { className: "flex gap-1.5 ml-2 flex-wrap max-[600px]:ml-0", children: u.map((h, p) => x.jsx("div", { className: `px-6 py-[5px] rounded-lg cursor-pointer ${t === h?.data_id ? "bg-[#e0e0e0] text-black" : "bg-[#373737] text-white"} max-[700px]:px-3 max-[600px]:px-2 max-[600px]:py-1`, onClick: () => f(h), children: x.jsx("p", { className: "text-[13px] font-semibold max-[600px]:text-[12px]", children: h.serverName }) }, p)) })] }), o.length > 0 && x.jsxs("div", { className: `servers px-2 flex items-center flex-wrap gap-y-1 ml-2 max-[600px]:py-1.5 max-[600px]:px-1 max-[600px]:ml-0 ${c.length === 0 ? "h-1/2" : "h-full"}`, children: [x.jsxs("div", { className: "flex items-center gap-x-2 min-w-[65px]", children: [x.jsx(me, { icon: Mn, className: "text-[#e0e0e0] text-[13px]" }), x.jsx("p", { className: "font-bold text-[14px] max-[600px]:text-[12px]", children: "SUB:" })] }), x.jsx("div", { className: "flex gap-1.5 ml-2 flex-wrap max-[600px]:ml-0", children: o.map((h, p) => x.jsx("div", { className: `px-6 py-[5px] rounded-lg cursor-pointer ${t === h?.data_id ? "bg-[#e0e0e0] text-black" : "bg-[#373737] text-white"} max-[700px]:px-3 max-[600px]:px-2 max-[600px]:py-1`, onClick: () => f(h), children: x.jsx("p", { className: "text-[13px] font-semibold max-[600px]:text-[12px]", children: h.serverName }) }, p)) })] }), c.length > 0 && x.jsxs("div", { className: `servers px-2 flex items-center flex-wrap gap-y-1 ml-2 max-[600px]:py-1.5 max-[600px]:px-1 max-[600px]:ml-0 ${o.length === 0 ? "h-1/2" : "h-full"}`, children: [x.jsxs("div", { className: "flex items-center gap-x-2 min-w-[65px]", children: [x.jsx(me, { icon: On, className: "text-[#e0e0e0] text-[13px]" }), x.jsx("p", { className: "font-bold text-[14px] max-[600px]:text-[12px]", children: "DUB:" })] }), x.jsx("div", { className: "flex gap-1.5 ml-2 flex-wrap max-[600px]:ml-0", children: c.map((h, p) => x.jsx("div", { className: `px-6 py-[5px] rounded-lg cursor-pointer ${t === h?.data_id ? "bg-[#e0e0e0] text-black" : "bg-[#373737] text-white"} max-[700px]:px-3 max-[600px]:px-2 max-[600px]:py-1`, onClick: () => f(h), children: x.jsx("p", { className: "text-[13px] font-semibold max-[600px]:text-[12px]", children: h.serverName }) }, p)) })] })] })] }) : x.jsxs("p", { className: "text-center font-medium text-[15px] absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10 pointer-events-none", children: ["Could not load servers ", x.jsx("br", {}), "Either reload or try again after sometime"] }) }) } const cf = ({ label: n, isActive: e, onClick: t }) => x.jsxs("button", { className: "flex items-center text-xs px-2 py-0.5 rounded transition-colors hover:bg-[#2a2a2a]", onClick: t, children: [x.jsx("span", { className: "text-gray-300", children: n }), x.jsx("span", { className: `ml-1.5 ${e ? "text-white" : "text-gray-500"}`, children: e ? "ON" : "OFF" })] }); function CR({ autoPlay: n, setAutoPlay: e, autoSkipIntro: t, setAutoSkipIntro: r, autoNext: s, setAutoNext: i, episodeId: a, episodes: o = [], onButtonClick: c }) { const [u, f] = j.useState(o?.findIndex(h => h.id.match(/ep=(\d+)/)?.[1] === a)); return j.useEffect(() => { if (o?.length > 0) { const h = o.findIndex(p => p.id.match(/ep=(\d+)/)?.[1] === a); f(h) } }, [a, o]), x.jsxs("div", { className: "w-full flex justify-between items-center px-3 py-2 border-b border-gray-800", children: [x.jsxs("div", { className: "flex gap-x-2", children: [x.jsx(cf, { label: "Auto Play", isActive: n, onClick: () => e(h => !h) }), x.jsx(cf, { label: "Skip Intro", isActive: t, onClick: () => r(h => !h) }), x.jsx(cf, { label: "Auto Next", isActive: s, onClick: () => i(h => !h) })] }), x.jsxs("div", { className: "flex items-center gap-x-2", children: [x.jsx("button", { onClick: () => { u > 0 && c(o[u - 1].id.match(/ep=(\d+)/)?.[1]) }, disabled: u <= 0, className: `w-7 h-7 flex items-center justify-center rounded transition-colors ${u <= 0 ? "text-gray-600 cursor-not-allowed" : "text-gray-300 hover:text-white"}`, children: x.jsx(me, { icon: pC, className: "text-[14px]" }) }), x.jsx("button", { onClick: () => { u < o?.length - 1 && c(o[u + 1].id.match(/ep=(\d+)/)?.[1]) }, disabled: u >= o?.length - 1, className: `w-7 h-7 flex items-center justify-center rounded transition-colors ${u >= o?.length - 1 ? "text-gray-600 cursor-not-allowed" : "text-gray-300 hover:text-white"}`, children: x.jsx(me, { icon: CC, className: "text-[14px]" }) })] })] }) } function kR() { const [n, e] = j.useState(() => JSON.parse(localStorage.getItem("autoPlay")) || !1), [t, r] = j.useState(() => JSON.parse(localStorage.getItem("autoSkipIntro")) || !1), [s, i] = j.useState(() => JSON.parse(localStorage.getItem("autoNext")) || !1); return j.useEffect(() => { localStorage.setItem("autoPlay", JSON.stringify(n)) }, [n]), j.useEffect(() => { localStorage.setItem("autoSkipIntro", JSON.stringify(t)) }, [t]), j.useEffect(() => { localStorage.setItem("autoNext", JSON.stringify(s)) }, [s]), { autoPlay: n, setAutoPlay: e, autoSkipIntro: t, setAutoSkipIntro: r, autoNext: s, setAutoNext: i } } const ge = Number.isFinite || function (n) { return typeof n == "number" && isFinite(n) }, RR = Number.isSafeInteger || function (n) { return typeof n == "number" && Math.abs(n) <= _R }, _R = Number.MAX_SAFE_INTEGER || 9007199254740991; let Ee = (function (n) { return n.NETWORK_ERROR = "networkError", n.MEDIA_ERROR = "mediaError", n.KEY_SYSTEM_ERROR = "keySystemError", n.MUX_ERROR = "muxError", n.OTHER_ERROR = "otherError", n })({}), J = (function (n) { return n.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", n.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", n.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", n.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", n.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", n.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", n.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", n.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", n.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", n.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", n.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", n.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", n.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", n.MANIFEST_LOAD_ERROR = "manifestLoadError", n.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", n.MANIFEST_PARSING_ERROR = "manifestParsingError", n.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", n.LEVEL_EMPTY_ERROR = "levelEmptyError", n.LEVEL_LOAD_ERROR = "levelLoadError", n.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", n.LEVEL_PARSING_ERROR = "levelParsingError", n.LEVEL_SWITCH_ERROR = "levelSwitchError", n.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", n.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", n.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", n.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", n.FRAG_LOAD_ERROR = "fragLoadError", n.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", n.FRAG_DECRYPT_ERROR = "fragDecryptError", n.FRAG_PARSING_ERROR = "fragParsingError", n.FRAG_GAP = "fragGap", n.REMUX_ALLOC_ERROR = "remuxAllocError", n.KEY_LOAD_ERROR = "keyLoadError", n.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", n.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", n.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", n.BUFFER_APPEND_ERROR = "bufferAppendError", n.BUFFER_APPENDING_ERROR = "bufferAppendingError", n.BUFFER_STALLED_ERROR = "bufferStalledError", n.BUFFER_FULL_ERROR = "bufferFullError", n.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", n.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", n.ASSET_LIST_LOAD_ERROR = "assetListLoadError", n.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", n.ASSET_LIST_PARSING_ERROR = "assetListParsingError", n.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", n.INTERNAL_EXCEPTION = "internalException", n.INTERNAL_ABORTED = "aborted", n.ATTACH_MEDIA_ERROR = "attachMediaError", n.UNKNOWN = "unknown", n })({}), k = (function (n) { return n.MEDIA_ATTACHING = "hlsMediaAttaching", n.MEDIA_ATTACHED = "hlsMediaAttached", n.MEDIA_DETACHING = "hlsMediaDetaching", n.MEDIA_DETACHED = "hlsMediaDetached", n.MEDIA_ENDED = "hlsMediaEnded", n.STALL_RESOLVED = "hlsStallResolved", n.BUFFER_RESET = "hlsBufferReset", n.BUFFER_CODECS = "hlsBufferCodecs", n.BUFFER_CREATED = "hlsBufferCreated", n.BUFFER_APPENDING = "hlsBufferAppending", n.BUFFER_APPENDED = "hlsBufferAppended", n.BUFFER_EOS = "hlsBufferEos", n.BUFFERED_TO_END = "hlsBufferedToEnd", n.BUFFER_FLUSHING = "hlsBufferFlushing", n.BUFFER_FLUSHED = "hlsBufferFlushed", n.MANIFEST_LOADING = "hlsManifestLoading", n.MANIFEST_LOADED = "hlsManifestLoaded", n.MANIFEST_PARSED = "hlsManifestParsed", n.LEVEL_SWITCHING = "hlsLevelSwitching", n.LEVEL_SWITCHED = "hlsLevelSwitched", n.LEVEL_LOADING = "hlsLevelLoading", n.LEVEL_LOADED = "hlsLevelLoaded", n.LEVEL_UPDATED = "hlsLevelUpdated", n.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", n.LEVELS_UPDATED = "hlsLevelsUpdated", n.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", n.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", n.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", n.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", n.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", n.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", n.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", n.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", n.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", n.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", n.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", n.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", n.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", n.CUES_PARSED = "hlsCuesParsed", n.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", n.INIT_PTS_FOUND = "hlsInitPtsFound", n.FRAG_LOADING = "hlsFragLoading", n.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", n.FRAG_LOADED = "hlsFragLoaded", n.FRAG_DECRYPTED = "hlsFragDecrypted", n.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", n.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", n.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", n.FRAG_PARSED = "hlsFragParsed", n.FRAG_BUFFERED = "hlsFragBuffered", n.FRAG_CHANGED = "hlsFragChanged", n.FPS_DROP = "hlsFpsDrop", n.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", n.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", n.ERROR = "hlsError", n.DESTROYING = "hlsDestroying", n.KEY_LOADING = "hlsKeyLoading", n.KEY_LOADED = "hlsKeyLoaded", n.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", n.BACK_BUFFER_REACHED = "hlsBackBufferReached", n.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", n.ASSET_LIST_LOADING = "hlsAssetListLoading", n.ASSET_LIST_LOADED = "hlsAssetListLoaded", n.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", n.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", n.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", n.INTERSTITIAL_STARTED = "hlsInterstitialStarted", n.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", n.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", n.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", n.INTERSTITIAL_ENDED = "hlsInterstitialEnded", n.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", n.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", n.EVENT_CUE_ENTER = "hlsEventCueEnter", n })({}); var He = { MANIFEST: "manifest", LEVEL: "level", AUDIO_TRACK: "audioTrack", SUBTITLE_TRACK: "subtitleTrack" }, ve = { MAIN: "main", AUDIO: "audio", SUBTITLE: "subtitle" }; class Ei { constructor(e, t = 0, r = 0) { this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r } sample(e, t) { const r = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e } getTotalWeight() { return this.totalWeight_ } getEstimate() { if (this.alpha_) { const e = 1 - Math.pow(this.alpha_, this.totalWeight_); if (e) return this.estimate_ / e } return this.estimate_ } } class PR { constructor(e, t, r, s = 100) { this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Ei(e), this.fast_ = new Ei(t), this.defaultTTFB_ = s, this.ttfb_ = new Ei(e) } update(e, t) { const { slow_: r, fast_: s, ttfb_: i } = this; r.halfLife !== e && (this.slow_ = new Ei(e, r.getEstimate(), r.getTotalWeight())), s.halfLife !== t && (this.fast_ = new Ei(t, s.getEstimate(), s.getTotalWeight())), i.halfLife !== e && (this.ttfb_ = new Ei(e, i.getEstimate(), i.getTotalWeight())) } sample(e, t) { e = Math.max(e, this.minDelayMs_); const r = 8 * t, s = e / 1e3, i = r / s; this.fast_.sample(s, i), this.slow_.sample(s, i) } sampleTTFB(e) { const t = e / 1e3, r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2); this.ttfb_.sample(r, Math.max(e, 5)) } canEstimate() { return this.fast_.getTotalWeight() >= this.minWeight_ } getEstimate() { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_ } getEstimateTTFB() { return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_ } get defaultEstimate() { return this.defaultEstimate_ } destroy() { } } function NR(n, e, t) { return (e = OR(e)) in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function nt() { return nt = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, nt.apply(null, arguments) } function Jx(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(n, s).enumerable })), t.push.apply(t, r) } return t } function et(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? Jx(Object(t), !0).forEach(function (r) { NR(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : Jx(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function DR(n, e) { if (typeof n != "object" || !n) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var r = t.call(n, e); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function OR(n) { var e = DR(n, "string"); return typeof e == "symbol" ? e : e + "" } class Pr { constructor(e, t) { this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0; const r = `[${e}]:`; this.trace = ds, this.debug = t.debug.bind(null, r), this.log = t.log.bind(null, r), this.warn = t.warn.bind(null, r), this.info = t.info.bind(null, r), this.error = t.error.bind(null, r) } } const ds = function () { }, MR = { trace: ds, debug: ds, log: ds, warn: ds, info: ds, error: ds }; function xh() { return nt({}, MR) } function jR(n, e) { const t = self.console[n]; return t ? t.bind(self.console, `${e ? "[" + e + "] " : ""}[${n}] >`) : ds } function ev(n, e, t) { return e[n] ? e[n].bind(e) : jR(n, t) } const vh = xh(); function FR(n, e, t) { const r = xh(); if (typeof console == "object" && n === !0 || typeof n == "object") { const s = ["debug", "log", "info", "warn", "error"]; s.forEach(i => { r[i] = ev(i, n, t) }); try { r.log(`Debug logs enabled for "${e}" in hls.js version 1.6.12`) } catch { return xh() } s.forEach(i => { vh[i] = ev(i, n) }) } else nt(vh, r); return r } const tt = vh; function bs(n = !0) { return typeof self > "u" ? void 0 : (n || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource } function $R(n) { return typeof self < "u" && n === self.ManagedMediaSource } function Lb(n, e) { const t = Object.keys(n), r = Object.keys(e), s = t.length, i = r.length; return !s || !i || s === i && !t.some(a => r.indexOf(a) === -1) } function wr(n, e = !1) { if (typeof TextDecoder < "u") { const u = new TextDecoder("utf-8").decode(n); if (e) { const f = u.indexOf("\0"); return f !== -1 ? u.substring(0, f) : u } return u.replace(/\0/g, "") } const t = n.length; let r, s, i, a = "", o = 0; for (; o < t;) { if (r = n[o++], r === 0 && e) return a; if (r === 0 || r === 3) continue; switch (r >> 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: a += String.fromCharCode(r); break; case 12: case 13: s = n[o++], a += String.fromCharCode((r & 31) << 6 | s & 63); break; case 14: s = n[o++], i = n[o++], a += String.fromCharCode((r & 15) << 12 | (s & 63) << 6 | (i & 63) << 0); break } } return a } function or(n) { let e = ""; for (let t = 0; t < n.length; t++) { let r = n[t].toString(16); r.length < 2 && (r = "0" + r), e += r } return e } function Cb(n) { return Uint8Array.from(n.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer } function BR(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var uf = { exports: {} }, tv; function UR() { return tv || (tv = 1, (function (n, e) { (function (t) { var r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, s = /^(?=([^\/?#]*))\1([^]*)$/, i = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = { buildAbsoluteURL: function (c, u, f) { if (f = f || {}, c = c.trim(), u = u.trim(), !u) { if (!f.alwaysNormalize) return c; var h = o.parseURL(c); if (!h) throw new Error("Error trying to parse base URL."); return h.path = o.normalizePath(h.path), o.buildURLFromParts(h) } var p = o.parseURL(u); if (!p) throw new Error("Error trying to parse relative URL."); if (p.scheme) return f.alwaysNormalize ? (p.path = o.normalizePath(p.path), o.buildURLFromParts(p)) : u; var v = o.parseURL(c); if (!v) throw new Error("Error trying to parse base URL."); if (!v.netLoc && v.path && v.path[0] !== "/") { var g = s.exec(v.path); v.netLoc = g[1], v.path = g[2] } v.netLoc && !v.path && (v.path = "/"); var y = { scheme: v.scheme, netLoc: p.netLoc, path: null, params: p.params, query: p.query, fragment: p.fragment }; if (!p.netLoc && (y.netLoc = v.netLoc, p.path[0] !== "/")) if (!p.path) y.path = v.path, p.params || (y.params = v.params, p.query || (y.query = v.query)); else { var w = v.path, T = w.substring(0, w.lastIndexOf("/") + 1) + p.path; y.path = o.normalizePath(T) } return y.path === null && (y.path = f.alwaysNormalize ? o.normalizePath(p.path) : p.path), o.buildURLFromParts(y) }, parseURL: function (c) { var u = r.exec(c); return u ? { scheme: u[1] || "", netLoc: u[2] || "", path: u[3] || "", params: u[4] || "", query: u[5] || "", fragment: u[6] || "" } : null }, normalizePath: function (c) { for (c = c.split("").reverse().join("").replace(i, ""); c.length !== (c = c.replace(a, "")).length;); return c.split("").reverse().join("") }, buildURLFromParts: function (c) { return c.scheme + c.netLoc + c.path + c.params + c.query + c.fragment } }; n.exports = o })() })(uf)), uf.exports } var dp = UR(); class fp { constructor() { this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = { start: 0, first: 0, end: 0 }, this.parsing = { start: 0, end: 0 }, this.buffering = { start: 0, first: 0, end: 0 } } } var st = { AUDIO: "audio", VIDEO: "video", AUDIOVIDEO: "audiovideo" }; class kb { constructor(e) { this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == "string" && (e = { url: e }), this.base = e, VR(this, "stats") } setByteRange(e, t) { const r = e.split("@", 2); let s; r.length === 1 ? s = t?.byteRangeEndOffset || 0 : s = parseInt(r[1]), this._byteRange = [s, parseInt(r[0]) + s] } get baseurl() { return this.base.url } get byteRange() { return this._byteRange === null ? [] : this._byteRange } get byteRangeStartOffset() { return this.byteRange[0] } get byteRangeEndOffset() { return this.byteRange[1] } get elementaryStreams() { return this._streams === null && (this._streams = { [st.AUDIO]: null, [st.VIDEO]: null, [st.AUDIOVIDEO]: null }), this._streams } set elementaryStreams(e) { this._streams = e } get hasStats() { return this._stats !== null } get hasStreams() { return this._streams !== null } get stats() { return this._stats === null && (this._stats = new fp), this._stats } set stats(e) { this._stats = e } get url() { return !this._url && this.baseurl && this.relurl && (this._url = dp.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url || "" } set url(e) { this._url = e } clearElementaryStreamInfo() { const { elementaryStreams: e } = this; e[st.AUDIO] = null, e[st.VIDEO] = null, e[st.AUDIOVIDEO] = null } } function At(n) { return n.sn !== "initSegment" } class df extends kb { constructor(e, t) { super(t), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e } get byteLength() { if (this.hasStats) { const e = this.stats.total; if (e) return e } if (this.byteRange.length) { const e = this.byteRange[0], t = this.byteRange[1]; if (ge(e) && ge(t)) return t - e } return null } get bitrate() { return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null } set bitrate(e) { this._bitrate = e } get decryptdata() { const { levelkeys: e } = this; if (!e && !this._decryptdata) return null; if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) { const t = this.levelkeys.identity; if (t) this._decryptdata = t.getDecryptData(this.sn); else { const r = Object.keys(this.levelkeys); if (r.length === 1) { const s = this._decryptdata = this.levelkeys[r[0]] || null; if (s) return s.getDecryptData(this.sn) } } } return this._decryptdata } get end() { return this.start + this.duration } get endProgramDateTime() { if (this.programDateTime === null) return null; const e = ge(this.duration) ? this.duration : 0; return this.programDateTime + e * 1e3 } get encrypted() { var e; if ((e = this._decryptdata) != null && e.encrypted) return !0; if (this.levelkeys) { var t; const r = Object.keys(this.levelkeys), s = r.length; if (s > 1 || s === 1 && (t = this.levelkeys[r[0]]) != null && t.encrypted) return !0 } return !1 } get programDateTime() { return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime } set programDateTime(e) { if (!ge(e)) { this._programDateTime = this.rawProgramDateTime = null; return } this._programDateTime = e } get ref() { return At(this) ? (this._ref || (this._ref = { base: this.base, start: this.start, duration: this.duration, sn: this.sn, programDateTime: this.programDateTime }), this._ref) : null } addStart(e) { this.setStart(this.start + e) } setStart(e) { this.start = e, this._ref && (this._ref.start = e) } setDuration(e) { this.duration = e, this._ref && (this._ref.duration = e) } setKeyFormat(e) { if (this.levelkeys) { const t = this.levelkeys[e]; t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn)) } } abortRequests() { var e, t; (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort() } setElementaryStreamInfo(e, t, r, s, i, a = !1) { const { elementaryStreams: o } = this, c = o[e]; if (!c) { o[e] = { startPTS: t, endPTS: r, startDTS: s, endDTS: i, partial: a }; return } c.startPTS = Math.min(c.startPTS, t), c.endPTS = Math.max(c.endPTS, r), c.startDTS = Math.min(c.startDTS, s), c.endDTS = Math.max(c.endDTS, i) } } class zR extends kb { constructor(e, t, r, s, i) { super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = s; const a = e.enumeratedString("BYTERANGE"); a && this.setByteRange(a, i), i && (this.fragOffset = i.fragOffset + i.duration) } get start() { return this.fragment.start + this.fragOffset } get end() { return this.start + this.duration } get loaded() { const { elementaryStreams: e } = this; return !!(e.audio || e.video || e.audiovideo) } } function Rb(n, e) { const t = Object.getPrototypeOf(n); if (t) { const r = Object.getOwnPropertyDescriptor(t, e); return r || Rb(t, e) } } function VR(n, e) { const t = Rb(n, e); t && (t.enumerable = !0, Object.defineProperty(n, e, t)) } const rv = Math.pow(2, 32) - 1, GR = [].push, _b = { video: 1, audio: 2, id3: 3, text: 4 }; function kt(n) { return String.fromCharCode.apply(null, n) } function Pb(n, e) { const t = n[e] << 8 | n[e + 1]; return t < 0 ? 65536 + t : t } function De(n, e) { const t = Nb(n, e); return t < 0 ? 4294967296 + t : t } function nv(n, e) { let t = De(n, e); return t *= Math.pow(2, 32), t += De(n, e + 4), t } function Nb(n, e) { return n[e] << 24 | n[e + 1] << 16 | n[e + 2] << 8 | n[e + 3] } function HR(n) { const e = n.byteLength; for (let t = 0; t < e;) { const r = De(n, t); if (r > 8 && n[t + 4] === 109 && n[t + 5] === 111 && n[t + 6] === 111 && n[t + 7] === 102) return !0; t = r > 1 ? t + r : e } return !1 } function ze(n, e) { const t = []; if (!e.length) return t; const r = n.byteLength; for (let s = 0; s < r;) { const i = De(n, s), a = kt(n.subarray(s + 4, s + 8)), o = i > 1 ? s + i : r; if (a === e[0]) if (e.length === 1) t.push(n.subarray(s + 8, o)); else { const c = ze(n.subarray(s + 8, o), e.slice(1)); c.length && GR.apply(t, c) } s = o } return t } function WR(n) { const e = [], t = n[0]; let r = 8; const s = De(n, r); r += 4; let i = 0, a = 0; t === 0 ? (i = De(n, r), a = De(n, r + 4), r += 8) : (i = nv(n, r), a = nv(n, r + 8), r += 16), r += 2; let o = n.length + a; const c = Pb(n, r); r += 2; for (let u = 0; u < c; u++) { let f = r; const h = De(n, f); f += 4; const p = h & 2147483647; if ((h & 2147483648) >>> 31 === 1) return tt.warn("SIDX has hierarchical references (not supported)"), null; const g = De(n, f); f += 4, e.push({ referenceSize: p, subsegmentDuration: g, info: { duration: g / s, start: o, end: o + p - 1 } }), o += p, f += 4, r = f } return { earliestPresentationTime: i, timescale: s, version: t, referencesCount: c, references: e } } function Db(n) { const e = [], t = ze(n, ["moov", "trak"]); for (let s = 0; s < t.length; s++) { const i = t[s], a = ze(i, ["tkhd"])[0]; if (a) { let o = a[0]; const c = De(a, o === 0 ? 12 : 20), u = ze(i, ["mdia", "mdhd"])[0]; if (u) { o = u[0]; const f = De(u, o === 0 ? 12 : 20), h = ze(i, ["mdia", "hdlr"])[0]; if (h) { const p = kt(h.subarray(8, 12)), v = { soun: st.AUDIO, vide: st.VIDEO }[p], g = ze(i, ["mdia", "minf", "stbl", "stsd"])[0], y = KR(g); v ? (e[c] = { timescale: f, type: v, stsd: y }, e[v] = et({ timescale: f, id: c }, y)) : e[c] = { timescale: f, type: p, stsd: y } } } } } return ze(n, ["moov", "mvex", "trex"]).forEach(s => { const i = De(s, 4), a = e[i]; a && (a.default = { duration: De(s, 12), flags: De(s, 20) }) }), e } function KR(n) { const e = n.subarray(8), t = e.subarray(86), r = kt(e.subarray(4, 8)); let s = r, i; const a = r === "enca" || r === "encv"; if (a) { const u = ze(e, [r])[0].subarray(r === "enca" ? 28 : 78); ze(u, ["sinf"]).forEach(h => { const p = ze(h, ["schm"])[0]; if (p) { const v = kt(p.subarray(4, 8)); if (v === "cbcs" || v === "cenc") { const g = ze(h, ["frma"])[0]; g && (s = kt(g)) } } }) } const o = s; switch (s) { case "avc1": case "avc2": case "avc3": case "avc4": { const c = ze(t, ["avcC"])[0]; c && c.length > 3 && (s += "." + Nl(c[1]) + Nl(c[2]) + Nl(c[3]), i = Pl(o === "avc1" ? "dva1" : "dvav", t)); break } case "mp4a": { const c = ze(e, [r])[0], u = ze(c.subarray(28), ["esds"])[0]; if (u && u.length > 7) { let f = 4; if (u[f++] !== 3) break; f = ff(u, f), f += 2; const h = u[f++]; if (h & 128 && (f += 2), h & 64 && (f += u[f++]), u[f++] !== 4) break; f = ff(u, f); const p = u[f++]; if (p === 64) s += "." + Nl(p); else break; if (f += 12, u[f++] !== 5) break; f = ff(u, f); const v = u[f++]; let g = (v & 248) >> 3; g === 31 && (g += 1 + ((v & 7) << 3) + ((u[f] & 224) >> 5)), s += "." + g } break } case "hvc1": case "hev1": { const c = ze(t, ["hvcC"])[0]; if (c && c.length > 12) { const u = c[1], f = ["", "A", "B", "C"][u >> 6], h = u & 31, p = De(c, 2), v = (u & 32) >> 5 ? "H" : "L", g = c[12], y = c.subarray(6, 12); s += "." + f + h, s += "." + qR(p).toString(16).toUpperCase(), s += "." + v + g; let w = ""; for (let T = y.length; T--;) { const S = y[T]; (S || w) && (w = "." + S.toString(16).toUpperCase() + w) } s += w } i = Pl(o == "hev1" ? "dvhe" : "dvh1", t); break } case "dvh1": case "dvhe": case "dvav": case "dva1": case "dav1": { s = Pl(s, t) || s; break } case "vp09": { const c = ze(t, ["vpcC"])[0]; if (c && c.length > 6) { const u = c[4], f = c[5], h = c[6] >> 4 & 15; s += "." + tn(u) + "." + tn(f) + "." + tn(h) } break } case "av01": { const c = ze(t, ["av1C"])[0]; if (c && c.length > 2) { const u = c[1] >>> 5, f = c[1] & 31, h = c[2] >>> 7 ? "H" : "M", p = (c[2] & 64) >> 6, v = (c[2] & 32) >> 5, g = u === 2 && p ? v ? 12 : 10 : p ? 10 : 8, y = (c[2] & 16) >> 4, w = (c[2] & 8) >> 3, T = (c[2] & 4) >> 2, S = c[2] & 3; s += "." + u + "." + tn(f) + h + "." + tn(g) + "." + y + "." + w + T + S + "." + tn(1) + "." + tn(1) + "." + tn(1) + "." + 0, i = Pl("dav1", t) } break } }return { codec: s, encrypted: a, supplemental: i } } function Pl(n, e) { const t = ze(e, ["dvvC"]), r = t.length ? t[0] : ze(e, ["dvcC"])[0]; if (r) { const s = r[2] >> 1 & 127, i = r[2] << 5 & 32 | r[3] >> 3 & 31; return n + "." + tn(s) + "." + tn(i) } } function qR(n) { let e = 0; for (let t = 0; t < 32; t++)e |= (n >> t & 1) << 31 - t; return e >>> 0 } function ff(n, e) { const t = e + 5; for (; n[e++] & 128 && e < t;); return e } function Nl(n) { return ("0" + n.toString(16).toUpperCase()).slice(-2) } function tn(n) { return (n < 10 ? "0" : "") + n } function YR(n, e) { if (!n || !e) return; const t = e.keyId; t && e.isCommonEncryption && ze(n, ["moov", "trak"]).forEach(s => { const a = ze(s, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8); let o = ze(a, ["enca"]); const c = o.length > 0; c || (o = ze(a, ["encv"])), o.forEach(u => { const f = c ? u.subarray(28) : u.subarray(78); ze(f, ["sinf"]).forEach(p => { const v = Ob(p); if (v) { const g = v.subarray(8, 24); g.some(y => y !== 0) || (tt.log(`[eme] Patching keyId in 'enc${c ? "a" : "v"}>sinf>>tenc' box: ${or(g)} -> ${or(t)}`), v.set(t, 8)) } }) }) }) } function Ob(n) { const e = ze(n, ["schm"])[0]; if (e) { const t = kt(e.subarray(4, 8)); if (t === "cbcs" || t === "cenc") return ze(n, ["schi", "tenc"])[0] } return null } function XR(n, e, t) { const r = {}, s = ze(n, ["moof", "traf"]); for (let i = 0; i < s.length; i++) { const a = s[i], o = ze(a, ["tfhd"])[0], c = De(o, 4), u = e[c]; if (!u) continue; r[c] || (r[c] = { start: NaN, duration: 0, sampleCount: 0, timescale: u.timescale, type: u.type }); const f = r[c], h = ze(a, ["tfdt"])[0]; if (h) { const E = h[0]; let I = De(h, 4); E === 1 && (I === rv ? t.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (I *= rv + 1, I += De(h, 8))), ge(I) && (!ge(f.start) || I < f.start) && (f.start = I) } const p = u.default, v = De(o, 0) | p?.flags; let g = p?.duration || 0; v & 8 && (v & 2 ? g = De(o, 12) : g = De(o, 8)); const y = ze(a, ["trun"]); let w = f.start || 0, T = 0, S = g; for (let E = 0; E < y.length; E++) { const I = y[E], C = De(I, 4), D = f.sampleCount; f.sampleCount += C; const R = I[3] & 1, N = I[3] & 4, P = I[2] & 1, _ = I[2] & 2, M = I[2] & 4, $ = I[2] & 8; let B = 8, V = C; for (R && (B += 4), N && C && (!(I[B + 1] & 1) && f.keyFrameIndex === void 0 && (f.keyFrameIndex = D), B += 4, P ? (S = De(I, B), B += 4) : S = g, _ && (B += 4), $ && (B += 4), w += S, T += S, V--); V--;)P ? (S = De(I, B), B += 4) : S = g, _ && (B += 4), M && (I[B + 1] & 1 || f.keyFrameIndex === void 0 && (f.keyFrameIndex = f.sampleCount - (V + 1), f.keyFrameStart = w), B += 4), $ && (B += 4), w += S, T += S; !T && g && (T += g * C) } f.duration += T } if (!Object.keys(r).some(i => r[i].duration)) { let i = 1 / 0, a = 0; const o = ze(n, ["sidx"]); for (let c = 0; c < o.length; c++) { const u = WR(o[c]); if (u != null && u.references) { i = Math.min(i, u.earliestPresentationTime / u.timescale); const f = u.references.reduce((h, p) => h + p.info.duration || 0, 0); a = Math.max(a, f + u.earliestPresentationTime / u.timescale) } } a && ge(a) && Object.keys(r).forEach(c => { r[c].duration || (r[c].duration = a * r[c].timescale - r[c].start) }) } return r } function QR(n) { const e = { valid: null, remainder: null }, t = ze(n, ["moof"]); if (t.length < 2) return e.remainder = n, e; const r = t[t.length - 1]; return e.valid = n.slice(0, r.byteOffset - 8), e.remainder = n.slice(r.byteOffset - 8), e } function Rr(n, e) { const t = new Uint8Array(n.length + e.length); return t.set(n), t.set(e, n.length), t } function sv(n, e) { const t = [], r = e.samples, s = e.timescale, i = e.id; let a = !1; return ze(r, ["moof"]).map(c => { const u = c.byteOffset - 8; ze(c, ["traf"]).map(h => { const p = ze(h, ["tfdt"]).map(v => { const g = v[0]; let y = De(v, 4); return g === 1 && (y *= Math.pow(2, 32), y += De(v, 8)), y / s })[0]; return p !== void 0 && (n = p), ze(h, ["tfhd"]).map(v => { const g = De(v, 4), y = De(v, 0) & 16777215, w = (y & 1) !== 0, T = (y & 2) !== 0, S = (y & 8) !== 0; let E = 0; const I = (y & 16) !== 0; let C = 0; const D = (y & 32) !== 0; let R = 8; g === i && (w && (R += 8), T && (R += 4), S && (E = De(v, R), R += 4), I && (C = De(v, R), R += 4), D && (R += 4), e.type === "video" && (a = Kc(e.codec)), ze(h, ["trun"]).map(N => { const P = N[0], _ = De(N, 0) & 16777215, M = (_ & 1) !== 0; let $ = 0; const B = (_ & 4) !== 0, V = (_ & 256) !== 0; let W = 0; const U = (_ & 512) !== 0; let q = 0; const z = (_ & 1024) !== 0, X = (_ & 2048) !== 0; let Z = 0; const F = De(N, 4); let H = 8; M && ($ = De(N, H), H += 4), B && (H += 4); let ae = $ + u; for (let he = 0; he < F; he++) { if (V ? (W = De(N, H), H += 4) : W = E, U ? (q = De(N, H), H += 4) : q = C, z && (H += 4), X && (P === 0 ? Z = De(N, H) : Z = Nb(N, H), H += 4), e.type === st.VIDEO) { let de = 0; for (; de < q;) { const pe = De(r, ae); if (ae += 4, ZR(a, r[ae])) { const Ce = r.subarray(ae, ae + pe); hp(Ce, a ? 2 : 1, n + Z / s, t) } ae += pe, de += pe + 4 } } n += W / s } })) }) }) }), t } function Kc(n) { if (!n) return !1; const e = n.substring(0, 4); return e === "hvc1" || e === "hev1" || e === "dvh1" || e === "dvhe" } function ZR(n, e) { if (n) { const t = e >> 1 & 63; return t === 39 || t === 40 } else return (e & 31) === 6 } function hp(n, e, t, r) { const s = Mb(n); let i = 0; i += e; let a = 0, o = 0, c = 0; for (; i < s.length;) { a = 0; do { if (i >= s.length) break; c = s[i++], a += c } while (c === 255); o = 0; do { if (i >= s.length) break; c = s[i++], o += c } while (c === 255); const u = s.length - i; let f = i; if (o < u) i += o; else if (o > u) { tt.error(`Malformed SEI payload. ${o} is too small, only ${u} bytes left to parse.`); break } if (a === 4) { if (s[f++] === 181) { const p = Pb(s, f); if (f += 2, p === 49) { const v = De(s, f); if (f += 4, v === 1195456820) { const g = s[f++]; if (g === 3) { const y = s[f++], w = 31 & y, T = 64 & y, S = T ? 2 + w * 3 : 0, E = new Uint8Array(S); if (T) { E[0] = y; for (let I = 1; I < S; I++)E[I] = s[f++] } r.push({ type: g, payloadType: a, pts: t, bytes: E }) } } } } } else if (a === 5 && o > 16) { const h = []; for (let g = 0; g < 16; g++) { const y = s[f++].toString(16); h.push(y.length == 1 ? "0" + y : y), (g === 3 || g === 5 || g === 7 || g === 9) && h.push("-") } const p = o - 16, v = new Uint8Array(p); for (let g = 0; g < p; g++)v[g] = s[f++]; r.push({ payloadType: a, pts: t, uuid: h.join(""), userData: wr(v), userDataBytes: v }) } } } function Mb(n) { const e = n.byteLength, t = []; let r = 1; for (; r < e - 2;)n[r] === 0 && n[r + 1] === 0 && n[r + 2] === 3 ? (t.push(r + 2), r += 2) : r++; if (t.length === 0) return n; const s = e - t.length, i = new Uint8Array(s); let a = 0; for (r = 0; r < s; a++, r++)a === t[0] && (a++, t.shift()), i[r] = n[a]; return i } function JR(n) { const e = n[0]; let t = "", r = "", s = 0, i = 0, a = 0, o = 0, c = 0, u = 0; if (e === 0) { for (; kt(n.subarray(u, u + 1)) !== "\0";)t += kt(n.subarray(u, u + 1)), u += 1; for (t += kt(n.subarray(u, u + 1)), u += 1; kt(n.subarray(u, u + 1)) !== "\0";)r += kt(n.subarray(u, u + 1)), u += 1; r += kt(n.subarray(u, u + 1)), u += 1, s = De(n, 12), i = De(n, 16), o = De(n, 20), c = De(n, 24), u = 28 } else if (e === 1) { u += 4, s = De(n, u), u += 4; const h = De(n, u); u += 4; const p = De(n, u); for (u += 4, a = 2 ** 32 * h + p, RR(a) || (a = Number.MAX_SAFE_INTEGER, tt.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = De(n, u), u += 4, c = De(n, u), u += 4; kt(n.subarray(u, u + 1)) !== "\0";)t += kt(n.subarray(u, u + 1)), u += 1; for (t += kt(n.subarray(u, u + 1)), u += 1; kt(n.subarray(u, u + 1)) !== "\0";)r += kt(n.subarray(u, u + 1)), u += 1; r += kt(n.subarray(u, u + 1)), u += 1 } const f = n.subarray(u, n.byteLength); return { schemeIdUri: t, value: r, timeScale: s, presentationTime: a, presentationTimeDelta: i, eventDuration: o, id: c, payload: f } } function e_(n, ...e) { const t = e.length; let r = 8, s = t; for (; s--;)r += e[s].byteLength; const i = new Uint8Array(r); for (i[0] = r >> 24 & 255, i[1] = r >> 16 & 255, i[2] = r >> 8 & 255, i[3] = r & 255, i.set(n, 4), s = 0, r = 8; s < t; s++)i.set(e[s], r), r += e[s].byteLength; return i } function t_(n, e, t) { if (n.byteLength !== 16) throw new RangeError("Invalid system id"); let r, s; r = 0, s = new Uint8Array; let i; r > 0 ? (i = new Uint8Array(4), e.length > 0 && new DataView(i.buffer).setUint32(0, e.length, !1)) : i = new Uint8Array; const a = new Uint8Array(4); return t.byteLength > 0 && new DataView(a.buffer).setUint32(0, t.byteLength, !1), e_([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), n, i, s, a, t) } function r_(n) { const e = []; if (n instanceof ArrayBuffer) { const t = n.byteLength; let r = 0; for (; r + 32 < t;) { const s = new DataView(n, r), i = n_(s); e.push(i), r += i.size } } return e } function n_(n) { const e = n.getUint32(0), t = n.byteOffset, r = n.byteLength; if (r < e) return { offset: t, size: r }; if (n.getUint32(4) !== 1886614376) return { offset: t, size: e }; const i = n.getUint32(8) >>> 24; if (i !== 0 && i !== 1) return { offset: t, size: e }; const a = n.buffer, o = or(new Uint8Array(a, t + 12, 16)); let c = null, u = null, f = 0; if (i === 0) f = 28; else { const p = n.getUint32(28); if (!p || r < 32 + p * 16) return { offset: t, size: e }; c = []; for (let v = 0; v < p; v++)c.push(new Uint8Array(a, t + 32 + v * 16, 16)); f = 32 + p * 16 } if (!f) return { offset: t, size: e }; const h = n.getUint32(f); return e - 32 < h ? { offset: t, size: e } : (u = new Uint8Array(a, t + f + 4, h), { version: i, systemId: o, kids: c, data: u, offset: t, size: e }) } const jb = () => /\(Windows.+Firefox\//i.test(navigator.userAgent), $i = { audio: { a3ds: 1, "ac-3": .95, "ac-4": 1, alac: .9, alaw: 1, dra1: 1, "dts+": 1, "dts-": 1, dtsc: 1, dtse: 1, dtsh: 1, "ec-3": .9, enca: 1, fLaC: .9, flac: .9, FLAC: .9, g719: 1, g726: 1, m4ae: 1, mha1: 1, mha2: 1, mhm1: 1, mhm2: 1, mlpa: 1, mp4a: 1, "raw ": 1, Opus: 1, opus: 1, samr: 1, sawb: 1, sawp: 1, sevc: 1, sqcp: 1, ssmv: 1, twos: 1, ulaw: 1 }, video: { avc1: 1, avc2: 1, avc3: 1, avc4: 1, avcp: 1, av01: .8, dav1: .8, drac: 1, dva1: 1, dvav: 1, dvh1: .7, dvhe: .7, encv: 1, hev1: .75, hvc1: .75, mjp2: 1, mp4v: 1, mvc1: 1, mvc2: 1, mvc3: 1, mvc4: 1, resv: 1, rv60: 1, s263: 1, svc1: 1, svc2: 1, "vc-1": 1, vp08: 1, vp09: .9 }, text: { stpp: 1, wvtt: 1 } }; function pp(n, e) { const t = $i[e]; return !!t && !!t[n.slice(0, 4)] } function Za(n, e, t = !0) { return !n.split(",").some(r => !mp(r, e, t)) } function mp(n, e, t = !0) { var r; const s = bs(t); return (r = s?.isTypeSupported(Ja(n, e))) != null ? r : !1 } function Ja(n, e) { return `${e}/mp4;codecs=${n}` } function iv(n) { if (n) { const e = n.substring(0, 4); return $i.video[e] } return 2 } function Sc(n) { const e = jb(); return n.split(",").reduce((t, r) => { const i = e && Kc(r) ? 9 : $i.video[r]; return i ? (i * 2 + t) / (t ? 3 : 2) : ($i.audio[r] + t) / (t ? 2 : 1) }, 0) } const hf = {}; function s_(n, e = !0) { if (hf[n]) return hf[n]; const t = { flac: ["flac", "fLaC", "FLAC"], opus: ["opus", "Opus"], "mp4a.40.34": ["mp3"] }[n]; for (let s = 0; s < t.length; s++) { var r; if (mp(t[s], "audio", e)) return hf[n] = t[s], t[s]; if (t[s] === "mp3" && (r = bs(e)) != null && r.isTypeSupported("audio/mpeg")) return "" } return n } const i_ = /flac|opus|mp4a\.40\.34/i; function Ec(n, e = !0) { return n.replace(i_, t => s_(t.toLowerCase(), e)) } function a_(n, e) { const t = []; if (n) { const r = n.split(","); for (let s = 0; s < r.length; s++)pp(r[s], "video") || t.push(r[s]) } return e && t.push(e), t.join(",") } function ec(n, e) { if (n && (n.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(n) !== -1) && (av(n, "audio") || av(n, "video"))) return n; if (e) { const t = e.split(","); if (t.length > 1) { if (n) { for (let r = t.length; r--;)if (t[r].substring(0, 4) === n.substring(0, 4)) return t[r] } return t[0] } } return e || n } function av(n, e) { return pp(n, e) && mp(n, e) } function o_(n) { const e = n.split(","); for (let t = 0; t < e.length; t++) { const r = e[t].split("."); r.length > 2 && r[0] === "avc1" && (e[t] = `avc1.${parseInt(r[1]).toString(16)}${("000" + parseInt(r[2]).toString(16)).slice(-4)}`) } return e.join(",") } function l_(n) { if (n.startsWith("av01.")) { const e = n.split("."), t = ["0", "111", "01", "01", "01", "0"]; for (let r = e.length; r > 4 && r < 10; r++)e[r] = t[r - 4]; return e.join(".") } return n } function ov(n) { const e = bs(n) || { isTypeSupported: () => !1 }; return { mpeg: e.isTypeSupported("audio/mpeg"), mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'), ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"') } } function yh(n) { return n.replace(/^.+codecs=["']?([^"']+).*$/, "$1") } const c_ = { supported: !0, powerEfficient: !0, smooth: !0 }, u_ = { supported: !1, smooth: !1, powerEfficient: !1 }, Fb = { supported: !0, configurations: [], decodingInfoResults: [c_] }; function $b(n, e) { return { supported: !1, configurations: e, decodingInfoResults: [u_], error: n } } function d_(n, e, t, r, s, i) { const a = n.videoCodec, o = n.audioCodec ? n.audioGroups : null, c = i?.audioCodec, u = i?.channels, f = u ? parseInt(u) : c ? 1 / 0 : 2; let h = null; if (o != null && o.length) try { o.length === 1 && o[0] ? h = e.groups[o[0]].channels : h = o.reduce((p, v) => { if (v) { const g = e.groups[v]; if (!g) throw new Error(`Audio track group ${v} not found`); Object.keys(g.channels).forEach(y => { p[y] = (p[y] || 0) + g.channels[y] }) } return p }, { 2: 0 }) } catch { return !0 } return a !== void 0 && (a.split(",").some(p => Kc(p)) || n.width > 1920 && n.height > 1088 || n.height > 1920 && n.width > 1088 || n.frameRate > Math.max(r, 30) || n.videoRange !== "SDR" && n.videoRange !== t || n.bitrate > Math.max(s, 8e6)) || !!h && ge(f) && Object.keys(h).some(p => parseInt(p) > f) } function Bb(n, e, t, r = {}) { const s = n.videoCodec; if (!s && !n.audioCodec || !t) return Promise.resolve(Fb); const i = [], a = f_(n), o = a.length, c = h_(n, e, o > 0), u = c.length; for (let f = o || 1 * u || 1; f--;) { const h = { type: "media-source" }; if (o && (h.video = a[f % o]), u) { h.audio = c[f % u]; const p = h.audio.bitrate; h.video && p && (h.video.bitrate -= p) } i.push(h) } if (s) { const f = navigator.userAgent; if (s.split(",").some(h => Kc(h)) && jb()) return Promise.resolve($b(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${f})`), i)) } return Promise.all(i.map(f => { const h = m_(f); return r[h] || (r[h] = t.decodingInfo(f)) })).then(f => ({ supported: !f.some(h => !h.supported), configurations: i, decodingInfoResults: f })).catch(f => ({ supported: !1, configurations: i, decodingInfoResults: [], error: f })) } function f_(n) { var e; const t = (e = n.videoCodec) == null ? void 0 : e.split(","), r = Ub(n), s = n.width || 640, i = n.height || 480, a = n.frameRate || 30, o = n.videoRange.toLowerCase(); return t ? t.map(c => { const u = { contentType: Ja(l_(c), "video"), width: s, height: i, bitrate: r, framerate: a }; return o !== "sdr" && (u.transferFunction = o), u }) : [] } function h_(n, e, t) { var r; const s = (r = n.audioCodec) == null ? void 0 : r.split(","), i = Ub(n); return s && n.audioGroups ? n.audioGroups.reduce((a, o) => { var c; const u = o ? (c = e.groups[o]) == null ? void 0 : c.tracks : null; return u ? u.reduce((f, h) => { if (h.groupId === o) { const p = parseFloat(h.channels || ""); s.forEach(v => { const g = { contentType: Ja(v, "audio"), bitrate: t ? p_(v, i) : i }; p && (g.channels = "" + p), f.push(g) }) } return f }, a) : a }, []) : [] } function p_(n, e) { if (e <= 1) return 1; let t = 128e3; return n === "ec-3" ? t = 768e3 : n === "ac-3" && (t = 64e4), Math.min(e / 2, t) } function Ub(n) { return Math.ceil(Math.max(n.bitrate * .9, n.averageBitrate) / 1e3) * 1e3 || 1 } function m_(n) { let e = ""; const { audio: t, video: r } = n; if (r) { const s = yh(r.contentType); e += `${s}_r${r.height}x${r.width}f${Math.ceil(r.framerate)}${r.transferFunction || "sd"}_${Math.ceil(r.bitrate / 1e5)}` } if (t) { const s = yh(t.contentType); e += `${r ? "_" : ""}${s}_c${t.channels}` } return e } const bh = ["NONE", "TYPE-0", "TYPE-1", null]; function g_(n) { return bh.indexOf(n) > -1 } const Tc = ["SDR", "PQ", "HLG"]; function x_(n) { return !!n && Tc.indexOf(n) > -1 } var tc = { No: "", Yes: "YES", v2: "v2" }; function lv(n) { const { canSkipUntil: e, canSkipDateRanges: t, age: r } = n, s = r < e / 2; return e && s ? t ? tc.v2 : tc.Yes : tc.No } class cv { constructor(e, t, r) { this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r } addDirectives(e) { const t = new self.URL(e); return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href } } class eo { constructor(e) { if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter(r => !!r).map(r => r.substring(0, 4)).join(","), "supplemental" in e) { var t; this.supplemental = e.supplemental; const r = (t = e.supplemental) == null ? void 0 : t.videoCodec; r && r !== e.videoCodec && (this.codecSet += `,${r.substring(0, 4)}`) } this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES) } get maxBitrate() { return Math.max(this.realBitrate, this.bitrate) } get averageBitrate() { return this._avgBitrate || this.realBitrate || this.bitrate } get attrs() { return this._attrs[0] } get codecs() { return this.attrs.CODECS || "" } get pathwayId() { return this.attrs["PATHWAY-ID"] || "." } get videoRange() { return this.attrs["VIDEO-RANGE"] || "SDR" } get score() { return this.attrs.optionalFloat("SCORE", 0) } get uri() { return this.url[0] || "" } hasAudioGroup(e) { return uv(this._audioGroups, e) } hasSubtitleGroup(e) { return uv(this._subtitleGroups, e) } get audioGroups() { return this._audioGroups } get subtitleGroups() { return this._subtitleGroups } addGroupId(e, t) { if (t) { if (e === "audio") { let r = this._audioGroups; r || (r = this._audioGroups = []), r.indexOf(t) === -1 && r.push(t) } else if (e === "text") { let r = this._subtitleGroups; r || (r = this._subtitleGroups = []), r.indexOf(t) === -1 && r.push(t) } } } get urlId() { return 0 } set urlId(e) { } get audioGroupIds() { return this.audioGroups ? [this.audioGroupId] : void 0 } get textGroupIds() { return this.subtitleGroups ? [this.textGroupId] : void 0 } get audioGroupId() { var e; return (e = this.audioGroups) == null ? void 0 : e[0] } get textGroupId() { var e; return (e = this.subtitleGroups) == null ? void 0 : e[0] } addFallback() { } } function uv(n, e) { return !e || !n ? !1 : n.indexOf(e) !== -1 } function v_() { if (typeof matchMedia == "function") { const n = matchMedia("(dynamic-range: high)"), e = matchMedia("bad query"); if (n.media !== e.media) return n.matches === !0 } return !1 } function y_(n, e) { let t = !1, r = []; if (n && (t = n !== "SDR", r = [n]), e) { r = e.allowedVideoRanges || Tc.slice(0); const s = r.join("") !== "SDR" && !e.videoCodec; t = e.preferHDR !== void 0 ? e.preferHDR : s && v_(), t || (r = ["SDR"]) } return { preferHDR: t, allowedVideoRanges: r } } const b_ = n => { const e = new WeakSet; return (t, r) => { if (n && (r = n(t, r)), typeof r == "object" && r !== null) { if (e.has(r)) return; e.add(r) } return r } }, it = (n, e) => JSON.stringify(n, b_(e)); function w_(n, e, t, r, s) { const i = Object.keys(n), a = r?.channels, o = r?.audioCodec, c = s?.videoCodec, u = a && parseInt(a) === 2; let f = !1, h = !1, p = 1 / 0, v = 1 / 0, g = 1 / 0, y = 1 / 0, w = 0, T = []; const { preferHDR: S, allowedVideoRanges: E } = y_(e, s); for (let N = i.length; N--;) { const P = n[i[N]]; f || (f = P.channels[2] > 0), p = Math.min(p, P.minHeight), v = Math.min(v, P.minFramerate), g = Math.min(g, P.minBitrate), E.filter(M => P.videoRanges[M] > 0).length > 0 && (h = !0) } p = ge(p) ? p : 0, v = ge(v) ? v : 0; const I = Math.max(1080, p), C = Math.max(30, v); g = ge(g) ? g : t, t = Math.max(g, t), h || (e = void 0); const D = i.length > 1; return { codecSet: i.reduce((N, P) => { const _ = n[P]; if (P === N) return N; if (T = h ? E.filter(M => _.videoRanges[M] > 0) : [], D) { if (_.minBitrate > t) return Jr(P, `min bitrate of ${_.minBitrate} > current estimate of ${t}`), N; if (!_.hasDefaultAudio) return Jr(P, "no renditions with default or auto-select sound found"), N; if (o && P.indexOf(o.substring(0, 4)) % 5 !== 0) return Jr(P, `audio codec preference "${o}" not found`), N; if (a && !u) { if (!_.channels[a]) return Jr(P, `no renditions with ${a} channel sound found (channels options: ${Object.keys(_.channels)})`), N } else if ((!o || u) && f && _.channels[2] === 0) return Jr(P, "no renditions with stereo sound found"), N; if (_.minHeight > I) return Jr(P, `min resolution of ${_.minHeight} > maximum of ${I}`), N; if (_.minFramerate > C) return Jr(P, `min framerate of ${_.minFramerate} > maximum of ${C}`), N; if (!T.some(M => _.videoRanges[M] > 0)) return Jr(P, `no variants with VIDEO-RANGE of ${it(T)} found`), N; if (c && P.indexOf(c.substring(0, 4)) % 5 !== 0) return Jr(P, `video codec preference "${c}" not found`), N; if (_.maxScore < w) return Jr(P, `max score of ${_.maxScore} < selected max of ${w}`), N } return N && (Sc(P) >= Sc(N) || _.fragmentError > n[N].fragmentError) ? N : (y = _.minIndex, w = _.maxScore, P) }, void 0), videoRanges: T, preferHDR: S, minFramerate: v, minBitrate: g, minIndex: y } } function Jr(n, e) { tt.log(`[abr] start candidates with "${n}" ignored because ${e}`) } function zb(n) { return n.reduce((e, t) => { let r = e.groups[t.groupId]; r || (r = e.groups[t.groupId] = { tracks: [], channels: { 2: 0 }, hasDefault: !1, hasAutoSelect: !1 }), r.tracks.push(t); const s = t.channels || "2"; return r.channels[s] = (r.channels[s] || 0) + 1, r.hasDefault = r.hasDefault || t.default, r.hasAutoSelect = r.hasAutoSelect || t.autoselect, r.hasDefault && (e.hasDefaultAudio = !0), r.hasAutoSelect && (e.hasAutoSelectAudio = !0), e }, { hasDefaultAudio: !1, hasAutoSelectAudio: !1, groups: {} }) } function S_(n, e, t, r) { return n.slice(t, r + 1).reduce((s, i, a) => { if (!i.codecSet) return s; const o = i.audioGroups; let c = s[i.codecSet]; c || (s[i.codecSet] = c = { minBitrate: 1 / 0, minHeight: 1 / 0, minFramerate: 1 / 0, minIndex: a, maxScore: 0, videoRanges: { SDR: 0 }, channels: { 2: 0 }, hasDefaultAudio: !o, fragmentError: 0 }), c.minBitrate = Math.min(c.minBitrate, i.bitrate); const u = Math.min(i.height, i.width); return c.minHeight = Math.min(c.minHeight, u), c.minFramerate = Math.min(c.minFramerate, i.frameRate), c.minIndex = Math.min(c.minIndex, a), c.maxScore = Math.max(c.maxScore, i.score), c.fragmentError += i.fragmentError, c.videoRanges[i.videoRange] = (c.videoRanges[i.videoRange] || 0) + 1, o && o.forEach(f => { if (!f) return; const h = e.groups[f]; h && (c.hasDefaultAudio = c.hasDefaultAudio || e.hasDefaultAudio ? h.hasDefault : h.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(h.channels).forEach(p => { c.channels[p] = (c.channels[p] || 0) + h.channels[p] })) }), s }, {}) } function dv(n) { if (!n) return n; const { lang: e, assocLang: t, characteristics: r, channels: s, audioCodec: i } = n; return { lang: e, assocLang: t, characteristics: r, channels: s, audioCodec: i } } function cn(n, e, t) { if ("attrs" in n) { const r = e.indexOf(n); if (r !== -1) return r } for (let r = 0; r < e.length; r++) { const s = e[r]; if (Hs(n, s, t)) return r } return -1 } function Hs(n, e, t) { const { groupId: r, name: s, lang: i, assocLang: a, default: o } = n, c = n.forced; return (r === void 0 || e.groupId === r) && (s === void 0 || e.name === s) && (i === void 0 || E_(i, e.lang)) && (i === void 0 || e.assocLang === a) && (o === void 0 || e.default === o) && (c === void 0 || e.forced === c) && (!("characteristics" in n) || T_(n.characteristics || "", e.characteristics)) && (t === void 0 || t(n, e)) } function E_(n, e = "--") { return n.length === e.length ? n === e : n.startsWith(e) || e.startsWith(n) } function T_(n, e = "") { const t = n.split(","), r = e.split(","); return t.length === r.length && !t.some(s => r.indexOf(s) === -1) } function Bs(n, e) { const { audioCodec: t, channels: r } = n; return (t === void 0 || (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) && (r === void 0 || r === (e.channels || "2")) } function A_(n, e, t, r, s) { const i = e[r], o = e.reduce((p, v, g) => { const y = v.uri; return (p[y] || (p[y] = [])).push(g), p }, {})[i.uri]; o.length > 1 && (r = Math.max.apply(Math, o)); const c = i.videoRange, u = i.frameRate, f = i.codecSet.substring(0, 4), h = fv(e, r, p => { if (p.videoRange !== c || p.frameRate !== u || p.codecSet.substring(0, 4) !== f) return !1; const v = p.audioGroups, g = t.filter(y => !v || v.indexOf(y.groupId) !== -1); return cn(n, g, s) > -1 }); return h > -1 ? h : fv(e, r, p => { const v = p.audioGroups, g = t.filter(y => !v || v.indexOf(y.groupId) !== -1); return cn(n, g, s) > -1 }) } function fv(n, e, t) { for (let r = e; r > -1; r--)if (t(n[r])) return r; for (let r = e + 1; r < n.length; r++)if (t(n[r])) return r; return -1 } function Ac(n, e) { var t; return !!n && n !== ((t = e.loadLevelObj) == null ? void 0 : t.uri) } class I_ extends Pr {
    constructor(e) {
      super("abr", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = t => {
        var r; const { fragCurrent: s, partCurrent: i, hls: a } = this, { autoLevelEnabled: o, media: c } = a; if (!s || !c) return; const u = performance.now(), f = i ? i.stats : s.stats, h = i ? i.duration : s.duration, p = u - f.loading.start, v = a.minAutoLevel, g = s.level, y = this._nextAutoLevel; if (f.aborted || f.loaded && f.loaded === f.total || g <= v) { this.clearTimer(), this._nextAutoLevel = -1; return } if (!o) return; const w = y > -1 && y !== g, T = !!t || w; if (!T && (c.paused || !c.playbackRate || !c.readyState)) return; const S = a.mainForwardBufferInfo; if (!T && S === null) return; const E = this.bwEstimator.getEstimateTTFB(), I = Math.abs(c.playbackRate); if (p <= Math.max(E, 1e3 * (h / (I * 2)))) return; const C = S ? S.len / I : 0, D = f.loading.first ? f.loading.first - f.loading.start : -1, R = f.loaded && D > -1, N = this.getBwEstimate(), P = a.levels, _ = P[g], M = Math.max(f.loaded, Math.round(h * (s.bitrate || _.averageBitrate) / 8)); let $ = R ? p - D : p; $ < 1 && R && ($ = Math.min(p, f.loaded * 8 / N)); const B = R ? f.loaded * 1e3 / $ : 0, V = E / 1e3, W = B ? (M - f.loaded) / B : M * 8 / N + V; if (W <= C) return; const U = B ? B * 8 : N, q = ((r = t?.details || this.hls.latestLevelDetails) == null ? void 0 : r.live) === !0, z = this.hls.config.abrBandWidthUpFactor; let X = Number.POSITIVE_INFINITY, Z; for (Z = g - 1; Z > v; Z--) { const he = P[Z].maxBitrate, de = !P[Z].details || q; if (X = this.getTimeToLoadFrag(V, U, h * he, de), X < Math.min(C, h + V)) break } if (X >= W || X > h * 10) return; R ? this.bwEstimator.sample(p - Math.min(E, D), f.loaded) : this.bwEstimator.sampleTTFB(p); const F = P[Z].maxBitrate; this.getBwEstimate() * z > F && this.resetEstimator(F); const H = this.findBestLevel(F, v, Z, 0, C, 1, 1); H > -1 && (Z = H), this.warn(`Fragment ${s.sn}${i ? " part " + i.index : ""} of level ${g} is loading too slowly;
      Fragment duration: ${s.duration.toFixed(3)}
      Time to underbuffer: ${C.toFixed(3)} s
      Estimated load time for current fragment: ${W.toFixed(3)} s
      Estimated load time for down switch fragment: ${X.toFixed(3)} s
      TTFB estimate: ${D | 0} ms
      Current BW estimate: ${ge(N) ? N | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${Z} @ ${F | 0} bps`), a.nextLoadLevel = a.nextAutoLevel = Z, this.clearTimer(); const ae = () => {
          if (this.clearTimer(), this.fragCurrent === s && this.hls.loadLevel === Z && Z > 0) {
            const he = this.getStarvationDelay(); if (this.warn(`Aborting inflight request ${Z > 0 ? "and switching down" : ""}
      Fragment duration: ${s.duration.toFixed(3)} s
      Time to underbuffer: ${he.toFixed(3)} s`), s.abortRequests(), this.fragCurrent = this.partCurrent = null, Z > v) { let de = this.findBestLevel(this.hls.levels[v].bitrate, v, Z, 0, he, 1, 1); de === -1 && (de = v), this.hls.nextLoadLevel = this.hls.nextAutoLevel = de, this.resetEstimator(this.hls.levels[de].bitrate) }
          }
        }; w || W > X * 2 ? ae() : this.timer = self.setInterval(ae, X * 1e3), a.trigger(k.FRAG_LOAD_EMERGENCY_ABORTED, { frag: s, part: i, stats: f })
      }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners()
    } resetEstimator(e) { e && (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator() } initEstimator() { const e = this.hls.config; return new PR(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate) } registerListeners() { const { hls: e } = this; e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.FRAG_LOADING, this.onFragLoading, this), e.on(k.FRAG_LOADED, this.onFragLoaded, this), e.on(k.FRAG_BUFFERED, this.onFragBuffered, this), e.on(k.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(k.LEVEL_LOADED, this.onLevelLoaded, this), e.on(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(k.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(k.ERROR, this.onError, this) } unregisterListeners() { const { hls: e } = this; e && (e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.FRAG_LOADING, this.onFragLoading, this), e.off(k.FRAG_LOADED, this.onFragLoaded, this), e.off(k.FRAG_BUFFERED, this.onFragBuffered, this), e.off(k.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(k.LEVEL_LOADED, this.onLevelLoaded, this), e.off(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(k.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(k.ERROR, this.onError, this)) } destroy() { this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null } onManifestLoading(e, t) { this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer() } onLevelsUpdated() { this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null } onMaxAutoLevelUpdated() { this.firstSelection = -1, this.nextAutoLevelKey = "" } onFragLoading(e, t) { const r = t.frag; if (!this.ignoreFragment(r)) { if (!r.bitrateTest) { var s; this.fragCurrent = r, this.partCurrent = (s = t.part) != null ? s : null } this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100) } } onLevelSwitching(e, t) { this.clearTimer() } onError(e, t) { if (!t.fatal) switch (t.details) { case J.BUFFER_ADD_CODEC_ERROR: case J.BUFFER_APPEND_ERROR: this.lastLoadedFragLevel = -1, this.firstSelection = -1; break; case J.FRAG_LOAD_TIMEOUT: { const r = t.frag, { fragCurrent: s, partCurrent: i } = this; if (r && s && r.sn === s.sn && r.level === s.level) { const a = performance.now(), o = i ? i.stats : r.stats, c = a - o.loading.start, u = o.loading.first ? o.loading.first - o.loading.start : -1; if (o.loaded && u > -1) { const h = this.bwEstimator.getEstimateTTFB(); this.bwEstimator.sample(c - Math.min(h, u), o.loaded) } else this.bwEstimator.sampleTTFB(c) } break } } } getTimeToLoadFrag(e, t, r, s) { const i = e + r / t, a = s ? e + this.lastLevelLoadSec : 0; return i + a } onLevelLoaded(e, t) { const r = this.hls.config, { loading: s } = t.stats, i = s.end - s.first; ge(i) && (this.lastLevelLoadSec = i / 1e3), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(t.levelInfo) } onFragLoaded(e, { frag: t, part: r }) { const s = r ? r.stats : t.stats; if (t.type === ve.MAIN && this.bwEstimator.sampleTTFB(s.loading.first - s.loading.start), !this.ignoreFragment(t)) { if (this.clearTimer(), t.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) { const i = r ? r.duration : t.duration, a = this.hls.levels[t.level], o = (a.loaded ? a.loaded.bytes : 0) + s.loaded, c = (a.loaded ? a.loaded.duration : 0) + i; a.loaded = { bytes: o, duration: c }, a.realBitrate = Math.round(8 * o / c) } if (t.bitrateTest) { const i = { stats: s, frag: t, part: r, id: t.type }; this.onFragBuffered(k.FRAG_BUFFERED, i), t.bitrateTest = !1 } else this.lastLoadedFragLevel = t.level } } onFragBuffered(e, t) { const { frag: r, part: s } = t, i = s != null && s.stats.loaded ? s.stats : r.stats; if (i.aborted || this.ignoreFragment(r)) return; const a = i.parsing.end - i.loading.start - Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB()); this.bwEstimator.sample(a, i.loaded), i.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0 } ignoreFragment(e) { return e.type !== ve.MAIN || e.sn === "initSegment" } clearTimer() { this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1) } get firstAutoLevel() { const { maxAutoLevel: e, minAutoLevel: t } = this.hls, r = this.getBwEstimate(), s = this.hls.config.maxStarvationDelay, i = this.findBestLevel(r, t, e, 0, s, 1, 1); if (i > -1) return i; const a = this.hls.firstLevel, o = Math.min(Math.max(a, t), e); return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`), o } get forcedAutoLevel() { return this.nextAutoLevelKey ? -1 : this._nextAutoLevel } get nextAutoLevel() { const e = this.forcedAutoLevel, r = this.bwEstimator.canEstimate(), s = this.lastLoadedFragLevel > -1; if (e !== -1 && (!r || !s || this.nextAutoLevelKey === this.getAutoLevelKey())) return e; const i = r && s ? this.getNextABRAutoLevel() : this.firstAutoLevel; if (e !== -1) { const a = this.hls.levels; if (a.length > Math.max(e, i) && a[e].loadError <= a[i].loadError) return e } return this._nextAutoLevel = i, this.nextAutoLevelKey = this.getAutoLevelKey(), i } getAutoLevelKey() { return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}` } getNextABRAutoLevel() { const { fragCurrent: e, partCurrent: t, hls: r } = this; if (r.levels.length <= 1) return r.loadLevel; const { maxAutoLevel: s, config: i, minAutoLevel: a } = r, o = t ? t.duration : e ? e.duration : 0, c = this.getBwEstimate(), u = this.getStarvationDelay(); let f = i.abrBandWidthFactor, h = i.abrBandWidthUpFactor; if (u) { const w = this.findBestLevel(c, a, s, u, 0, f, h); if (w >= 0) return this.rebufferNotice = -1, w } let p = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay; if (!u) { const w = this.bitrateTestDelay; w && (p = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - w, this.info(`bitrate test took ${Math.round(1e3 * w)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * p)} ms`), f = h = 1) } const v = this.findBestLevel(c, a, s, u, p, f, h); if (this.rebufferNotice !== v && (this.rebufferNotice = v, this.info(`${u ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${v}`)), v > -1) return v; const g = r.levels[a], y = r.loadLevelObj; return y && g?.bitrate < y.bitrate ? a : r.loadLevel } getStarvationDelay() { const e = this.hls, t = e.media; if (!t) return 1 / 0; const r = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1, s = e.mainForwardBufferInfo; return (s ? s.len : 0) / r } getBwEstimate() { return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate } findBestLevel(e, t, r, s, i, a, o) { var c; const u = s + i, f = this.lastLoadedFragLevel, h = f === -1 ? this.hls.firstLevel : f, { fragCurrent: p, partCurrent: v } = this, { levels: g, allAudioTracks: y, loadLevel: w, config: T } = this.hls; if (g.length === 1) return 0; const S = g[h], E = !!((c = this.hls.latestLevelDetails) != null && c.live), I = w === -1 || f === -1; let C, D = "SDR", R = S?.frameRate || 0; const { audioPreference: N, videoPreference: P } = T, _ = this.audioTracksByGroup || (this.audioTracksByGroup = zb(y)); let M = -1; if (I) { if (this.firstSelection !== -1) return this.firstSelection; const U = this.codecTiers || (this.codecTiers = S_(g, _, t, r)), q = w_(U, D, e, N, P), { codecSet: z, videoRanges: X, minFramerate: Z, minBitrate: F, minIndex: H, preferHDR: ae } = q; M = H, C = z, D = ae ? X[X.length - 1] : X[0], R = Z, e = Math.max(e, F), this.log(`picked start tier ${it(q)}`) } else C = S?.codecSet, D = S?.videoRange; const $ = v ? v.duration : p ? p.duration : 0, B = this.bwEstimator.getEstimateTTFB() / 1e3, V = []; for (let U = r; U >= t; U--) { var W; const q = g[U], z = U > h; if (!q) continue; if (T.useMediaCapabilities && !q.supportedResult && !q.supportedPromise) { const de = navigator.mediaCapabilities; typeof de?.decodingInfo == "function" && d_(q, _, D, R, e, N) ? (q.supportedPromise = Bb(q, _, de, this.supportedCache), q.supportedPromise.then(pe => { if (!this.hls) return; q.supportedResult = pe; const Ce = this.hls.levels, Ie = Ce.indexOf(q); pe.error ? this.warn(`MediaCapabilities decodingInfo error: "${pe.error}" for level ${Ie} ${it(pe)}`) : pe.supported ? pe.decodingInfoResults.some(Pe => Pe.smooth === !1 || Pe.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${Ie} not smooth or powerEfficient: ${it(pe)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${Ie} ${it(pe)}`), Ie > -1 && Ce.length > 1 && (this.log(`Removing unsupported level ${Ie}`), this.hls.removeLevel(Ie), this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0))) }).catch(pe => { this.warn(`Error handling MediaCapabilities decodingInfo: ${pe}`) })) : q.supportedResult = Fb } if ((C && q.codecSet !== C || D && q.videoRange !== D || z && R > q.frameRate || !z && R > 0 && R < q.frameRate || (W = q.supportedResult) != null && (W = W.decodingInfoResults) != null && W.some(de => de.smooth === !1)) && (!I || U !== M)) { V.push(U); continue } const X = q.details, Z = (v ? X?.partTarget : X?.averagetargetduration) || $; let F; z ? F = o * e : F = a * e; const H = $ && s >= $ * 2 && i === 0 ? q.averageBitrate : q.maxBitrate, ae = this.getTimeToLoadFrag(B, F, H * Z, X === void 0); if (F >= H && (U === f || q.loadError === 0 && q.fragmentError === 0) && (ae <= B || !ge(ae) || E && !this.bitrateTestDelay || ae < u)) { const de = this.forcedAutoLevel; return U !== w && (de === -1 || de !== w) && (V.length && this.trace(`Skipped level(s) ${V.join(",")} of ${r} max with CODECS and VIDEO-RANGE:"${g[V[0]].codecs}" ${g[V[0]].videoRange}; not compatible with "${C}" ${D}`), this.info(`switch candidate:${h}->${U} adjustedbw(${Math.round(F)})-bitrate=${Math.round(F - H)} ttfb:${B.toFixed(1)} avgDuration:${Z.toFixed(1)} maxFetchDuration:${u.toFixed(1)} fetchDuration:${ae.toFixed(1)} firstSelection:${I} codecSet:${q.codecSet} videoRange:${q.videoRange} hls.loadLevel:${w}`)), I && (this.firstSelection = U), U } } return -1 } set nextAutoLevel(e) { const t = this.deriveNextAutoLevel(e); this._nextAutoLevel !== t && (this.nextAutoLevelKey = "", this._nextAutoLevel = t) } deriveNextAutoLevel(e) { const { maxAutoLevel: t, minAutoLevel: r } = this.hls; return Math.min(Math.max(e, r), t) }
  } const Vb = { search: function (n, e) { let t = 0, r = n.length - 1, s = null, i = null; for (; t <= r;) { s = (t + r) / 2 | 0, i = n[s]; const a = e(i); if (a > 0) t = s + 1; else if (a < 0) r = s - 1; else return i } return null } }; function L_(n, e, t) { if (e === null || !Array.isArray(n) || !n.length || !ge(e)) return null; const r = n[0].programDateTime; if (e < (r || 0)) return null; const s = n[n.length - 1].endProgramDateTime; if (e >= (s || 0)) return null; for (let i = 0; i < n.length; ++i) { const a = n[i]; if (k_(e, t, a)) return a } return null } function Xs(n, e, t = 0, r = 0, s = .005) { let i = null; if (n) { i = e[1 + n.sn - e[0].sn] || null; const o = n.endDTS - t; o > 0 && o < 15e-7 && (t += 15e-7), i && n.level !== i.level && i.end <= n.end && (i = e[2 + n.sn - e[0].sn] || null) } else t === 0 && e[0].start === 0 && (i = e[0]); if (i && ((!n || n.level === i.level) && hv(t, r, i) === 0 || C_(i, n, Math.min(s, r)))) return i; const a = Vb.search(e, hv.bind(null, t, r)); return a && (a !== n || !i) ? a : i } function C_(n, e, t) { if (e && e.start === 0 && e.level < n.level && (e.endPTS || 0) > 0) { const r = e.tagList.reduce((s, i) => (i[0] === "INF" && (s += parseFloat(i[1])), s), t); return n.start <= r } return !1 } function hv(n = 0, e = 0, t) { if (t.start <= n && t.start + t.duration > n) return 0; const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)); return t.start + t.duration - r <= n ? 1 : t.start - r > n && t.start ? -1 : 0 } function k_(n, e, t) { const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3; return (t.endProgramDateTime || 0) - r > n } function Gb(n, e, t) { if (n && n.startCC <= e && n.endCC >= e) { let r = n.fragments; const { fragmentHint: s } = n; s && (r = r.concat(s)); let i; return Vb.search(r, a => a.cc < e ? 1 : a.cc > e ? -1 : (i = a, a.end <= t ? 1 : a.start > t ? -1 : 0)), i || null } return null } function Ic(n) { switch (n.details) { case J.FRAG_LOAD_TIMEOUT: case J.KEY_LOAD_TIMEOUT: case J.LEVEL_LOAD_TIMEOUT: case J.MANIFEST_LOAD_TIMEOUT: return !0 }return !1 } function Hb(n) { return n.details.startsWith("key") } function Wb(n) { return Hb(n) && !!n.frag && !n.frag.decryptdata } function pv(n, e) { const t = Ic(e); return n.default[`${t ? "timeout" : "error"}Retry`] } function gp(n, e) { const t = n.backoff === "linear" ? 1 : Math.pow(2, e); return Math.min(t * n.retryDelayMs, n.maxRetryDelayMs) } function mv(n) { return et(et({}, n), { errorRetry: null, timeoutRetry: null }) } function Lc(n, e, t, r) { if (!n) return !1; const s = r?.code, i = e < n.maxNumRetry && (R_(s) || !!t); return n.shouldRetry ? n.shouldRetry(n, e, t, r, i) : i } function R_(n) { return wh(n) || !!n && (n < 400 || n > 499) } function wh(n) { return n === 0 && navigator.onLine === !1 } var $t = { DoNothing: 0, SendAlternateToPenaltyBox: 2, RemoveAlternatePermanently: 3, RetryRequest: 5 }, vr = { None: 0, MoveAllAlternatesMatchingHost: 1, MoveAllAlternatesMatchingHDCP: 2, MoveAllAlternatesMatchingKey: 4 }; class __ extends Pr { constructor(e) { super("error-controller", e.logger), this.hls = void 0, this.playlistError = 0, this.hls = e, this.registerListeners() } registerListeners() { const e = this.hls; e.on(k.ERROR, this.onError, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.LEVEL_UPDATED, this.onLevelUpdated, this) } unregisterListeners() { const e = this.hls; e && (e.off(k.ERROR, this.onError, this), e.off(k.ERROR, this.onErrorOut, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.LEVEL_UPDATED, this.onLevelUpdated, this)) } destroy() { this.unregisterListeners(), this.hls = null } startLoad(e) { } stopLoad() { this.playlistError = 0 } getVariantLevelIndex(e) { return e?.type === ve.MAIN ? e.level : this.getVariantIndex() } getVariantIndex() { var e; const t = this.hls, r = t.currentLevel; return (e = t.loadLevelObj) != null && e.details || r === -1 ? t.loadLevel : r } variantHasKey(e, t) { if (e) { var r; if ((r = e.details) != null && r.hasKey(t)) return !0; const s = e.audioGroups; if (s) return this.hls.allAudioTracks.filter(a => s.indexOf(a.groupId) >= 0).some(a => { var o; return (o = a.details) == null ? void 0 : o.hasKey(t) }) } return !1 } onManifestLoading() { this.playlistError = 0 } onLevelUpdated() { this.playlistError = 0 } onError(e, t) { var r; if (t.fatal) return; const s = this.hls, i = t.context; switch (t.details) { case J.FRAG_LOAD_ERROR: case J.FRAG_LOAD_TIMEOUT: case J.KEY_LOAD_ERROR: case J.KEY_LOAD_TIMEOUT: t.errorAction = this.getFragRetryOrSwitchAction(t); return; case J.FRAG_PARSING_ERROR: if ((r = t.frag) != null && r.gap) { t.errorAction = Ni(); return } case J.FRAG_GAP: case J.FRAG_DECRYPT_ERROR: { t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = $t.SendAlternateToPenaltyBox; return } case J.LEVEL_EMPTY_ERROR: case J.LEVEL_PARSING_ERROR: { var a; const c = t.parent === ve.MAIN ? t.level : s.loadLevel; t.details === J.LEVEL_EMPTY_ERROR && ((a = t.context) != null && (a = a.levelDetails) != null && a.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, c) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, c)) } return; case J.LEVEL_LOAD_ERROR: case J.LEVEL_LOAD_TIMEOUT: typeof i?.level == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.level)); return; case J.AUDIO_TRACK_LOAD_ERROR: case J.AUDIO_TRACK_LOAD_TIMEOUT: case J.SUBTITLE_LOAD_ERROR: case J.SUBTITLE_TRACK_LOAD_TIMEOUT: if (i) { const c = s.loadLevelObj; if (c && (i.type === He.AUDIO_TRACK && c.hasAudioGroup(i.groupId) || i.type === He.SUBTITLE_TRACK && c.hasSubtitleGroup(i.groupId))) { t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.loadLevel), t.errorAction.action = $t.SendAlternateToPenaltyBox, t.errorAction.flags = vr.MoveAllAlternatesMatchingHost; return } } return; case J.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED: t.errorAction = { action: $t.SendAlternateToPenaltyBox, flags: vr.MoveAllAlternatesMatchingHDCP }; return; case J.KEY_SYSTEM_SESSION_UPDATE_FAILED: case J.KEY_SYSTEM_STATUS_INTERNAL_ERROR: case J.KEY_SYSTEM_NO_SESSION: t.errorAction = { action: $t.SendAlternateToPenaltyBox, flags: vr.MoveAllAlternatesMatchingKey }; return; case J.BUFFER_ADD_CODEC_ERROR: case J.REMUX_ALLOC_ERROR: case J.BUFFER_APPEND_ERROR: if (!t.errorAction) { var o; t.errorAction = this.getLevelSwitchAction(t, (o = t.level) != null ? o : s.loadLevel) } return; case J.INTERNAL_EXCEPTION: case J.BUFFER_APPENDING_ERROR: case J.BUFFER_FULL_ERROR: case J.LEVEL_SWITCH_ERROR: case J.BUFFER_STALLED_ERROR: case J.BUFFER_SEEK_OVER_HOLE: case J.BUFFER_NUDGE_ON_STALL: t.errorAction = Ni(); return }t.type === Ee.KEY_SYSTEM_ERROR && (t.levelRetry = !1, t.errorAction = Ni()) } getPlaylistRetryOrSwitchAction(e, t) { const r = this.hls, s = pv(r.config.playlistLoadPolicy, e), i = this.playlistError++; if (Lc(s, i, Ic(e), e.response)) return { action: $t.RetryRequest, flags: vr.None, retryConfig: s, retryCount: i }; const o = this.getLevelSwitchAction(e, t); return s && (o.retryConfig = s, o.retryCount = i), o } getFragRetryOrSwitchAction(e) { const t = this.hls, r = this.getVariantLevelIndex(e.frag), s = t.levels[r], { fragLoadPolicy: i, keyLoadPolicy: a } = t.config, o = pv(Hb(e) ? a : i, e), c = t.levels.reduce((f, h) => f + h.fragmentError, 0); if (s && (e.details !== J.FRAG_GAP && s.fragmentError++, !Wb(e) && Lc(o, c, Ic(e), e.response))) return { action: $t.RetryRequest, flags: vr.None, retryConfig: o, retryCount: c }; const u = this.getLevelSwitchAction(e, r); return o && (u.retryConfig = o, u.retryCount = c), u } getLevelSwitchAction(e, t) { const r = this.hls; t == null && (t = r.loadLevel); const s = this.hls.levels[t]; if (s) { var i, a; const u = e.details; s.loadError++, u === J.BUFFER_APPEND_ERROR && s.fragmentError++; let f = -1; const { levels: h, loadLevel: p, minAutoLevel: v, maxAutoLevel: g } = r; !r.autoLevelEnabled && !r.config.preserveManualLevelOnError && (r.loadLevel = -1); const y = (i = e.frag) == null ? void 0 : i.type, T = (y === ve.AUDIO && u === J.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (u === J.BUFFER_ADD_CODEC_ERROR || u === J.BUFFER_APPEND_ERROR)) && h.some(({ audioCodec: D }) => s.audioCodec !== D), E = e.sourceBufferName === "video" && (u === J.BUFFER_ADD_CODEC_ERROR || u === J.BUFFER_APPEND_ERROR) && h.some(({ codecSet: D, audioCodec: R }) => s.codecSet !== D && s.audioCodec === R), { type: I, groupId: C } = (a = e.context) != null ? a : {}; for (let D = h.length; D--;) { const R = (D + p) % h.length; if (R !== p && R >= v && R <= g && h[R].loadError === 0) { var o, c; const N = h[R]; if (u === J.FRAG_GAP && y === ve.MAIN && e.frag) { const P = h[R].details; if (P) { const _ = Xs(e.frag, P.fragments, e.frag.start); if (_ != null && _.gap) continue } } else { if (I === He.AUDIO_TRACK && N.hasAudioGroup(C) || I === He.SUBTITLE_TRACK && N.hasSubtitleGroup(C)) continue; if (y === ve.AUDIO && (o = s.audioGroups) != null && o.some(P => N.hasAudioGroup(P)) || y === ve.SUBTITLE && (c = s.subtitleGroups) != null && c.some(P => N.hasSubtitleGroup(P)) || T && s.audioCodec === N.audioCodec || E && s.codecSet === N.codecSet || !T && s.codecSet !== N.codecSet) continue } f = R; break } } if (f > -1 && r.loadLevel !== f) return e.levelRetry = !0, this.playlistError = 0, { action: $t.SendAlternateToPenaltyBox, flags: vr.None, nextAutoLevel: f } } return { action: $t.SendAlternateToPenaltyBox, flags: vr.MoveAllAlternatesMatchingHost } } onErrorOut(e, t) { var r; switch ((r = t.errorAction) == null ? void 0 : r.action) { case $t.DoNothing: break; case $t.SendAlternateToPenaltyBox: this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved && t.details !== J.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError()); break }if (t.fatal) { this.hls.stopLoad(); return } } sendAlternateToPenaltyBox(e) { const t = this.hls, r = e.errorAction; if (!r) return; const { flags: s } = r, i = r.nextAutoLevel; switch (s) { case vr.None: this.switchLevel(e, i); break; case vr.MoveAllAlternatesMatchingHDCP: { const c = this.getVariantLevelIndex(e.frag), u = t.levels[c], f = u?.attrs["HDCP-LEVEL"]; if (r.hdcpLevel = f, f === "NONE") this.warn("HDCP policy resticted output with HDCP-LEVEL=NONE"); else if (f) { t.maxHdcpLevel = bh[bh.indexOf(f) - 1], r.resolved = !0, this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`); break } } case vr.MoveAllAlternatesMatchingKey: { const c = e.decryptdata; if (c) { const u = this.hls.levels, f = u.length; for (let p = f; p--;)if (this.variantHasKey(u[p], c)) { var a, o; this.log(`Banned key found in level ${p} (${u[p].bitrate}bps) or audio group "${(a = u[p].audioGroups) == null ? void 0 : a.join(",")}" (${(o = e.frag) == null ? void 0 : o.type} fragment) ${or(c.keyId || [])}`), u[p].fragmentError++, u[p].loadError++, this.log(`Removing level ${p} with key error (${e.error})`), this.hls.removeLevel(p) } const h = e.frag; if (this.hls.levels.length < f) r.resolved = !0; else if (h && h.type !== ve.MAIN) { const p = h.decryptdata; p && !c.matches(p) && (r.resolved = !0) } } break } }r.resolved || this.switchLevel(e, i) } switchLevel(e, t) { if (t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === J.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) { const r = yh(e.mimeType), s = this.hls.levels; for (let i = s.length; i--;)s[i][`${e.sourceBufferName}Codec`] === r && (this.log(`Removing level ${i} for ${e.details} ("${r}" not supported)`), this.hls.removeLevel(i)) } } } function Ni(n) { const e = { action: $t.DoNothing, flags: vr.None }; return n && (e.resolved = !0), e } var Rt = { NOT_LOADED: "NOT_LOADED", APPENDING: "APPENDING", PARTIAL: "PARTIAL", OK: "OK" }; class P_ { constructor(e) { this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners() } _registerListeners() { const { hls: e } = this; e && (e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.BUFFER_APPENDED, this.onBufferAppended, this), e.on(k.FRAG_BUFFERED, this.onFragBuffered, this), e.on(k.FRAG_LOADED, this.onFragLoaded, this)) } _unregisterListeners() { const { hls: e } = this; e && (e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.BUFFER_APPENDED, this.onBufferAppended, this), e.off(k.FRAG_BUFFERED, this.onFragBuffered, this), e.off(k.FRAG_LOADED, this.onFragLoaded, this)) } destroy() { this._unregisterListeners(), this.hls = this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null } getAppendedFrag(e, t) { const r = this.activePartLists[t]; if (r) for (let s = r.length; s--;) { const i = r[s]; if (!i) break; if (i.start <= e && e <= i.end && i.loaded) return i } return this.getBufferedFrag(e, t) } getBufferedFrag(e, t) { return this.getFragAtPos(e, t, !0) } getFragAtPos(e, t, r) { const { fragments: s } = this, i = Object.keys(s); for (let a = i.length; a--;) { const o = s[i[a]]; if (o?.body.type === t && (!r || o.buffered)) { const c = o.body; if (c.start <= e && e <= c.end) return c } } return null } detectEvictedFragments(e, t, r, s, i) { this.timeRanges && (this.timeRanges[e] = t); const a = s?.fragment.sn || -1; Object.keys(this.fragments).forEach(o => { const c = this.fragments[o]; if (!c || a >= c.body.sn) return; if (!c.buffered && (!c.loaded || i)) { c.body.type === r && this.removeFragment(c.body); return } const u = c.range[e]; if (u) { if (u.time.length === 0) { this.removeFragment(c.body); return } u.time.some(f => { const h = !this.isTimeBuffered(f.startPTS, f.endPTS, t); return h && this.removeFragment(c.body), h }) } }) } detectPartialFragments(e) { const t = this.timeRanges; if (!t || e.frag.sn === "initSegment") return; const r = e.frag, s = Ti(r), i = this.fragments[s]; if (!i || i.buffered && r.gap) return; const a = !r.relurl; Object.keys(t).forEach(o => { const c = r.elementaryStreams[o]; if (!c) return; const u = t[o], f = a || c.partial === !0; i.range[o] = this.getBufferedTimes(r, e.part, f, u) }), i.loaded = null, Object.keys(i.range).length ? (i.buffered = !0, (i.body.endList = r.endList || i.body.endList) && (this.endListFragments[i.body.type] = i), Dl(i) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(i.body) } removeParts(e, t) { const r = this.activePartLists[t]; r && (this.activePartLists[t] = gv(r, s => s.fragment.sn >= e)) } fragBuffered(e, t) { const r = Ti(e); let s = this.fragments[r]; !s && t && (s = this.fragments[r] = { body: e, appendedPTS: null, loaded: null, buffered: !1, range: Object.create(null) }, e.gap && (this.hasGaps = !0)), s && (s.loaded = null, s.buffered = !0) } getBufferedTimes(e, t, r, s) { const i = { time: [], partial: r }, a = e.start, o = e.end, c = e.minEndPTS || o, u = e.maxStartPTS || a; for (let f = 0; f < s.length; f++) { const h = s.start(f) - this.bufferPadding, p = s.end(f) + this.bufferPadding; if (u >= h && c <= p) { i.time.push({ startPTS: Math.max(a, s.start(f)), endPTS: Math.min(o, s.end(f)) }); break } else if (a < p && o > h) { const v = Math.max(a, s.start(f)), g = Math.min(o, s.end(f)); g > v && (i.partial = !0, i.time.push({ startPTS: v, endPTS: g })) } else if (o <= h) break } return i } getPartialFragment(e) { let t = null, r, s, i, a = 0; const { bufferPadding: o, fragments: c } = this; return Object.keys(c).forEach(u => { const f = c[u]; f && Dl(f) && (s = f.body.start - o, i = f.body.end + o, e >= s && e <= i && (r = Math.min(e - s, i - e), a <= r && (t = f.body, a = r))) }), t } isEndListAppended(e) { const t = this.endListFragments[e]; return t !== void 0 && (t.buffered || Dl(t)) } getState(e) { const t = Ti(e), r = this.fragments[t]; return r ? r.buffered ? Dl(r) ? Rt.PARTIAL : Rt.OK : Rt.APPENDING : Rt.NOT_LOADED } isTimeBuffered(e, t, r) { let s, i; for (let a = 0; a < r.length; a++) { if (s = r.start(a) - this.bufferPadding, i = r.end(a) + this.bufferPadding, e >= s && t <= i) return !0; if (t <= s) return !1 } return !1 } onManifestLoading() { this.removeAllFragments() } onFragLoaded(e, t) { if (t.frag.sn === "initSegment" || t.frag.bitrateTest) return; const r = t.frag, s = t.part ? null : t, i = Ti(r); this.fragments[i] = { body: r, appendedPTS: null, loaded: s, buffered: !1, range: Object.create(null) } } onBufferAppended(e, t) { const { frag: r, part: s, timeRanges: i, type: a } = t; if (r.sn === "initSegment") return; const o = r.type; if (s) { let u = this.activePartLists[o]; u || (this.activePartLists[o] = u = []), u.push(s) } this.timeRanges = i; const c = i[a]; this.detectEvictedFragments(a, c, o, s) } onFragBuffered(e, t) { this.detectPartialFragments(t) } hasFragment(e) { const t = Ti(e); return !!this.fragments[t] } hasFragments(e) { const { fragments: t } = this, r = Object.keys(t); if (!e) return r.length > 0; for (let s = r.length; s--;) { const i = t[r[s]]; if (i?.body.type === e) return !0 } return !1 } hasParts(e) { var t; return !!((t = this.activePartLists[e]) != null && t.length) } removeFragmentsInRange(e, t, r, s, i) { s && !this.hasGaps || Object.keys(this.fragments).forEach(a => { const o = this.fragments[a]; if (!o) return; const c = o.body; c.type !== r || s && !c.gap || c.start < t && c.end > e && (o.buffered || i) && this.removeFragment(c) }) } removeFragment(e) { const t = Ti(e); e.clearElementaryStreamInfo(); const r = this.activePartLists[e.type]; if (r) { const s = e.sn; this.activePartLists[e.type] = gv(r, i => i.fragment.sn !== s) } delete this.fragments[t], e.endList && delete this.endListFragments[e.type] } removeAllFragments() { var e; this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1; const t = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList; t && t.forEach(r => r.clearElementaryStreamInfo()) } } function Dl(n) { var e, t, r; return n.buffered && !!(n.body.gap || (e = n.range.video) != null && e.partial || (t = n.range.audio) != null && t.partial || (r = n.range.audiovideo) != null && r.partial) } function Ti(n) { return `${n.type}_${n.level}_${n.sn}` } function gv(n, e) { return n.filter(t => { const r = e(t); return r || t.clearElementaryStreamInfo(), r }) } var ws = { cbc: 0, ctr: 1 }; class N_ { constructor(e, t, r) { this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = t, this.aesMode = r } decrypt(e, t) { switch (this.aesMode) { case ws.cbc: return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, t, e); case ws.ctr: return this.subtle.decrypt({ name: "AES-CTR", counter: this.aesIV, length: 64 }, t, e); default: throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`) } } } function D_(n) { const e = n.byteLength, t = e && new DataView(n.buffer).getUint8(e - 1); return t ? n.slice(0, e - t) : n } class O_ { constructor() { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable() } uint8ArrayToUint32Array_(e) { const t = new DataView(e), r = new Uint32Array(4); for (let s = 0; s < 4; s++)r[s] = t.getUint32(s * 4); return r } initTable() { const e = this.sBox, t = this.invSBox, r = this.subMix, s = r[0], i = r[1], a = r[2], o = r[3], c = this.invSubMix, u = c[0], f = c[1], h = c[2], p = c[3], v = new Uint32Array(256); let g = 0, y = 0, w = 0; for (w = 0; w < 256; w++)w < 128 ? v[w] = w << 1 : v[w] = w << 1 ^ 283; for (w = 0; w < 256; w++) { let T = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4; T = T >>> 8 ^ T & 255 ^ 99, e[g] = T, t[T] = g; const S = v[g], E = v[S], I = v[E]; let C = v[T] * 257 ^ T * 16843008; s[g] = C << 24 | C >>> 8, i[g] = C << 16 | C >>> 16, a[g] = C << 8 | C >>> 24, o[g] = C, C = I * 16843009 ^ E * 65537 ^ S * 257 ^ g * 16843008, u[T] = C << 24 | C >>> 8, f[T] = C << 16 | C >>> 16, h[T] = C << 8 | C >>> 24, p[T] = C, g ? (g = S ^ v[v[v[I ^ S]]], y ^= v[v[y]]) : g = y = 1 } } expandKey(e) { const t = this.uint8ArrayToUint32Array_(e); let r = !0, s = 0; for (; s < t.length && r;)r = t[s] === this.key[s], s++; if (r) return; this.key = t; const i = this.keySize = t.length; if (i !== 4 && i !== 6 && i !== 8) throw new Error("Invalid aes key size=" + i); const a = this.ksRows = (i + 6 + 1) * 4; let o, c; const u = this.keySchedule = new Uint32Array(a), f = this.invKeySchedule = new Uint32Array(a), h = this.sBox, p = this.rcon, v = this.invSubMix, g = v[0], y = v[1], w = v[2], T = v[3]; let S, E; for (o = 0; o < a; o++) { if (o < i) { S = u[o] = t[o]; continue } E = S, o % i === 0 ? (E = E << 8 | E >>> 24, E = h[E >>> 24] << 24 | h[E >>> 16 & 255] << 16 | h[E >>> 8 & 255] << 8 | h[E & 255], E ^= p[o / i | 0] << 24) : i > 6 && o % i === 4 && (E = h[E >>> 24] << 24 | h[E >>> 16 & 255] << 16 | h[E >>> 8 & 255] << 8 | h[E & 255]), u[o] = S = (u[o - i] ^ E) >>> 0 } for (c = 0; c < a; c++)o = a - c, c & 3 ? E = u[o] : E = u[o - 4], c < 4 || o <= 4 ? f[c] = E : f[c] = g[h[E >>> 24]] ^ y[h[E >>> 16 & 255]] ^ w[h[E >>> 8 & 255]] ^ T[h[E & 255]], f[c] = f[c] >>> 0 } networkToHostOrderSwap(e) { return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24 } decrypt(e, t, r) { const s = this.keySize + 6, i = this.invKeySchedule, a = this.invSBox, o = this.invSubMix, c = o[0], u = o[1], f = o[2], h = o[3], p = this.uint8ArrayToUint32Array_(r); let v = p[0], g = p[1], y = p[2], w = p[3]; const T = new Int32Array(e), S = new Int32Array(T.length); let E, I, C, D, R, N, P, _, M, $, B, V, W, U; const q = this.networkToHostOrderSwap; for (; t < T.length;) { for (M = q(T[t]), $ = q(T[t + 1]), B = q(T[t + 2]), V = q(T[t + 3]), R = M ^ i[0], N = V ^ i[1], P = B ^ i[2], _ = $ ^ i[3], W = 4, U = 1; U < s; U++)E = c[R >>> 24] ^ u[N >> 16 & 255] ^ f[P >> 8 & 255] ^ h[_ & 255] ^ i[W], I = c[N >>> 24] ^ u[P >> 16 & 255] ^ f[_ >> 8 & 255] ^ h[R & 255] ^ i[W + 1], C = c[P >>> 24] ^ u[_ >> 16 & 255] ^ f[R >> 8 & 255] ^ h[N & 255] ^ i[W + 2], D = c[_ >>> 24] ^ u[R >> 16 & 255] ^ f[N >> 8 & 255] ^ h[P & 255] ^ i[W + 3], R = E, N = I, P = C, _ = D, W = W + 4; E = a[R >>> 24] << 24 ^ a[N >> 16 & 255] << 16 ^ a[P >> 8 & 255] << 8 ^ a[_ & 255] ^ i[W], I = a[N >>> 24] << 24 ^ a[P >> 16 & 255] << 16 ^ a[_ >> 8 & 255] << 8 ^ a[R & 255] ^ i[W + 1], C = a[P >>> 24] << 24 ^ a[_ >> 16 & 255] << 16 ^ a[R >> 8 & 255] << 8 ^ a[N & 255] ^ i[W + 2], D = a[_ >>> 24] << 24 ^ a[R >> 16 & 255] << 16 ^ a[N >> 8 & 255] << 8 ^ a[P & 255] ^ i[W + 3], S[t] = q(E ^ v), S[t + 1] = q(D ^ g), S[t + 2] = q(C ^ y), S[t + 3] = q(I ^ w), v = M, g = $, y = B, w = V, t = t + 4 } return S.buffer } } class M_ { constructor(e, t, r) { this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = t, this.aesMode = r } expandKey() { const e = j_(this.aesMode); return this.subtle.importKey("raw", this.key, { name: e }, !1, ["encrypt", "decrypt"]) } } function j_(n) { switch (n) { case ws.cbc: return "AES-CBC"; case ws.ctr: return "AES-CTR"; default: throw new Error(`[FastAESKey] invalid aes mode ${n}`) } } const F_ = 16; class xp { constructor(e, { removePKCS7Padding: t = !0 } = {}) { if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try { const r = self.crypto; r && (this.subtle = r.subtle || r.webkitSubtle) } catch { } this.useSoftware = !this.subtle } destroy() { this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null } isSync() { return this.useSoftware } flush() { const { currentResult: e, remainderData: t } = this; if (!e || t) return this.reset(), null; const r = new Uint8Array(e); return this.reset(), this.removePKCS7Padding ? D_(r) : r } reset() { this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null) } decrypt(e, t, r, s) { return this.useSoftware ? new Promise((i, a) => { const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e); this.softwareDecrypt(o, t, r, s); const c = this.flush(); c ? i(c.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data")) }) : this.webCryptoDecrypt(new Uint8Array(e), t, r, s) } softwareDecrypt(e, t, r, s) { const { currentIV: i, currentResult: a, remainderData: o } = this; if (s !== ws.cbc || t.byteLength !== 16) return tt.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null; this.logOnce("JS AES decrypt"), o && (e = Rr(o, e), this.remainderData = null); const c = this.getValidChunk(e); if (!c.length) return null; i && (r = i); let u = this.softwareDecrypter; u || (u = this.softwareDecrypter = new O_), u.expandKey(t); const f = a; return this.currentResult = u.decrypt(c.buffer, 0, r), this.currentIV = c.slice(-16).buffer, f || null } webCryptoDecrypt(e, t, r, s) { if (this.key !== t || !this.fastAesKey) { if (!this.subtle) return Promise.resolve(this.onWebCryptoError(e, t, r, s)); this.key = t, this.fastAesKey = new M_(this.subtle, t, s) } return this.fastAesKey.expandKey().then(i => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new N_(this.subtle, new Uint8Array(r), s).decrypt(e.buffer, i)) : Promise.reject(new Error("web crypto not initialized"))).catch(i => (tt.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${i.name}: ${i.message}`), this.onWebCryptoError(e, t, r, s))) } onWebCryptoError(e, t, r, s) { const i = this.enableSoftwareAES; if (i) { this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r, s); const a = this.flush(); if (a) return a.buffer } throw new Error("WebCrypto" + (i ? " and softwareDecrypt" : "") + ": failed to decrypt data") } getValidChunk(e) { let t = e; const r = e.length - e.length % F_; return r !== e.length && (t = e.slice(0, r), this.remainderData = e.slice(r)), t } logOnce(e) { this.logEnabled && (tt.log(`[decrypter]: ${e}`), this.logEnabled = !1) } } const xv = Math.pow(2, 17); class $_ { constructor(e) { this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e } destroy() { this.loader && (this.loader.destroy(), this.loader = null) } abort() { this.loader && this.loader.abort() } load(e, t) { const r = e.url; if (!r) return Promise.reject(new Cn({ type: Ee.NETWORK_ERROR, details: J.FRAG_LOAD_ERROR, fatal: !1, frag: e, error: new Error(`Fragment does not have a ${r ? "part list" : "url"}`), networkDetails: null })); this.abort(); const s = this.config, i = s.fLoader, a = s.loader; return new Promise((o, c) => { if (this.loader && this.loader.destroy(), e.gap) if (e.tagList.some(g => g[0] === "GAP")) { c(yv(e)); return } else e.gap = !1; const u = this.loader = i ? new i(s) : new a(s), f = vv(e); e.loader = u; const h = mv(s.fragLoadPolicy.default), p = { loadPolicy: h, timeout: h.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: e.sn === "initSegment" ? 1 / 0 : xv }; e.stats = u.stats; const v = { onSuccess: (g, y, w, T) => { this.resetLoader(e, u); let S = g.data; w.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(S.slice(0, 16)), S = S.slice(16)), o({ frag: e, part: null, payload: S, networkDetails: T }) }, onError: (g, y, w, T) => { this.resetLoader(e, u), c(new Cn({ type: Ee.NETWORK_ERROR, details: J.FRAG_LOAD_ERROR, fatal: !1, frag: e, response: et({ url: r, data: void 0 }, g), error: new Error(`HTTP Error ${g.code} ${g.text}`), networkDetails: w, stats: T })) }, onAbort: (g, y, w) => { this.resetLoader(e, u), c(new Cn({ type: Ee.NETWORK_ERROR, details: J.INTERNAL_ABORTED, fatal: !1, frag: e, error: new Error("Aborted"), networkDetails: w, stats: g })) }, onTimeout: (g, y, w) => { this.resetLoader(e, u), c(new Cn({ type: Ee.NETWORK_ERROR, details: J.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, error: new Error(`Timeout after ${p.timeout}ms`), networkDetails: w, stats: g })) } }; t && (v.onProgress = (g, y, w, T) => t({ frag: e, part: null, payload: w, networkDetails: T })), u.load(f, p, v) }) } loadPart(e, t, r) { this.abort(); const s = this.config, i = s.fLoader, a = s.loader; return new Promise((o, c) => { if (this.loader && this.loader.destroy(), e.gap || t.gap) { c(yv(e, t)); return } const u = this.loader = i ? new i(s) : new a(s), f = vv(e, t); e.loader = u; const h = mv(s.fragLoadPolicy.default), p = { loadPolicy: h, timeout: h.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0, highWaterMark: xv }; t.stats = u.stats, u.load(f, p, { onSuccess: (v, g, y, w) => { this.resetLoader(e, u), this.updateStatsFromPart(e, t); const T = { frag: e, part: t, payload: v.data, networkDetails: w }; r(T), o(T) }, onError: (v, g, y, w) => { this.resetLoader(e, u), c(new Cn({ type: Ee.NETWORK_ERROR, details: J.FRAG_LOAD_ERROR, fatal: !1, frag: e, part: t, response: et({ url: f.url, data: void 0 }, v), error: new Error(`HTTP Error ${v.code} ${v.text}`), networkDetails: y, stats: w })) }, onAbort: (v, g, y) => { e.stats.aborted = t.stats.aborted, this.resetLoader(e, u), c(new Cn({ type: Ee.NETWORK_ERROR, details: J.INTERNAL_ABORTED, fatal: !1, frag: e, part: t, error: new Error("Aborted"), networkDetails: y, stats: v })) }, onTimeout: (v, g, y) => { this.resetLoader(e, u), c(new Cn({ type: Ee.NETWORK_ERROR, details: J.FRAG_LOAD_TIMEOUT, fatal: !1, frag: e, part: t, error: new Error(`Timeout after ${p.timeout}ms`), networkDetails: y, stats: v })) } }) }) } updateStatsFromPart(e, t) { const r = e.stats, s = t.stats, i = s.total; if (r.loaded += s.loaded, i) { const c = Math.round(e.duration / t.duration), u = Math.min(Math.round(r.loaded / i), c), h = (c - u) * Math.round(r.loaded / u); r.total = r.loaded + h } else r.total = Math.max(r.loaded, r.total); const a = r.loading, o = s.loading; a.start ? a.first += o.first - o.start : (a.start = o.start, a.first = o.first), a.end = o.end } resetLoader(e, t) { e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy() } } function vv(n, e = null) { const t = e || n, r = { frag: n, part: e, responseType: "arraybuffer", url: t.url, headers: {}, rangeStart: 0, rangeEnd: 0 }, s = t.byteRangeStartOffset, i = t.byteRangeEndOffset; if (ge(s) && ge(i)) { var a; let o = s, c = i; if (n.sn === "initSegment" && B_((a = n.decryptdata) == null ? void 0 : a.method)) { const u = i - s; u % 16 && (c = i + (16 - u % 16)), s !== 0 && (r.resetIV = !0, o = s - 16) } r.rangeStart = o, r.rangeEnd = c } return r } function yv(n, e) { const t = new Error(`GAP ${n.gap ? "tag" : "attribute"} found`), r = { type: Ee.MEDIA_ERROR, details: J.FRAG_GAP, fatal: !1, frag: n, error: t, networkDetails: null }; return e && (r.part = e), (e || n).stats.aborted = !0, new Cn(r) } function B_(n) { return n === "AES-128" || n === "AES-256" } class Cn extends Error { constructor(e) { super(e.error.message), this.data = void 0, this.data = e } } class Kb extends Pr { constructor(e, t) { super(e, t), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this) } destroy() { this.onHandlerDestroying(), this.onHandlerDestroyed() } onHandlerDestroying() { this.clearNextTick(), this.clearInterval() } onHandlerDestroyed() { } hasInterval() { return !!this._tickInterval } hasNextTick() { return !!this._tickTimer } setInterval(e) { return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0) } clearInterval() { return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1 } clearNextTick() { return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1 } tick() { this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0) } tickImmediate() { this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0) } doTick() { } } class vp { constructor(e, t, r, s = 0, i = -1, a = !1) { this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = Ol(), this.buffering = { audio: Ol(), video: Ol(), audiovideo: Ol() }, this.level = e, this.sn = t, this.id = r, this.size = s, this.part = i, this.partial = a } } function Ol() { return { start: 0, executeStart: 0, executeEnd: 0, end: 0 } } const bv = { length: 0, start: () => 0, end: () => 0 }; class Me { static isBuffered(e, t) { if (e) { const r = Me.getBuffered(e); for (let s = r.length; s--;)if (t >= r.start(s) && t <= r.end(s)) return !0 } return !1 } static bufferedRanges(e) { if (e) { const t = Me.getBuffered(e); return Me.timeRangesToArray(t) } return [] } static timeRangesToArray(e) { const t = []; for (let r = 0; r < e.length; r++)t.push({ start: e.start(r), end: e.end(r) }); return t } static bufferInfo(e, t, r) { if (e) { const s = Me.bufferedRanges(e); if (s.length) return Me.bufferedInfo(s, t, r) } return { len: 0, start: t, end: t, bufferedIndex: -1 } } static bufferedInfo(e, t, r) { t = Math.max(0, t), e.length > 1 && e.sort((f, h) => f.start - h.start || h.end - f.end); let s = -1, i = []; if (r) for (let f = 0; f < e.length; f++) { t >= e[f].start && t <= e[f].end && (s = f); const h = i.length; if (h) { const p = i[h - 1].end; e[f].start - p < r ? e[f].end > p && (i[h - 1].end = e[f].end) : i.push(e[f]) } else i.push(e[f]) } else i = e; let a = 0, o, c = t, u = t; for (let f = 0; f < i.length; f++) { const h = i[f].start, p = i[f].end; if (s === -1 && t >= h && t <= p && (s = f), t + r >= h && t < p) c = h, u = p, a = u - t; else if (t + r < h) { o = h; break } } return { len: a, start: c || 0, end: u || 0, nextStart: o, buffered: e, bufferedIndex: s } } static getBuffered(e) { try { return e.buffered || bv } catch (t) { return tt.log("failed to get media.buffered", t), bv } } } const qb = /\{\$([a-zA-Z0-9-_]+)\}/g; function wv(n) { return qb.test(n) } function Sh(n, e) { if (n.variableList !== null || n.hasVariableRefs) { const t = n.variableList; return e.replace(qb, r => { const s = r.substring(2, r.length - 1), i = t?.[s]; return i === void 0 ? (n.playlistParsingError || (n.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${s}"`)), r) : i }) } return e } function Sv(n, e, t) { let r = n.variableList; r || (n.variableList = r = {}); let s, i; if ("QUERYPARAM" in e) { s = e.QUERYPARAM; try { const a = new self.URL(t).searchParams; if (a.has(s)) i = a.get(s); else throw new Error(`"${s}" does not match any query parameter in URI: "${t}"`) } catch (a) { n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`)) } } else s = e.NAME, i = e.VALUE; s in r ? n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${s}"`)) : r[s] = i || "" } function U_(n, e, t) { const r = e.IMPORT; if (t && r in t) { let s = n.variableList; s || (n.variableList = s = {}), s[r] = t[r] } else n.playlistParsingError || (n.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`)) } const z_ = /^(\d+)x(\d+)$/, Ev = /(.+?)=(".*?"|.*?)(?:,|$)/g; class gt { constructor(e, t) { typeof e == "string" && (e = gt.parseAttrList(e, t)), nt(this, e) } get clientAttrs() { return Object.keys(this).filter(e => e.substring(0, 2) === "X-") } decimalInteger(e) { const t = parseInt(this[e], 10); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t } hexadecimalInteger(e) { if (this[e]) { let t = (this[e] || "0x").slice(2); t = (t.length & 1 ? "0" : "") + t; const r = new Uint8Array(t.length / 2); for (let s = 0; s < t.length / 2; s++)r[s] = parseInt(t.slice(s * 2, s * 2 + 2), 16); return r } return null } hexadecimalIntegerAsNumber(e) { const t = parseInt(this[e], 16); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t } decimalFloatingPoint(e) { return parseFloat(this[e]) } optionalFloat(e, t) { const r = this[e]; return r ? parseFloat(r) : t } enumeratedString(e) { return this[e] } enumeratedStringList(e, t) { const r = this[e]; return (r ? r.split(/[ ,]+/) : []).reduce((s, i) => (s[i.toLowerCase()] = !0, s), t) } bool(e) { return this[e] === "YES" } decimalResolution(e) { const t = z_.exec(this[e]); if (t !== null) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) } } static parseAttrList(e, t) { let r; const s = {}; for (Ev.lastIndex = 0; (r = Ev.exec(e)) !== null;) { const a = r[1].trim(); let o = r[2]; const c = o.indexOf('"') === 0 && o.lastIndexOf('"') === o.length - 1; let u = !1; if (c) o = o.slice(1, -1); else switch (a) { case "IV": case "SCTE35-CMD": case "SCTE35-IN": case "SCTE35-OUT": u = !0 }if (t && (c || u)) o = Sh(t, o); else if (!u && !c) switch (a) { case "CLOSED-CAPTIONS": if (o === "NONE") break; case "ALLOWED-CPC": case "CLASS": case "ASSOC-LANGUAGE": case "AUDIO": case "BYTERANGE": case "CHANNELS": case "CHARACTERISTICS": case "CODECS": case "DATA-ID": case "END-DATE": case "GROUP-ID": case "ID": case "IMPORT": case "INSTREAM-ID": case "KEYFORMAT": case "KEYFORMATVERSIONS": case "LANGUAGE": case "NAME": case "PATHWAY-ID": case "QUERYPARAM": case "RECENTLY-REMOVED-DATERANGES": case "SERVER-URI": case "STABLE-RENDITION-ID": case "STABLE-VARIANT-ID": case "START-DATE": case "SUBTITLES": case "SUPPLEMENTAL-CODECS": case "URI": case "VALUE": case "VIDEO": case "X-ASSET-LIST": case "X-ASSET-URI": tt.warn(`${e}: attribute ${a} is missing quotes`) }s[a] = o } return s } } const V_ = "com.apple.hls.interstitial"; function G_(n) { return n !== "ID" && n !== "CLASS" && n !== "CUE" && n !== "START-DATE" && n !== "DURATION" && n !== "END-DATE" && n !== "END-ON-NEXT" } function H_(n) { return n === "SCTE35-OUT" || n === "SCTE35-IN" || n === "SCTE35-CMD" } class Yb { constructor(e, t, r = 0) { var s; if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = t?.tagAnchor || null, this.tagOrder = (s = t?.tagOrder) != null ? s : r, t) { const i = t.attr; for (const a in i) if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== i[a]) { tt.warn(`DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = a; break } e = nt(new gt({}), i, e) } if (this.attr = e, t ? (this._startDate = t._startDate, this._cue = t._cue, this._endDate = t._endDate, this._dateAtEnd = t._dateAtEnd) : this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) { const i = t?.endDate || new Date(this.attr["END-DATE"]); ge(i.getTime()) && (this._endDate = i) } } get id() { return this.attr.ID } get class() { return this.attr.CLASS } get cue() { const e = this._cue; return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", { pre: !1, post: !1, once: !1 }) : e } get startTime() { const { tagAnchor: e } = this; return e === null || e.programDateTime === null ? (tt.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3 } get startDate() { return this._startDate } get endDate() { const e = this._endDate || this._dateAtEnd; if (e) return e; const t = this.duration; return t !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3) : null } get duration() { if ("DURATION" in this.attr) { const e = this.attr.decimalFloatingPoint("DURATION"); if (ge(e)) return e } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3; return null } get plannedDuration() { return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null } get endOnNext() { return this.attr.bool("END-ON-NEXT") } get isInterstitial() { return this.class === V_ } get isValid() { return !!this.id && !this._badValueForSameId && ge(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr) } } const W_ = 10; class K_ { constructor(e) { this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e } reloaded(e) { if (!e) { this.advanced = !0, this.updated = !0; return } const t = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex; this.updated = this.endSN !== e.endSN || !!r || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && r > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * .6) : this.misses = e.misses + 1 } hasKey(e) { return this.encryptedFragments.some(t => { let r = t.decryptdata; return r || (t.setKeyFormat(e.keyFormat), r = t.decryptdata), !!r && e.matches(r) }) } get hasProgramDateTime() { return this.fragments.length ? ge(this.fragments[this.fragments.length - 1].programDateTime) : !1 } get levelTargetDuration() { return this.averagetargetduration || this.targetduration || W_ } get drift() { const e = this.driftEndTime - this.driftStartTime; return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1 } get edge() { return this.partEnd || this.fragmentEnd } get partEnd() { var e; return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd } get fragmentEnd() { return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0 } get fragmentStart() { return this.fragments.length ? this.fragments[0].start : 0 } get age() { return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0 } get lastPartIndex() { var e; return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1 } get maxPartIndex() { const e = this.partList; if (e) { const t = this.lastPartIndex; if (t !== -1) { for (let r = e.length; r--;)if (e[r].index > t) return e[r].index; return t } } return 0 } get lastPartSn() { var e; return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN } get expired() { if (this.live && this.age && this.misses < 3) { const e = this.partEnd - this.fragmentStart; return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration } return !1 } } function yp(n, e) { return n.length === e.length ? !n.some((t, r) => t !== e[r]) : !1 } function Tv(n, e) { return !n && !e ? !0 : !n || !e ? !1 : yp(n, e) } function Di(n) { return n === "AES-128" || n === "AES-256" || n === "AES-256-CTR" } function bp(n) { switch (n) { case "AES-128": case "AES-256": return ws.cbc; case "AES-256-CTR": return ws.ctr; default: throw new Error(`invalid full segment method ${n}`) } } function wp(n) { return Uint8Array.from(atob(n), e => e.charCodeAt(0)) } function Eh(n) { return Uint8Array.from(unescape(encodeURIComponent(n)), e => e.charCodeAt(0)) } function q_(n) { const e = Eh(n).subarray(0, 16), t = new Uint8Array(16); return t.set(e, 16 - e.length), t } function Xb(n) { const e = function (r, s, i) { const a = r[s]; r[s] = r[i], r[i] = a }; e(n, 0, 3), e(n, 1, 2), e(n, 4, 5), e(n, 6, 7) } function Y_(n) { const e = n.split(":"); let t = null; if (e[0] === "data" && e.length === 2) { const r = e[1].split(";"), s = r[r.length - 1].split(","); if (s.length === 2) { const i = s[0] === "base64", a = s[1]; i ? (r.splice(-1, 1), t = wp(a)) : t = q_(a) } } return t } const Cc = typeof self < "u" ? self : void 0; var xt = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.fps", PLAYREADY: "com.microsoft.playready", WIDEVINE: "com.widevine.alpha" }, qt = { CLEARKEY: "org.w3.clearkey", FAIRPLAY: "com.apple.streamingkeydelivery", PLAYREADY: "com.microsoft.playready", WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" }; function rc(n) { switch (n) { case qt.FAIRPLAY: return xt.FAIRPLAY; case qt.PLAYREADY: return xt.PLAYREADY; case qt.WIDEVINE: return xt.WIDEVINE; case qt.CLEARKEY: return xt.CLEARKEY } } function pf(n) { switch (n) { case xt.FAIRPLAY: return qt.FAIRPLAY; case xt.PLAYREADY: return qt.PLAYREADY; case xt.WIDEVINE: return qt.WIDEVINE; case xt.CLEARKEY: return qt.CLEARKEY } } function $a(n) { const { drmSystems: e, widevineLicenseUrl: t } = n, r = e ? [xt.FAIRPLAY, xt.WIDEVINE, xt.PLAYREADY, xt.CLEARKEY].filter(s => !!e[s]) : []; return !r[xt.WIDEVINE] && t && r.push(xt.WIDEVINE), r } const Qb = (function (n) { return Cc != null && (n = Cc.navigator) != null && n.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null })(); function X_(n, e, t, r) { let s; switch (n) { case xt.FAIRPLAY: s = ["cenc", "sinf"]; break; case xt.WIDEVINE: case xt.PLAYREADY: s = ["cenc"]; break; case xt.CLEARKEY: s = ["cenc", "keyids"]; break; default: throw new Error(`Unknown key-system: ${n}`) }return Q_(s, e, t, r) } function Q_(n, e, t, r) { return [{ initDataTypes: n, persistentState: r.persistentState || "optional", distinctiveIdentifier: r.distinctiveIdentifier || "optional", sessionTypes: r.sessionTypes || [r.sessionType || "temporary"], audioCapabilities: e.map(i => ({ contentType: `audio/mp4; codecs=${i}`, robustness: r.audioRobustness || "", encryptionScheme: r.audioEncryptionScheme || null })), videoCapabilities: t.map(i => ({ contentType: `video/mp4; codecs=${i}`, robustness: r.videoRobustness || "", encryptionScheme: r.videoEncryptionScheme || null })) }] } function Z_(n) { var e; return !!n && (n.sessionType === "persistent-license" || !!((e = n.sessionTypes) != null && e.some(t => t === "persistent-license"))) } function J_(n) { const e = new Uint16Array(n.buffer, n.byteOffset, n.byteLength / 2), t = String.fromCharCode.apply(null, Array.from(e)), r = t.substring(t.indexOf("<"), t.length), a = new DOMParser().parseFromString(r, "text/xml").getElementsByTagName("KID")[0]; if (a) { const o = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE"); if (o) { const c = wp(o).subarray(0, 16); return Xb(c), c } } return null } let Ml = {}; class to { static clearKeyUriToKeyIdMap() { Ml = {} } static setKeyIdForUri(e, t) { Ml[e] = t } constructor(e, t, r, s = [1], i = null, a) { this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = s, this.iv = i, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && !Di(e), a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(Cb(a))) } matches(e) { return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && yp(e.keyFormatVersions, this.keyFormatVersions) && Tv(e.iv, this.iv) && Tv(e.keyId, this.keyId) } isSupported() { if (this.method) { if (Di(this.method) || this.method === "NONE") return !0; if (this.keyFormat === "identity") return this.method === "SAMPLE-AES"; switch (this.keyFormat) { case qt.FAIRPLAY: case qt.WIDEVINE: case qt.PLAYREADY: case qt.CLEARKEY: return ["SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1 } } return !1 } getDecryptData(e) { if (!this.encrypted || !this.uri) return null; if (Di(this.method)) { let s = this.iv; return s || (typeof e != "number" && (tt.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0), s = eP(e)), new to(this.method, this.uri, "identity", this.keyFormatVersions, s) } if (this.pssh && this.keyId) return this; const t = Y_(this.uri); if (t) switch (this.keyFormat) { case qt.WIDEVINE: if (this.pssh = t, !this.keyId) { const s = r_(t.buffer); if (s.length) { var r; const i = s[0]; this.keyId = (r = i.kids) != null && r.length ? i.kids[0] : null } } if (!this.keyId) { const s = t.length - 22; this.keyId = t.subarray(s, s + 16) } break; case qt.PLAYREADY: { const s = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]); this.pssh = t_(s, null, t), this.keyId = J_(t); break } default: { let s = t.subarray(0, 16); if (s.length !== 16) { const i = new Uint8Array(16); i.set(s, 16 - s.length), s = i } this.keyId = s; break } }if (!this.keyId || this.keyId.byteLength !== 16) { let s = Ml[this.uri]; if (!s) { const i = Object.keys(Ml).length % Number.MAX_SAFE_INTEGER; s = new Uint8Array(16), new DataView(s.buffer, 12, 4).setUint32(0, i), to.setKeyIdForUri(this.uri, s) } this.keyId = s } return this } } function eP(n) { const e = new Uint8Array(16); for (let t = 12; t < 16; t++)e[t] = n >> 8 * (15 - t) & 255; return e } const Av = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, Iv = /#EXT-X-MEDIA:(.*)/g, tP = /^#EXT(?:INF|-X-TARGETDURATION):/m, mf = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[^\r\n]*)/.source, /#.*/.source].join("|"), "g"), rP = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")); class un { static findGroup(e, t) { for (let r = 0; r < e.length; r++) { const s = e[r]; if (s.id === t) return s } } static resolve(e, t) { return dp.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }) } static isMediaPlaylist(e) { return tP.test(e) } static parseMasterPlaylist(e, t) { const r = wv(e), s = { contentSteering: null, levels: [], playlistParsingError: null, sessionData: null, sessionKeys: null, startTimeOffset: null, variableList: null, hasVariableRefs: r }, i = []; if (Av.lastIndex = 0, !e.startsWith("#EXTM3U")) return s.playlistParsingError = new Error("no EXTM3U delimiter"), s; let a; for (; (a = Av.exec(e)) != null;)if (a[1]) { var o; const u = new gt(a[1], s), f = Sh(s, a[2]), h = { attrs: u, bitrate: u.decimalInteger("BANDWIDTH") || u.decimalInteger("AVERAGE-BANDWIDTH"), name: u.NAME, url: un.resolve(f, t) }, p = u.decimalResolution("RESOLUTION"); p && (h.width = p.width, h.height = p.height), kv(u.CODECS, h); const v = u["SUPPLEMENTAL-CODECS"]; v && (h.supplemental = {}, kv(v, h.supplemental)), (o = h.unknownCodecs) != null && o.length || i.push(h), s.levels.push(h) } else if (a[3]) { const u = a[3], f = a[4]; switch (u) { case "SESSION-DATA": { const h = new gt(f, s), p = h["DATA-ID"]; p && (s.sessionData === null && (s.sessionData = {}), s.sessionData[p] = h); break } case "SESSION-KEY": { const h = Lv(f, t, s); h.encrypted && h.isSupported() ? (s.sessionKeys === null && (s.sessionKeys = []), s.sessionKeys.push(h)) : tt.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${f}"`); break } case "DEFINE": { { const h = new gt(f, s); Sv(s, h, t) } break } case "CONTENT-STEERING": { const h = new gt(f, s); s.contentSteering = { uri: un.resolve(h["SERVER-URI"], t), pathwayId: h["PATHWAY-ID"] || "." }; break } case "START": { s.startTimeOffset = Cv(f); break } } } const c = i.length > 0 && i.length < s.levels.length; return s.levels = c ? i : s.levels, s.levels.length === 0 && (s.playlistParsingError = new Error("no levels found in manifest")), s } static parseMasterPlaylistMedia(e, t, r) { let s; const i = {}, a = r.levels, o = { AUDIO: a.map(u => ({ id: u.attrs.AUDIO, audioCodec: u.audioCodec })), SUBTITLES: a.map(u => ({ id: u.attrs.SUBTITLES, textCodec: u.textCodec })), "CLOSED-CAPTIONS": [] }; let c = 0; for (Iv.lastIndex = 0; (s = Iv.exec(e)) !== null;) { const u = new gt(s[1], r), f = u.TYPE; if (f) { const h = o[f], p = i[f] || []; i[f] = p; const v = u.LANGUAGE, g = u["ASSOC-LANGUAGE"], y = u.CHANNELS, w = u.CHARACTERISTICS, T = u["INSTREAM-ID"], S = { attrs: u, bitrate: 0, id: c++, groupId: u["GROUP-ID"] || "", name: u.NAME || v || "", type: f, default: u.bool("DEFAULT"), autoselect: u.bool("AUTOSELECT"), forced: u.bool("FORCED"), lang: v, url: u.URI ? un.resolve(u.URI, t) : "" }; if (g && (S.assocLang = g), y && (S.channels = y), w && (S.characteristics = w), T && (S.instreamId = T), h != null && h.length) { const E = un.findGroup(h, S.groupId) || h[0]; Rv(S, E, "audioCodec"), Rv(S, E, "textCodec") } p.push(S) } } return i } static parseLevelPlaylist(e, t, r, s, i, a) { var o; const c = { url: t }, u = new K_(t), f = u.fragments, h = []; let p = null, v = 0, g = 0, y = 0, w = 0, T = 0, S = null, E = new df(s, c), I, C, D, R = -1, N = !1, P = null, _; if (mf.lastIndex = 0, u.m3u8 = e, u.hasVariableRefs = wv(e), ((o = mf.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U") return u.playlistParsingError = new Error("Missing format identifier #EXTM3U"), u; for (; (I = mf.exec(e)) !== null;) { N && (N = !1, E = new df(s, c), E.playlistOffset = y, E.setStart(y), E.sn = v, E.cc = w, T && (E.bitrate = T), E.level = r, p && (E.initSegment = p, p.rawProgramDateTime && (E.rawProgramDateTime = p.rawProgramDateTime, p.rawProgramDateTime = null), P && (E.setByteRange(P), P = null))); const V = I[1]; if (V) { E.duration = parseFloat(V); const W = (" " + I[2]).slice(1); E.title = W || null, E.tagList.push(W ? ["INF", V, W] : ["INF", V]) } else if (I[3]) { if (ge(E.duration)) { E.playlistOffset = y, E.setStart(y), D && Pv(E, D, u), E.sn = v, E.level = r, E.cc = w, f.push(E); const W = (" " + I[3]).slice(1); E.relurl = Sh(u, W), Th(E, S, h), S = E, y += E.duration, v++, g = 0, N = !0 } } else { if (I = I[0].match(rP), !I) { tt.warn("No matches on slow regex match for level playlist!"); continue } for (C = 1; C < I.length && I[C] === void 0; C++); const W = (" " + I[C]).slice(1), U = (" " + I[C + 1]).slice(1), q = I[C + 2] ? (" " + I[C + 2]).slice(1) : null; switch (W) { case "BYTERANGE": S ? E.setByteRange(U, S) : E.setByteRange(U); break; case "PROGRAM-DATE-TIME": E.rawProgramDateTime = U, E.tagList.push(["PROGRAM-DATE-TIME", U]), R === -1 && (R = f.length); break; case "PLAYLIST-TYPE": u.type && Tn(u, W, I), u.type = U.toUpperCase(); break; case "MEDIA-SEQUENCE": u.startSN !== 0 ? Tn(u, W, I) : f.length > 0 && Nv(u, W, I), v = u.startSN = parseInt(U); break; case "SKIP": { u.skippedSegments && Tn(u, W, I); const z = new gt(U, u), X = z.decimalInteger("SKIPPED-SEGMENTS"); if (ge(X)) { u.skippedSegments += X; for (let F = X; F--;)f.push(null); v += X } const Z = z.enumeratedString("RECENTLY-REMOVED-DATERANGES"); Z && (u.recentlyRemovedDateranges = (u.recentlyRemovedDateranges || []).concat(Z.split("	"))); break } case "TARGETDURATION": u.targetduration !== 0 && Tn(u, W, I), u.targetduration = Math.max(parseInt(U), 1); break; case "VERSION": u.version !== null && Tn(u, W, I), u.version = parseInt(U); break; case "INDEPENDENT-SEGMENTS": break; case "ENDLIST": u.live || Tn(u, W, I), u.live = !1; break; case "#": (U || q) && E.tagList.push(q ? [U, q] : [U]); break; case "DISCONTINUITY": w++, E.tagList.push(["DIS"]); break; case "GAP": E.gap = !0, E.tagList.push([W]); break; case "BITRATE": E.tagList.push([W, U]), T = parseInt(U) * 1e3, ge(T) ? E.bitrate = T : T = 0; break; case "DATERANGE": { const z = new gt(U, u), X = new Yb(z, u.dateRanges[z.ID], u.dateRangeTagCount); u.dateRangeTagCount++, X.isValid || u.skippedSegments ? u.dateRanges[X.id] = X : tt.warn(`Ignoring invalid DATERANGE tag: "${U}"`), E.tagList.push(["EXT-X-DATERANGE", U]); break } case "DEFINE": { { const z = new gt(U, u); "IMPORT" in z ? U_(u, z, a) : Sv(u, z, t) } break } case "DISCONTINUITY-SEQUENCE": u.startCC !== 0 ? Tn(u, W, I) : f.length > 0 && Nv(u, W, I), u.startCC = w = parseInt(U); break; case "KEY": { const z = Lv(U, t, u); if (z.isSupported()) { if (z.method === "NONE") { D = void 0; break } D || (D = {}); const X = D[z.keyFormat]; X != null && X.matches(z) || (X && (D = nt({}, D)), D[z.keyFormat] = z) } else tt.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: "${U}"`); break } case "START": u.startTimeOffset = Cv(U); break; case "MAP": { const z = new gt(U, u); if (E.duration) { const X = new df(s, c); _v(X, z, r, D), p = X, E.initSegment = p, p.rawProgramDateTime && !E.rawProgramDateTime && (E.rawProgramDateTime = p.rawProgramDateTime) } else { const X = E.byteRangeEndOffset; if (X) { const Z = E.byteRangeStartOffset; P = `${X - Z}@${Z}` } else P = null; _v(E, z, r, D), p = E, N = !0 } p.cc = w; break } case "SERVER-CONTROL": { _ && Tn(u, W, I), _ = new gt(U), u.canBlockReload = _.bool("CAN-BLOCK-RELOAD"), u.canSkipUntil = _.optionalFloat("CAN-SKIP-UNTIL", 0), u.canSkipDateRanges = u.canSkipUntil > 0 && _.bool("CAN-SKIP-DATERANGES"), u.partHoldBack = _.optionalFloat("PART-HOLD-BACK", 0), u.holdBack = _.optionalFloat("HOLD-BACK", 0); break } case "PART-INF": { u.partTarget && Tn(u, W, I); const z = new gt(U); u.partTarget = z.decimalFloatingPoint("PART-TARGET"); break } case "PART": { let z = u.partList; z || (z = u.partList = []); const X = g > 0 ? z[z.length - 1] : void 0, Z = g++, F = new gt(U, u), H = new zR(F, E, c, Z, X); z.push(H), E.duration += H.duration; break } case "PRELOAD-HINT": { const z = new gt(U, u); u.preloadHint = z; break } case "RENDITION-REPORT": { const z = new gt(U, u); u.renditionReports = u.renditionReports || [], u.renditionReports.push(z); break } default: tt.warn(`line parsed but not handled: ${I}`); break } } } S && !S.relurl ? (f.pop(), y -= S.duration, u.partList && (u.fragmentHint = S)) : u.partList && (Th(E, S, h), E.cc = w, u.fragmentHint = E, D && Pv(E, D, u)), u.targetduration || (u.playlistParsingError = new Error("Missing Target Duration")); const M = f.length, $ = f[0], B = f[M - 1]; if (y += u.skippedSegments * u.targetduration, y > 0 && M && B) { u.averagetargetduration = y / M; const V = B.sn; u.endSN = V !== "initSegment" ? V : 0, u.live || (B.endList = !0), R > 0 && (sP(f, R), $ && h.unshift($)) } return u.fragmentHint && (y += u.fragmentHint.duration), u.totalduration = y, h.length && u.dateRangeTagCount && $ && Zb(h, u), u.endCC = w, u } } function Zb(n, e) { let t = n.length; if (!t) if (e.hasProgramDateTime) { const o = e.fragments[e.fragments.length - 1]; n.push(o), t++ } else return; const r = n[t - 1], s = e.live ? 1 / 0 : e.totalduration, i = Object.keys(e.dateRanges); for (let o = i.length; o--;) { const c = e.dateRanges[i[o]], u = c.startDate.getTime(); c.tagAnchor = r.ref; for (let f = t; f--;) { var a; if (((a = n[f]) == null ? void 0 : a.sn) < e.startSN) break; const h = nP(e, u, n, f, s); if (h !== -1) { c.tagAnchor = e.fragments[h].ref; break } } } } function nP(n, e, t, r, s) { const i = t[r]; if (i) { const o = i.programDateTime; if (e >= o || r === 0) { var a; const c = (((a = t[r + 1]) == null ? void 0 : a.start) || s) - i.start; if (e <= o + c * 1e3) { const u = t[r].sn - n.startSN; if (u < 0) return -1; const f = n.fragments; if (f.length > t.length) { const p = (t[r + 1] || f[f.length - 1]).sn - n.startSN; for (let v = p; v > u; v--) { const g = f[v].programDateTime; if (e >= g && e < g + f[v].duration * 1e3) return v } } return u } } } return -1 } function Lv(n, e, t) { var r, s; const i = new gt(n, t), a = (r = i.METHOD) != null ? r : "", o = i.URI, c = i.hexadecimalInteger("IV"), u = i.KEYFORMATVERSIONS, f = (s = i.KEYFORMAT) != null ? s : "identity"; o && i.IV && !c && tt.error(`Invalid IV: ${i.IV}`); const h = o ? un.resolve(o, e) : "", p = (u || "1").split("/").map(Number).filter(Number.isFinite); return new to(a, h, f, p, c, i.KEYID) } function Cv(n) { const t = new gt(n).decimalFloatingPoint("TIME-OFFSET"); return ge(t) ? t : null } function kv(n, e) { let t = (n || "").split(/[ ,]+/).filter(r => r);["video", "audio", "text"].forEach(r => { const s = t.filter(i => pp(i, r)); s.length && (e[`${r}Codec`] = s.map(i => i.split("/")[0]).join(","), t = t.filter(i => s.indexOf(i) === -1)) }), e.unknownCodecs = t } function Rv(n, e, t) { const r = e[t]; r && (n[t] = r) } function sP(n, e) { let t = n[e]; for (let r = e; r--;) { const s = n[r]; if (!s) return; s.programDateTime = t.programDateTime - s.duration * 1e3, t = s } } function Th(n, e, t) { n.rawProgramDateTime ? t.push(n) : e != null && e.programDateTime && (n.programDateTime = e.endProgramDateTime) } function _v(n, e, t, r) { n.relurl = e.URI, e.BYTERANGE && n.setByteRange(e.BYTERANGE), n.level = t, n.sn = "initSegment", r && (n.levelkeys = r), n.initSegment = null } function Pv(n, e, t) { n.levelkeys = e; const { encryptedFragments: r } = t; (!r.length || r[r.length - 1].levelkeys !== e) && Object.keys(e).some(s => e[s].isCommonEncryption) && r.push(n) } function Tn(n, e, t) { n.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${t[0]})`) } function Nv(n, e, t) { n.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${t[0]})`) } function gf(n, e) { const t = e.startPTS; if (ge(t)) { let r = 0, s; e.sn > n.sn ? (r = t - n.start, s = n) : (r = n.start - t, s = e), s.duration !== r && s.setDuration(r) } else e.sn > n.sn ? n.cc === e.cc && n.minEndPTS ? e.setStart(n.start + (n.minEndPTS - n.start)) : e.setStart(n.start + n.duration) : e.setStart(Math.max(n.start - e.duration, 0)) } function Jb(n, e, t, r, s, i, a) { r - t <= 0 && (a.warn("Fragment should have a positive duration", e), r = t + e.duration, i = s + e.duration); let c = t, u = r; const f = e.startPTS, h = e.endPTS; if (ge(f)) { const T = Math.abs(f - t); n && T > n.totalduration ? a.warn(`media timestamps and playlist times differ by ${T}s for level ${e.level} ${n.url}`) : ge(e.deltaPTS) ? e.deltaPTS = Math.max(T, e.deltaPTS) : e.deltaPTS = T, c = Math.max(t, f), t = Math.min(t, f), s = e.startDTS !== void 0 ? Math.min(s, e.startDTS) : s, u = Math.min(r, h), r = Math.max(r, h), i = e.endDTS !== void 0 ? Math.max(i, e.endDTS) : i } const p = t - e.start; e.start !== 0 && e.setStart(t), e.setDuration(r - e.start), e.startPTS = t, e.maxStartPTS = c, e.startDTS = s, e.endPTS = r, e.minEndPTS = u, e.endDTS = i; const v = e.sn; if (!n || v < n.startSN || v > n.endSN) return 0; let g; const y = v - n.startSN, w = n.fragments; for (w[y] = e, g = y; g > 0; g--)gf(w[g], w[g - 1]); for (g = y; g < w.length - 1; g++)gf(w[g], w[g + 1]); return n.fragmentHint && gf(w[w.length - 1], n.fragmentHint), n.PTSKnown = n.alignedSliding = !0, p } function iP(n, e, t) { if (n === e) return; let r = null; const s = n.fragments; for (let f = s.length - 1; f >= 0; f--) { const h = s[f].initSegment; if (h) { r = h; break } } n.fragmentHint && delete n.fragmentHint.endPTS; let i; lP(n, e, (f, h, p, v) => { if ((!e.startCC || e.skippedSegments) && h.cc !== f.cc) { const g = f.cc - h.cc; for (let y = p; y < v.length; y++)v[y].cc += g; e.endCC = v[v.length - 1].cc } ge(f.startPTS) && ge(f.endPTS) && (h.setStart(h.startPTS = f.startPTS), h.startDTS = f.startDTS, h.maxStartPTS = f.maxStartPTS, h.endPTS = f.endPTS, h.endDTS = f.endDTS, h.minEndPTS = f.minEndPTS, h.setDuration(f.endPTS - f.startPTS), h.duration && (i = h), e.PTSKnown = e.alignedSliding = !0), f.hasStreams && (h.elementaryStreams = f.elementaryStreams), h.loader = f.loader, f.hasStats && (h.stats = f.stats), f.initSegment && (h.initSegment = f.initSegment, r = f.initSegment) }); const a = e.fragments, o = e.fragmentHint ? a.concat(e.fragmentHint) : a; if (r && o.forEach(f => { var h; f && (!f.initSegment || f.initSegment.relurl === ((h = r) == null ? void 0 : h.relurl)) && (f.initSegment = r) }), e.skippedSegments) { if (e.deltaUpdateFailed = a.some(f => !f), e.deltaUpdateFailed) { t.warn("[level-helper] Previous playlist missing segments skipped in delta playlist"); for (let f = e.skippedSegments; f--;)a.shift(); e.startSN = a[0].sn } else { e.canSkipDateRanges && (e.dateRanges = aP(n.dateRanges, e, t)); const f = n.fragments.filter(h => h.rawProgramDateTime); if (n.hasProgramDateTime && !e.hasProgramDateTime) for (let h = 1; h < o.length; h++)o[h].programDateTime === null && Th(o[h], o[h - 1], f); Zb(f, e) } e.endCC = a[a.length - 1].cc } if (!e.startCC) { var c; const f = rw(n, e.startSN - 1); e.startCC = (c = f?.cc) != null ? c : a[0].cc } oP(n.partList, e.partList, (f, h) => { h.elementaryStreams = f.elementaryStreams, h.stats = f.stats }), i ? Jb(e, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS, t) : ew(n, e), a.length && (e.totalduration = e.edge - a[0].start), e.driftStartTime = n.driftStartTime, e.driftStart = n.driftStart; const u = e.advancedDateTime; if (e.advanced && u) { const f = e.edge; e.driftStart || (e.driftStartTime = u, e.driftStart = f), e.driftEndTime = u, e.driftEnd = f } else e.driftEndTime = n.driftEndTime, e.driftEnd = n.driftEnd, e.advancedDateTime = n.advancedDateTime; e.requestScheduled === -1 && (e.requestScheduled = n.requestScheduled) } function aP(n, e, t) { const { dateRanges: r, recentlyRemovedDateranges: s } = e, i = nt({}, n); s && s.forEach(c => { delete i[c] }); const o = Object.keys(i).length; return o ? (Object.keys(r).forEach(c => { const u = i[c], f = new Yb(r[c].attr, u); f.isValid ? (i[c] = f, u || (f.tagOrder += o)) : t.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${it(r[c].attr)}"`) }), i) : r } function oP(n, e, t) { if (n && e) { let r = 0; for (let s = 0, i = n.length; s <= i; s++) { const a = n[s], o = e[s + r]; a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? t(a, o) : r-- } } } function lP(n, e, t) { const r = e.skippedSegments, s = Math.max(n.startSN, e.startSN) - e.startSN, i = (n.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(n.endSN, e.endSN)) - e.startSN, a = e.startSN - n.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, c = n.fragmentHint ? n.fragments.concat(n.fragmentHint) : n.fragments; for (let u = s; u <= i; u++) { const f = c[a + u]; let h = o[u]; if (r && !h && f && (h = e.fragments[u] = f), f && h) { t(f, h, u, o); const p = f.relurl, v = h.relurl; if (p && cP(p, v)) { e.playlistParsingError = Dv(`media sequence mismatch ${h.sn}:`, n, e, f, h); return } else if (f.cc !== h.cc) { e.playlistParsingError = Dv(`discontinuity sequence mismatch (${f.cc}!=${h.cc})`, n, e, f, h); return } } } } function Dv(n, e, t, r, s) {
    return new Error(`${n} ${s.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${t.startSN}
${t.m3u8}`)
  } function ew(n, e, t = !0) { const r = e.startSN + e.skippedSegments - n.startSN, s = n.fragments, i = r >= 0; let a = 0; if (i && r < s.length) a = s[r].start; else if (i && e.startSN === n.endSN + 1) a = n.fragmentEnd; else if (i && t) a = n.fragmentStart + r * e.levelTargetDuration; else if (!e.skippedSegments && e.fragmentStart === 0) a = n.fragmentStart; else return; Ah(e, a) } function Ah(n, e) { if (e) { const t = n.fragments; for (let r = n.skippedSegments; r < t.length; r++)t[r].addStart(e); n.fragmentHint && n.fragmentHint.addStart(e) } } function tw(n, e = 1 / 0) { let t = 1e3 * n.targetduration; if (n.updated) { const r = n.fragments; if (r.length && t * 4 > e) { const i = r[r.length - 1].duration * 1e3; i < t && (t = i) } } else t /= 2; return Math.round(t) } function rw(n, e, t) { if (!n) return null; let r = n.fragments[e - n.startSN]; return r || (r = n.fragmentHint, r && r.sn === e) ? r : e < n.startSN && t && t.sn === e ? t : null } function Ov(n, e, t) { return n ? nw(n.partList, e, t) : null } function nw(n, e, t) { if (n) for (let r = n.length; r--;) { const s = n[r]; if (s.index === t && s.fragment.sn === e) return s } return null } function sw(n) { n.forEach((e, t) => { var r; (r = e.details) == null || r.fragments.forEach(s => { s.level = t, s.initSegment && (s.initSegment.level = t) }) }) } function cP(n, e) { return n !== e && e ? Mv(n) !== Mv(e) : !1 } function Mv(n) { return n.replace(/\?[^?]*$/, "") } function Ga(n, e) { for (let r = 0, s = n.length; r < s; r++) { var t; if (((t = n[r]) == null ? void 0 : t.cc) === e) return n[r] } return null } function uP(n, e) { return !!(n && e.startCC < n.endCC && e.endCC > n.startCC) } function jv(n, e) { const t = n.start + e; n.startPTS = t, n.setStart(t), n.endPTS = t + n.duration } function iw(n, e) { const t = e.fragments; for (let r = 0, s = t.length; r < s; r++)jv(t[r], n); e.fragmentHint && jv(e.fragmentHint, n), e.alignedSliding = !0 } function dP(n, e) { n && (aw(e, n), e.alignedSliding || kc(e, n), !e.alignedSliding && !e.skippedSegments && ew(n, e, !1)) } function aw(n, e) { if (!uP(e, n)) return; const t = Math.min(e.endCC, n.endCC), r = Ga(e.fragments, t), s = Ga(n.fragments, t); if (!r || !s) return; tt.log(`Aligning playlist at start of dicontinuity sequence ${t}`); const i = r.start - s.start; iw(i, n) } function kc(n, e) { if (!n.hasProgramDateTime || !e.hasProgramDateTime) return; const t = n.fragments, r = e.fragments; if (!t.length || !r.length) return; let s, i; const a = Math.min(e.endCC, n.endCC); e.startCC < a && n.startCC < a && (s = Ga(r, a), i = Ga(t, a)), (!s || !i) && (s = r[Math.floor(r.length / 2)], i = Ga(t, s.cc) || t[Math.floor(t.length / 2)]); const o = s.programDateTime, c = i.programDateTime; if (!o || !c) return; const u = (c - o) / 1e3 - (i.start - s.start); iw(u, n) } function Yt(n, e, t) { lr(n, e, t), n.addEventListener(e, t) } function lr(n, e, t) { n.removeEventListener(e, t) } const fP = { toString: function (n) { let e = ""; const t = n.length; for (let r = 0; r < t; r++)e += `[${n.start(r).toFixed(3)}-${n.end(r).toFixed(3)}]`; return e } }, se = { STOPPED: "STOPPED", IDLE: "IDLE", KEY_LOADING: "KEY_LOADING", FRAG_LOADING: "FRAG_LOADING", FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY", WAITING_TRACK: "WAITING_TRACK", PARSING: "PARSING", PARSED: "PARSED", ENDED: "ENDED", ERROR: "ERROR", WAITING_INIT_PTS: "WAITING_INIT_PTS", WAITING_LEVEL: "WAITING_LEVEL" }; class Sp extends Kb { constructor(e, t, r, s, i) { super(s, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = se.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () => { const { config: a, fragCurrent: o, media: c, mediaBuffer: u, state: f } = this, h = c ? c.currentTime : 0, p = Me.bufferInfo(u || c, h, a.maxBufferHole), v = !p.len; if (this.log(`Media seeking to ${ge(h) ? h.toFixed(3) : h}, state: ${f}, ${v ? "out of" : "in"} buffer`), this.state === se.ENDED) this.resetLoadingState(); else if (o) { const g = a.maxFragLookUpTolerance, y = o.start - g, w = o.start + o.duration + g; if (v || w < p.start || y > p.end) { const T = h > w; (h < y || T) && (T && o.loader && (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`), o.abortRequests(), this.resetLoadingState()), this.fragPrevious = null) } } if (c) { this.fragmentTracker.removeFragmentsInRange(h, 1 / 0, this.playlistType, !0); const g = this.lastCurrentTime; if (h > g && (this.lastCurrentTime = h), !this.loadingParts) { const y = Math.max(p.end, h), w = this.shouldLoadParts(this.getLevelDetails(), y); w && (this.log(`LL-Part loading ON after seeking to ${h.toFixed(2)} with buffer @${y.toFixed(2)}`), this.loadingParts = w) } } this.hls.hasEnoughToStart || (this.log(`Setting ${v ? "startPosition" : "nextLoadPosition"} to ${h} for seek without enough to start`), this.nextLoadPosition = h, v && (this.startPosition = h)), v && this.state === se.IDLE && this.tickImmediate() }, this.onMediaEnded = () => { this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0 }, this.playlistType = i, this.hls = e, this.fragmentLoader = new $_(e.config), this.keyLoader = r, this.fragmentTracker = t, this.config = e.config, this.decrypter = new xp(e.config) } registerListeners() { const { hls: e } = this; e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(k.ERROR, this.onError, this) } unregisterListeners() { const { hls: e } = this; e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(k.ERROR, this.onError, this) } doTick() { this.onTickEnd() } onTickEnd() { } startLoad(e) { } stopLoad() { if (this.state === se.STOPPED) return; this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType); const e = this.fragCurrent; e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = se.STOPPED } get startPositionValue() { const { nextLoadPosition: e, startPosition: t } = this; return t === -1 && e ? e : t } get bufferingEnabled() { return this.buffering } pauseBuffering() { this.buffering = !1 } resumeBuffering() { this.buffering = !0 } get inFlightFrag() { return { frag: this.fragCurrent, state: this.state } } _streamEnded(e, t) { if (t.live || !this.media) return !1; const r = e.end || 0, s = this.config.timelineOffset || 0; if (r <= s) return !1; const i = e.buffered; this.config.maxBufferHole && i && i.length > 1 && (e = Me.bufferedInfo(i, e.start, 0)); const a = e.nextStart; if (a && a > s && a < t.edge || this.media.currentTime < e.start) return !1; const c = t.partList; if (c != null && c.length) { const f = c[c.length - 1]; return Me.isBuffered(this.media, f.start + f.duration / 2) } const u = t.fragments[t.fragments.length - 1].type; return this.fragmentTracker.isEndListAppended(u) } getLevelDetails() { if (this.levels && this.levelLastLoaded !== null) return this.levelLastLoaded.details } get timelineOffset() { const e = this.config.timelineOffset; if (e) { var t; return ((t = this.getLevelDetails()) == null ? void 0 : t.appliedTimelineOffset) || e } return 0 } onMediaAttached(e, t) { const r = this.media = this.mediaBuffer = t.media; Yt(r, "seeking", this.onMediaSeeking), Yt(r, "ended", this.onMediaEnded); const s = this.config; this.levels && s.autoStartLoad && this.state === se.STOPPED && this.startLoad(s.startPosition) } onMediaDetaching(e, t) { const r = !!t.transferMedia, s = this.media; if (s !== null) { if (s.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), lr(s, "seeking", this.onMediaSeeking), lr(s, "ended", this.onMediaEnded), this.keyLoader && !r && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, r) { this.resetLoadingState(), this.resetTransmuxer(); return } this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad() } } onManifestLoading() { this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1 } onError(e, t) { } onManifestLoaded(e, t) { this.startTimeOffset = t.startTimeOffset } onHandlerDestroying() { this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null } onHandlerDestroyed() { this.state = se.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed() } loadFragment(e, t, r) { this.startFragRequested = !0, this._loadFragForPlayback(e, t, r) } _loadFragForPlayback(e, t, r) { const s = i => { const a = i.frag; if (this.fragContextChanged(a)) { this.warn(`${a.type} sn: ${a.sn}${i.part ? " part: " + i.part.index : ""} of ${this.fragInfo(a, !1, i.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(a); return } a.stats.chunkCount++, this._handleFragmentLoadProgress(i) }; this._doFragLoad(e, t, r, s).then(i => { if (!i) return; const a = this.state, o = i.frag; if (this.fragContextChanged(o)) { (a === se.FRAG_LOADING || !this.fragCurrent && a === se.PARSING) && (this.fragmentTracker.removeFragment(o), this.state = se.IDLE); return } "payload" in i && (this.log(`Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`), this.hls.trigger(k.FRAG_LOADED, i)), this._handleFragmentLoadComplete(i) }).catch(i => { this.state === se.STOPPED || this.state === se.ERROR || (this.warn(`Frag error: ${i?.message || i}`), this.resetFragmentLoading(e)) }) } clearTrackerIfNeeded(e) { var t; const { fragmentTracker: r } = this; if (r.getState(e) === Rt.APPENDING) { const i = e.type, a = this.getFwdBufferInfo(this.mediaBuffer, i), o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength), c = this.backtrackFragment; ((c ? e.sn - c.sn : 0) === 1 || this.reduceMaxBufferLength(o, e.duration)) && r.removeFragment(e) } else ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }), r.getState(e) === Rt.PARTIAL && r.removeFragment(e)) } checkLiveUpdate(e) { if (e.updated && !e.live) { const t = e.fragments[e.fragments.length - 1]; this.fragmentTracker.detectPartialFragments({ frag: t, part: null, stats: t.stats, id: t.type }) } e.fragments[0] || (e.deltaUpdateFailed = !0) } waitForLive(e) { const t = e.details; return t?.live && t.type !== "EVENT" && (this.levelLastLoaded !== e || t.expired) } flushMainBuffer(e, t, r = null) { if (!(e - t)) return; const s = { startOffset: e, endOffset: t, type: r }; this.hls.trigger(k.BUFFER_FLUSHING, s) } _loadInitSegment(e, t) { this._doFragLoad(e, t).then(r => { const s = r?.frag; if (!s || this.fragContextChanged(s) || !this.levels) throw new Error("init load aborted"); return r }).then(r => { const { hls: s } = this, { frag: i, payload: a } = r, o = i.decryptdata; if (a && a.byteLength > 0 && o != null && o.key && o.iv && Di(o.method)) { const c = self.performance.now(); return this.decrypter.decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, bp(o.method)).catch(u => { throw s.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_DECRYPT_ERROR, fatal: !1, error: u, reason: u.message, frag: i }), u }).then(u => { const f = self.performance.now(); return s.trigger(k.FRAG_DECRYPTED, { frag: i, payload: u, stats: { tstart: c, tdecrypt: f } }), r.payload = u, this.completeInitSegmentLoad(r) }) } return this.completeInitSegmentLoad(r) }).catch(r => { this.state === se.STOPPED || this.state === se.ERROR || (this.warn(r), this.resetFragmentLoading(e)) }) } completeInitSegmentLoad(e) { const { levels: t } = this; if (!t) throw new Error("init load aborted, missing levels"); const r = e.frag.stats; this.state !== se.STOPPED && (this.state = se.IDLE), e.frag.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), this.tick() } unhandledEncryptionError(e, t) { var r, s; const i = e.tracks; if (i && !t.encrypted && ((r = i.audio) != null && r.encrypted || (s = i.video) != null && s.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) { const a = this.media, o = new Error(`Encrypted track with no key in ${this.fragInfo(t)} (media ${a ? "attached mediaKeys: " + a.mediaKeys : "detached"})`); return this.warn(o.message), !a || a.mediaKeys ? !1 : (this.hls.trigger(k.ERROR, { type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_NO_KEYS, fatal: !1, error: o, frag: t }), this.resetTransmuxer(), !0) } return !1 } fragContextChanged(e) { const { fragCurrent: t } = this; return !e || !t || e.sn !== t.sn || e.level !== t.level } fragBufferedComplete(e, t) { const r = this.mediaBuffer ? this.mediaBuffer : this.media; if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)} > buffer:${r ? fP.toString(Me.getBuffered(r)) : "(detached)"})`), At(e)) { var s; if (e.type !== ve.SUBTITLE) { const a = e.elementaryStreams; if (!Object.keys(a).some(o => !!a[o])) { this.state = se.IDLE; return } } const i = (s = this.levels) == null ? void 0 : s[e.level]; i != null && i.fragmentError && (this.log(`Resetting level fragment error count of ${i.fragmentError} on frag buffered`), i.fragmentError = 0) } this.state = se.IDLE } _handleFragmentLoadComplete(e) { const { transmuxer: t } = this; if (!t) return; const { frag: r, part: s, partsLoaded: i } = e, a = !i || i.length === 0 || i.some(c => !c), o = new vp(r.level, r.sn, r.stats.chunkCount + 1, 0, s ? s.index : -1, !a); t.flush(o) } _handleFragmentLoadProgress(e) { } _doFragLoad(e, t, r = null, s) { var i; this.fragCurrent = e; const a = t.details; if (!this.levels || !a) throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`); let o = null; if (e.encrypted && !((i = e.decryptdata) != null && i.key)) { if (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = se.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then(p => { if (!this.fragContextChanged(p.frag)) return this.hls.trigger(k.KEY_LOADED, p), this.state === se.KEY_LOADING && (this.state = se.IDLE), p }), this.hls.trigger(k.KEY_LOADING, { frag: e }), this.fragCurrent === null) return this.log("context changed in KEY_LOADING"), Promise.resolve(null) } else e.encrypted || (o = this.keyLoader.loadClear(e, a.encryptedFragments, this.startFragRequested), o && this.log("[eme] blocking frag load until media-keys acquired")); const c = this.fragPrevious; if (At(e) && (!c || e.sn !== c.sn)) { const p = this.shouldLoadParts(t.details, e.end); p !== this.loadingParts && (this.log(`LL-Part loading ${p ? "ON" : "OFF"} loading sn ${c?.sn}->${e.sn}`), this.loadingParts = p) } if (r = Math.max(e.start, r || 0), this.loadingParts && At(e)) { const p = a.partList; if (p && s) { r > a.fragmentEnd && a.fragmentHint && (e = a.fragmentHint); const v = this.getNextPart(p, e, r); if (v > -1) { const g = p[v]; e = this.fragCurrent = g.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${g.index} (${v}/${p.length - 1}) of ${this.fragInfo(e, !1, g)}) cc: ${e.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = g.start + g.duration, this.state = se.FRAG_LOADING; let y; return o ? y = o.then(w => !w || this.fragContextChanged(w.frag) ? null : this.doFragPartsLoad(e, g, t, s)).catch(w => this.handleFragLoadError(w)) : y = this.doFragPartsLoad(e, g, t, s).catch(w => this.handleFragLoadError(w)), this.hls.trigger(k.FRAG_LOADING, { frag: e, part: g, targetBufferTime: r }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : y } else if (!e.url || this.loadedEndOfParts(p, r)) return Promise.resolve(null) } } if (At(e) && this.loadingParts) { var u; this.log(`LL-Part loading OFF after next part miss @${r.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(u = a.partList) == null ? void 0 : u.filter(p => p.loaded).map(p => `[${p.start}-${p.end}]`)}`), this.loadingParts = !1 } else if (!e.url) return Promise.resolve(null); this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${"[" + a.startSN + "-" + a.endSN + "]"}, target: ${parseFloat(r.toFixed(3))}`), ge(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = se.FRAG_LOADING; const f = this.config.progressive; let h; return f && o ? h = o.then(p => !p || this.fragContextChanged(p.frag) ? null : this.fragmentLoader.load(e, s)).catch(p => this.handleFragLoadError(p)) : h = Promise.all([this.fragmentLoader.load(e, f ? s : void 0), o]).then(([p]) => (!f && s && s(p), p)).catch(p => this.handleFragLoadError(p)), this.hls.trigger(k.FRAG_LOADING, { frag: e, targetBufferTime: r }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : h } doFragPartsLoad(e, t, r, s) { return new Promise((i, a) => { var o; const c = [], u = (o = r.details) == null ? void 0 : o.partList, f = h => { this.fragmentLoader.loadPart(e, h, s).then(p => { c[h.index] = p; const v = p.part; this.hls.trigger(k.FRAG_LOADED, p); const g = Ov(r.details, e.sn, h.index + 1) || nw(u, e.sn, h.index + 1); if (g) f(g); else return i({ frag: e, part: v, partsLoaded: c }) }).catch(a) }; f(t) }) } handleFragLoadError(e) { if ("data" in e) { const t = e.data; t.frag && t.details === J.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : t.frag && t.type === Ee.KEY_SYSTEM_ERROR ? (t.frag.abortRequests(), this.resetStartWhenNotLoaded(), this.resetFragmentLoading(t.frag)) : this.hls.trigger(k.ERROR, t) } else this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.INTERNAL_EXCEPTION, err: e, error: e, fatal: !0 }); return null } _handleTransmuxerFlush(e) { const t = this.getCurrentContext(e); if (!t || this.state !== se.PARSING) { !this.fragCurrent && this.state !== se.STOPPED && this.state !== se.ERROR && (this.state = se.IDLE); return } const { frag: r, part: s, level: i } = t, a = self.performance.now(); r.stats.parsing.end = a, s && (s.stats.parsing.end = a); const o = this.getLevelDetails(), u = o && r.sn > o.endSN || this.shouldLoadParts(o, r.end); u !== this.loadingParts && (this.log(`LL-Part loading ${u ? "ON" : "OFF"} after parsing segment ending @${r.end.toFixed(2)}`), this.loadingParts = u), this.updateLevelTiming(r, s, i, e.partial) } shouldLoadParts(e, t) { if (this.config.lowLatencyMode) { if (!e) return this.loadingParts; if (e.partList) { var r; const i = e.partList[0]; if (i.fragment.type === ve.SUBTITLE) return !1; const a = i.end + (((r = e.fragmentHint) == null ? void 0 : r.duration) || 0); if (t >= a) { var s; if ((this.hls.hasEnoughToStart ? ((s = this.media) == null ? void 0 : s.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > i.start - i.fragment.duration) return !0 } } } return !1 } getCurrentContext(e) { const { levels: t, fragCurrent: r } = this, { level: s, sn: i, part: a } = e; if (!(t != null && t[s])) return this.warn(`Levels object was unset while buffering fragment ${i} of ${this.playlistLabel()} ${s}. The current chunk will not be buffered.`), null; const o = t[s], c = o.details, u = a > -1 ? Ov(c, i, a) : null, f = u ? u.fragment : rw(c, i, r); return f ? (r && r !== f && (f.stats = r.stats), { frag: f, part: u, level: o }) : null } bufferFragmentData(e, t, r, s, i) { if (this.state !== se.PARSING) return; const { data1: a, data2: o } = e; let c = a; if (o && (c = Rr(a, o)), !c.length) return; const u = this.initPTS[t.cc], f = u ? -u.baseTime / u.timescale : void 0, h = { type: e.type, frag: t, part: r, chunkMeta: s, offset: f, parent: t.type, data: c }; if (this.hls.trigger(k.BUFFER_APPENDING, h), e.dropped && e.independent && !r) { if (i) return; this.flushBufferGap(t) } } flushBufferGap(e) { const t = this.media; if (!t) return; if (!Me.isBuffered(t, t.currentTime)) { this.flushMainBuffer(0, e.start); return } const r = t.currentTime, s = Me.bufferInfo(t, r, 0), i = e.duration, a = Math.min(this.config.maxFragLookUpTolerance * 2, i * .25), o = Math.max(Math.min(e.start - a, s.end - a), r + a); e.start - o > a && this.flushMainBuffer(o, e.start) } getFwdBufferInfo(e, t) { var r; const s = this.getLoadPosition(); if (!ge(s)) return null; const a = this.lastCurrentTime > s || (r = this.media) != null && r.paused ? 0 : this.config.maxBufferHole; return this.getFwdBufferInfoAtPos(e, s, t, a) } getFwdBufferInfoAtPos(e, t, r, s) { const i = Me.bufferInfo(e, t, s); if (i.len === 0 && i.nextStart !== void 0) { const a = this.fragmentTracker.getBufferedFrag(t, r); if (a && (i.nextStart <= a.end || a.gap)) { const o = Math.max(Math.min(i.nextStart, a.end) - t, s); return Me.bufferInfo(e, t, o) } } return i } getMaxBufferLength(e) { const { config: t } = this; let r; return e ? r = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : r = t.maxBufferLength, Math.min(r, t.maxMaxBufferLength) } reduceMaxBufferLength(e, t) { const r = this.config, s = Math.max(Math.min(e - t, r.maxBufferLength), t), i = Math.max(e - t * 3, r.maxMaxBufferLength / 2, s); return i >= s ? (r.maxMaxBufferLength = i, this.warn(`Reduce max buffer length to ${i}s`), !0) : !1 } getAppendedFrag(e, t = ve.MAIN) { const r = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, t) : null; return r && "fragment" in r ? r.fragment : r } getNextFragment(e, t) { const r = t.fragments, s = r.length; if (!s) return null; const { config: i } = this, a = r[0].start, o = i.lowLatencyMode && !!t.partList; let c = null; if (t.live) { const h = i.initialLiveManifestSize; if (s < h) return this.warn(`Not enough fragments to start playback (have: ${s}, need: ${h})`), null; if (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < a) { var u; o && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), c = this.getInitialLiveFragment(t); const p = this.hls.startPosition, v = this.hls.liveSyncPosition, g = c ? (p !== -1 && p >= a ? p : v) || c.start : e; this.log(`Setting startPosition to ${g} to match start frag at live edge. mainStart: ${p} liveSyncPosition: ${v} frag.start: ${(u = c) == null ? void 0 : u.start}`), this.startPosition = this.nextLoadPosition = g } } else e <= a && (c = r[0]); if (!c) { const h = this.loadingParts ? t.partEnd : t.fragmentEnd; c = this.getFragmentAtPosition(e, h, t) } let f = this.filterReplacedPrimary(c, t); if (!f && c) { const h = c.sn - t.startSN; f = this.filterReplacedPrimary(r[h + 1] || null, t) } return this.mapToInitFragWhenRequired(f) } isLoopLoading(e, t) { const r = this.fragmentTracker.getState(e); return (r === Rt.OK || r === Rt.PARTIAL && !!e.gap) && this.nextLoadPosition > t } getNextFragmentLoopLoading(e, t, r, s, i) { let a = null; if (e.gap && (a = this.getNextFragment(this.nextLoadPosition, t), a && !a.gap && r.nextStart)) { const o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, s, 0); if (o !== null && r.len + o.len >= i) { const c = a.sn; return this.loopSn !== c && (this.log(`buffer full after gaps in "${s}" playlist starting at sn: ${c}`), this.loopSn = c), null } } return this.loopSn = void 0, a } get primaryPrefetch() { if (Fv(this.config)) { var e; if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event) return !0 } return !1 } filterReplacedPrimary(e, t) { if (!e) return e; if (Fv(this.config) && e.type !== ve.SUBTITLE) { const r = this.hls.interstitialsManager, s = r?.bufferingItem; if (s) { const a = s.event; if (a) { if (a.appendInPlace || Math.abs(e.start - s.start) > 1 || s.start === 0) return null } else if (e.end <= s.start && t?.live === !1 || e.start > s.end && s.nextEvent && (s.nextEvent.appendInPlace || e.start - s.end > 1)) return null } const i = r?.playerQueue; if (i) for (let a = i.length; a--;) { const o = i[a].interstitial; if (o.appendInPlace && e.start >= o.startTime && e.end <= o.resumeTime) return null } } return e } mapToInitFragWhenRequired(e) { return e != null && e.initSegment && !e.initSegment.data && !this.bitrateTest ? e.initSegment : e } getNextPart(e, t, r) { let s = -1, i = !1, a = !0; for (let o = 0, c = e.length; o < c; o++) { const u = e[o]; if (a = a && !u.independent, s > -1 && r < u.start) break; const f = u.loaded; f ? s = -1 : (i || (u.independent || a) && u.fragment === t) && (u.fragment !== t && this.warn(`Need buffer at ${r} but next unloaded part starts at ${u.start}`), s = o), i = f } return s } loadedEndOfParts(e, t) { let r; for (let s = e.length; s--;) { if (r = e[s], !r.loaded) return !1; if (t > r.start) return !0 } return !1 } getInitialLiveFragment(e) { const t = e.fragments, r = this.fragPrevious; let s = null; if (r) { if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), s = L_(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !s) { const i = r.sn + 1; if (i >= e.startSN && i <= e.endSN) { const a = t[i - e.startSN]; r.cc === a.cc && (s = a, this.log(`Live playlist, switching playlist, load frag with next SN: ${s.sn}`)) } s || (s = Gb(e, r.cc, r.end), s && this.log(`Live playlist, switching playlist, load frag with same CC: ${s.sn}`)) } } else { const i = this.hls.liveSyncPosition; i !== null && (s = this.getFragmentAtPosition(i, this.bitrateTest ? e.fragmentEnd : e.edge, e)) } return s } getFragmentAtPosition(e, t, r) { const { config: s } = this; let { fragPrevious: i } = this, { fragments: a, endSN: o } = r; const { fragmentHint: c } = r, { maxFragLookUpTolerance: u } = s, f = r.partList, h = !!(this.loadingParts && f != null && f.length && c); h && !this.bitrateTest && f[f.length - 1].fragment.sn === c.sn && (a = a.concat(c), o = c.sn); let p; if (e < t) { var v; const y = e < this.lastCurrentTime || e > t - u || (v = this.media) != null && v.paused || !this.startFragRequested ? 0 : u; p = Xs(i, a, e, y) } else p = a[a.length - 1]; if (p) { const g = p.sn - r.startSN, y = this.fragmentTracker.getState(p); if ((y === Rt.OK || y === Rt.PARTIAL && p.gap) && (i = p), i && p.sn === i.sn && (!h || f[0].fragment.sn > p.sn || !r.live) && p.level === i.level) { const T = a[g + 1]; p.sn < o && this.fragmentTracker.getState(T) !== Rt.OK ? p = T : p = null } } return p } alignPlaylists(e, t, r) { const s = e.fragments.length; if (!s) return this.warn("No fragments in live playlist"), 0; const i = e.fragmentStart, a = !t, o = e.alignedSliding && ge(i); if (a || !o && !i) { dP(r, e); const c = e.fragmentStart; return this.log(`Live playlist sliding: ${c.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} fragments: ${s}`), c } return i } waitForCdnTuneIn(e) { return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3) } setStartPosition(e, t) { let r = this.startPosition; r < t && (r = -1); const s = this.timelineOffset; if (r === -1) { const i = this.startTimeOffset !== null, a = i ? this.startTimeOffset : e.startTimeOffset; a !== null && ge(a) ? (r = t + a, a < 0 && (r += e.edge), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(`Setting startPosition to ${r} for start time offset ${a} found in ${i ? "multivariant" : "media"} playlist`), this.startPosition = r) : e.live ? (r = this.hls.liveSyncPosition || t, this.log(`Setting startPosition to -1 to start at live edge ${r}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = r = 0), this.lastCurrentTime = r + s } this.nextLoadPosition = r + s } getLoadPosition() { var e; const { media: t } = this; let r = 0; return (e = this.hls) != null && e.hasEnoughToStart && t ? r = t.currentTime : this.nextLoadPosition >= 0 && (r = this.nextLoadPosition), r } handleFragLoadAborted(e, t) { this.transmuxer && e.type === this.playlistType && At(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${t ? " part " + t.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e)) } resetFragmentLoading(e) { (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== se.FRAG_LOADING_WAITING_RETRY) && (this.state = se.IDLE) } onFragmentOrKeyLoadError(e, t) { var r; if (t.chunkMeta && !t.frag) { const T = this.getCurrentContext(t.chunkMeta); T && (t.frag = T.frag) } const s = t.frag; if (!s || s.type !== e || !this.levels) return; if (this.fragContextChanged(s)) { var i; this.warn(`Frag load error must match current frag to retry ${s.url} > ${(i = this.fragCurrent) == null ? void 0 : i.url}`); return } const a = t.details === J.FRAG_GAP; a && this.fragmentTracker.fragBuffered(s, !0); const o = t.errorAction; if (!o) { this.state = se.ERROR; return } const { action: c, flags: u, retryCount: f = 0, retryConfig: h } = o, p = !!h, v = p && c === $t.RetryRequest, g = p && !o.resolved && u === vr.MoveAllAlternatesMatchingHost, y = (r = this.hls.latestLevelDetails) == null ? void 0 : r.live; if (!v && g && At(s) && !s.endList && y && !Wb(t)) this.resetFragmentErrors(e), this.treatAsGap(s), o.resolved = !0; else if ((v || g) && f < h.maxNumRetry) { var w; const T = wh((w = t.response) == null ? void 0 : w.code), S = gp(h, f); if (this.resetStartWhenNotLoaded(), this.retryDate = self.performance.now() + S, this.state = se.FRAG_LOADING_WAITING_RETRY, o.resolved = !0, T) { this.log("Waiting for connection (offline)"), this.retryDate = 1 / 0, t.reason = "offline"; return } this.warn(`Fragment ${s.sn} of ${e} ${s.level} errored with ${t.details}, retrying loading ${f + 1}/${h.maxNumRetry} in ${S}ms`) } else if (h) if (this.resetFragmentErrors(e), f < h.maxNumRetry) !a && c !== $t.RemoveAlternatePermanently && (o.resolved = !0); else { this.warn(`${t.details} reached or exceeded max retry (${f})`); return } else c === $t.SendAlternateToPenaltyBox ? this.state = se.WAITING_LEVEL : this.state = se.ERROR; this.tickImmediate() } checkRetryDate() { const e = self.performance.now(), t = this.retryDate, r = t === 1 / 0; (!t || e >= t || r && !wh(0)) && (r && this.log("Connection restored (online)"), this.resetStartWhenNotLoaded(), this.state = se.IDLE) } reduceLengthAndFlushBuffer(e) { if (this.state === se.PARSING || this.state === se.PARSED) { const t = e.frag, r = e.parent, s = this.getFwdBufferInfo(this.mediaBuffer, r), i = s && s.len > .5; i && this.reduceMaxBufferLength(s.len, t?.duration || 10); const a = !i; return a && this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${r} buffer`), t && (this.fragmentTracker.removeFragment(t), this.nextLoadPosition = t.start), this.resetLoadingState(), a } return !1 } resetFragmentErrors(e) { e === ve.AUDIO && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== se.STOPPED && (this.state = se.IDLE) } afterBufferFlushed(e, t, r) { if (!e) return; const s = Me.getBuffered(e); this.fragmentTracker.detectEvictedFragments(t, s, r), this.state === se.ENDED && this.resetLoadingState() } resetLoadingState() { this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== se.STOPPED && (this.state = se.IDLE) } resetStartWhenNotLoaded() { if (!this.hls.hasEnoughToStart) { this.startFragRequested = !1; const e = this.levelLastLoaded, t = e ? e.details : null; t != null && t.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(t, t.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition } } resetWhenMissingContext(e) { this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? "<removed>" : e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(), this.resetLoadingState() } removeUnbufferedFrags(e = 0) { this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0) } updateLevelTiming(e, t, r, s) { const i = r.details; if (!i) { this.warn("level.details undefined"); return } if (!Object.keys(e.elementaryStreams).reduce((c, u) => { const f = e.elementaryStreams[u]; if (f) { const h = f.endPTS - f.startPTS; if (h <= 0) return this.warn(`Could not parse fragment ${e.sn} ${u} duration reliably (${h})`), c || !1; const p = s ? 0 : Jb(i, e, f.startPTS, f.endPTS, f.startDTS, f.endDTS, this); return this.hls.trigger(k.LEVEL_PTS_UPDATED, { details: i, level: r, drift: p, type: u, frag: e, start: f.startPTS, end: f.endPTS }), !0 } return c }, !1)) { var o; if (r.fragmentError === 0 && this.treatAsGap(e, r), ((o = this.transmuxer) == null ? void 0 : o.error) === null) { const c = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`); if (this.warn(c.message), this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_PARSING_ERROR, fatal: !1, error: c, frag: e, reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${r.url}"` }), !this.hls) return; this.resetTransmuxer() } } this.state = se.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)})`), this.hls.trigger(k.FRAG_PARSED, { frag: e, part: t }) } playlistLabel() { return this.playlistType === ve.MAIN ? "level" : "track" } fragInfo(e, t = !0, r) { var s, i; return `${this.playlistLabel()} ${e.level} (${r ? "part" : "frag"}:[${((s = t && !r ? e.startPTS : (r || e).start) != null ? s : NaN).toFixed(3)}-${((i = t && !r ? e.endPTS : (r || e).end) != null ? i : NaN).toFixed(3)}]${r && e.type === "main" ? "INDEPENDENT=" + (r.independent ? "YES" : "NO") : ""}` } treatAsGap(e, t) { t && t.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0) } resetTransmuxer() { var e; (e = this.transmuxer) == null || e.reset() } recoverWorkerError(e) { e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(), this.resetLoadingState()) } set state(e) { const t = this._state; t !== e && (this._state = e, this.log(`${t}->${e}`)) } get state() { return this._state } } function Fv(n) { return !!n.interstitialsController && n.enableInterstitialPlayback !== !1 } class ow { constructor() { this.chunks = [], this.dataLength = 0 } push(e) { this.chunks.push(e), this.dataLength += e.length } flush() { const { chunks: e, dataLength: t } = this; let r; if (e.length) e.length === 1 ? r = e[0] : r = hP(e, t); else return new Uint8Array(0); return this.reset(), r } reset() { this.chunks.length = 0, this.dataLength = 0 } } function hP(n, e) { const t = new Uint8Array(e); let r = 0; for (let s = 0; s < n.length; s++) { const i = n[s]; t.set(i, r), r += i.length } return t } var xf = { exports: {} }, $v; function pP() { return $v || ($v = 1, (function (n) { var e = Object.prototype.hasOwnProperty, t = "~"; function r() { } Object.create && (r.prototype = Object.create(null), new r().__proto__ || (t = !1)); function s(c, u, f) { this.fn = c, this.context = u, this.once = f || !1 } function i(c, u, f, h, p) { if (typeof f != "function") throw new TypeError("The listener must be a function"); var v = new s(f, h || c, p), g = t ? t + u : u; return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], v] : c._events[g].push(v) : (c._events[g] = v, c._eventsCount++), c } function a(c, u) { --c._eventsCount === 0 ? c._events = new r : delete c._events[u] } function o() { this._events = new r, this._eventsCount = 0 } o.prototype.eventNames = function () { var u = [], f, h; if (this._eventsCount === 0) return u; for (h in f = this._events) e.call(f, h) && u.push(t ? h.slice(1) : h); return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u }, o.prototype.listeners = function (u) { var f = t ? t + u : u, h = this._events[f]; if (!h) return []; if (h.fn) return [h.fn]; for (var p = 0, v = h.length, g = new Array(v); p < v; p++)g[p] = h[p].fn; return g }, o.prototype.listenerCount = function (u) { var f = t ? t + u : u, h = this._events[f]; return h ? h.fn ? 1 : h.length : 0 }, o.prototype.emit = function (u, f, h, p, v, g) { var y = t ? t + u : u; if (!this._events[y]) return !1; var w = this._events[y], T = arguments.length, S, E; if (w.fn) { switch (w.once && this.removeListener(u, w.fn, void 0, !0), T) { case 1: return w.fn.call(w.context), !0; case 2: return w.fn.call(w.context, f), !0; case 3: return w.fn.call(w.context, f, h), !0; case 4: return w.fn.call(w.context, f, h, p), !0; case 5: return w.fn.call(w.context, f, h, p, v), !0; case 6: return w.fn.call(w.context, f, h, p, v, g), !0 }for (E = 1, S = new Array(T - 1); E < T; E++)S[E - 1] = arguments[E]; w.fn.apply(w.context, S) } else { var I = w.length, C; for (E = 0; E < I; E++)switch (w[E].once && this.removeListener(u, w[E].fn, void 0, !0), T) { case 1: w[E].fn.call(w[E].context); break; case 2: w[E].fn.call(w[E].context, f); break; case 3: w[E].fn.call(w[E].context, f, h); break; case 4: w[E].fn.call(w[E].context, f, h, p); break; default: if (!S) for (C = 1, S = new Array(T - 1); C < T; C++)S[C - 1] = arguments[C]; w[E].fn.apply(w[E].context, S) } } return !0 }, o.prototype.on = function (u, f, h) { return i(this, u, f, h, !1) }, o.prototype.once = function (u, f, h) { return i(this, u, f, h, !0) }, o.prototype.removeListener = function (u, f, h, p) { var v = t ? t + u : u; if (!this._events[v]) return this; if (!f) return a(this, v), this; var g = this._events[v]; if (g.fn) g.fn === f && (!p || g.once) && (!h || g.context === h) && a(this, v); else { for (var y = 0, w = [], T = g.length; y < T; y++)(g[y].fn !== f || p && !g[y].once || h && g[y].context !== h) && w.push(g[y]); w.length ? this._events[v] = w.length === 1 ? w[0] : w : a(this, v) } return this }, o.prototype.removeAllListeners = function (u) { var f; return u ? (f = t ? t + u : u, this._events[f] && a(this, f)) : (this._events = new r, this._eventsCount = 0), this }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, n.exports = o })(xf)), xf.exports } var mP = pP(), Ep = BR(mP); const ro = "1.6.12", Bi = {}; function gP() { return typeof __HLS_WORKER_BUNDLE__ == "function" } function xP() { const n = Bi[ro]; if (n) return n.clientCount++, n; const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], { type: "text/javascript" }), t = self.URL.createObjectURL(e), s = { worker: new self.Worker(t), objectURL: t, clientCount: 1 }; return Bi[ro] = s, s } function vP(n) { const e = Bi[n]; if (e) return e.clientCount++, e; const t = new self.URL(n, self.location.href).href, s = { worker: new self.Worker(t), scriptURL: t, clientCount: 1 }; return Bi[n] = s, s } function yP(n) { const e = Bi[n || ro]; if (e && e.clientCount-- === 1) { const { worker: r, objectURL: s } = e; delete Bi[n || ro], s && self.URL.revokeObjectURL(s), r.terminate() } } function lw(n, e) { return e + 10 <= n.length && n[e] === 51 && n[e + 1] === 68 && n[e + 2] === 73 && n[e + 3] < 255 && n[e + 4] < 255 && n[e + 6] < 128 && n[e + 7] < 128 && n[e + 8] < 128 && n[e + 9] < 128 } function Tp(n, e) { return e + 10 <= n.length && n[e] === 73 && n[e + 1] === 68 && n[e + 2] === 51 && n[e + 3] < 255 && n[e + 4] < 255 && n[e + 6] < 128 && n[e + 7] < 128 && n[e + 8] < 128 && n[e + 9] < 128 } function qc(n, e) { let t = 0; return t = (n[e] & 127) << 21, t |= (n[e + 1] & 127) << 14, t |= (n[e + 2] & 127) << 7, t |= n[e + 3] & 127, t } function no(n, e) { const t = e; let r = 0; for (; Tp(n, e);) { r += 10; const s = qc(n, e + 6); r += s, lw(n, e + 10) && (r += 10), e += r } if (r > 0) return n.subarray(t, t + r) } function bP(n, e, t, r) { const s = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], i = e[t + 2], a = i >> 2 & 15; if (a > 12) { const v = new Error(`invalid ADTS sampling index:${a}`); n.emit(k.ERROR, k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_PARSING_ERROR, fatal: !0, error: v, reason: v.message }); return } const o = (i >> 6 & 3) + 1, c = e[t + 3] >> 6 & 3 | (i & 1) << 2, u = "mp4a.40." + o, f = s[a]; let h = a; (o === 5 || o === 29) && (h -= 3); const p = [o << 3 | (h & 14) >> 1, (h & 1) << 7 | c << 3]; return tt.log(`manifest codec:${r}, parsed codec:${u}, channels:${c}, rate:${f} (ADTS object type:${o} sampling index:${a})`), { config: p, samplerate: f, channelCount: c, codec: u, parsedCodec: u, manifestCodec: r } } function cw(n, e) { return n[e] === 255 && (n[e + 1] & 246) === 240 } function uw(n, e) { return n[e + 1] & 1 ? 7 : 9 } function Ap(n, e) { return (n[e + 3] & 3) << 11 | n[e + 4] << 3 | (n[e + 5] & 224) >>> 5 } function wP(n, e) { return e + 5 < n.length } function Rc(n, e) { return e + 1 < n.length && cw(n, e) } function SP(n, e) { return wP(n, e) && cw(n, e) && Ap(n, e) <= n.length - e } function EP(n, e) { if (Rc(n, e)) { const t = uw(n, e); if (e + t >= n.length) return !1; const r = Ap(n, e); if (r <= t) return !1; const s = e + r; return s === n.length || Rc(n, s) } return !1 } function dw(n, e, t, r, s) { if (!n.samplerate) { const i = bP(e, t, r, s); if (!i) return; nt(n, i) } } function fw(n) { return 1024 * 9e4 / n } function TP(n, e) { const t = uw(n, e); if (e + t <= n.length) { const r = Ap(n, e) - t; if (r > 0) return { headerLength: t, frameLength: r } } } function hw(n, e, t, r, s) { const i = fw(n.samplerate), a = r + s * i, o = TP(e, t); let c; if (o) { const { frameLength: h, headerLength: p } = o, v = p + h, g = Math.max(0, t + v - e.length); g ? (c = new Uint8Array(v - p), c.set(e.subarray(t + p, e.length), 0)) : c = e.subarray(t + p, t + v); const y = { unit: c, pts: a }; return g || n.samples.push(y), { sample: y, length: v, missing: g } } const u = e.length - t; return c = new Uint8Array(u), c.set(e.subarray(t, e.length), 0), { sample: { unit: c, pts: a }, length: u, missing: -1 } } function AP(n, e) { return Tp(n, e) && qc(n, e + 6) + 10 <= n.length - e } function IP(n) { return n instanceof ArrayBuffer ? n : n.byteOffset == 0 && n.byteLength == n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer } function vf(n, e = 0, t = 1 / 0) { return LP(n, e, t, Uint8Array) } function LP(n, e, t, r) { const s = CP(n); let i = 1; "BYTES_PER_ELEMENT" in r && (i = r.BYTES_PER_ELEMENT); const a = kP(n) ? n.byteOffset : 0, o = (a + n.byteLength) / i, c = (a + e) / i, u = Math.floor(Math.max(0, Math.min(c, o))), f = Math.floor(Math.min(u + Math.max(t, 0), o)); return new r(s, u, f - u) } function CP(n) { return n instanceof ArrayBuffer ? n : n.buffer } function kP(n) { return n && n.buffer instanceof ArrayBuffer && n.byteLength !== void 0 && n.byteOffset !== void 0 } function RP(n) { const e = { key: n.type, description: "", data: "", mimeType: null, pictureType: null }, t = 3; if (n.size < 2) return; if (n.data[0] !== t) { console.log("Ignore frame with unrecognized character encoding"); return } const r = n.data.subarray(1).indexOf(0); if (r === -1) return; const s = wr(vf(n.data, 1, r)), i = n.data[2 + r], a = n.data.subarray(3 + r).indexOf(0); if (a === -1) return; const o = wr(vf(n.data, 3 + r, a)); let c; return s === "-->" ? c = wr(vf(n.data, 4 + r + a)) : c = IP(n.data.subarray(4 + r + a)), e.mimeType = s, e.pictureType = i, e.description = o, e.data = c, e } function _P(n) { if (n.size < 2) return; const e = wr(n.data, !0), t = new Uint8Array(n.data.subarray(e.length + 1)); return { key: n.type, info: e, data: t.buffer } } function PP(n) { if (n.size < 2) return; if (n.type === "TXXX") { let t = 1; const r = wr(n.data.subarray(t), !0); t += r.length + 1; const s = wr(n.data.subarray(t)); return { key: n.type, info: r, data: s } } const e = wr(n.data.subarray(1)); return { key: n.type, info: "", data: e } } function NP(n) { if (n.type === "WXXX") { if (n.size < 2) return; let t = 1; const r = wr(n.data.subarray(t), !0); t += r.length + 1; const s = wr(n.data.subarray(t)); return { key: n.type, info: r, data: s } } const e = wr(n.data); return { key: n.type, info: "", data: e } } function DP(n) { return n.type === "PRIV" ? _P(n) : n.type[0] === "W" ? NP(n) : n.type === "APIC" ? RP(n) : PP(n) } function OP(n) { const e = String.fromCharCode(n[0], n[1], n[2], n[3]), t = qc(n, 4), r = 10; return { type: e, size: t, data: n.subarray(r, r + t) } } const jl = 10, MP = 10; function pw(n) { let e = 0; const t = []; for (; Tp(n, e);) { const r = qc(n, e + 6); n[e + 5] >> 6 & 1 && (e += jl), e += jl; const s = e + r; for (; e + MP < s;) { const i = OP(n.subarray(e)), a = DP(i); a && t.push(a), e += i.size + jl } lw(n, e) && (e += jl) } return t } function mw(n) { return n && n.key === "PRIV" && n.info === "com.apple.streaming.transportStreamTimestamp" } function jP(n) { if (n.data.byteLength === 8) { const e = new Uint8Array(n.data), t = e[3] & 1; let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7]; return r /= 45, t && (r += 4772185884e-2), Math.round(r) } } function Ip(n) { const e = pw(n); for (let t = 0; t < e.length; t++) { const r = e[t]; if (mw(r)) return jP(r) } } let br = (function (n) { return n.audioId3 = "org.id3", n.dateRange = "com.apple.quicktime.HLS", n.emsg = "https://aomedia.org/emsg/ID3", n.misbklv = "urn:misb:KLV:bin:1910.1", n })({}); function sn(n = "", e = 9e4) { return { type: n, id: -1, pid: -1, inputTimeScale: e, sequenceNumber: -1, samples: [], dropped: 0 } } class Lp { constructor() { this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null } resetInitSegment(e, t, r, s) { this._id3Track = { type: "id3", id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 } } resetTimeStamp(e) { this.initPTS = e, this.resetContiguity() } resetContiguity() { this.basePTS = null, this.lastPTS = null, this.frameIndex = 0 } canParse(e, t) { return !1 } appendFrame(e, t, r) { } demux(e, t) { this.cachedData && (e = Rr(this.cachedData, e), this.cachedData = null); let r = no(e, 0), s = r ? r.length : 0, i; const a = this._audioTrack, o = this._id3Track, c = r ? Ip(r) : void 0, u = e.length; for ((this.basePTS === null || this.frameIndex === 0 && ge(c)) && (this.basePTS = FP(c, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), r && r.length > 0 && o.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: br.audioId3, duration: Number.POSITIVE_INFINITY }); s < u;) { if (this.canParse(e, s)) { const f = this.appendFrame(a, e, s); f ? (this.frameIndex++, this.lastPTS = f.sample.pts, s += f.length, i = s) : s = u } else AP(e, s) ? (r = no(e, s), o.samples.push({ pts: this.lastPTS, dts: this.lastPTS, data: r, type: br.audioId3, duration: Number.POSITIVE_INFINITY }), s += r.length, i = s) : s++; if (s === u && i !== u) { const f = e.slice(i); this.cachedData ? this.cachedData = Rr(this.cachedData, f) : this.cachedData = f } } return { audioTrack: a, videoTrack: sn(), id3Track: o, textTrack: sn() } } demuxSampleAes(e, t, r) { return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`)) } flush(e) { const t = this.cachedData; return t && (this.cachedData = null, this.demux(t, 0)), { audioTrack: this._audioTrack, videoTrack: sn(), id3Track: this._id3Track, textTrack: sn() } } destroy() { this.cachedData = null, this._audioTrack = this._id3Track = void 0 } } const FP = (n, e, t) => { if (ge(n)) return n * 90; const r = t ? t.baseTime * 9e4 / t.timescale : 0; return e * 9e4 + r }; let Fl = null; const $P = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], BP = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], UP = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], zP = [0, 1, 1, 4]; function gw(n, e, t, r, s) { if (t + 24 > e.length) return; const i = xw(e, t); if (i && t + i.frameLength <= e.length) { const a = i.samplesPerFrame * 9e4 / i.sampleRate, o = r + s * a, c = { unit: e.subarray(t, t + i.frameLength), pts: o, dts: o }; return n.config = [], n.channelCount = i.channelCount, n.samplerate = i.sampleRate, n.samples.push(c), { sample: c, length: i.frameLength, missing: 0 } } } function xw(n, e) { const t = n[e + 1] >> 3 & 3, r = n[e + 1] >> 1 & 3, s = n[e + 2] >> 4 & 15, i = n[e + 2] >> 2 & 3; if (t !== 1 && s !== 0 && s !== 15 && i !== 3) { const a = n[e + 2] >> 1 & 1, o = n[e + 3] >> 6, c = t === 3 ? 3 - r : r === 3 ? 3 : 4, u = $P[c * 14 + s - 1] * 1e3, h = BP[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + i], p = o === 3 ? 1 : 2, v = UP[t][r], g = zP[r], y = v * 8 * g, w = Math.floor(v * u / h + a) * g; if (Fl === null) { const E = (navigator.userAgent || "").match(/Chrome\/(\d+)/i); Fl = E ? parseInt(E[1]) : 0 } return !!Fl && Fl <= 87 && r === 2 && u >= 224e3 && o === 0 && (n[e + 3] = n[e + 3] | 128), { sampleRate: h, channelCount: p, frameLength: w, samplesPerFrame: y } } } function Cp(n, e) { return n[e] === 255 && (n[e + 1] & 224) === 224 && (n[e + 1] & 6) !== 0 } function vw(n, e) { return e + 1 < n.length && Cp(n, e) } function VP(n, e) { return Cp(n, e) && 4 <= n.length - e } function yw(n, e) { if (e + 1 < n.length && Cp(n, e)) { const r = xw(n, e); let s = 4; r != null && r.frameLength && (s = r.frameLength); const i = e + s; return i === n.length || vw(n, i) } return !1 } class GP extends Lp { constructor(e, t) { super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t } resetInitSegment(e, t, r, s) { super.resetInitSegment(e, t, r, s), this._audioTrack = { container: "audio/adts", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "aac", samples: [], manifestCodec: t, duration: s, inputTimeScale: 9e4, dropped: 0 } } static probe(e, t) { if (!e) return !1; const r = no(e, 0); let s = r?.length || 0; if (yw(e, s)) return !1; for (let i = e.length; s < i; s++)if (EP(e, s)) return t.log("ADTS sync word found !"), !0; return !1 } canParse(e, t) { return SP(e, t) } appendFrame(e, t, r) { dw(e, this.observer, t, r, e.manifestCodec); const s = hw(e, t, r, this.basePTS, this.frameIndex); if (s && s.missing === 0) return s } } const bw = (n, e) => { let t = 0, r = 5; e += r; const s = new Uint32Array(1), i = new Uint32Array(1), a = new Uint8Array(1); for (; r > 0;) { a[0] = n[e]; const o = Math.min(r, 8), c = 8 - o; i[0] = 4278190080 >>> 24 + c << c, s[0] = (a[0] & i[0]) >> c, t = t ? t << o | s[0] : s[0], e += 1, r -= o } return t }; class HP extends Lp { constructor(e) { super(), this.observer = void 0, this.observer = e } resetInitSegment(e, t, r, s) { super.resetInitSegment(e, t, r, s), this._audioTrack = { container: "audio/ac-3", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "ac3", samples: [], manifestCodec: t, duration: s, inputTimeScale: 9e4, dropped: 0 } } canParse(e, t) { return t + 64 < e.length } appendFrame(e, t, r) { const s = ww(e, t, r, this.basePTS, this.frameIndex); if (s !== -1) return { sample: e.samples[e.samples.length - 1], length: s, missing: 0 } } static probe(e) { if (!e) return !1; const t = no(e, 0); if (!t) return !1; const r = t.length; return e[r] === 11 && e[r + 1] === 119 && Ip(t) !== void 0 && bw(e, r) < 16 } } function ww(n, e, t, r, s) { if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119) return -1; const i = e[t + 4] >> 6; if (i >= 3) return -1; const o = [48e3, 44100, 32e3][i], c = e[t + 4] & 63, f = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][c * 3 + i] * 2; if (t + f > e.length) return -1; const h = e[t + 6] >> 5; let p = 0; h === 2 ? p += 2 : (h & 1 && h !== 1 && (p += 2), h & 4 && (p += 2)); const v = (e[t + 6] << 8 | e[t + 7]) >> 12 - p & 1, y = [2, 1, 2, 3, 3, 4, 4, 5][h] + v, w = e[t + 5] >> 3, T = e[t + 5] & 7, S = new Uint8Array([i << 6 | w << 1 | T >> 2, (T & 3) << 6 | h << 3 | v << 2 | c >> 4, c << 4 & 224]), E = 1536 / o * 9e4, I = r + s * E, C = e.subarray(t, t + f); return n.config = S, n.channelCount = y, n.samplerate = o, n.samples.push({ unit: C, pts: I }), f } class WP extends Lp { resetInitSegment(e, t, r, s) { super.resetInitSegment(e, t, r, s), this._audioTrack = { container: "audio/mpeg", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "mp3", samples: [], manifestCodec: t, duration: s, inputTimeScale: 9e4, dropped: 0 } } static probe(e) { if (!e) return !1; const t = no(e, 0); let r = t?.length || 0; if (t && e[r] === 11 && e[r + 1] === 119 && Ip(t) !== void 0 && bw(e, r) <= 16) return !1; for (let s = e.length; r < s; r++)if (yw(e, r)) return tt.log("MPEG Audio sync word found !"), !0; return !1 } canParse(e, t) { return VP(e, t) } appendFrame(e, t, r) { if (this.basePTS !== null) return gw(e, t, r, this.basePTS, this.frameIndex) } } const KP = /\/emsg[-/]ID3/i; class qP { constructor(e, t) { this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t } resetTimeStamp() { } resetInitSegment(e, t, r, s) { const i = this.videoTrack = sn("video", 1), a = this.audioTrack = sn("audio", 1), o = this.txtTrack = sn("text", 1); if (this.id3Track = sn("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength)) return; const c = Db(e); if (c.video) { const { id: u, timescale: f, codec: h, supplemental: p } = c.video; i.id = u, i.timescale = o.timescale = f, i.codec = h, i.supplemental = p } if (c.audio) { const { id: u, timescale: f, codec: h } = c.audio; a.id = u, a.timescale = f, a.codec = h } o.id = _b.text, i.sampleDuration = 0, i.duration = a.duration = s } resetContiguity() { this.remainderData = null } static probe(e) { return HR(e) } demux(e, t) { this.timeOffset = t; let r = e; const s = this.videoTrack, i = this.txtTrack; if (this.config.progressive) { this.remainderData && (r = Rr(this.remainderData, e)); const o = QR(r); this.remainderData = o.remainder, s.samples = o.valid || new Uint8Array } else s.samples = r; const a = this.extractID3Track(s, t); return i.samples = sv(t, s), { videoTrack: s, audioTrack: this.audioTrack, id3Track: a, textTrack: this.txtTrack } } flush() { const e = this.timeOffset, t = this.videoTrack, r = this.txtTrack; t.samples = this.remainderData || new Uint8Array, this.remainderData = null; const s = this.extractID3Track(t, this.timeOffset); return r.samples = sv(e, t), { videoTrack: t, audioTrack: sn(), id3Track: s, textTrack: sn() } } extractID3Track(e, t) { const r = this.id3Track; if (e.samples.length) { const s = ze(e.samples, ["emsg"]); s && s.forEach(i => { const a = JR(i); if (KP.test(a.schemeIdUri)) { const o = Bv(a, t); let c = a.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale; c <= .001 && (c = Number.POSITIVE_INFINITY); const u = a.payload; r.samples.push({ data: u, len: u.byteLength, dts: o, pts: o, type: br.emsg, duration: c }) } else if (this.config.enableEmsgKLVMetadata && a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) { const o = Bv(a, t); r.samples.push({ data: a.payload, len: a.payload.byteLength, dts: o, pts: o, type: br.misbklv, duration: Number.POSITIVE_INFINITY }) } }) } return r } demuxSampleAes(e, t, r) { return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption")) } destroy() { this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0 } } function Bv(n, e) { return ge(n.presentationTime) ? n.presentationTime / n.timeScale : e + n.presentationTimeDelta / n.timeScale } class YP { constructor(e, t, r) { this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new xp(t, { removePKCS7Padding: !1 }) } decryptBuffer(e) { return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, ws.cbc) } decryptAacSample(e, t, r) { const s = e[t].unit; if (s.length <= 16) return; const i = s.subarray(16, s.length - s.length % 16), a = i.buffer.slice(i.byteOffset, i.byteOffset + i.length); this.decryptBuffer(a).then(o => { const c = new Uint8Array(o); s.set(c, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, r) }).catch(r) } decryptAacSamples(e, t, r) { for (; ; t++) { if (t >= e.length) { r(); return } if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, r), !this.decrypter.isSync())) return } } getAvcEncryptedData(e) { const t = Math.floor((e.length - 48) / 160) * 16 + 16, r = new Int8Array(t); let s = 0; for (let i = 32; i < e.length - 16; i += 160, s += 16)r.set(e.subarray(i, i + 16), s); return r } getAvcDecryptedUnit(e, t) { const r = new Uint8Array(t); let s = 0; for (let i = 32; i < e.length - 16; i += 160, s += 16)e.set(r.subarray(s, s + 16), i); return e } decryptAvcSample(e, t, r, s, i) { const a = Mb(i.data), o = this.getAvcEncryptedData(a); this.decryptBuffer(o.buffer).then(c => { i.data = this.getAvcDecryptedUnit(a, c), this.decrypter.isSync() || this.decryptAvcSamples(e, t, r + 1, s) }).catch(s) } decryptAvcSamples(e, t, r, s) { if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array"); for (; ; t++, r = 0) { if (t >= e.length) { s(); return } const i = e[t].units; for (; !(r >= i.length); r++) { const a = i[r]; if (!(a.data.length <= 48 || a.type !== 1 && a.type !== 5) && (this.decryptAvcSample(e, t, r, s, a), !this.decrypter.isSync())) return } } } } class Sw { constructor() { this.VideoSample = null } createVideoSample(e, t, r) { return { key: e, frame: !1, pts: t, dts: r, units: [], length: 0 } } getLastNalUnit(e) { var t; let r = this.VideoSample, s; if ((!r || r.units.length === 0) && (r = e[e.length - 1]), (t = r) != null && t.units) { const i = r.units; s = i[i.length - 1] } return s } pushAccessUnit(e, t) { if (e.units.length && e.frame) { if (e.pts === void 0) { const r = t.samples, s = r.length; if (s) { const i = r[s - 1]; e.pts = i.pts, e.dts = i.dts } else { t.dropped++; return } } t.samples.push(e) } } parseNALu(e, t, r) { const s = t.byteLength; let i = e.naluState || 0; const a = i, o = []; let c = 0, u, f, h, p = -1, v = 0; for (i === -1 && (p = 0, v = this.getNALuType(t, 0), i = 0, c = 1); c < s;) { if (u = t[c++], !i) { i = u ? 0 : 1; continue } if (i === 1) { i = u ? 0 : 2; continue } if (!u) i = 3; else if (u === 1) { if (f = c - i - 1, p >= 0) { const g = { data: t.subarray(p, f), type: v }; o.push(g) } else { const g = this.getLastNalUnit(e.samples); g && (a && c <= 4 - a && g.state && (g.data = g.data.subarray(0, g.data.byteLength - a)), f > 0 && (g.data = Rr(g.data, t.subarray(0, f)), g.state = 0)) } c < s ? (h = this.getNALuType(t, c), p = c, v = h, i = 0) : i = -1 } else i = 0 } if (p >= 0 && i >= 0) { const g = { data: t.subarray(p, s), type: v, state: i }; o.push(g) } if (o.length === 0) { const g = this.getLastNalUnit(e.samples); g && (g.data = Rr(g.data, t)) } return e.naluState = i, o } } class Ha { constructor(e) { this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0 } loadWord() { const e = this.data, t = this.bytesAvailable, r = e.byteLength - t, s = new Uint8Array(4), i = Math.min(4, t); if (i === 0) throw new Error("no bytes available"); s.set(e.subarray(r, r + i)), this.word = new DataView(s.buffer).getUint32(0), this.bitsAvailable = i * 8, this.bytesAvailable -= i } skipBits(e) { let t; e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e) } readBits(e) { let t = Math.min(this.bitsAvailable, e); const r = this.word >>> 32 - t; if (e > 32 && tt.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t; else if (this.bytesAvailable > 0) this.loadWord(); else throw new Error("no bits available"); return t = e - t, t > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r } skipLZ() { let e; for (e = 0; e < this.bitsAvailable; ++e)if ((this.word & 2147483648 >>> e) !== 0) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ() } skipUEG() { this.skipBits(1 + this.skipLZ()) } skipEG() { this.skipBits(1 + this.skipLZ()) } readUEG() { const e = this.skipLZ(); return this.readBits(e + 1) - 1 } readEG() { const e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1) } readBoolean() { return this.readBits(1) === 1 } readUByte() { return this.readBits(8) } readUShort() { return this.readBits(16) } readUInt() { return this.readBits(32) } } class XP extends Sw { parsePES(e, t, r, s) { const i = this.parseNALu(e, r.data, s); let a = this.VideoSample, o, c = !1; r.data = null, a && i.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), i.forEach(u => { var f, h; switch (u.type) { case 1: { let y = !1; o = !0; const w = u.data; if (c && w.length > 4) { const T = this.readSliceType(w); (T === 2 || T === 4 || T === 7 || T === 9) && (y = !0) } if (y) { var p; (p = a) != null && p.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null) } a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.frame = !0, a.key = y; break } case 5: o = !0, (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0; break; case 6: { o = !0, hp(u.data, 1, r.pts, t.samples); break } case 7: { var v, g; o = !0, c = !0; const y = u.data, w = this.readSPS(y); if (!e.sps || e.width !== w.width || e.height !== w.height || ((v = e.pixelRatio) == null ? void 0 : v[0]) !== w.pixelRatio[0] || ((g = e.pixelRatio) == null ? void 0 : g[1]) !== w.pixelRatio[1]) { e.width = w.width, e.height = w.height, e.pixelRatio = w.pixelRatio, e.sps = [y]; const T = y.subarray(1, 4); let S = "avc1."; for (let E = 0; E < 3; E++) { let I = T[E].toString(16); I.length < 2 && (I = "0" + I), S += I } e.codec = S } break } case 8: o = !0, e.pps = [u.data]; break; case 9: o = !0, e.audFound = !0, (h = a) != null && h.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)); break; case 12: o = !0; break; default: o = !1; break }a && o && a.units.push(u) }), s && a && (this.pushAccessUnit(a, e), this.VideoSample = null) } getNALuType(e, t) { return e[t] & 31 } readSliceType(e) { const t = new Ha(e); return t.readUByte(), t.readUEG(), t.readUEG() } skipScalingList(e, t) { let r = 8, s = 8, i; for (let a = 0; a < e; a++)s !== 0 && (i = t.readEG(), s = (r + i + 256) % 256), r = s === 0 ? r : s } readSPS(e) { const t = new Ha(e); let r = 0, s = 0, i = 0, a = 0, o, c, u; const f = t.readUByte.bind(t), h = t.readBits.bind(t), p = t.readUEG.bind(t), v = t.readBoolean.bind(t), g = t.skipBits.bind(t), y = t.skipEG.bind(t), w = t.skipUEG.bind(t), T = this.skipScalingList.bind(this); f(); const S = f(); if (h(5), g(3), f(), w(), S === 100 || S === 110 || S === 122 || S === 244 || S === 44 || S === 83 || S === 86 || S === 118 || S === 128) { const N = p(); if (N === 3 && g(1), w(), w(), g(1), v()) for (c = N !== 3 ? 8 : 12, u = 0; u < c; u++)v() && (u < 6 ? T(16, t) : T(64, t)) } w(); const E = p(); if (E === 0) p(); else if (E === 1) for (g(1), y(), y(), o = p(), u = 0; u < o; u++)y(); w(), g(1); const I = p(), C = p(), D = h(1); D === 0 && g(1), g(1), v() && (r = p(), s = p(), i = p(), a = p()); let R = [1, 1]; if (v() && v()) switch (f()) { case 1: R = [1, 1]; break; case 2: R = [12, 11]; break; case 3: R = [10, 11]; break; case 4: R = [16, 11]; break; case 5: R = [40, 33]; break; case 6: R = [24, 11]; break; case 7: R = [20, 11]; break; case 8: R = [32, 11]; break; case 9: R = [80, 33]; break; case 10: R = [18, 11]; break; case 11: R = [15, 11]; break; case 12: R = [64, 33]; break; case 13: R = [160, 99]; break; case 14: R = [4, 3]; break; case 15: R = [3, 2]; break; case 16: R = [2, 1]; break; case 255: { R = [f() << 8 | f(), f() << 8 | f()]; break } }return { width: Math.ceil((I + 1) * 16 - r * 2 - s * 2), height: (2 - D) * (C + 1) * 16 - (D ? 2 : 4) * (i + a), pixelRatio: R } } } class QP extends Sw { constructor(...e) { super(...e), this.initVPS = null } parsePES(e, t, r, s) { const i = this.parseNALu(e, r.data, s); let a = this.VideoSample, o, c = !1; r.data = null, a && i.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), i.forEach(u => { var f, h; switch (u.type) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), a.frame = !0, o = !0; break; case 16: case 17: case 18: case 21: if (o = !0, c) { var p; (p = a) != null && p.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null) } a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0; break; case 19: case 20: o = !0, (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0; break; case 39: o = !0, hp(u.data, 2, r.pts, t.samples); break; case 32: o = !0, e.vps || (typeof e.params != "object" && (e.params = {}), e.params = nt(e.params, this.readVPS(u.data)), this.initVPS = u.data), e.vps = [u.data]; break; case 33: if (o = !0, c = !0, e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], u.data) && (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) { const v = this.readSPS(u.data); e.width = v.width, e.height = v.height, e.pixelRatio = v.pixelRatio, e.codec = v.codecString, e.sps = [], typeof e.params != "object" && (e.params = {}); for (const g in v.params) e.params[g] = v.params[g] } this.pushParameterSet(e.sps, u.data, e.vps), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0; break; case 34: if (o = !0, typeof e.params == "object") { if (!e.pps) { e.pps = []; const v = this.readPPS(u.data); for (const g in v) e.params[g] = v[g] } this.pushParameterSet(e.pps, u.data, e.vps) } break; case 35: o = !0, e.audFound = !0, (h = a) != null && h.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)); break; default: o = !1; break }a && o && a.units.push(u) }), s && a && (this.pushAccessUnit(a, e), this.VideoSample = null) } pushParameterSet(e, t, r) { (r && r[0] === this.initVPS || !r && !e.length) && e.push(t) } getNALuType(e, t) { return (e[t] & 126) >>> 1 } ebsp2rbsp(e) { const t = new Uint8Array(e.byteLength); let r = 0; for (let s = 0; s < e.byteLength; s++)s >= 2 && e[s] === 3 && e[s - 1] === 0 && e[s - 2] === 0 || (t[r] = e[s], r++); return new Uint8Array(t.buffer, 0, r) } pushAccessUnit(e, t) { super.pushAccessUnit(e, t), this.initVPS && (this.initVPS = null) } readVPS(e) { const t = new Ha(e); t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6); const r = t.readBits(3), s = t.readBoolean(); return { numTemporalLayers: r + 1, temporalIdNested: s } } readSPS(e) { const t = new Ha(this.ebsp2rbsp(e)); t.readUByte(), t.readUByte(), t.readBits(4); const r = t.readBits(3); t.readBoolean(); const s = t.readBits(2), i = t.readBoolean(), a = t.readBits(5), o = t.readUByte(), c = t.readUByte(), u = t.readUByte(), f = t.readUByte(), h = t.readUByte(), p = t.readUByte(), v = t.readUByte(), g = t.readUByte(), y = t.readUByte(), w = t.readUByte(), T = t.readUByte(), S = [], E = []; for (let Le = 0; Le < r; Le++)S.push(t.readBoolean()), E.push(t.readBoolean()); if (r > 0) for (let Le = r; Le < 8; Le++)t.readBits(2); for (let Le = 0; Le < r; Le++)S[Le] && (t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte()), E[Le] && t.readUByte(); t.readUEG(); const I = t.readUEG(); I == 3 && t.skipBits(1); const C = t.readUEG(), D = t.readUEG(), R = t.readBoolean(); let N = 0, P = 0, _ = 0, M = 0; R && (N += t.readUEG(), P += t.readUEG(), _ += t.readUEG(), M += t.readUEG()); const $ = t.readUEG(), B = t.readUEG(), V = t.readUEG(), W = t.readBoolean(); for (let Le = W ? 0 : r; Le <= r; Le++)t.skipUEG(), t.skipUEG(), t.skipUEG(); if (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.readBoolean() && t.readBoolean()) for (let ie = 0; ie < 4; ie++)for (let _e = 0; _e < (ie === 3 ? 2 : 6); _e++)if (!t.readBoolean()) t.readUEG(); else { const Ze = Math.min(64, 1 << 4 + (ie << 1)); ie > 1 && t.readEG(); for (let vt = 0; vt < Ze; vt++)t.readEG() } t.readBoolean(), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean()); const z = t.readUEG(); let X = 0; for (let Le = 0; Le < z; Le++) { let ie = !1; if (Le !== 0 && (ie = t.readBoolean()), ie) { Le === z && t.readUEG(), t.readBoolean(), t.readUEG(); let _e = 0; for (let qe = 0; qe <= X; qe++) { const Ze = t.readBoolean(); let vt = !1; Ze || (vt = t.readBoolean()), (Ze || vt) && _e++ } X = _e } else { const _e = t.readUEG(), qe = t.readUEG(); X = _e + qe; for (let Ze = 0; Ze < _e; Ze++)t.readUEG(), t.readBoolean(); for (let Ze = 0; Ze < qe; Ze++)t.readUEG(), t.readBoolean() } } if (t.readBoolean()) { const Le = t.readUEG(); for (let ie = 0; ie < Le; ie++) { for (let _e = 0; _e < V + 4; _e++)t.readBits(1); t.readBits(1) } } let F = 0, H = 1, ae = 1, he = !0, de = 1, pe = 0; t.readBoolean(), t.readBoolean(); let Ce = !1; if (t.readBoolean()) { if (t.readBoolean()) { const Et = t.readUByte(), _t = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], dr = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1]; Et > 0 && Et < 16 ? (H = _t[Et - 1], ae = dr[Et - 1]) : Et === 255 && (H = t.readBits(16), ae = t.readBits(16)) } if (t.readBoolean() && t.readBoolean(), t.readBoolean() && (t.readBits(3), t.readBoolean(), t.readBoolean() && (t.readUByte(), t.readUByte(), t.readUByte())), t.readBoolean() && (t.readUEG(), t.readUEG()), t.readBoolean(), t.readBoolean(), t.readBoolean(), Ce = t.readBoolean(), Ce && (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG()), t.readBoolean() && (de = t.readBits(32), pe = t.readBits(32), t.readBoolean() && t.readUEG(), t.readBoolean())) { const dr = t.readBoolean(), Gr = t.readBoolean(); let Zt = !1; (dr || Gr) && (Zt = t.readBoolean(), Zt && (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)), t.readBits(4), t.readBits(4), Zt && t.readBits(4), t.readBits(5), t.readBits(5), t.readBits(5)); for (let Fn = 0; Fn <= r; Fn++) { he = t.readBoolean(); const $n = he || t.readBoolean(); let Ts = !1; $n ? t.readEG() : Ts = t.readBoolean(); const Hr = Ts ? 1 : t.readUEG() + 1; if (dr) for (let fr = 0; fr < Hr; fr++)t.readUEG(), t.readUEG(), Zt && (t.readUEG(), t.readUEG()), t.skipBits(1); if (Gr) for (let fr = 0; fr < Hr; fr++)t.readUEG(), t.readUEG(), Zt && (t.readUEG(), t.readUEG()), t.skipBits(1) } } t.readBoolean() && (t.readBoolean(), t.readBoolean(), t.readBoolean(), F = t.readUEG()) } let Pe = C, Ve = D; if (R) { let Le = 1, ie = 1; I === 1 ? Le = ie = 2 : I == 2 && (Le = 2), Pe = C - Le * P - Le * N, Ve = D - ie * M - ie * _ } const rt = s ? ["A", "B", "C"][s] : "", ft = o << 24 | c << 16 | u << 8 | f; let je = 0; for (let Le = 0; Le < 32; Le++)je = (je | (ft >> Le & 1) << 31 - Le) >>> 0; let Oe = je.toString(16); return a === 1 && Oe === "2" && (Oe = "6"), { codecString: `hvc1.${rt}${a}.${Oe}.${i ? "H" : "L"}${T}.B0`, params: { general_tier_flag: i, general_profile_idc: a, general_profile_space: s, general_profile_compatibility_flags: [o, c, u, f], general_constraint_indicator_flags: [h, p, v, g, y, w], general_level_idc: T, bit_depth: $ + 8, bit_depth_luma_minus8: $, bit_depth_chroma_minus8: B, min_spatial_segmentation_idc: F, chroma_format_idc: I, frame_rate: { fixed: he, fps: pe / de } }, width: Pe, height: Ve, pixelRatio: [H, ae] } } readPPS(e) { const t = new Ha(this.ebsp2rbsp(e)); t.readUByte(), t.readUByte(), t.skipUEG(), t.skipUEG(), t.skipBits(2), t.skipBits(3), t.skipBits(2), t.skipUEG(), t.skipUEG(), t.skipEG(), t.skipBits(2), t.readBoolean() && t.skipUEG(), t.skipEG(), t.skipEG(), t.skipBits(4); const s = t.readBoolean(), i = t.readBoolean(); let a = 1; return i && s ? a = 0 : i ? a = 3 : s && (a = 2), { parallelismType: a } } matchSPS(e, t) { return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, t).substr(3) } } const Ot = 188; class fs { constructor(e, t, r, s) { this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.logger = s, this.videoParser = null } static probe(e, t) { const r = fs.syncOffset(e); return r > 0 && t.warn(`MPEG2-TS detected but first sync word found @ offset ${r}`), r !== -1 } static syncOffset(e) { const t = e.length; let r = Math.min(Ot * 5, t - Ot) + 1, s = 0; for (; s < r;) { let i = !1, a = -1, o = 0; for (let c = s; c < t; c += Ot)if (e[c] === 71 && (t - c === Ot || e[c + Ot] === 71)) { if (o++, a === -1 && (a = c, a !== 0 && (r = Math.min(a + Ot * 99, e.length - Ot) + 1)), i || (i = Ih(e, c) === 0), i && o > 1 && (a === 0 && o > 2 || c + Ot > r)) return a } else { if (o) return -1; break } s++ } return -1 } static createTrack(e, t) { return { container: e === "video" || e === "audio" ? "video/mp2t" : void 0, type: e, id: _b[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0, duration: e === "audio" ? t : void 0 } } resetInitSegment(e, t, r, s) { this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = fs.createTrack("video"), this._videoTrack.duration = s, this._audioTrack = fs.createTrack("audio", s), this._id3Track = fs.createTrack("id3"), this._txtTrack = fs.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.videoParser = null, this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = r } resetTimeStamp() { } resetContiguity() { const { _audioTrack: e, _videoTrack: t, _id3Track: r } = this; e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.remainderData = null } demux(e, t, r = !1, s = !1) { r || (this.sampleAes = null); let i; const a = this._videoTrack, o = this._audioTrack, c = this._id3Track, u = this._txtTrack; let f = a.pid, h = a.pesData, p = o.pid, v = c.pid, g = o.pesData, y = c.pesData, w = null, T = this.pmtParsed, S = this._pmtId, E = e.length; if (this.remainderData && (e = Rr(this.remainderData, e), E = e.length, this.remainderData = null), E < Ot && !s) return this.remainderData = e, { audioTrack: o, videoTrack: a, id3Track: c, textTrack: u }; const I = Math.max(0, fs.syncOffset(e)); E -= (E - I) % Ot, E < e.byteLength && !s && (this.remainderData = new Uint8Array(e.buffer, E, e.buffer.byteLength - E)); let C = 0; for (let R = I; R < E; R += Ot)if (e[R] === 71) { const N = !!(e[R + 1] & 64), P = Ih(e, R), _ = (e[R + 3] & 48) >> 4; let M; if (_ > 1) { if (M = R + 5 + e[R + 4], M === R + Ot) continue } else M = R + 4; switch (P) { case f: N && (h && (i = Ai(h, this.logger)) && (this.readyVideoParser(a.segmentCodec), this.videoParser !== null && this.videoParser.parsePES(a, u, i, !1)), h = { data: [], size: 0 }), h && (h.data.push(e.subarray(M, R + Ot)), h.size += R + Ot - M); break; case p: if (N) { if (g && (i = Ai(g, this.logger))) switch (o.segmentCodec) { case "aac": this.parseAACPES(o, i); break; case "mp3": this.parseMPEGPES(o, i); break; case "ac3": this.parseAC3PES(o, i); break }g = { data: [], size: 0 } } g && (g.data.push(e.subarray(M, R + Ot)), g.size += R + Ot - M); break; case v: N && (y && (i = Ai(y, this.logger)) && this.parseID3PES(c, i), y = { data: [], size: 0 }), y && (y.data.push(e.subarray(M, R + Ot)), y.size += R + Ot - M); break; case 0: N && (M += e[M] + 1), S = this._pmtId = ZP(e, M); break; case S: { N && (M += e[M] + 1); const $ = JP(e, M, this.typeSupported, r, this.observer, this.logger); f = $.videoPid, f > 0 && (a.pid = f, a.segmentCodec = $.segmentVideoCodec), p = $.audioPid, p > 0 && (o.pid = p, o.segmentCodec = $.segmentAudioCodec), v = $.id3Pid, v > 0 && (c.pid = v), w !== null && !T && (this.logger.warn(`MPEG-TS PMT found at ${R} after unknown PID '${w}'. Backtracking to sync byte @${I} to parse all TS packets.`), w = null, R = I - 188), T = this.pmtParsed = !0; break } case 17: case 8191: break; default: w = P; break } } else C++; C > 0 && Lh(this.observer, new Error(`Found ${C} TS packet/s that do not start with 0x47`), void 0, this.logger), a.pesData = h, o.pesData = g, c.pesData = y; const D = { audioTrack: o, videoTrack: a, id3Track: c, textTrack: u }; return s && this.extractRemainingSamples(D), D } flush() { const { remainderData: e } = this; this.remainderData = null; let t; return e ? t = this.demux(e, -1, !1, !0) : t = { videoTrack: this._videoTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t } extractRemainingSamples(e) { const { audioTrack: t, videoTrack: r, id3Track: s, textTrack: i } = e, a = r.pesData, o = t.pesData, c = s.pesData; let u; if (a && (u = Ai(a, this.logger)) ? (this.readyVideoParser(r.segmentCodec), this.videoParser !== null && (this.videoParser.parsePES(r, i, u, !0), r.pesData = null)) : r.pesData = a, o && (u = Ai(o, this.logger))) { switch (t.segmentCodec) { case "aac": this.parseAACPES(t, u); break; case "mp3": this.parseMPEGPES(t, u); break; case "ac3": this.parseAC3PES(t, u); break }t.pesData = null } else o != null && o.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = o; c && (u = Ai(c, this.logger)) ? (this.parseID3PES(s, u), s.pesData = null) : s.pesData = c } demuxSampleAes(e, t, r) { const s = this.demux(e, r, !0, !this.config.progressive), i = this.sampleAes = new YP(this.observer, this.config, t); return this.decrypt(s, i) } readyVideoParser(e) { this.videoParser === null && (e === "avc" ? this.videoParser = new XP : e === "hevc" && (this.videoParser = new QP)) } decrypt(e, t) { return new Promise(r => { const { audioTrack: s, videoTrack: i } = e; s.samples && s.segmentCodec === "aac" ? t.decryptAacSamples(s.samples, 0, () => { i.samples ? t.decryptAvcSamples(i.samples, 0, 0, () => { r(e) }) : r(e) }) : i.samples && t.decryptAvcSamples(i.samples, 0, 0, () => { r(e) }) }) } destroy() { this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0 } parseAACPES(e, t) { let r = 0; const s = this.aacOverFlow; let i = t.data; if (s) { this.aacOverFlow = null; const h = s.missing, p = s.sample.unit.byteLength; if (h === -1) i = Rr(s.sample.unit, i); else { const v = p - h; s.sample.unit.set(i.subarray(0, h), v), e.samples.push(s.sample), r = s.missing } } let a, o; for (a = r, o = i.length; a < o - 1 && !Rc(i, a); a++); if (a !== r) { let h; const p = a < o - 1; if (p ? h = `AAC PES did not start with ADTS header,offset:${a}` : h = "No ADTS header found in AAC PES", Lh(this.observer, new Error(h), p, this.logger), !p) return } dw(e, this.observer, i, a, this.audioCodec); let c; if (t.pts !== void 0) c = t.pts; else if (s) { const h = fw(e.samplerate); c = s.sample.pts + h } else { this.logger.warn("[tsdemuxer]: AAC PES unknown PTS"); return } let u = 0, f; for (; a < o;)if (f = hw(e, i, a, c, u), a += f.length, f.missing) { this.aacOverFlow = f; break } else for (u++; a < o - 1 && !Rc(i, a); a++); } parseMPEGPES(e, t) { const r = t.data, s = r.length; let i = 0, a = 0; const o = t.pts; if (o === void 0) { this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS"); return } for (; a < s;)if (vw(r, a)) { const c = gw(e, r, a, o, i); if (c) a += c.length, i++; else break } else a++ } parseAC3PES(e, t) { { const r = t.data, s = t.pts; if (s === void 0) { this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS"); return } const i = r.length; let a = 0, o = 0, c; for (; o < i && (c = ww(e, r, o, s, a++)) > 0;)o += c } } parseID3PES(e, t) { if (t.pts === void 0) { this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS"); return } const r = nt({}, t, { type: this._videoTrack ? br.emsg : br.audioId3, duration: Number.POSITIVE_INFINITY }); e.samples.push(r) } } function Ih(n, e) { return ((n[e + 1] & 31) << 8) + n[e + 2] } function ZP(n, e) { return (n[e + 10] & 31) << 8 | n[e + 11] } function JP(n, e, t, r, s, i) { const a = { audioPid: -1, videoPid: -1, id3Pid: -1, segmentVideoCodec: "avc", segmentAudioCodec: "aac" }, o = (n[e + 1] & 15) << 8 | n[e + 2], c = e + 3 + o - 4, u = (n[e + 10] & 15) << 8 | n[e + 11]; for (e += 12 + u; e < c;) { const f = Ih(n, e), h = (n[e + 3] & 15) << 8 | n[e + 4]; switch (n[e]) { case 207: if (!r) { yf("ADTS AAC", i); break } case 15: a.audioPid === -1 && (a.audioPid = f); break; case 21: a.id3Pid === -1 && (a.id3Pid = f); break; case 219: if (!r) { yf("H.264", i); break } case 27: a.videoPid === -1 && (a.videoPid = f); break; case 3: case 4: !t.mpeg && !t.mp3 ? i.log("MPEG audio found, not supported in this browser") : a.audioPid === -1 && (a.audioPid = f, a.segmentAudioCodec = "mp3"); break; case 193: if (!r) { yf("AC-3", i); break } case 129: t.ac3 ? a.audioPid === -1 && (a.audioPid = f, a.segmentAudioCodec = "ac3") : i.log("AC-3 audio found, not supported in this browser"); break; case 6: if (a.audioPid === -1 && h > 0) { let p = e + 5, v = h; for (; v > 2;) { switch (n[p]) { case 106: t.ac3 !== !0 ? i.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = f, a.segmentAudioCodec = "ac3"); break }const y = n[p + 1] + 2; p += y, v -= y } } break; case 194: case 135: return Lh(s, new Error("Unsupported EC-3 in M2TS found"), void 0, i), a; case 36: a.videoPid === -1 && (a.videoPid = f, a.segmentVideoCodec = "hevc", i.log("HEVC in M2TS found")); break }e += h + 5 } return a } function Lh(n, e, t, r) { r.warn(`parsing error: ${e.message}`), n.emit(k.ERROR, k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_PARSING_ERROR, fatal: !1, levelRetry: t, error: e, reason: e.message }) } function yf(n, e) { e.log(`${n} with AES-128-CBC encryption found in unencrypted stream`) } function Ai(n, e) { let t = 0, r, s, i, a, o; const c = n.data; if (!n || n.size === 0) return null; for (; c[0].length < 19 && c.length > 1;)c[0] = Rr(c[0], c[1]), c.splice(1, 1); if (r = c[0], (r[0] << 16) + (r[1] << 8) + r[2] === 1) { if (s = (r[4] << 8) + r[5], s && s > n.size - 6) return null; const f = r[7]; f & 192 && (a = (r[9] & 14) * 536870912 + (r[10] & 255) * 4194304 + (r[11] & 254) * 16384 + (r[12] & 255) * 128 + (r[13] & 254) / 2, f & 64 ? (o = (r[14] & 14) * 536870912 + (r[15] & 255) * 4194304 + (r[16] & 254) * 16384 + (r[17] & 255) * 128 + (r[18] & 254) / 2, a - o > 60 * 9e4 && (e.warn(`${Math.round((a - o) / 9e4)}s delta between PTS and DTS, align them`), a = o)) : o = a), i = r[8]; let h = i + 9; if (n.size <= h) return null; n.size -= h; const p = new Uint8Array(n.size); for (let v = 0, g = c.length; v < g; v++) { r = c[v]; let y = r.byteLength; if (h) if (h > y) { h -= y; continue } else r = r.subarray(h), y -= h, h = 0; p.set(r, t), t += y } return s && (s -= i + 3), { data: p, pts: a, dts: o, len: s } } return null } class eN { static getSilentFrame(e, t) { switch (e) { case "mp4a.40.2": if (t === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]); if (t === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]); if (t === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]); if (t === 4) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]); if (t === 5) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]); if (t === 6) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]); break; default: if (t === 1) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (t === 2) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (t === 3) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); break } } } const ls = Math.pow(2, 32) - 1; class Q { static init() { Q.types = { avc1: [], avcC: [], hvc1: [], hvcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], ".mp3": [], dac3: [], "ac-3": [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }; let e; for (e in Q.types) Q.types.hasOwnProperty(e) && (Q.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]); const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]); Q.HDLR_TYPES = { video: t, audio: r }; const s = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]); Q.STTS = Q.STSC = Q.STCO = i, Q.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Q.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), Q.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), Q.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); const a = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]), c = new Uint8Array([0, 0, 0, 1]); Q.FTYP = Q.box(Q.types.ftyp, a, c, a, o), Q.DINF = Q.box(Q.types.dinf, Q.box(Q.types.dref, s)) } static box(e, ...t) { let r = 8, s = t.length; const i = s; for (; s--;)r += t[s].byteLength; const a = new Uint8Array(r); for (a[0] = r >> 24 & 255, a[1] = r >> 16 & 255, a[2] = r >> 8 & 255, a[3] = r & 255, a.set(e, 4), s = 0, r = 8; s < i; s++)a.set(t[s], r), r += t[s].byteLength; return a } static hdlr(e) { return Q.box(Q.types.hdlr, Q.HDLR_TYPES[e]) } static mdat(e) { return Q.box(Q.types.mdat, e) } static mdhd(e, t) { t *= e; const r = Math.floor(t / (ls + 1)), s = Math.floor(t % (ls + 1)); return Q.box(Q.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255, 85, 196, 0, 0])) } static mdia(e) { return Q.box(Q.types.mdia, Q.mdhd(e.timescale || 0, e.duration || 0), Q.hdlr(e.type), Q.minf(e)) } static mfhd(e) { return Q.box(Q.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, e & 255])) } static minf(e) { return e.type === "audio" ? Q.box(Q.types.minf, Q.box(Q.types.smhd, Q.SMHD), Q.DINF, Q.stbl(e)) : Q.box(Q.types.minf, Q.box(Q.types.vmhd, Q.VMHD), Q.DINF, Q.stbl(e)) } static moof(e, t, r) { return Q.box(Q.types.moof, Q.mfhd(e), Q.traf(r, t)) } static moov(e) { let t = e.length; const r = []; for (; t--;)r[t] = Q.trak(e[t]); return Q.box.apply(null, [Q.types.moov, Q.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(r).concat(Q.mvex(e))) } static mvex(e) { let t = e.length; const r = []; for (; t--;)r[t] = Q.trex(e[t]); return Q.box.apply(null, [Q.types.mvex, ...r]) } static mvhd(e, t) { t *= e; const r = Math.floor(t / (ls + 1)), s = Math.floor(t % (ls + 1)), i = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return Q.box(Q.types.mvhd, i) } static sdtp(e) { const t = e.samples || [], r = new Uint8Array(4 + t.length); let s, i; for (s = 0; s < t.length; s++)i = t[s].flags, r[s + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy; return Q.box(Q.types.sdtp, r) } static stbl(e) { return Q.box(Q.types.stbl, Q.stsd(e), Q.box(Q.types.stts, Q.STTS), Q.box(Q.types.stsc, Q.STSC), Q.box(Q.types.stsz, Q.STSZ), Q.box(Q.types.stco, Q.STCO)) } static avc1(e) { let t = [], r = [], s, i, a; for (s = 0; s < e.sps.length; s++)i = e.sps[s], a = i.byteLength, t.push(a >>> 8 & 255), t.push(a & 255), t = t.concat(Array.prototype.slice.call(i)); for (s = 0; s < e.pps.length; s++)i = e.pps[s], a = i.byteLength, r.push(a >>> 8 & 255), r.push(a & 255), r = r.concat(Array.prototype.slice.call(i)); const o = Q.box(Q.types.avcC, new Uint8Array([1, t[3], t[4], t[5], 255, 224 | e.sps.length].concat(t).concat([e.pps.length]).concat(r))), c = e.width, u = e.height, f = e.pixelRatio[0], h = e.pixelRatio[1]; return Q.box(Q.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, c >> 8 & 255, c & 255, u >> 8 & 255, u & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, Q.box(Q.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), Q.box(Q.types.pasp, new Uint8Array([f >> 24, f >> 16 & 255, f >> 8 & 255, f & 255, h >> 24, h >> 16 & 255, h >> 8 & 255, h & 255]))) } static esds(e) { const t = e.config; return new Uint8Array([0, 0, 0, 0, 3, 25, 0, 1, 0, 4, 17, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, ...t, 6, 1, 2]) } static audioStsd(e) { const t = e.samplerate || 0; return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount || 0, 0, 16, 0, 0, 0, 0, t >> 8 & 255, t & 255, 0, 0]) } static mp4a(e) { return Q.box(Q.types.mp4a, Q.audioStsd(e), Q.box(Q.types.esds, Q.esds(e))) } static mp3(e) { return Q.box(Q.types[".mp3"], Q.audioStsd(e)) } static ac3(e) { return Q.box(Q.types["ac-3"], Q.audioStsd(e), Q.box(Q.types.dac3, e.config)) } static stsd(e) { const { segmentCodec: t } = e; if (e.type === "audio") { if (t === "aac") return Q.box(Q.types.stsd, Q.STSD, Q.mp4a(e)); if (t === "ac3" && e.config) return Q.box(Q.types.stsd, Q.STSD, Q.ac3(e)); if (t === "mp3" && e.codec === "mp3") return Q.box(Q.types.stsd, Q.STSD, Q.mp3(e)) } else if (e.pps && e.sps) { if (t === "avc") return Q.box(Q.types.stsd, Q.STSD, Q.avc1(e)); if (t === "hevc" && e.vps) return Q.box(Q.types.stsd, Q.STSD, Q.hvc1(e)) } else throw new Error("video track missing pps or sps"); throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`) } static tkhd(e) { const t = e.id, r = (e.duration || 0) * (e.timescale || 0), s = e.width || 0, i = e.height || 0, a = Math.floor(r / (ls + 1)), o = Math.floor(r % (ls + 1)); return Q.box(Q.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, s >> 8 & 255, s & 255, 0, 0, i >> 8 & 255, i & 255, 0, 0])) } static traf(e, t) { const r = Q.sdtp(e), s = e.id, i = Math.floor(t / (ls + 1)), a = Math.floor(t % (ls + 1)); return Q.box(Q.types.traf, Q.box(Q.types.tfhd, new Uint8Array([0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255])), Q.box(Q.types.tfdt, new Uint8Array([1, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255])), Q.trun(e, r.length + 16 + 20 + 8 + 16 + 8 + 8), r) } static trak(e) { return e.duration = e.duration || 4294967295, Q.box(Q.types.trak, Q.tkhd(e), Q.mdia(e)) } static trex(e) { const t = e.id; return Q.box(Q.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])) } static trun(e, t) { const r = e.samples || [], s = r.length, i = 12 + 16 * s, a = new Uint8Array(i); let o, c, u, f, h, p; for (t += 8 + i, a.set([e.type === "video" ? 1 : 0, 0, 15, 1, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, s & 255, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255], 0), o = 0; o < s; o++)c = r[o], u = c.duration, f = c.size, h = c.flags, p = c.cts, a.set([u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u & 255, f >>> 24 & 255, f >>> 16 & 255, f >>> 8 & 255, f & 255, h.isLeading << 2 | h.dependsOn, h.isDependedOn << 6 | h.hasRedundancy << 4 | h.paddingValue << 1 | h.isNonSync, h.degradPrio & 61440, h.degradPrio & 15, p >>> 24 & 255, p >>> 16 & 255, p >>> 8 & 255, p & 255], 12 + 16 * o); return Q.box(Q.types.trun, a) } static initSegment(e) { Q.types || Q.init(); const t = Q.moov(e); return Rr(Q.FTYP, t) } static hvc1(e) { const t = e.params, r = [e.vps, e.sps, e.pps], s = 4, i = new Uint8Array([1, t.general_profile_space << 6 | (t.general_tier_flag ? 32 : 0) | t.general_profile_idc, t.general_profile_compatibility_flags[0], t.general_profile_compatibility_flags[1], t.general_profile_compatibility_flags[2], t.general_profile_compatibility_flags[3], t.general_constraint_indicator_flags[0], t.general_constraint_indicator_flags[1], t.general_constraint_indicator_flags[2], t.general_constraint_indicator_flags[3], t.general_constraint_indicator_flags[4], t.general_constraint_indicator_flags[5], t.general_level_idc, 240 | t.min_spatial_segmentation_idc >> 8, 255 & t.min_spatial_segmentation_idc, 252 | t.parallelismType, 252 | t.chroma_format_idc, 248 | t.bit_depth_luma_minus8, 248 | t.bit_depth_chroma_minus8, 0, parseInt(t.frame_rate.fps), s - 1 | t.temporal_id_nested << 2 | t.num_temporal_layers << 3 | (t.frame_rate.fixed ? 64 : 0), r.length]); let a = i.length; for (let g = 0; g < r.length; g += 1) { a += 3; for (let y = 0; y < r[g].length; y += 1)a += 2 + r[g][y].length } const o = new Uint8Array(a); o.set(i, 0), a = i.length; const c = r.length - 1; for (let g = 0; g < r.length; g += 1) { o.set(new Uint8Array([32 + g | (g === c ? 128 : 0), 0, r[g].length]), a), a += 3; for (let y = 0; y < r[g].length; y += 1)o.set(new Uint8Array([r[g][y].length >> 8, r[g][y].length & 255]), a), a += 2, o.set(r[g][y], a), a += r[g][y].length } const u = Q.box(Q.types.hvcC, o), f = e.width, h = e.height, p = e.pixelRatio[0], v = e.pixelRatio[1]; return Q.box(Q.types.hvc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, f >> 8 & 255, f & 255, h >> 8 & 255, h & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), u, Q.box(Q.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), Q.box(Q.types.pasp, new Uint8Array([p >> 24, p >> 16 & 255, p >> 8 & 255, p & 255, v >> 24, v >> 16 & 255, v >> 8 & 255, v & 255]))) } } Q.types = void 0; Q.HDLR_TYPES = void 0; Q.STTS = void 0; Q.STSC = void 0; Q.STCO = void 0; Q.STSZ = void 0; Q.VMHD = void 0; Q.SMHD = void 0; Q.STSD = void 0; Q.FTYP = void 0; Q.DINF = void 0; const Ew = 9e4; function kp(n, e, t = 1, r = !1) { const s = n * e * t; return r ? Math.round(s) : s } function tN(n, e, t = 1, r = !1) { return kp(n, e, 1 / t, r) } function ja(n, e = !1) { return kp(n, 1e3, 1 / Ew, e) } function rN(n, e = 1) { return kp(n, Ew, 1 / e) } const nN = 10 * 1e3, sN = 1024, iN = 1152, aN = 1536; let Ii = null, bf = null; function Uv(n, e, t, r) { return { duration: e, size: t, cts: r, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: n ? 2 : 1, isNonSync: n ? 0 : 1 } } } class nc extends Pr { constructor(e, t, r, s) { if (super("mp4-remuxer", s), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, Ii === null) { const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i); Ii = a ? parseInt(a[1]) : 0 } if (bf === null) { const i = navigator.userAgent.match(/Safari\/(\d+)/i); bf = i ? parseInt(i[1]) : 0 } } destroy() { this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null } resetTimeStamp(e) { this.log("initPTS & initDTS reset"), this._initPTS = this._initDTS = e } resetNextTimestamp() { this.log("reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1 } resetInitSegment() { this.log("ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0 } getVideoStartPts(e) { let t = !1; const r = e[0].pts, s = e.reduce((i, a) => { let o = a.pts, c = o - i; return c < -4294967296 && (t = !0, o = kr(o, r), c = o - i), c > 0 ? i : o }, r); return t && this.debug("PTS rollover detected"), s } remux(e, t, r, s, i, a, o, c) { let u, f, h, p, v, g, y = i, w = i; const T = e.pid > -1, S = t.pid > -1, E = t.samples.length, I = e.samples.length > 0, C = o && E > 0 || E > 1; if ((!T || I) && (!S || C) || this.ISGenerated || o) { if (this.ISGenerated) { var R, N, P, _; const V = this.videoTrackConfig; (V && (t.width !== V.width || t.height !== V.height || ((R = t.pixelRatio) == null ? void 0 : R[0]) !== ((N = V.pixelRatio) == null ? void 0 : N[0]) || ((P = t.pixelRatio) == null ? void 0 : P[1]) !== ((_ = V.pixelRatio) == null ? void 0 : _[1])) || !V && C || this.nextAudioTs === null && I) && this.resetInitSegment() } this.ISGenerated || (h = this.generateIS(e, t, i, a)); const M = this.isVideoContiguous; let $ = -1, B; if (C && ($ = oN(t.samples), !M && this.config.forceKeyFrameOnDiscontinuity)) if (g = !0, $ > 0) { this.warn(`Dropped ${$} out of ${E} video samples due to a missing keyframe`); const V = this.getVideoStartPts(t.samples); t.samples = t.samples.slice($), t.dropped += $, w += (t.samples[0].pts - V) / t.inputTimeScale, B = w } else $ === -1 && (this.warn(`No keyframe found out of ${E} video samples`), g = !1); if (this.ISGenerated) { if (I && C) { const V = this.getVideoStartPts(t.samples), U = (kr(e.samples[0].pts, V) - V) / t.inputTimeScale; y += Math.max(0, U), w += Math.max(0, -U) } if (I) { if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"), h = this.generateIS(e, t, i, a)), f = this.remuxAudio(e, y, this.isAudioContiguous, a, S || C || c === ve.AUDIO ? w : void 0), C) { const V = f ? f.endPTS - f.startPTS : 0; t.inputTimeScale || (this.warn("regenerate InitSegment as video detected"), h = this.generateIS(e, t, i, a)), u = this.remuxVideo(t, w, M, V) } } else C && (u = this.remuxVideo(t, w, M, 0)); u && (u.firstKeyFrame = $, u.independent = $ !== -1, u.firstKeyFramePTS = B) } } return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (v = Tw(r, i, this._initPTS, this._initDTS)), s.samples.length && (p = Aw(s, i, this._initPTS))), { audio: f, video: u, initSegment: h, independent: g, text: p, id3: v } } generateIS(e, t, r, s) { const i = e.samples, a = t.samples, o = this.typeSupported, c = {}, u = this._initPTS; let f = !u || s, h = "audio/mp4", p, v, g, y = -1; if (f && (p = v = 1 / 0), e.config && i.length) { switch (e.timescale = e.samplerate, e.segmentCodec) { case "mp3": o.mpeg ? (h = "audio/mpeg", e.codec = "") : o.mp3 && (e.codec = "mp3"); break; case "ac3": e.codec = "ac-3"; break }c.audio = { id: "audio", container: h, codec: e.codec, initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : Q.initSegment([e]), metadata: { channelCount: e.channelCount } }, f && (y = e.id, g = e.inputTimeScale, !u || g !== u.timescale ? p = v = i[0].pts - Math.round(g * r) : f = !1) } if (t.sps && t.pps && a.length) { if (t.timescale = t.inputTimeScale, c.video = { id: "main", container: "video/mp4", codec: t.codec, initSegment: Q.initSegment([t]), metadata: { width: t.width, height: t.height } }, f) if (y = t.id, g = t.inputTimeScale, !u || g !== u.timescale) { const w = this.getVideoStartPts(a), T = Math.round(g * r); v = Math.min(v, kr(a[0].dts, w) - T), p = Math.min(p, w - T) } else f = !1; this.videoTrackConfig = { width: t.width, height: t.height, pixelRatio: t.pixelRatio } } if (Object.keys(c).length) return this.ISGenerated = !0, f ? (u && this.warn(`Timestamps at playlist time: ${s ? "" : "~"}${r} ${p / g} != initPTS: ${u.baseTime / u.timescale} (${u.baseTime}/${u.timescale}) trackId: ${u.trackId}`), this.log(`Found initPTS at playlist time: ${r} offset: ${p / g} (${p}/${g}) trackId: ${y}`), this._initPTS = { baseTime: p, timescale: g, trackId: y }, this._initDTS = { baseTime: v, timescale: g, trackId: y }) : p = g = void 0, { tracks: c, initPTS: p, timescale: g, trackId: y } } remuxVideo(e, t, r, s) { const i = e.inputTimeScale, a = e.samples, o = [], c = a.length, u = this._initPTS, f = u.baseTime * i / u.timescale; let h = this.nextVideoTs, p = 8, v = this.videoSampleDuration, g, y, w = Number.POSITIVE_INFINITY, T = Number.NEGATIVE_INFINITY, S = !1; if (!r || h === null) { const F = f + t * i, H = a[0].pts - kr(a[0].dts, a[0].pts); Ii && h !== null && Math.abs(F - H - (h + f)) < 15e3 ? r = !0 : h = F - H - f } const E = h + f; for (let F = 0; F < c; F++) { const H = a[F]; H.pts = kr(H.pts, E), H.dts = kr(H.dts, E), H.dts < a[F > 0 ? F - 1 : F].dts && (S = !0) } S && a.sort(function (F, H) { const ae = F.dts - H.dts, he = F.pts - H.pts; return ae || he }), g = a[0].dts, y = a[a.length - 1].dts; const I = y - g, C = I ? Math.round(I / (c - 1)) : v || e.inputTimeScale / 30; if (r) { const F = g - E, H = F > C, ae = F < -1; if ((H || ae) && (H ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${ja(F, !0)} ms (${F}dts) hole between fragments detected at ${t.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${ja(-F, !0)} ms (${F}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !ae || E >= a[0].pts || Ii)) { g = E; const he = a[0].pts - F; if (H) a[0].dts = g, a[0].pts = he; else { let de = !0; for (let pe = 0; pe < a.length && !(a[pe].dts > he && de); pe++) { const Ce = a[pe].pts; if (a[pe].dts -= F, a[pe].pts -= F, pe < a.length - 1) { const Ie = a[pe + 1].pts, Pe = a[pe].pts, Ve = Ie <= Pe, rt = Ie <= Ce; de = Ve == rt } } } this.log(`Video: Initial PTS/DTS adjusted: ${ja(he, !0)}/${ja(g, !0)}, delta: ${ja(F, !0)} ms`) } } g = Math.max(0, g); let D = 0, R = 0, N = g; for (let F = 0; F < c; F++) { const H = a[F], ae = H.units, he = ae.length; let de = 0; for (let pe = 0; pe < he; pe++)de += ae[pe].data.length; R += de, D += he, H.length = de, H.dts < N ? (H.dts = N, N += C / 4 | 0 || 1) : N = H.dts, w = Math.min(H.pts, w), T = Math.max(H.pts, T) } y = a[c - 1].dts; const P = R + 4 * D + 8; let _; try { _ = new Uint8Array(P) } catch (F) { this.observer.emit(k.ERROR, k.ERROR, { type: Ee.MUX_ERROR, details: J.REMUX_ALLOC_ERROR, fatal: !1, error: F, bytes: P, reason: `fail allocating video mdat ${P}` }); return } const M = new DataView(_.buffer); M.setUint32(0, P), _.set(Q.types.mdat, 4); let $ = !1, B = Number.POSITIVE_INFINITY, V = Number.POSITIVE_INFINITY, W = Number.NEGATIVE_INFINITY, U = Number.NEGATIVE_INFINITY; for (let F = 0; F < c; F++) { const H = a[F], ae = H.units; let he = 0; for (let Ce = 0, Ie = ae.length; Ce < Ie; Ce++) { const Pe = ae[Ce], Ve = Pe.data, rt = Pe.data.byteLength; M.setUint32(p, rt), p += 4, _.set(Ve, p), p += rt, he += 4 + rt } let de; if (F < c - 1) v = a[F + 1].dts - H.dts, de = a[F + 1].pts - H.pts; else { const Ce = this.config, Ie = F > 0 ? H.dts - a[F - 1].dts : C; if (de = F > 0 ? H.pts - a[F - 1].pts : C, Ce.stretchShortVideoTrack && this.nextAudioTs !== null) { const Pe = Math.floor(Ce.maxBufferHole * i), Ve = (s ? w + s * i : this.nextAudioTs + f) - H.pts; Ve > Pe ? (v = Ve - Ie, v < 0 ? v = Ie : $ = !0, this.log(`It is approximately ${Ve / 90} ms to the next segment; using duration ${v / 90} ms for the last video frame.`)) : v = Ie } else v = Ie } const pe = Math.round(H.pts - H.dts); B = Math.min(B, v), W = Math.max(W, v), V = Math.min(V, de), U = Math.max(U, de), o.push(Uv(H.key, v, he, pe)) } if (o.length) { if (Ii) { if (Ii < 70) { const F = o[0].flags; F.dependsOn = 2, F.isNonSync = 0 } } else if (bf && U - V < W - B && C / W < .025 && o[0].cts === 0) { this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration."); let F = g; for (let H = 0, ae = o.length; H < ae; H++) { const he = F + o[H].duration, de = F + o[H].cts; if (H < ae - 1) { const pe = he + o[H + 1].cts; o[H].duration = pe - de } else o[H].duration = H ? o[H - 1].duration : C; o[H].cts = 0, F = he } } } v = $ || !v ? C : v; const q = y + v; this.nextVideoTs = h = q - f, this.videoSampleDuration = v, this.isVideoContiguous = !0; const Z = { data1: Q.moof(e.sequenceNumber++, g, nt(e, { samples: o })), data2: _, startPTS: (w - f) / i, endPTS: (T + v - f) / i, startDTS: (g - f) / i, endDTS: h / i, type: "video", hasAudio: !1, hasVideo: !0, nb: o.length, dropped: e.dropped }; return e.samples = [], e.dropped = 0, Z } getSamplesPerFrame(e) { switch (e.segmentCodec) { case "mp3": return iN; case "ac3": return aN; default: return sN } } remuxAudio(e, t, r, s, i) { const a = e.inputTimeScale, o = e.samplerate ? e.samplerate : a, c = a / o, u = this.getSamplesPerFrame(e), f = u * c, h = this._initPTS, p = e.segmentCodec === "mp3" && this.typeSupported.mpeg, v = [], g = i !== void 0; let y = e.samples, w = p ? 0 : 8, T = this.nextAudioTs || -1; const S = h.baseTime * a / h.timescale, E = S + t * a; if (this.isAudioContiguous = r = r || y.length && T > 0 && (s && Math.abs(E - (T + S)) < 9e3 || Math.abs(kr(y[0].pts, E) - (T + S)) < 20 * f), y.forEach(function (U) { U.pts = kr(U.pts, E) }), !r || T < 0) { if (y = y.filter(U => U.pts >= 0), !y.length) return; i === 0 ? T = 0 : s && !g ? T = Math.max(0, E - S) : T = y[0].pts - S } if (e.segmentCodec === "aac") { const U = this.config.maxAudioFramesDrift; for (let q = 0, z = T + S; q < y.length; q++) { const X = y[q], Z = X.pts, F = Z - z, H = Math.abs(1e3 * F / a); if (F <= -U * f && g) q === 0 && (this.warn(`Audio frame @ ${(Z / a).toFixed(3)}s overlaps marker by ${Math.round(1e3 * F / a)} ms.`), this.nextAudioTs = T = Z - S, z = Z); else if (F >= U * f && H < nN && g) { let ae = Math.round(F / f); for (z = Z - ae * f; z < 0 && ae && f;)ae--, z += f; q === 0 && (this.nextAudioTs = T = z - S), this.warn(`Injecting ${ae} audio frames @ ${((z - S) / a).toFixed(3)}s due to ${Math.round(1e3 * F / a)} ms gap.`); for (let he = 0; he < ae; he++) { let de = eN.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount); de || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), de = X.unit.subarray()), y.splice(q, 0, { unit: de, pts: z }), z += f, q++ } } X.pts = z, z += f } } let I = null, C = null, D, R = 0, N = y.length; for (; N--;)R += y[N].unit.byteLength; for (let U = 0, q = y.length; U < q; U++) { const z = y[U], X = z.unit; let Z = z.pts; if (C !== null) { const H = v[U - 1]; H.duration = Math.round((Z - C) / c) } else if (r && e.segmentCodec === "aac" && (Z = T + S), I = Z, R > 0) { R += w; try { D = new Uint8Array(R) } catch (H) { this.observer.emit(k.ERROR, k.ERROR, { type: Ee.MUX_ERROR, details: J.REMUX_ALLOC_ERROR, fatal: !1, error: H, bytes: R, reason: `fail allocating audio mdat ${R}` }); return } p || (new DataView(D.buffer).setUint32(0, R), D.set(Q.types.mdat, 4)) } else return; D.set(X, w); const F = X.byteLength; w += F, v.push(Uv(!0, u, F, 0)), C = Z } const P = v.length; if (!P) return; const _ = v[v.length - 1]; T = C - S, this.nextAudioTs = T + c * _.duration; const M = p ? new Uint8Array(0) : Q.moof(e.sequenceNumber++, I / c, nt({}, e, { samples: v })); e.samples = []; const $ = (I - S) / a, B = T / a, W = { data1: M, data2: D, startPTS: $, endPTS: B, startDTS: $, endDTS: B, type: "audio", hasAudio: !0, hasVideo: !1, nb: P }; return this.isAudioContiguous = !0, W } } function kr(n, e) { let t; if (e === null) return n; for (e < n ? t = -8589934592 : t = 8589934592; Math.abs(n - e) > 4294967296;)n += t; return n } function oN(n) { for (let e = 0; e < n.length; e++)if (n[e].key) return e; return -1 } function Tw(n, e, t, r) { const s = n.samples.length; if (!s) return; const i = n.inputTimeScale; for (let o = 0; o < s; o++) { const c = n.samples[o]; c.pts = kr(c.pts - t.baseTime * i / t.timescale, e * i) / i, c.dts = kr(c.dts - r.baseTime * i / r.timescale, e * i) / i } const a = n.samples; return n.samples = [], { samples: a } } function Aw(n, e, t) { const r = n.samples.length; if (!r) return; const s = n.inputTimeScale; for (let a = 0; a < r; a++) { const o = n.samples[a]; o.pts = kr(o.pts - t.baseTime * s / t.timescale, e * s) / s } n.samples.sort((a, o) => a.pts - o.pts); const i = n.samples; return n.samples = [], { samples: i } } class lN extends Pr { constructor(e, t, r, s) { super("passthrough-remuxer", s), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1 } destroy() { } resetTimeStamp(e) { this.lastEndTime = null; const t = this.initPTS; t && e && t.baseTime === e.baseTime && t.timescale === e.timescale || (this.initPTS = e) } resetNextTimestamp() { this.isVideoContiguous = !1, this.lastEndTime = null } resetInitSegment(e, t, r, s) { this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(e, s), this.emitInitSegment = !0 } generateInitSegment(e, t) { let { audioCodec: r, videoCodec: s } = this; if (!(e != null && e.byteLength)) { this.initTracks = void 0, this.initData = void 0; return } const { audio: i, video: a } = this.initData = Db(e); if (t) YR(e, t); else { const c = i || a; c != null && c.encrypted && this.warn(`Init segment with encrypted track with has no key ("${c.codec}")!`) } i && (r = zv(i, st.AUDIO, this)), a && (s = zv(a, st.VIDEO, this)); const o = {}; i && a ? o.audiovideo = { container: "video/mp4", codec: r + "," + s, supplemental: a.supplemental, encrypted: a.encrypted, initSegment: e, id: "main" } : i ? o.audio = { container: "audio/mp4", codec: r, encrypted: i.encrypted, initSegment: e, id: "audio" } : a ? o.video = { container: "video/mp4", codec: s, supplemental: a.supplemental, encrypted: a.encrypted, initSegment: e, id: "main" } : this.warn("initSegment does not contain moov or trak boxes."), this.initTracks = o } remux(e, t, r, s, i, a) { var o, c; let { initPTS: u, lastEndTime: f } = this; const h = { audio: void 0, video: void 0, text: s, id3: r, initSegment: void 0 }; ge(f) || (f = this.lastEndTime = i || 0); const p = t.samples; if (!p.length) return h; const v = { initPTS: void 0, timescale: void 0, trackId: void 0 }; let g = this.initData; if ((o = g) != null && o.length || (this.generateInitSegment(p), g = this.initData), !((c = g) != null && c.length)) return this.warn("Failed to generate initSegment."), h; this.emitInitSegment && (v.tracks = this.initTracks, this.emitInitSegment = !1); const y = XR(p, g, this), w = g.audio ? y[g.audio.id] : null, T = g.video ? y[g.video.id] : null, S = $l(T, 1 / 0), E = $l(w, 1 / 0), I = $l(T, 0, !0), C = $l(w, 0, !0); let D = i, R = 0; const N = w && (!T || !u && E < S || u && u.trackId === g.audio.id), P = N ? w : T; if (P) { const z = P.timescale, X = P.start - i * z, Z = N ? g.audio.id : g.video.id; D = P.start / z, R = N ? C - E : I - S, (a || !u) && (cN(u, D, i, R) || z !== u.timescale) && (u && this.warn(`Timestamps at playlist time: ${a ? "" : "~"}${i} ${X / z} != initPTS: ${u.baseTime / u.timescale} (${u.baseTime}/${u.timescale}) trackId: ${u.trackId}`), this.log(`Found initPTS at playlist time: ${i} offset: ${D - i} (${X}/${z}) trackId: ${Z}`), u = null, v.initPTS = X, v.timescale = z, v.trackId = Z) } else this.warn(`No audio or video samples found for initPTS at playlist time: ${i}`); u ? (v.initPTS = u.baseTime, v.timescale = u.timescale, v.trackId = u.trackId) : ((!v.timescale || v.trackId === void 0 || v.initPTS === void 0) && (this.warn("Could not set initPTS"), v.initPTS = D, v.timescale = 1, v.trackId = -1), this.initPTS = u = { baseTime: v.initPTS, timescale: v.timescale, trackId: v.trackId }); const _ = D - u.baseTime / u.timescale, M = _ + R; R > 0 ? this.lastEndTime = M : (this.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp()); const $ = !!g.audio, B = !!g.video; let V = ""; $ && (V += "audio"), B && (V += "video"); const W = (g.audio ? g.audio.encrypted : !1) || (g.video ? g.video.encrypted : !1), U = { data1: p, startPTS: _, startDTS: _, endPTS: M, endDTS: M, type: V, hasAudio: $, hasVideo: B, nb: 1, dropped: 0, encrypted: W }; h.audio = $ && !B ? U : void 0, h.video = B ? U : void 0; const q = T?.sampleCount; if (q) { const z = T.keyFrameIndex, X = z !== -1; U.nb = q, U.dropped = z === 0 || this.isVideoContiguous ? 0 : X ? z : q, U.independent = X, U.firstKeyFrame = z, X && T.keyFrameStart && (U.firstKeyFramePTS = (T.keyFrameStart - u.baseTime) / u.timescale), this.isVideoContiguous || (h.independent = X), this.isVideoContiguous || (this.isVideoContiguous = X), U.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${z}/${q} dropped: ${U.dropped} start: ${U.firstKeyFramePTS || "NA"}`) } return h.initSegment = v, h.id3 = Tw(r, i, u, u), s.samples.length && (h.text = Aw(s, i, u)), h } } function $l(n, e, t = !1) { return n?.start !== void 0 ? (n.start + (t ? n.duration : 0)) / n.timescale : e } function cN(n, e, t, r) { if (n === null) return !0; const s = Math.max(r, 1), i = e - n.baseTime / n.timescale; return Math.abs(i - t) > s } function zv(n, e, t) { const r = n.codec; return r && r.length > 4 ? r : e === st.AUDIO ? r === "ec-3" || r === "ac-3" || r === "alac" ? r : r === "fLaC" || r === "Opus" ? Ec(r, !1) : (t.warn(`Unhandled audio codec "${r}" in mp4 MAP`), r || "mp4a") : (t.warn(`Unhandled video codec "${r}" in mp4 MAP`), r || "avc1") } let kn; try { kn = self.performance.now.bind(self.performance) } catch { kn = Date.now } const sc = [{ demux: qP, remux: lN }, { demux: fs, remux: nc }, { demux: GP, remux: nc }, { demux: WP, remux: nc }]; sc.splice(2, 0, { demux: HP, remux: nc }); class Vv { constructor(e, t, r, s, i, a) { this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.id = i, this.logger = a } configure(e) { this.transmuxConfig = e, this.decrypter && this.decrypter.reset() } push(e, t, r, s) { const i = r.transmuxing; i.executeStart = kn(); let a = new Uint8Array(e); const { currentTransmuxState: o, transmuxConfig: c } = this; s && (this.currentTransmuxState = s); const { contiguous: u, discontinuity: f, trackSwitch: h, accurateTimeOffset: p, timeOffset: v, initSegmentChange: g } = s || o, { audioCodec: y, videoCodec: w, defaultInitPts: T, duration: S, initSegmentData: E } = c, I = uN(a, t); if (I && Di(I.method)) { const N = this.getDecrypter(), P = bp(I.method); if (N.isSync()) { let _ = N.softwareDecrypt(a, I.key.buffer, I.iv.buffer, P); if (r.part > -1) { const $ = N.flush(); _ = $ && $.buffer } if (!_) return i.executeEnd = kn(), wf(r); a = new Uint8Array(_) } else return this.asyncResult = !0, this.decryptionPromise = N.webCryptoDecrypt(a, I.key.buffer, I.iv.buffer, P).then(_ => { const M = this.push(_, null, r); return this.decryptionPromise = null, M }), this.decryptionPromise } const C = this.needsProbing(f, h); if (C) { const N = this.configureTransmuxer(a); if (N) return this.logger.warn(`[transmuxer] ${N.message}`), this.observer.emit(k.ERROR, k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_PARSING_ERROR, fatal: !1, error: N, reason: N.message }), i.executeEnd = kn(), wf(r) } (f || h || g || C) && this.resetInitSegment(E, y, w, S, t), (f || g || C) && this.resetInitialTimestamp(T), u || this.resetContiguity(); const D = this.transmux(a, I, v, p, r); this.asyncResult = so(D); const R = this.currentTransmuxState; return R.contiguous = !0, R.discontinuity = !1, R.trackSwitch = !1, i.executeEnd = kn(), D } flush(e) { const t = e.transmuxing; t.executeStart = kn(); const { decrypter: r, currentTransmuxState: s, decryptionPromise: i } = this; if (i) return this.asyncResult = !0, i.then(() => this.flush(e)); const a = [], { timeOffset: o } = s; if (r) { const h = r.flush(); h && a.push(this.push(h.buffer, null, e)) } const { demuxer: c, remuxer: u } = this; if (!c || !u) { t.executeEnd = kn(); const h = [wf(e)]; return this.asyncResult ? Promise.resolve(h) : h } const f = c.flush(o); return so(f) ? (this.asyncResult = !0, f.then(h => (this.flushRemux(a, h, e), a))) : (this.flushRemux(a, f, e), this.asyncResult ? Promise.resolve(a) : a) } flushRemux(e, t, r) { const { audioTrack: s, videoTrack: i, id3Track: a, textTrack: o } = t, { accurateTimeOffset: c, timeOffset: u } = this.currentTransmuxState; this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${r.sn}${r.part > -1 ? " part: " + r.part : ""} of ${this.id === ve.MAIN ? "level" : "track"} ${r.level}`); const f = this.remuxer.remux(s, i, a, o, u, c, !0, this.id); e.push({ remuxResult: f, chunkMeta: r }), r.transmuxing.executeEnd = kn() } resetInitialTimestamp(e) { const { demuxer: t, remuxer: r } = this; !t || !r || (t.resetTimeStamp(e), r.resetTimeStamp(e)) } resetContiguity() { const { demuxer: e, remuxer: t } = this; !e || !t || (e.resetContiguity(), t.resetNextTimestamp()) } resetInitSegment(e, t, r, s, i) { const { demuxer: a, remuxer: o } = this; !a || !o || (a.resetInitSegment(e, t, r, s), o.resetInitSegment(e, t, r, i)) } destroy() { this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0) } transmux(e, t, r, s, i) { let a; return t && t.method === "SAMPLE-AES" ? a = this.transmuxSampleAes(e, t, r, s, i) : a = this.transmuxUnencrypted(e, r, s, i), a } transmuxUnencrypted(e, t, r, s) { const { audioTrack: i, videoTrack: a, id3Track: o, textTrack: c } = this.demuxer.demux(e, t, !1, !this.config.progressive); return { remuxResult: this.remuxer.remux(i, a, o, c, t, r, !1, this.id), chunkMeta: s } } transmuxSampleAes(e, t, r, s, i) { return this.demuxer.demuxSampleAes(e, t, r).then(a => ({ remuxResult: this.remuxer.remux(a.audioTrack, a.videoTrack, a.id3Track, a.textTrack, r, s, !1, this.id), chunkMeta: i })) } configureTransmuxer(e) { const { config: t, observer: r, typeSupported: s } = this; let i; for (let h = 0, p = sc.length; h < p; h++) { var a; if ((a = sc[h].demux) != null && a.probe(e, this.logger)) { i = sc[h]; break } } if (!i) return new Error("Failed to find demuxer by probing fragment data"); const o = this.demuxer, c = this.remuxer, u = i.remux, f = i.demux; (!c || !(c instanceof u)) && (this.remuxer = new u(r, t, s, this.logger)), (!o || !(o instanceof f)) && (this.demuxer = new f(r, t, s, this.logger), this.probe = f.probe) } needsProbing(e, t) { return !this.demuxer || !this.remuxer || e || t } getDecrypter() { let e = this.decrypter; return e || (e = this.decrypter = new xp(this.config)), e } } function uN(n, e) { let t = null; return n.byteLength > 0 && e?.key != null && e.iv !== null && e.method != null && (t = e), t } const wf = n => ({ remuxResult: {}, chunkMeta: n }); function so(n) { return "then" in n && n.then instanceof Function } class dN { constructor(e, t, r, s, i) { this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = s, this.defaultInitPts = i || null } } class fN { constructor(e, t, r, s, i, a) { this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = s, this.timeOffset = i, this.initSegmentChange = a } } let Gv = 0; class Iw {
    constructor(e, t, r, s) { this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = Gv++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = c => { const u = c.data, f = this.hls; if (!(!f || !(u != null && u.event) || u.instanceNo !== this.instanceNo)) switch (u.event) { case "init": { var h; const p = (h = this.workerContext) == null ? void 0 : h.objectURL; p && self.URL.revokeObjectURL(p); break } case "transmuxComplete": { this.handleTransmuxComplete(u.data); break } case "flush": { this.onFlush(u.data); break } case "workerLog": { f.logger[u.data.logType] && f.logger[u.data.logType](u.data.message); break } default: { u.data = u.data || {}, u.data.frag = this.frag, u.data.part = this.part, u.data.id = this.id, f.trigger(u.event, u.data); break } } }, this.onWorkerError = c => { if (!this.hls) return; const u = new Error(`${c.message}  (${c.filename}:${c.lineno})`); this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.INTERNAL_EXCEPTION, fatal: !1, event: "demuxerWorker", error: u }) }; const i = e.config; this.hls = e, this.id = t, this.useWorker = !!i.enableWorker, this.onTransmuxComplete = r, this.onFlush = s; const a = (c, u) => { u = u || {}, u.frag = this.frag || void 0, c === k.ERROR && (u = u, u.parent = this.id, u.part = this.part, this.error = u.error), this.hls.trigger(c, u) }; this.observer = new Ep, this.observer.on(k.FRAG_DECRYPTED, a), this.observer.on(k.ERROR, a); const o = ov(i.preferManagedMediaSource); if (this.useWorker && typeof Worker < "u") { const c = this.hls.logger; if (i.workerPath || gP()) { try { i.workerPath ? (c.log(`loading Web Worker ${i.workerPath} for "${t}"`), this.workerContext = vP(i.workerPath)) : (c.log(`injecting Web Worker for "${t}"`), this.workerContext = xP()); const { worker: f } = this.workerContext; f.addEventListener("message", this.onWorkerMessage), f.addEventListener("error", this.onWorkerError), f.postMessage({ instanceNo: this.instanceNo, cmd: "init", typeSupported: o, id: t, config: it(i) }) } catch (f) { c.warn(`Error setting up "${t}" Web Worker, fallback to inline`, f), this.terminateWorker(), this.error = null, this.transmuxer = new Vv(this.observer, o, i, "", t, e.logger) } return } } this.transmuxer = new Vv(this.observer, o, i, "", t, e.logger) } reset() { if (this.frag = null, this.part = null, this.workerContext) { const e = this.instanceNo; this.instanceNo = Gv++; const t = this.hls.config, r = ov(t.preferManagedMediaSource); this.workerContext.worker.postMessage({ instanceNo: this.instanceNo, cmd: "reset", resetNo: e, typeSupported: r, id: this.id, config: it(t) }) } } terminateWorker() { if (this.workerContext) { const { worker: e } = this.workerContext; this.workerContext = null, e.removeEventListener("message", this.onWorkerMessage), e.removeEventListener("error", this.onWorkerError), yP(this.hls.config.workerPath) } } destroy() { if (this.workerContext) this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null; else { const t = this.transmuxer; t && (t.destroy(), this.transmuxer = null) } const e = this.observer; e && e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null } push(e, t, r, s, i, a, o, c, u, f) {
      var h, p; u.transmuxing.start = self.performance.now(); const { instanceNo: v, transmuxer: g } = this, y = a ? a.start : i.start, w = i.decryptdata, T = this.frag, S = !(T && i.cc === T.cc), E = !(T && u.level === T.level), I = T ? u.sn - T.sn : -1, C = this.part ? u.part - this.part.index : -1, D = I === 0 && u.id > 1 && u.id === T?.stats.chunkCount, R = !E && (I === 1 || I === 0 && (C === 1 || D && C <= 0)), N = self.performance.now(); (E || I || i.stats.parsing.start === 0) && (i.stats.parsing.start = N), a && (C || !R) && (a.stats.parsing.start = N); const P = !(T && ((h = i.initSegment) == null ? void 0 : h.url) === ((p = T.initSegment) == null ? void 0 : p.url)), _ = new fN(S, R, c, E, y, P); if (!R || S || P) {
        this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${i.type} sn: ${u.sn}${u.part > -1 ? " part: " + u.part : ""} ${this.id === ve.MAIN ? "level" : "track"}: ${u.level} id: ${u.id}
        discontinuity: ${S}
        trackSwitch: ${E}
        contiguous: ${R}
        accurateTimeOffset: ${c}
        timeOffset: ${y}
        initSegmentChange: ${P}`); const M = new dN(r, s, t, o, f); this.configureTransmuxer(M)
      } if (this.frag = i, this.part = a, this.workerContext) this.workerContext.worker.postMessage({ instanceNo: v, cmd: "demux", data: e, decryptdata: w, chunkMeta: u, state: _ }, e instanceof ArrayBuffer ? [e] : []); else if (g) { const M = g.push(e, w, u, _); so(M) ? M.then($ => { this.handleTransmuxComplete($) }).catch($ => { this.transmuxerError($, u, "transmuxer-interface push error") }) : this.handleTransmuxComplete(M) }
    } flush(e) { e.transmuxing.start = self.performance.now(); const { instanceNo: t, transmuxer: r } = this; if (this.workerContext) this.workerContext.worker.postMessage({ instanceNo: t, cmd: "flush", chunkMeta: e }); else if (r) { const s = r.flush(e); so(s) ? s.then(i => { this.handleFlushResult(i, e) }).catch(i => { this.transmuxerError(i, e, "transmuxer-interface flush error") }) : this.handleFlushResult(s, e) } } transmuxerError(e, t, r) { this.hls && (this.error = e, this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_PARSING_ERROR, chunkMeta: t, frag: this.frag || void 0, part: this.part || void 0, fatal: !1, error: e, err: e, reason: r })) } handleFlushResult(e, t) { e.forEach(r => { this.handleTransmuxComplete(r) }), this.onFlush(t) } configureTransmuxer(e) { const { instanceNo: t, transmuxer: r } = this; this.workerContext ? this.workerContext.worker.postMessage({ instanceNo: t, cmd: "configure", config: e }) : r && r.configure(e) } handleTransmuxComplete(e) { e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e) }
  } const Hv = 100; class hN extends Sp { constructor(e, t, r) { super(e, t, r, "audio-stream-controller", ve.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners() } onHandlerDestroying() { this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem() } resetItem() { this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null } registerListeners() { super.registerListeners(); const { hls: e } = this; e.on(k.LEVEL_LOADED, this.onLevelLoaded, this), e.on(k.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(k.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(k.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(k.BUFFER_RESET, this.onBufferReset, this), e.on(k.BUFFER_CREATED, this.onBufferCreated, this), e.on(k.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(k.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(k.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(k.FRAG_LOADING, this.onFragLoading, this), e.on(k.FRAG_BUFFERED, this.onFragBuffered, this) } unregisterListeners() { const { hls: e } = this; e && (super.unregisterListeners(), e.off(k.LEVEL_LOADED, this.onLevelLoaded, this), e.off(k.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(k.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(k.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(k.BUFFER_RESET, this.onBufferReset, this), e.off(k.BUFFER_CREATED, this.onBufferCreated, this), e.off(k.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(k.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(k.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(k.FRAG_LOADING, this.onFragLoading, this), e.off(k.FRAG_BUFFERED, this.onFragBuffered, this)) } onInitPtsFound(e, { frag: t, id: r, initPTS: s, timescale: i, trackId: a }) { if (r === ve.MAIN) { const o = t.cc, c = this.fragCurrent; if (this.initPTS[o] = { baseTime: s, timescale: i, trackId: a }, this.log(`InitPTS for cc: ${o} found from main: ${s / i} (${s}/${i}) trackId: ${a}`), this.mainAnchor = t, this.state === se.WAITING_INIT_PTS) { const u = this.waitingData; (!u && !this.loadingParts || u && u.frag.cc !== o) && this.syncWithAnchor(t, u?.frag) } else !this.hls.hasEnoughToStart && c && c.cc !== o ? (c.abortRequests(), this.syncWithAnchor(t, c)) : this.state === se.IDLE && this.tick() } } getLoadPosition() { return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition() } syncWithAnchor(e, t) { var r; const s = ((r = this.mainFragLoading) == null ? void 0 : r.frag) || null; if (t && s?.cc === t.cc) return; const i = (s || e).cc, a = this.getLevelDetails(), o = this.getLoadPosition(), c = Gb(a, i, o); c && (this.log(`Syncing with main frag at ${c.start} cc ${c.cc}`), this.startFragRequested = !1, this.nextLoadPosition = c.start, this.resetLoadingState(), this.state === se.IDLE && this.doTickIdle()) } startLoad(e, t) { if (!this.levels) { this.startPosition = e, this.state = se.STOPPED; return } const r = this.lastCurrentTime; this.stopLoad(), this.setInterval(Hv), r > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r, this.state = se.IDLE) : this.state = se.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick() } doTick() { switch (this.state) { case se.IDLE: this.doTickIdle(); break; case se.WAITING_TRACK: { const { levels: e, trackId: t } = this, r = e?.[t], s = r?.details; if (s && !this.waitForLive(r)) { if (this.waitForCdnTuneIn(s)) break; this.state = se.WAITING_INIT_PTS } break } case se.FRAG_LOADING_WAITING_RETRY: { this.checkRetryDate(); break } case se.WAITING_INIT_PTS: { const e = this.waitingData; if (e) { const { frag: t, part: r, cache: s, complete: i } = e, a = this.mainAnchor; if (this.initPTS[t.cc] !== void 0) { this.waitingData = null, this.state = se.FRAG_LOADING; const o = s.flush().buffer, c = { frag: t, part: r, payload: o, networkDetails: null }; this._handleFragmentLoadProgress(c), i && super._handleFragmentLoadComplete(c) } else a && a.cc !== e.frag.cc && this.syncWithAnchor(a, e.frag) } else this.state = se.IDLE } }this.onTickEnd() } resetLoadingState() { const e = this.waitingData; e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState() } onTickEnd() { const { media: e } = this; e != null && e.readyState && (this.lastCurrentTime = e.currentTime) } doTickIdle() { var e; const { hls: t, levels: r, media: s, trackId: i } = this, a = t.config; if (!this.buffering || !s && !this.primaryPrefetch && (this.startFragRequested || !a.startFragPrefetch) || !(r != null && r[i])) return; const o = r[i], c = o.details; if (!c || this.waitForLive(o) || this.waitForCdnTuneIn(c)) { this.state = se.WAITING_TRACK, this.startFragRequested = !1; return } const u = this.mediaBuffer ? this.mediaBuffer : this.media; this.bufferFlushed && u && (this.bufferFlushed = !1, this.afterBufferFlushed(u, st.AUDIO, ve.AUDIO)); const f = this.getFwdBufferInfo(u, ve.AUDIO); if (f === null) return; if (!this.switchingTrack && this._streamEnded(f, c)) { t.trigger(k.BUFFER_EOS, { type: "audio" }), this.state = se.ENDED; return } const h = f.len, p = t.maxBufferLength, v = c.fragments, g = v[0].start, y = this.getLoadPosition(), w = this.flushing ? y : f.end; if (this.switchingTrack && s) { const E = y; c.PTSKnown && E < g && (f.end > g || f.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), s.currentTime = g + .05) } if (h >= p && !this.switchingTrack && w < v[v.length - 1].start) return; let T = this.getNextFragment(w, c); if (T && this.isLoopLoading(T, w) && (T = this.getNextFragmentLoopLoading(T, c, f, ve.MAIN, p)), !T) { this.bufferFlushed = !0; return } let S = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null; if (!this.audioOnly && this.startFragRequested && S && At(T) && !T.endList && (!c.live || !this.loadingParts && w < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(S) === Rt.OK && (this.mainFragLoading = S = null), S && At(S))) { if (T.start > S.end) { const I = this.fragmentTracker.getFragAtPos(w, ve.MAIN); I && I.end > S.end && (S = I, this.mainFragLoading = { frag: I, targetBufferTime: null }) } if (T.start > S.end) return } this.loadFragment(T, o, w) } onMediaDetaching(e, t) { this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, t) } onAudioTracksUpdated(e, { audioTracks: t }) { this.resetTransmuxer(), this.levels = t.map(r => new eo(r)) } onAudioTrackSwitching(e, t) { const r = !!t.url; this.trackId = t.id; const { fragCurrent: s } = this; s && (s.abortRequests(), this.removeUnbufferedFrags(s.start)), this.resetLoadingState(), r ? (this.switchingTrack = t, this.flushAudioIfNeeded(t), this.state !== se.STOPPED && (this.setInterval(Hv), this.state = se.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = t, this.clearInterval()) } onManifestLoading() { super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1 } onLevelLoaded(e, t) { this.mainDetails = t.details; const r = this.cachedTrackLoadedData; r && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(k.AUDIO_TRACK_LOADED, r)) } onAudioTrackLoaded(e, t) { var r; const { levels: s } = this, { details: i, id: a, groupId: o, track: c } = t; if (!s) { this.warn(`Audio tracks reset while loading track ${a} "${c.name}" of "${o}"`); return } const u = this.mainDetails; if (!u || i.endCC > u.endCC || u.expired) { this.cachedTrackLoadedData = t, this.state !== se.STOPPED && (this.state = se.WAITING_TRACK); return } this.cachedTrackLoadedData = null, this.log(`Audio track ${a} "${c.name}" of "${o}" loaded [${i.startSN},${i.endSN}]${i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : ""},duration:${i.totalduration}`); const f = s[a]; let h = 0; if (i.live || (r = f.details) != null && r.live) { if (this.checkLiveUpdate(i), i.deltaUpdateFailed) return; if (f.details) { var p; h = this.alignPlaylists(i, f.details, (p = this.levelLastLoaded) == null ? void 0 : p.details) } i.alignedSliding || (aw(i, u), i.alignedSliding || kc(i, u), h = i.fragmentStart) } f.details = i, this.levelLastLoaded = f, this.startFragRequested || this.setStartPosition(u, h), this.hls.trigger(k.AUDIO_TRACK_UPDATED, { details: i, id: a, groupId: t.groupId }), this.state === se.WAITING_TRACK && !this.waitForCdnTuneIn(i) && (this.state = se.IDLE), this.tick() } _handleFragmentLoadProgress(e) { var t; const r = e.frag, { part: s, payload: i } = e, { config: a, trackId: o, levels: c } = this; if (!c) { this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`); return } const u = c[o]; if (!u) { this.warn("Audio track is undefined on fragment load progress"); return } const f = u.details; if (!f) { this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(r.start); return } const h = a.defaultAudioCodec || u.audioCodec || "mp4a.40.2"; let p = this.transmuxer; p || (p = this.transmuxer = new Iw(this.hls, ve.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this))); const v = this.initPTS[r.cc], g = (t = r.initSegment) == null ? void 0 : t.data; if (v !== void 0) { const w = s ? s.index : -1, T = w !== -1, S = new vp(r.level, r.sn, r.stats.chunkCount, i.byteLength, w, T); p.push(i, g, h, "", r, s, f.totalduration, !1, S, v) } else { this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${f.startSN} ,${f.endSN}],track ${o}`); const { cache: y } = this.waitingData = this.waitingData || { frag: r, part: s, cache: new ow, complete: !1 }; y.push(new Uint8Array(i)), this.state !== se.STOPPED && (this.state = se.WAITING_INIT_PTS) } } _handleFragmentLoadComplete(e) { if (this.waitingData) { this.waitingData.complete = !0; return } super._handleFragmentLoadComplete(e) } onBufferReset() { this.mediaBuffer = null } onBufferCreated(e, t) { this.bufferFlushed = this.flushing = !1; const r = t.tracks.audio; r && (this.mediaBuffer = r.buffer || null) } onFragLoading(e, t) { !this.audioOnly && t.frag.type === ve.MAIN && At(t.frag) && (this.mainFragLoading = t, this.state === se.IDLE && this.tick()) } onFragBuffered(e, t) { const { frag: r, part: s } = t; if (r.type !== ve.AUDIO) { !this.audioOnly && r.type === ve.MAIN && !r.elementaryStreams.video && !r.elementaryStreams.audiovideo && (this.audioOnly = !0, this.mainFragLoading = null); return } if (this.fragContextChanged(r)) { this.warn(`Fragment ${r.sn}${s ? " p: " + s.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`); return } if (At(r)) { this.fragPrevious = r; const i = this.switchingTrack; i && (this.bufferedTrack = i, this.switchingTrack = null, this.hls.trigger(k.AUDIO_TRACK_SWITCHED, et({}, i))) } this.fragBufferedComplete(r, s), this.media && this.tick() } onError(e, t) { var r; if (t.fatal) { this.state = se.ERROR; return } switch (t.details) { case J.FRAG_GAP: case J.FRAG_PARSING_ERROR: case J.FRAG_DECRYPT_ERROR: case J.FRAG_LOAD_ERROR: case J.FRAG_LOAD_TIMEOUT: case J.KEY_LOAD_ERROR: case J.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(ve.AUDIO, t); break; case J.AUDIO_TRACK_LOAD_ERROR: case J.AUDIO_TRACK_LOAD_TIMEOUT: case J.LEVEL_PARSING_ERROR: !t.levelRetry && this.state === se.WAITING_TRACK && ((r = t.context) == null ? void 0 : r.type) === He.AUDIO_TRACK && (this.state = se.IDLE); break; case J.BUFFER_ADD_CODEC_ERROR: case J.BUFFER_APPEND_ERROR: if (t.parent !== "audio") return; this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState(); break; case J.BUFFER_FULL_ERROR: if (t.parent !== "audio") return; this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")); break; case J.INTERNAL_EXCEPTION: this.recoverWorkerError(t); break } } onBufferFlushing(e, { type: t }) { t !== st.VIDEO && (this.flushing = !0) } onBufferFlushed(e, { type: t }) { if (t !== st.VIDEO) { this.flushing = !1, this.bufferFlushed = !0, this.state === se.ENDED && (this.state = se.IDLE); const r = this.mediaBuffer || this.media; r && (this.afterBufferFlushed(r, t, ve.AUDIO), this.tick()) } } _handleTransmuxComplete(e) { var t; const r = "audio", { hls: s } = this, { remuxResult: i, chunkMeta: a } = e, o = this.getCurrentContext(a); if (!o) { this.resetWhenMissingContext(a); return } const { frag: c, part: u, level: f } = o, { details: h } = f, { audio: p, text: v, id3: g, initSegment: y } = i; if (this.fragContextChanged(c) || !h) { this.fragmentTracker.removeFragment(c); return } if (this.state = se.PARSING, this.switchingTrack && p && this.completeAudioSwitch(this.switchingTrack), y != null && y.tracks) { const w = c.initSegment || c; if (this.unhandledEncryptionError(y, c)) return; this._bufferInitSegment(f, y.tracks, w, a), s.trigger(k.FRAG_PARSING_INIT_SEGMENT, { frag: w, id: r, tracks: y.tracks }) } if (p) { const { startPTS: w, endPTS: T, startDTS: S, endDTS: E } = p; u && (u.elementaryStreams[st.AUDIO] = { startPTS: w, endPTS: T, startDTS: S, endDTS: E }), c.setElementaryStreamInfo(st.AUDIO, w, T, S, E), this.bufferFragmentData(p, c, u, a) } if (g != null && (t = g.samples) != null && t.length) { const w = nt({ id: r, frag: c, details: h }, g); s.trigger(k.FRAG_PARSING_METADATA, w) } if (v) { const w = nt({ id: r, frag: c, details: h }, v); s.trigger(k.FRAG_PARSING_USERDATA, w) } } _bufferInitSegment(e, t, r, s) { if (this.state !== se.PARSING || (t.video && delete t.video, t.audiovideo && delete t.audiovideo, !t.audio)) return; const i = t.audio; i.id = ve.AUDIO; const a = e.audioCodec; this.log(`Init audio buffer, container:${i.container}, codecs[level/parsed]=[${a}/${i.codec}]`), a && a.split(",").length === 1 && (i.levelCodec = a), this.hls.trigger(k.BUFFER_CODECS, t); const o = i.initSegment; if (o != null && o.byteLength) { const c = { type: "audio", frag: r, part: null, chunkMeta: s, parent: r.type, data: o }; this.hls.trigger(k.BUFFER_APPENDING, c) } this.tickImmediate() } loadFragment(e, t, r) { const s = this.fragmentTracker.getState(e); if (this.switchingTrack || s === Rt.NOT_LOADED || s === Rt.PARTIAL) { var i; if (!At(e)) this._loadInitSegment(e, t); else if ((i = t.details) != null && i.live && !this.initPTS[e.cc]) { this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = se.WAITING_INIT_PTS; const a = this.mainDetails; a && a.fragmentStart !== t.details.fragmentStart && kc(t.details, a) } else super.loadFragment(e, t, r) } else this.clearTrackerIfNeeded(e) } flushAudioIfNeeded(e) { if (this.media && this.bufferedTrack) { const { name: t, lang: r, assocLang: s, characteristics: i, audioCodec: a, channels: o } = this.bufferedTrack; Hs({ name: t, lang: r, assocLang: s, characteristics: i, audioCodec: a, channels: o }, e, Bs) || (Ac(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = e) } } completeAudioSwitch(e) { const { hls: t } = this; this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(k.AUDIO_TRACK_SWITCHED, et({}, e)) } } class Rp extends Pr { constructor(e, t) { super(t, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e } destroy() { this.clearTimer(), this.hls = this.log = this.warn = null } clearTimer() { this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1) } startLoad() { this.canLoad = !0, this.loadPlaylist() } stopLoad() { this.canLoad = !1, this.clearTimer() } switchParams(e, t, r) { const s = t?.renditionReports; if (s) { let i = -1; for (let a = 0; a < s.length; a++) { const o = s[a]; let c; try { c = new self.URL(o.URI, t.url).href } catch (u) { this.warn(`Could not construct new URL for Rendition Report: ${u}`), c = o.URI || "" } if (c === e) { i = a; break } else c === e.substring(0, c.length) && (i = a) } if (i !== -1) { const a = s[i], o = parseInt(a["LAST-MSN"]) || t.lastPartSn; let c = parseInt(a["LAST-PART"]) || t.lastPartIndex; if (this.hls.config.lowLatencyMode) { const f = Math.min(t.age - t.partTarget, t.targetduration); c >= 0 && f > t.partTarget && (c += 1) } const u = r && lv(r); return new cv(o, c >= 0 ? c : void 0, u) } } } loadPlaylist(e) { this.clearTimer() } loadingPlaylist(e, t) { this.clearTimer() } shouldLoadPlaylist(e) { return this.canLoad && !!e && !!e.url && (!e.details || e.details.live) } getUrlWithDirectives(e, t) { if (t) try { return t.addDirectives(e) } catch (r) { this.warn(`Could not construct new URL with HLS Delivery Directives: ${r}`) } return e } playlistLoaded(e, t, r) { const { details: s, stats: i } = t, a = self.performance.now(), o = i.loading.first ? Math.max(0, a - i.loading.first) : 0; s.advancedDateTime = Date.now() - o; const c = this.hls.config.timelineOffset; if (c !== s.appliedTimelineOffset) { const f = Math.max(c || 0, 0); s.appliedTimelineOffset = f, s.fragments.forEach(h => { h.setStart(h.playlistOffset + f) }) } if (s.live || r != null && r.live) { const f = "levelInfo" in t ? t.levelInfo : t.track; if (s.reloaded(r), r && s.fragments.length > 0) { iP(r, s, this); const S = s.playlistParsingError; if (S) { this.warn(S); const E = this.hls; if (!E.config.ignorePlaylistParsingErrors) { var u; const { networkDetails: I } = t; E.trigger(k.ERROR, { type: Ee.NETWORK_ERROR, details: J.LEVEL_PARSING_ERROR, fatal: !1, url: s.url, error: S, reason: S.message, level: t.level || void 0, parent: (u = s.fragments[0]) == null ? void 0 : u.type, networkDetails: I, stats: i }); return } s.playlistParsingError = null } } s.requestScheduled === -1 && (s.requestScheduled = i.loading.start); const h = this.hls.mainForwardBufferInfo, p = h ? h.end - h.len : 0, v = (s.edge - p) * 1e3, g = tw(s, v); if (s.requestScheduled + g < a ? s.requestScheduled = a : s.requestScheduled += g, this.log(`live playlist ${e} ${s.advanced ? "REFRESHED " + s.lastPartSn + "-" + s.lastPartIndex : s.updated ? "UPDATED" : "MISSED"}`), !this.canLoad || !s.live) return; let y, w, T; if (s.canBlockReload && s.endSN && s.advanced) { const S = this.hls.config.lowLatencyMode, E = s.lastPartSn, I = s.endSN, C = s.lastPartIndex, D = C !== -1, R = E === I; D ? R ? (w = I + 1, T = S ? 0 : C) : (w = E, T = S ? C + 1 : s.maxPartIndex) : w = I + 1; const N = s.age, P = N + s.ageHeader; let _ = Math.min(P - s.partTarget, s.targetduration * 1.5); if (_ > 0) { if (P > s.targetduration * 3) this.log(`Playlist last advanced ${N.toFixed(2)}s ago. Omitting segment and part directives.`), w = void 0, T = void 0; else if (r != null && r.tuneInGoal && P - s.partTarget > r.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${_} with playlist age: ${s.age}`), _ = 0; else { const M = Math.floor(_ / s.targetduration); if (w += M, T !== void 0) { const $ = Math.round(_ % s.targetduration / s.partTarget); T += $ } this.log(`CDN Tune-in age: ${s.ageHeader}s last advanced ${N.toFixed(2)}s goal: ${_} skip sn ${M} to part ${T}`) } s.tuneInGoal = _ } if (y = this.getDeliveryDirectives(s, t.deliveryDirectives, w, T), S || !R) { s.requestScheduled = a, this.loadingPlaylist(f, y); return } } else (s.canBlockReload || s.canSkipUntil) && (y = this.getDeliveryDirectives(s, t.deliveryDirectives, w, T)); y && w !== void 0 && s.canBlockReload && (s.requestScheduled = i.loading.first + Math.max(g - o * 2, g / 2)), this.scheduleLoading(f, y, s) } else this.clearTimer() } scheduleLoading(e, t, r) { const s = r || e.details; if (!s) { this.loadingPlaylist(e, t); return } const i = self.performance.now(), a = s.requestScheduled; if (i >= a) { this.loadingPlaylist(e, t); return } const o = a - i; this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(o)} ms`), this.clearTimer(), this.timer = self.setTimeout(() => this.loadingPlaylist(e, t), o) } getDeliveryDirectives(e, t, r, s) { let i = lv(e); return t != null && t.skip && e.deltaUpdateFailed && (r = t.msn, s = t.part, i = tc.No), new cv(r, s, i) } checkRetry(e) { const t = e.details, r = Ic(e), s = e.errorAction, { action: i, retryCount: a = 0, retryConfig: o } = s || {}, c = !!s && !!o && (i === $t.RetryRequest || !s.resolved && i === $t.SendAlternateToPenaltyBox); if (c) { var u; if (a >= o.maxNumRetry) return !1; if (r && (u = e.context) != null && u.deliveryDirectives) this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist(); else { const f = gp(o, a); this.clearTimer(), this.timer = self.setTimeout(() => this.loadPlaylist(), f), this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" in ${f}ms`) } e.levelRetry = !0, s.resolved = !0 } return c } } function Lw(n, e) { if (n.length !== e.length) return !1; for (let t = 0; t < n.length; t++)if (!io(n[t].attrs, e[t].attrs)) return !1; return !0 } function io(n, e, t) { const r = n["STABLE-RENDITION-ID"]; return r && !t ? r === e["STABLE-RENDITION-ID"] : !(t || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(s => n[s] !== e[s]) } function Ch(n, e) { return e.label.toLowerCase() === n.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (n.lang || "").toLowerCase()) } class pN extends Rp { constructor(e) { super(e, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners() } registerListeners() { const { hls: e } = this; e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_PARSED, this.onManifestParsed, this), e.on(k.LEVEL_LOADING, this.onLevelLoading, this), e.on(k.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(k.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(k.ERROR, this.onError, this) } unregisterListeners() { const { hls: e } = this; e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_PARSED, this.onManifestParsed, this), e.off(k.LEVEL_LOADING, this.onLevelLoading, this), e.off(k.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(k.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(k.ERROR, this.onError, this) } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy() } onManifestLoading() { this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.audioTracks || [] } onAudioTrackLoaded(e, t) { const { id: r, groupId: s, details: i } = t, a = this.tracksInGroup[r]; if (!a || a.groupId !== s) { this.warn(`Audio track with id:${r} and group:${s} not found in active group ${a?.groupId}`); return } const o = a.details; a.details = t.details, this.log(`Audio track ${r} "${a.name}" lang:${a.lang} group:${s} loaded [${i.startSN}-${i.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, o) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { const t = this.hls.levels[e]; if (!t) return; const r = t.audioGroups || null, s = this.groupIds; let i = this.currentTrack; if (!r || s?.length !== r?.length || r != null && r.some(o => s?.indexOf(o) === -1)) { this.groupIds = r, this.trackId = -1, this.currentTrack = null; const o = this.tracks.filter(p => !r || r.indexOf(p.groupId) !== -1); if (o.length) this.selectDefaultTrack && !o.some(p => p.default) && (this.selectDefaultTrack = !1), o.forEach((p, v) => { p.id = v }); else if (!i && !this.tracksInGroup.length) return; this.tracksInGroup = o; const c = this.hls.config.audioPreference; if (!i && c) { const p = cn(c, o, Bs); if (p > -1) i = o[p]; else { const v = cn(c, this.tracks); i = this.tracks[v] } } let u = this.findTrackId(i); u === -1 && i && (u = this.findTrackId(null)); const f = { audioTracks: o }; this.log(`Updating audio tracks, ${o.length} track(s) found in group(s): ${r?.join(",")}`), this.hls.trigger(k.AUDIO_TRACKS_UPDATED, f); const h = this.trackId; if (u !== -1 && h === -1) this.setAudioTrack(u); else if (o.length && h === -1) { var a; const p = new Error(`No audio track selected for current audio group-ID(s): ${(a = this.groupIds) == null ? void 0 : a.join(",")} track count: ${o.length}`); this.warn(p.message), this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.AUDIO_TRACK_LOAD_ERROR, fatal: !0, error: p }) } } } onError(e, t) { t.fatal || !t.context || t.context.type === He.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t) } get allAudioTracks() { return this.tracks } get audioTracks() { return this.tracksInGroup } get audioTrack() { return this.trackId } set audioTrack(e) { this.selectDefaultTrack = !1, this.setAudioTrack(e) } setAudioOption(e) { const t = this.hls; if (t.config.audioPreference = e, e) { const r = this.allAudioTracks; if (this.selectDefaultTrack = !1, r.length) { const s = this.currentTrack; if (s && Hs(e, s, Bs)) return s; const i = cn(e, this.tracksInGroup, Bs); if (i > -1) { const a = this.tracksInGroup[i]; return this.setAudioTrack(i), a } else if (s) { let a = t.loadLevel; a === -1 && (a = t.firstAutoLevel); const o = A_(e, t.levels, r, a, Bs); if (o === -1) return null; t.nextLoadLevel = o } if (e.channels || e.audioCodec) { const a = cn(e, r); if (a > -1) return r[a] } } } return null } setAudioTrack(e) { const t = this.tracksInGroup; if (e < 0 || e >= t.length) { this.warn(`Invalid audio track id: ${e}`); return } this.selectDefaultTrack = !1; const r = this.currentTrack, s = t[e], i = s.details && !s.details.live; if (e === this.trackId && s === r && i || (this.log(`Switching to audio-track ${e} "${s.name}" lang:${s.lang} group:${s.groupId} channels:${s.channels}`), this.trackId = e, this.currentTrack = s, this.hls.trigger(k.AUDIO_TRACK_SWITCHING, et({}, s)), i)) return; const a = this.switchParams(s.url, r?.details, s.details); this.loadPlaylist(a) } findTrackId(e) { const t = this.tracksInGroup; for (let r = 0; r < t.length; r++) { const s = t[r]; if (!(this.selectDefaultTrack && !s.default) && (!e || Hs(e, s, Bs))) return r } if (e) { const { name: r, lang: s, assocLang: i, characteristics: a, audioCodec: o, channels: c } = e; for (let u = 0; u < t.length; u++) { const f = t[u]; if (Hs({ name: r, lang: s, assocLang: i, characteristics: a, audioCodec: o, channels: c }, f, Bs)) return u } for (let u = 0; u < t.length; u++) { const f = t[u]; if (io(e.attrs, f.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return u } for (let u = 0; u < t.length; u++) { const f = t[u]; if (io(e.attrs, f.attrs, ["LANGUAGE"])) return u } } return -1 } loadPlaylist(e) { super.loadPlaylist(); const t = this.currentTrack; this.shouldLoadPlaylist(t) && Ac(t.url, this.hls) && this.scheduleLoading(t, e) } loadingPlaylist(e, t) { super.loadingPlaylist(e, t); const r = e.id, s = e.groupId, i = this.getUrlWithDirectives(e.url, t), a = e.details, o = a?.age; this.log(`Loading audio-track ${r} "${e.name}" lang:${e.lang} group:${s}${t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${i}`), this.hls.trigger(k.AUDIO_TRACK_LOADING, { url: i, id: r, groupId: s, deliveryDirectives: t || null, track: e }) } } class mN {
    constructor(e) { this.tracks = void 0, this.queues = { video: [], audio: [], audiovideo: [] }, this.tracks = e } destroy() { this.tracks = this.queues = null } append(e, t, r) { if (this.queues === null || this.tracks === null) return; const s = this.queues[t]; s.push(e), s.length === 1 && !r && this.executeNext(t) } appendBlocker(e) { return new Promise(t => { const r = { label: "async-blocker", execute: t, onStart: () => { }, onComplete: () => { }, onError: () => { } }; this.append(r, e) }) } prependBlocker(e) { return new Promise(t => { if (this.queues) { const r = { label: "async-blocker-prepend", execute: t, onStart: () => { }, onComplete: () => { }, onError: () => { } }; this.queues[e].unshift(r) } }) } removeBlockers() { this.queues !== null && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(e => { var t; const r = (t = e[0]) == null ? void 0 : t.label; (r === "async-blocker" || r === "async-blocker-prepend") && (e[0].execute(), e.splice(0, 1)) }) } unblockAudio(e) { if (this.queues === null) return; this.queues.audio[0] === e && this.shiftAndExecuteNext("audio") } executeNext(e) { if (this.queues === null || this.tracks === null) return; const t = this.queues[e]; if (t.length) { const s = t[0]; try { s.execute() } catch (i) { var r; if (s.onError(i), this.queues === null || this.tracks === null) return; const a = (r = this.tracks[e]) == null ? void 0 : r.buffer; a != null && a.updating || this.shiftAndExecuteNext(e) } } } shiftAndExecuteNext(e) { this.queues !== null && (this.queues[e].shift(), this.executeNext(e)) } current(e) { var t; return ((t = this.queues) == null ? void 0 : t[e][0]) || null } toString() {
      const { queues: e, tracks: t } = this; return e === null || t === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`
    } list(e) { var t, r; return (t = this.queues) != null && t[e] || (r = this.tracks) != null && r[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : "" } listSbInfo(e) { var t; const r = (t = this.tracks) == null ? void 0 : t[e], s = r?.buffer; return s ? `SourceBuffer${s.updating ? " updating" : ""}${r.ended ? " ended" : ""}${r.ending ? " ending" : ""}` : "none" } listOps(e) { var t; return ((t = this.queues) == null ? void 0 : t[e].map(r => r.label).join(", ")) || "" }
  } const Wv = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/, Cw = "HlsJsTrackRemovedError"; class gN extends Error { constructor(e) { super(e), this.name = Cw } } class xN extends Pr {
    constructor(e, t) { super("buffer-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = { audio: 0, video: 0, audiovideo: 0 }, this.tracks = {}, this.sourceBuffers = [[null, null], [null, null]], this._onEndStreaming = r => { var s; this.hls && ((s = this.mediaSource) == null ? void 0 : s.readyState) === "open" && this.hls.pauseBuffering() }, this._onStartStreaming = r => { this.hls && this.hls.resumeBuffering() }, this._onMediaSourceOpen = r => { const { media: s, mediaSource: i } = this; r && this.log("Media source opened"), !(!s || !i) && (i.removeEventListener("sourceopen", this._onMediaSourceOpen), s.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(k.MEDIA_ATTACHED, { media: s, mediaSource: i }), this.mediaSource !== null && this.checkPendingTracks()) }, this._onMediaSourceClose = () => { this.log("Media source closed") }, this._onMediaSourceEnded = () => { this.log("Media source ended") }, this._onMediaEmptied = () => { const { mediaSrc: r, _objectUrl: s } = this; r !== s && this.error(`Media element src was set while attaching MediaSource (${s} > ${r})`) }, this.hls = e, this.fragmentTracker = t, this.appendSource = $R(bs(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners() } hasSourceTypes() { return Object.keys(this.tracks).length > 0 } destroy() { this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null } registerListeners() { const { hls: e } = this; e.on(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_PARSED, this.onManifestParsed, this), e.on(k.BUFFER_RESET, this.onBufferReset, this), e.on(k.BUFFER_APPENDING, this.onBufferAppending, this), e.on(k.BUFFER_CODECS, this.onBufferCodecs, this), e.on(k.BUFFER_EOS, this.onBufferEos, this), e.on(k.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(k.FRAG_PARSED, this.onFragParsed, this), e.on(k.FRAG_CHANGED, this.onFragChanged, this), e.on(k.ERROR, this.onError, this) } unregisterListeners() { const { hls: e } = this; e.off(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_PARSED, this.onManifestParsed, this), e.off(k.BUFFER_RESET, this.onBufferReset, this), e.off(k.BUFFER_APPENDING, this.onBufferAppending, this), e.off(k.BUFFER_CODECS, this.onBufferCodecs, this), e.off(k.BUFFER_EOS, this.onBufferEos, this), e.off(k.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(k.FRAG_PARSED, this.onFragParsed, this), e.off(k.FRAG_CHANGED, this.onFragChanged, this), e.off(k.ERROR, this.onError, this) } transferMedia() { const { media: e, mediaSource: t } = this; if (!e) return null; const r = {}; if (this.operationQueue) { const i = this.isUpdating(); i || this.operationQueue.removeBlockers(); const a = this.isQueued(); (i || a) && this.warn(`Transfering MediaSource with${a ? " operations in queue" : ""}${i ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`), this.operationQueue.destroy() } const s = this.transferData; return !this.sourceBufferCount && s && s.mediaSource === t ? nt(r, s.tracks) : this.sourceBuffers.forEach(i => { const [a] = i; a && (r[a] = nt({}, this.tracks[a]), this.removeBuffer(a)), i[0] = i[1] = null }), { media: e, mediaSource: t, tracks: r } } initTracks() { const e = {}; this.sourceBuffers = [[null, null], [null, null]], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0 } onManifestLoading() { this.bufferCodecEventsTotal = 0, this.details = null } onManifestParsed(e, t) { var r; let s = 2; (t.audio && !t.video || !t.altAudio) && (s = 1), this.bufferCodecEventsTotal = s, this.log(`${s} bufferCodec event(s) expected.`), (r = this.transferData) != null && r.mediaSource && this.sourceBufferCount && s && this.bufferCreated() } onMediaAttaching(e, t) { const r = this.media = t.media; this.transferData = this.overrides = void 0; const s = bs(this.appendSource); if (s) { const i = !!t.mediaSource; (i || t.overrides) && (this.transferData = t, this.overrides = t.overrides); const a = this.mediaSource = t.mediaSource || new s; if (this.assignMediaSource(a), i) this._objectUrl = r.src, this.attachTransferred(); else { const o = this._objectUrl = self.URL.createObjectURL(a); if (this.appendSource) try { r.removeAttribute("src"); const c = self.ManagedMediaSource; r.disableRemotePlayback = r.disableRemotePlayback || c && a instanceof c, Kv(r), vN(r, o), r.load() } catch { r.src = o } else r.src = o } r.addEventListener("emptied", this._onMediaEmptied) } } assignMediaSource(e) { var t, r; this.log(`${((t = this.transferData) == null ? void 0 : t.mediaSource) === e ? "transferred" : "created"} media source: ${(r = e.constructor) == null ? void 0 : r.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming)) } attachTransferred() {
      const e = this.media, t = this.transferData; if (!t || !e) return; const r = this.tracks, s = t.tracks, i = s ? Object.keys(s) : null, a = i ? i.length : 0, o = () => { Promise.resolve().then(() => { this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen() }) }; if (s && i && a) {
        if (!this.tracksReady) { this.hls.config.startFragPrefetch = !0, this.log("attachTransferred: waiting for SourceBuffer track info"); return } if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${it(r, (c, u) => c === "initSegment" ? void 0 : u)};
transfer tracks: ${it(s, (c, u) => c === "initSegment" ? void 0 : u)}}`), !Lb(s, r)) { t.mediaSource = null, t.tracks = void 0; const c = e.currentTime, u = this.details, f = Math.max(c, u?.fragments[0].start || 0); if (f - c > 1) { this.log(`attachTransferred: waiting for playback to reach new tracks start time ${c} -> ${f}`); return } this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(s)}"->"${Object.keys(r)}") start time: ${f} currentTime: ${c}`), this.onMediaDetaching(k.MEDIA_DETACHING, {}), this.onMediaAttaching(k.MEDIA_ATTACHING, t), e.currentTime = f; return } this.transferData = void 0, i.forEach(c => { const u = c, f = s[u]; if (f) { const h = f.buffer; if (h) { const p = this.fragmentTracker, v = f.id; if (p.hasFragments(v) || p.hasParts(v)) { const w = Me.getBuffered(h); p.detectEvictedFragments(u, w, v, null, !0) } const g = Sf(u), y = [u, h]; this.sourceBuffers[g] = y, h.updating && this.operationQueue && this.operationQueue.prependBlocker(u), this.trackSourceBuffer(u, f) } } }), o(), this.bufferCreated()
      } else this.log("attachTransferred: MediaSource w/o SourceBuffers"), o()
    } get mediaSourceOpenOrEnded() { var e; const t = (e = this.mediaSource) == null ? void 0 : e.readyState; return t === "open" || t === "ended" } onMediaDetaching(e, t) { const r = !!t.transferMedia; this.transferData = this.overrides = void 0; const { media: s, mediaSource: i, _objectUrl: a } = this; if (i) { if (this.log(`media source ${r ? "transferring" : "detaching"}`), r) this.sourceBuffers.forEach(([o]) => { o && this.removeBuffer(o) }), this.resetQueue(); else { if (this.mediaSourceOpenOrEnded) { const o = i.readyState === "open"; try { const c = i.sourceBuffers; for (let u = c.length; u--;)o && c[u].abort(), i.removeSourceBuffer(c[u]); o && i.endOfStream() } catch (c) { this.warn(`onMediaDetaching: ${c.message} while calling endOfStream`) } } this.sourceBufferCount && this.onBufferReset() } i.removeEventListener("sourceopen", this._onMediaSourceOpen), i.removeEventListener("sourceended", this._onMediaSourceEnded), i.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (i.removeEventListener("startstreaming", this._onStartStreaming), i.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null } s && (s.removeEventListener("emptied", this._onMediaEmptied), r || (a && self.URL.revokeObjectURL(a), this.mediaSrc === a ? (s.removeAttribute("src"), this.appendSource && Kv(s), s.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(k.MEDIA_DETACHED, t) } onBufferReset() { this.sourceBuffers.forEach(([e]) => { e && this.resetBuffer(e) }), this.initTracks() } resetBuffer(e) { var t; const r = (t = this.tracks[e]) == null ? void 0 : t.buffer; if (this.removeBuffer(e), r) try { var s; (s = this.mediaSource) != null && s.sourceBuffers.length && this.mediaSource.removeSourceBuffer(r) } catch (i) { this.warn(`onBufferReset ${e}`, i) } delete this.tracks[e] } removeBuffer(e) { this.removeBufferListeners(e), this.sourceBuffers[Sf(e)] = [null, null]; const t = this.tracks[e]; t && (t.buffer = void 0) } resetQueue() { this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new mN(this.tracks) } onBufferCodecs(e, t) { var r; const s = this.tracks, i = Object.keys(t); this.log(`BUFFER_CODECS: "${i}" (current SB count ${this.sourceBufferCount})`); const a = "audiovideo" in t && (s.audio || s.video) || s.audiovideo && ("audio" in t || "video" in t), o = !a && this.sourceBufferCount && this.media && i.some(c => !s[c]); if (a || o) { this.warn(`Unsupported transition between "${Object.keys(s)}" and "${i}" SourceBuffers`); return } i.forEach(c => { var u, f; const h = t[c], { id: p, codec: v, levelCodec: g, container: y, metadata: w, supplemental: T } = h; let S = s[c]; const E = (u = this.transferData) == null || (u = u.tracks) == null ? void 0 : u[c], I = E != null && E.buffer ? E : S, C = I?.pendingCodec || I?.codec, D = I?.levelCodec; S || (S = s[c] = { buffer: void 0, listeners: [], codec: v, supplemental: T, container: y, levelCodec: g, metadata: w, id: p }); const R = ec(C, D), N = R?.replace(Wv, "$1"); let P = ec(v, g); const _ = (f = P) == null ? void 0 : f.replace(Wv, "$1"); P && R && N !== _ && (c.slice(0, 5) === "audio" && (P = Ec(P, this.appendSource)), this.log(`switching codec ${C} to ${P}`), P !== (S.pendingCodec || S.codec) && (S.pendingCodec = P), S.container = y, this.appendChangeType(c, y, P)) }), (this.tracksReady || this.sourceBufferCount) && (t.tracks = this.sourceBufferTracks), !this.sourceBufferCount && (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !t.video && ((r = t.audio) == null ? void 0 : r.id) === "main" && (this.log("Main audio-only"), this.bufferCodecEventsTotal = 1), this.mediaSourceOpenOrEnded && this.checkPendingTracks()) } get sourceBufferTracks() { return Object.keys(this.tracks).reduce((e, t) => { const r = this.tracks[t]; return e[t] = { id: r.id, container: r.container, codec: r.codec, levelCodec: r.levelCodec }, e }, {}) } appendChangeType(e, t, r) { const s = `${t};codecs=${r}`, i = { label: `change-type=${s}`, execute: () => { const a = this.tracks[e]; if (a) { const o = a.buffer; o != null && o.changeType && (this.log(`changing ${e} sourceBuffer type to ${s}`), o.changeType(s), a.codec = r, a.container = t) } this.shiftAndExecuteNext(e) }, onStart: () => { }, onComplete: () => { }, onError: a => { this.warn(`Failed to change ${e} SourceBuffer type`, a) } }; this.append(i, e, this.isPending(this.tracks[e])) } blockAudio(e) { var t; const r = e.start, s = r + e.duration * .05; if (((t = this.fragmentTracker.getAppendedFrag(r, ve.MAIN)) == null ? void 0 : t.gap) === !0) return; const a = { label: "block-audio", execute: () => { var o; const c = this.tracks.video; (this.lastVideoAppendEnd > s || c != null && c.buffer && Me.isBuffered(c.buffer, s) || ((o = this.fragmentTracker.getAppendedFrag(s, ve.MAIN)) == null ? void 0 : o.gap) === !0) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio")) }, onStart: () => { }, onComplete: () => { }, onError: o => { this.warn("Error executing block-audio operation", o) } }; this.blockedAudioAppend = { op: a, frag: e }, this.append(a, "audio", !0) } unblockAudio() { const { blockedAudioAppend: e, operationQueue: t } = this; e && t && (this.blockedAudioAppend = null, t.unblockAudio(e.op)) } onBufferAppending(e, t) { const { tracks: r } = this, { data: s, type: i, parent: a, frag: o, part: c, chunkMeta: u, offset: f } = t, h = u.buffering[i], { sn: p, cc: v } = o, g = self.performance.now(); h.start = g; const y = o.stats.buffering, w = c ? c.stats.buffering : null; y.start === 0 && (y.start = g), w && w.start === 0 && (w.start = g); const T = r.audio; let S = !1; i === "audio" && T?.container === "audio/mpeg" && (S = !this.lastMpegAudioChunk || u.id === 1 || this.lastMpegAudioChunk.sn !== u.sn, this.lastMpegAudioChunk = u); const E = r.video, I = E?.buffer; if (I && p !== "initSegment") { const R = c || o, N = this.blockedAudioAppend; if (i === "audio" && a !== "main" && !this.blockedAudioAppend && !(E.ending || E.ended)) { const _ = R.start + R.duration * .05, M = I.buffered, $ = this.currentOp("video"); !M.length && !$ ? this.blockAudio(R) : !$ && !Me.isBuffered(I, _) && this.lastVideoAppendEnd < _ && this.blockAudio(R) } else if (i === "video") { const P = R.end; if (N) { const _ = N.frag.start; (P > _ || P < this.lastVideoAppendEnd || Me.isBuffered(I, _)) && this.unblockAudio() } this.lastVideoAppendEnd = P } } const C = (c || o).start, D = { label: `append-${i}`, execute: () => { var R; h.executeStart = self.performance.now(); const N = (R = this.tracks[i]) == null ? void 0 : R.buffer; N && (S ? this.updateTimestampOffset(N, C, .1, i, p, v) : f !== void 0 && ge(f) && this.updateTimestampOffset(N, f, 1e-6, i, p, v)), this.appendExecutor(s, i) }, onStart: () => { }, onComplete: () => { const R = self.performance.now(); h.executeEnd = h.end = R, y.first === 0 && (y.first = R), w && w.first === 0 && (w.first = R); const N = {}; this.sourceBuffers.forEach(([P, _]) => { P && (N[P] = Me.getBuffered(_)) }), this.appendErrors[i] = 0, i === "audio" || i === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(k.BUFFER_APPENDED, { type: i, frag: o, part: c, chunkMeta: u, parent: o.type, timeRanges: N }) }, onError: R => { var N; const P = { type: Ee.MEDIA_ERROR, parent: o.type, details: J.BUFFER_APPEND_ERROR, sourceBufferName: i, frag: o, part: c, chunkMeta: u, error: R, err: R, fatal: !1 }, _ = (N = this.media) == null ? void 0 : N.error; if (R.code === DOMException.QUOTA_EXCEEDED_ERR || R.name == "QuotaExceededError" || "quota" in R) P.details = J.BUFFER_FULL_ERROR; else if (R.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !_) P.errorAction = Ni(!0); else if (R.name === Cw && this.sourceBufferCount === 0) P.errorAction = Ni(!0); else { const M = ++this.appendErrors[i]; this.warn(`Failed ${M}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${i}" sourceBuffer (${_ || "no media error"})`), (M >= this.hls.config.appendErrorMaxRetry || _) && (P.fatal = !0) } this.hls.trigger(k.ERROR, P) } }; this.log(`queuing "${i}" append sn: ${p}${c ? " p: " + c.index : ""} of ${o.type === ve.MAIN ? "level" : "track"} ${o.level} cc: ${v}`), this.append(D, i, this.isPending(this.tracks[i])) } getFlushOp(e, t, r) { return this.log(`queuing "${e}" remove ${t}-${r}`), { label: "remove", execute: () => { this.removeExecutor(e, t, r) }, onStart: () => { }, onComplete: () => { this.hls.trigger(k.BUFFER_FLUSHED, { type: e }) }, onError: s => { this.warn(`Failed to remove ${t}-${r} from "${e}" SourceBuffer`, s) } } } onBufferFlushing(e, t) { const { type: r, startOffset: s, endOffset: i } = t; r ? this.append(this.getFlushOp(r, s, i), r) : this.sourceBuffers.forEach(([a]) => { a && this.append(this.getFlushOp(a, s, i), a) }) } onFragParsed(e, t) { const { frag: r, part: s } = t, i = [], a = s ? s.elementaryStreams : r.elementaryStreams; a[st.AUDIOVIDEO] ? i.push("audiovideo") : (a[st.AUDIO] && i.push("audio"), a[st.VIDEO] && i.push("video")); const o = () => { const c = self.performance.now(); r.stats.buffering.end = c, s && (s.stats.buffering.end = c); const u = s ? s.stats : r.stats; this.hls.trigger(k.FRAG_BUFFERED, { frag: r, part: s, stats: u, id: r.type }) }; i.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(o, i).catch(c => { this.warn(`Fragment buffered callback ${c}`), this.stepOperationQueue(this.sourceBufferTypes) }) } onFragChanged(e, t) { this.trimBuffers() } get bufferedToEnd() { return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([e]) => { if (e) { const t = this.tracks[e]; if (t) return !t.ended || t.ending } return !1 }) } onBufferEos(e, t) { var r; this.sourceBuffers.forEach(([a]) => { if (a) { const o = this.tracks[a]; (!t.type || t.type === a) && (o.ending = !0, o.ended || (o.ended = !0, this.log(`${a} buffer reached EOS`))) } }); const s = ((r = this.overrides) == null ? void 0 : r.endOfStream) !== !1; this.sourceBufferCount > 0 && !this.sourceBuffers.some(([a]) => { var o; return a && !((o = this.tracks[a]) != null && o.ended) }) ? s ? (this.log("Queueing EOS"), this.blockUntilOpen(() => { this.tracksEnded(); const { mediaSource: a } = this; if (!a || a.readyState !== "open") { a && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`); return } this.log("Calling mediaSource.endOfStream()"), a.endOfStream(), this.hls.trigger(k.BUFFERED_TO_END, void 0) })) : (this.tracksEnded(), this.hls.trigger(k.BUFFERED_TO_END, void 0)) : t.type === "video" && this.unblockAudio() } tracksEnded() { this.sourceBuffers.forEach(([e]) => { if (e !== null) { const t = this.tracks[e]; t && (t.ending = !1) } }) } onLevelUpdated(e, { details: t }) { t.fragments.length && (this.details = t, this.updateDuration()) } updateDuration() { this.blockUntilOpen(() => { const e = this.getDurationAndRange(); e && this.updateMediaSource(e) }) } onError(e, t) { if (t.details === J.BUFFER_APPEND_ERROR && t.frag) { var r; const s = (r = t.errorAction) == null ? void 0 : r.nextAutoLevel; ge(s) && s !== t.frag.level && this.resetAppendErrors() } } resetAppendErrors() { this.appendErrors = { audio: 0, video: 0, audiovideo: 0 } } trimBuffers() { const { hls: e, details: t, media: r } = this; if (!r || t === null || !this.sourceBufferCount) return; const s = e.config, i = r.currentTime, a = t.levelTargetDuration, o = t.live && s.liveBackBufferLength !== null ? s.liveBackBufferLength : s.backBufferLength; if (ge(o) && o >= 0) { const u = Math.max(o, a), f = Math.floor(i / a) * a - u; this.flushBackBuffer(i, a, f) } const c = s.frontBufferFlushThreshold; if (ge(c) && c > 0) { const u = Math.max(s.maxBufferLength, c), f = Math.max(u, a), h = Math.floor(i / a) * a + f; this.flushFrontBuffer(i, a, h) } } flushBackBuffer(e, t, r) { this.sourceBuffers.forEach(([s, i]) => { if (i) { const o = Me.getBuffered(i); if (o.length > 0 && r > o.start(0)) { var a; this.hls.trigger(k.BACK_BUFFER_REACHED, { bufferEnd: r }); const c = this.tracks[s]; if ((a = this.details) != null && a.live) this.hls.trigger(k.LIVE_BACK_BUFFER_REACHED, { bufferEnd: r }); else if (c != null && c.ended) { this.log(`Cannot flush ${s} back buffer while SourceBuffer is in ended state`); return } this.hls.trigger(k.BUFFER_FLUSHING, { startOffset: 0, endOffset: r, type: s }) } } }) } flushFrontBuffer(e, t, r) { this.sourceBuffers.forEach(([s, i]) => { if (i) { const a = Me.getBuffered(i), o = a.length; if (o < 2) return; const c = a.start(o - 1), u = a.end(o - 1); if (r > c || e >= c && e <= u) return; this.hls.trigger(k.BUFFER_FLUSHING, { startOffset: c, endOffset: 1 / 0, type: s }) } }) } getDurationAndRange() { var e; const { details: t, mediaSource: r } = this; if (!t || !this.media || r?.readyState !== "open") return null; const s = t.edge; if (t.live && this.hls.config.liveDurationInfinity) { if (t.fragments.length && r.setLiveSeekableRange) { const u = Math.max(0, t.fragmentStart), f = Math.max(u, s); return { duration: 1 / 0, start: u, end: f } } return { duration: 1 / 0 } } const i = (e = this.overrides) == null ? void 0 : e.duration; if (i) return ge(i) ? { duration: i } : null; const a = this.media.duration, o = ge(r.duration) ? r.duration : 0; return s > o && s > a || !ge(a) ? { duration: s } : null } updateMediaSource({ duration: e, start: t, end: r }) { const s = this.mediaSource; !this.media || !s || s.readyState !== "open" || (s.duration !== e && (ge(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), s.duration = e), t !== void 0 && r !== void 0 && (this.log(`MediaSource duration is set to ${s.duration}. Setting seekable range to ${t}-${r}.`), s.setLiveSeekableRange(t, r))) } get tracksReady() { const e = this.pendingTrackCount; return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo)) } checkPendingTracks() { const { bufferCodecEventsTotal: e, pendingTrackCount: t, tracks: r } = this; if (this.log(`checkPendingTracks (pending: ${t} codec events expected: ${e}) ${it(r)}`), this.tracksReady) { var s; const i = (s = this.transferData) == null ? void 0 : s.tracks; i && Object.keys(i).length ? this.attachTransferred() : this.createSourceBuffers() } } bufferCreated() { if (this.sourceBufferCount) { const e = {}; this.sourceBuffers.forEach(([t, r]) => { if (t) { const s = this.tracks[t]; e[t] = { buffer: r, container: s.container, codec: s.codec, supplemental: s.supplemental, levelCodec: s.levelCodec, id: s.id, metadata: s.metadata } } }), this.hls.trigger(k.BUFFER_CREATED, { tracks: e }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([t]) => { this.executeNext(t) }) } else { const e = new Error("could not create source buffer for media codec(s)"); this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_INCOMPATIBLE_CODECS_ERROR, fatal: !0, error: e, reason: e.message }) } } createSourceBuffers() { const { tracks: e, sourceBuffers: t, mediaSource: r } = this; if (!r) throw new Error("createSourceBuffers called when mediaSource was null"); for (const i in e) { const a = i, o = e[a]; if (this.isPending(o)) { const c = this.getTrackCodec(o, a), u = `${o.container};codecs=${c}`; o.codec = c, this.log(`creating sourceBuffer(${u})${this.currentOp(a) ? " Queued" : ""} ${it(o)}`); try { const f = r.addSourceBuffer(u), h = Sf(a), p = [a, f]; t[h] = p, o.buffer = f } catch (f) { var s; this.error(`error while trying to add sourceBuffer: ${f.message}`), this.shiftAndExecuteNext(a), (s = this.operationQueue) == null || s.removeBlockers(), delete this.tracks[a], this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_ADD_CODEC_ERROR, fatal: !1, error: f, sourceBufferName: a, mimeType: u, parent: o.id }); return } this.trackSourceBuffer(a, o) } } this.bufferCreated() } getTrackCodec(e, t) { const r = e.supplemental; let s = e.codec; r && (t === "video" || t === "audiovideo") && Za(r, "video") && (s = a_(s, r)); const i = ec(s, e.levelCodec); return i ? t.slice(0, 5) === "audio" ? Ec(i, this.appendSource) : i : "" } trackSourceBuffer(e, t) { const r = t.buffer; if (!r) return; const s = this.getTrackCodec(t, e); this.tracks[e] = { buffer: r, codec: s, container: t.container, levelCodec: t.levelCodec, supplemental: t.supplemental, metadata: t.metadata, id: t.id, listeners: [] }, this.removeBufferListeners(e), this.addBufferListener(e, "updatestart", this.onSBUpdateStart), this.addBufferListener(e, "updateend", this.onSBUpdateEnd), this.addBufferListener(e, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(e, "bufferedchange", (i, a) => { const o = a.removedRanges; o != null && o.length && this.hls.trigger(k.BUFFER_FLUSHED, { type: i }) }) } get mediaSrc() { var e, t; const r = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, "source")) || this.media; return r?.src } onSBUpdateStart(e) { const t = this.currentOp(e); t && t.onStart() } onSBUpdateEnd(e) { var t; if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") { this.resetBuffer(e); return } const r = this.currentOp(e); r && (r.onComplete(), this.shiftAndExecuteNext(e)) } onSBUpdateError(e, t) { var r; const s = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(r = this.mediaSource) == null ? void 0 : r.readyState}`); this.error(`${s}`, t), this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_APPENDING_ERROR, sourceBufferName: e, error: s, fatal: !1 }); const i = this.currentOp(e); i && i.onError(s) } updateTimestampOffset(e, t, r, s, i, a) { const o = t - e.timestampOffset; Math.abs(o) >= r && (this.log(`Updating ${s} SourceBuffer timestampOffset to ${t} (sn: ${i} cc: ${a})`), e.timestampOffset = t) } removeExecutor(e, t, r) { const { media: s, mediaSource: i } = this, a = this.tracks[e], o = a?.buffer; if (!s || !i || !o) { this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e); return } const c = ge(s.duration) ? s.duration : 1 / 0, u = ge(i.duration) ? i.duration : 1 / 0, f = Math.max(0, t), h = Math.min(r, c, u); h > f && (!a.ending || a.ended) ? (a.ended = !1, this.log(`Removing [${f},${h}] from the ${e} SourceBuffer`), o.remove(f, h)) : this.shiftAndExecuteNext(e) } appendExecutor(e, t) { const r = this.tracks[t], s = r?.buffer; if (!s) throw new gN(`Attempting to append to the ${t} SourceBuffer, but it does not exist`); r.ending = !1, r.ended = !1, s.appendBuffer(e) } blockUntilOpen(e) { if (this.isUpdating() || this.isQueued()) this.blockBuffers(e).catch(t => { this.warn(`SourceBuffer blocked callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes) }); else try { e() } catch (t) { this.warn(`Callback run without blocking ${this.operationQueue} ${t}`) } } isUpdating() { return this.sourceBuffers.some(([e, t]) => e && t.updating) } isQueued() { return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e)) } isPending(e) { return !!e && !e.buffer } blockBuffers(e, t = this.sourceBufferTypes) { if (!t.length) return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e); const { operationQueue: r } = this, s = t.map(a => this.appendBlocker(a)); return t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(s).then(a => { r === this.operationQueue && (e(), this.stepOperationQueue(this.sourceBufferTypes)) }) } stepOperationQueue(e) { e.forEach(t => { var r; const s = (r = this.tracks[t]) == null ? void 0 : r.buffer; !s || s.updating || this.shiftAndExecuteNext(t) }) } append(e, t, r) { this.operationQueue && this.operationQueue.append(e, t, r) } appendBlocker(e) { if (this.operationQueue) return this.operationQueue.appendBlocker(e) } currentOp(e) { return this.operationQueue ? this.operationQueue.current(e) : null } executeNext(e) { e && this.operationQueue && this.operationQueue.executeNext(e) } shiftAndExecuteNext(e) { this.operationQueue && this.operationQueue.shiftAndExecuteNext(e) } get pendingTrackCount() { return Object.keys(this.tracks).reduce((e, t) => e + (this.isPending(this.tracks[t]) ? 1 : 0), 0) } get sourceBufferCount() { return this.sourceBuffers.reduce((e, [t]) => e + (t ? 1 : 0), 0) } get sourceBufferTypes() { return this.sourceBuffers.map(([e]) => e).filter(e => !!e) } addBufferListener(e, t, r) { const s = this.tracks[e]; if (!s) return; const i = s.buffer; if (!i) return; const a = r.bind(this, e); s.listeners.push({ event: t, listener: a }), i.addEventListener(t, a) } removeBufferListeners(e) { const t = this.tracks[e]; if (!t) return; const r = t.buffer; r && (t.listeners.forEach(s => { r.removeEventListener(s.event, s.listener) }), t.listeners.length = 0) }
  } function Kv(n) { const e = n.querySelectorAll("source");[].slice.call(e).forEach(t => { n.removeChild(t) }) } function vN(n, e) { const t = self.document.createElement("source"); t.type = "video/mp4", t.src = e, n.appendChild(t) } function Sf(n) { return n === "audio" ? 1 : 0 } class _p { constructor(e) { this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners() } setStreamController(e) { this.streamController = e } destroy() { this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null } registerListeners() { const { hls: e } = this; e.on(k.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(k.MANIFEST_PARSED, this.onManifestParsed, this), e.on(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(k.BUFFER_CODECS, this.onBufferCodecs, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this) } unregisterListener() { const { hls: e } = this; e.off(k.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(k.MANIFEST_PARSED, this.onManifestParsed, this), e.off(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(k.BUFFER_CODECS, this.onBufferCodecs, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this) } onFpsDropLevelCapping(e, t) { const r = this.hls.levels[t.droppedLevel]; this.isLevelAllowed(r) && this.restrictedLevels.push({ bitrate: r.bitrate, height: r.height, width: r.width }) } onMediaAttaching(e, t) { this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize() } onManifestParsed(e, t) { const r = this.hls; this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping() } onLevelsUpdated(e, t) { this.timer && ge(this.autoLevelCapping) && this.detectPlayerSize() } onBufferCodecs(e, t) { this.hls.config.capLevelToPlayerSize && t.video && this.startCapping() } onMediaDetaching() { this.stopCapping(), this.media = null } detectPlayerSize() { if (this.media) { if (this.mediaHeight <= 0 || this.mediaWidth <= 0) { this.clientRect = null; return } const e = this.hls.levels; if (e.length) { const t = this.hls, r = this.getMaxLevel(e.length - 1); r !== this.autoLevelCapping && t.logger.log(`Setting autoLevelCapping to ${r}: ${e[r].height}p@${e[r].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = r, t.autoLevelEnabled && t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping } } } getMaxLevel(e) { const t = this.hls.levels; if (!t.length) return -1; const r = t.filter((s, i) => this.isLevelAllowed(s) && i <= e); return this.clientRect = null, _p.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight) } startCapping() { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()) } stopCapping() { this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0) } getDimensions() { if (this.clientRect) return this.clientRect; const e = this.media, t = { width: 0, height: 0 }; if (e) { const r = e.getBoundingClientRect(); t.width = r.width, t.height = r.height, !t.width && !t.height && (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0) } return this.clientRect = t, t } get mediaWidth() { return this.getDimensions().width * this.contentScaleFactor } get mediaHeight() { return this.getDimensions().height * this.contentScaleFactor } get contentScaleFactor() { let e = 1; if (!this.hls.config.ignoreDevicePixelRatio) try { e = self.devicePixelRatio } catch { } return Math.min(e, this.hls.config.maxDevicePixelRatio) } isLevelAllowed(e) { return !this.restrictedLevels.some(r => e.bitrate === r.bitrate && e.width === r.width && e.height === r.height) } static getMaxLevelByMediaSize(e, t, r) { if (!(e != null && e.length)) return -1; const s = (o, c) => c ? o.width !== c.width || o.height !== c.height : !0; let i = e.length - 1; const a = Math.max(t, r); for (let o = 0; o < e.length; o += 1) { const c = e[o]; if ((c.width >= a || c.height >= a) && s(c, e[o + 1])) { i = o; break } } return i } } const yN = { MANIFEST: "m", AUDIO: "a", VIDEO: "v", MUXED: "av", INIT: "i", CAPTION: "c", TIMED_TEXT: "tt", KEY: "k", OTHER: "o" }, ir = yN, bN = { HLS: "h" }, wN = bN; class fn { constructor(e, t) { Array.isArray(e) && (e = e.map(r => r instanceof fn ? r : new fn(r))), this.value = e, this.params = t } } const SN = "Dict"; function EN(n) { return Array.isArray(n) ? JSON.stringify(n) : n instanceof Map ? "Map{}" : n instanceof Set ? "Set{}" : typeof n == "object" ? JSON.stringify(n) : String(n) } function TN(n, e, t, r) { return new Error(`failed to ${n} "${EN(e)}" as ${t}`, { cause: r }) } function hn(n, e, t) { return TN("serialize", n, e, t) } class kw { constructor(e) { this.description = e } } const qv = "Bare Item", AN = "Boolean"; function IN(n) { if (typeof n != "boolean") throw hn(n, AN); return n ? "?1" : "?0" } function LN(n) { return btoa(String.fromCharCode(...n)) } const CN = "Byte Sequence"; function kN(n) { if (ArrayBuffer.isView(n) === !1) throw hn(n, CN); return `:${LN(n)}:` } const RN = "Integer"; function _N(n) { return n < -999999999999999 || 999999999999999 < n } function Rw(n) { if (_N(n)) throw hn(n, RN); return n.toString() } function PN(n) { return `@${Rw(n.getTime() / 1e3)}` } function _w(n, e) { if (n < 0) return -_w(-n, e); const t = Math.pow(10, e); if (Math.abs(n * t % 1 - .5) < Number.EPSILON) { const s = Math.floor(n * t); return (s % 2 === 0 ? s : s + 1) / t } else return Math.round(n * t) / t } const NN = "Decimal"; function DN(n) { const e = _w(n, 3); if (Math.floor(Math.abs(e)).toString().length > 12) throw hn(n, NN); const t = e.toString(); return t.includes(".") ? t : `${t}.0` } const ON = "String", MN = /[\x00-\x1f\x7f]+/; function jN(n) { if (MN.test(n)) throw hn(n, ON); return `"${n.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` } function FN(n) { return n.description || n.toString().slice(7, -1) } const $N = "Token"; function Yv(n) { const e = FN(n); if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1) throw hn(e, $N); return e } function kh(n) { switch (typeof n) { case "number": if (!ge(n)) throw hn(n, qv); return Number.isInteger(n) ? Rw(n) : DN(n); case "string": return jN(n); case "symbol": return Yv(n); case "boolean": return IN(n); case "object": if (n instanceof Date) return PN(n); if (n instanceof Uint8Array) return kN(n); if (n instanceof kw) return Yv(n); default: throw hn(n, qv) } } const BN = "Key"; function Rh(n) { if (/^[a-z*][a-z0-9\-_.*]*$/.test(n) === !1) throw hn(n, BN); return n } function Pp(n) { return n == null ? "" : Object.entries(n).map(([e, t]) => t === !0 ? `;${Rh(e)}` : `;${Rh(e)}=${kh(t)}`).join("") } function Pw(n) { return n instanceof fn ? `${kh(n.value)}${Pp(n.params)}` : kh(n) } function UN(n) { return `(${n.value.map(Pw).join(" ")})${Pp(n.params)}` } function zN(n, e = { whitespace: !0 }) { if (typeof n != "object" || n == null) throw hn(n, SN); const t = n instanceof Map ? n.entries() : Object.entries(n), r = e?.whitespace ? " " : ""; return Array.from(t).map(([s, i]) => { i instanceof fn || (i = new fn(i)); let a = Rh(s); return i.value === !0 ? a += Pp(i.params) : (a += "=", Array.isArray(i.value) ? a += UN(i) : a += Pw(i)), a }).join(`,${r}`) } function Nw(n, e) { return zN(n, e) } const en = "CMCD-Object", bt = "CMCD-Request", Fs = "CMCD-Session", cs = "CMCD-Status", VN = { br: en, ab: en, d: en, ot: en, tb: en, tpb: en, lb: en, tab: en, lab: en, url: en, pb: bt, bl: bt, tbl: bt, dl: bt, ltc: bt, mtp: bt, nor: bt, nrr: bt, rc: bt, sn: bt, sta: bt, su: bt, ttfb: bt, ttfbb: bt, ttlb: bt, cmsdd: bt, cmsds: bt, smrt: bt, df: bt, cs: bt, ts: bt, cid: Fs, pr: Fs, sf: Fs, sid: Fs, st: Fs, v: Fs, msd: Fs, bs: cs, bsd: cs, cdn: cs, rtp: cs, bg: cs, pt: cs, ec: cs, e: cs }, GN = { REQUEST: bt }; function HN(n) { return Object.keys(n).reduce((e, t) => { var r; return (r = n[t]) === null || r === void 0 || r.forEach(s => e[s] = t), e }, {}) } function WN(n, e) { const t = {}; if (!n) return t; const r = Object.keys(n), s = e ? HN(e) : {}; return r.reduce((i, a) => { var o; const c = VN[a] || s[a] || GN.REQUEST, u = (o = i[c]) !== null && o !== void 0 ? o : i[c] = {}; return u[a] = n[a], i }, t) } function KN(n) { return ["ot", "sf", "st", "e", "sta"].includes(n) } function qN(n) { return typeof n == "number" ? ge(n) : n != null && n !== "" && n !== !1 } const Dw = "event"; function YN(n, e) { const t = new URL(n), r = new URL(e); if (t.origin !== r.origin) return n; const s = t.pathname.split("/").slice(1), i = r.pathname.split("/").slice(1, -1); for (; s[0] === i[0];)s.shift(), i.shift(); for (; i.length;)i.shift(), s.unshift(".."); return s.join("/") + t.search + t.hash } const ic = n => Math.round(n), _h = (n, e) => Array.isArray(n) ? n.map(t => _h(t, e)) : n instanceof fn && typeof n.value == "string" ? new fn(_h(n.value, e), n.params) : (e.baseUrl && (n = YN(n, e.baseUrl)), e.version === 1 ? encodeURIComponent(n) : n), Bl = n => ic(n / 100) * 100, XN = (n, e) => { let t = n; return e.version >= 2 && (n instanceof fn && typeof n.value == "string" ? t = new fn([n]) : typeof n == "string" && (t = [n])), _h(t, e) }, QN = { br: ic, d: ic, bl: Bl, dl: Bl, mtp: Bl, nor: XN, rtp: Bl, tb: ic }, Ow = "request", Mw = "response", Np = ["ab", "bg", "bl", "br", "bs", "bsd", "cdn", "cid", "cs", "df", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pr", "pt", "sf", "sid", "sn", "st", "sta", "tab", "tb", "tbl", "tpb", "ts", "v"], ZN = ["e"], JN = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/; function Yc(n) { return JN.test(n) } function e5(n) { return Np.includes(n) || ZN.includes(n) || Yc(n) } const jw = ["d", "dl", "nor", "ot", "rtp", "su"]; function t5(n) { return Np.includes(n) || jw.includes(n) || Yc(n) } const r5 = ["cmsdd", "cmsds", "rc", "smrt", "ttfb", "ttfbb", "ttlb", "url"]; function n5(n) { return Np.includes(n) || jw.includes(n) || r5.includes(n) || Yc(n) } const s5 = ["bl", "br", "bs", "cid", "d", "dl", "mtp", "nor", "nrr", "ot", "pr", "rtp", "sf", "sid", "st", "su", "tb", "v"]; function i5(n) { return s5.includes(n) || Yc(n) } const a5 = { [Mw]: n5, [Dw]: e5, [Ow]: t5 }; function Fw(n, e = {}) { const t = {}; if (n == null || typeof n != "object") return t; const r = e.version || n.v || 1, s = e.reportingMode || Ow, i = r === 1 ? i5 : a5[s]; let a = Object.keys(n).filter(i); const o = e.filter; typeof o == "function" && (a = a.filter(o)); const c = s === Mw || s === Dw; c && !a.includes("ts") && a.push("ts"), r > 1 && !a.includes("v") && a.push("v"); const u = nt({}, QN, e.formatters), f = { version: r, reportingMode: s, baseUrl: e.baseUrl }; return a.sort().forEach(h => { let p = n[h]; const v = u[h]; if (typeof v == "function" && (p = v(p, f)), h === "v") { if (r === 1) return; p = r } h == "pr" && p === 1 || (c && h === "ts" && !ge(p) && (p = Date.now()), qN(p) && (KN(h) && typeof p == "string" && (p = new kw(p)), t[h] = p)) }), t } function o5(n, e = {}) { const t = {}; if (!n) return t; const r = Fw(n, e), s = WN(r, e?.customHeaderMap); return Object.entries(s).reduce((i, [a, o]) => { const c = Nw(o, { whitespace: !1 }); return c && (i[a] = c), i }, t) } function l5(n, e, t) { return nt(n, o5(e, t)) } const c5 = "CMCD"; function u5(n, e = {}) { return n ? Nw(Fw(n, e), { whitespace: !1 }) : "" } function d5(n, e = {}) { if (!n) return ""; const t = u5(n, e); return encodeURIComponent(t) } function f5(n, e = {}) { if (!n) return ""; const t = d5(n, e); return `${c5}=${t}` } const Xv = /CMCD=[^&#]+/; function h5(n, e, t) { const r = f5(e, t); if (!r) return n; if (Xv.test(n)) return n.replace(Xv, r); const s = n.includes("?") ? "&" : "?"; return `${n}${s}${r}` } class p5 { constructor(e) { this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => { this.initialized && (this.starved = !0), this.buffering = !0 }, this.onPlaying = () => { this.initialized || (this.initialized = !0), this.buffering = !1 }, this.applyPlaylistData = s => { try { this.apply(s, { ot: ir.MANIFEST, su: !this.initialized }) } catch (i) { this.hls.logger.warn("Could not generate manifest CMCD data.", i) } }, this.applyFragmentData = s => { try { const { frag: i, part: a } = s, o = this.hls.levels[i.level], c = this.getObjectType(i), u = { d: (a || i).duration * 1e3, ot: c }; (c === ir.VIDEO || c === ir.AUDIO || c == ir.MUXED) && (u.br = o.bitrate / 1e3, u.tb = this.getTopBandwidth(c) / 1e3, u.bl = this.getBufferLength(c)); const f = a ? this.getNextPart(a) : this.getNextFrag(i); f != null && f.url && f.url !== i.url && (u.nor = f.url), this.apply(s, u) } catch (i) { this.hls.logger.warn("Could not generate segment CMCD data.", i) } }, this.hls = e; const t = this.config = e.config, { cmcd: r } = t; r != null && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || e.sessionId, this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.includeKeys = r.includeKeys, this.registerListeners()) } registerListeners() { const e = this.hls; e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHED, this.onMediaDetached, this), e.on(k.BUFFER_CREATED, this.onBufferCreated, this) } unregisterListeners() { const e = this.hls; e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHED, this.onMediaDetached, this), e.off(k.BUFFER_CREATED, this.onBufferCreated, this) } destroy() { this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying) } onMediaDetached() { this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null) } onBufferCreated(e, t) { var r, s; this.audioBuffer = (r = t.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (s = t.tracks.video) == null ? void 0 : s.buffer } createData() { var e; return { v: 1, sf: wN.HLS, sid: this.sid, cid: this.cid, pr: (e = this.media) == null ? void 0 : e.playbackRate, mtp: this.hls.bandwidthEstimate / 1e3 } } apply(e, t = {}) { nt(t, this.createData()); const r = t.ot === ir.INIT || t.ot === ir.VIDEO || t.ot === ir.MUXED; this.starved && r && (t.bs = !0, t.su = !0, this.starved = !1), t.su == null && (t.su = this.buffering); const { includeKeys: s } = this; s && (t = Object.keys(t).reduce((a, o) => (s.includes(o) && (a[o] = t[o]), a), {})); const i = { baseUrl: e.url }; this.useHeaders ? (e.headers || (e.headers = {}), l5(e.headers, t, i)) : e.url = h5(e.url, t, i) } getNextFrag(e) { var t; const r = (t = this.hls.levels[e.level]) == null ? void 0 : t.details; if (r) { const s = e.sn - r.startSN; return r.fragments[s + 1] } } getNextPart(e) { var t; const { index: r, fragment: s } = e, i = (t = this.hls.levels[s.level]) == null || (t = t.details) == null ? void 0 : t.partList; if (i) { const { sn: a } = s; for (let o = i.length - 1; o >= 0; o--) { const c = i[o]; if (c.index === r && c.fragment.sn === a) return i[o + 1] } } } getObjectType(e) { const { type: t } = e; if (t === "subtitle") return ir.TIMED_TEXT; if (e.sn === "initSegment") return ir.INIT; if (t === "audio") return ir.AUDIO; if (t === "main") return this.hls.audioTracks.length ? ir.VIDEO : ir.MUXED } getTopBandwidth(e) { let t = 0, r; const s = this.hls; if (e === ir.AUDIO) r = s.audioTracks; else { const i = s.maxAutoLevel, a = i > -1 ? i + 1 : s.levels.length; r = s.levels.slice(0, a) } return r.forEach(i => { i.bitrate > t && (t = i.bitrate) }), t > 0 ? t : NaN } getBufferLength(e) { const t = this.media, r = e === ir.AUDIO ? this.audioBuffer : this.videoBuffer; return !r || !t ? NaN : Me.bufferInfo(r, t.currentTime, this.config.maxBufferHole).len * 1e3 } createPlaylistLoader() { const { pLoader: e } = this.config, t = this.applyPlaylistData, r = e || this.config.loader; return class { constructor(i) { this.loader = void 0, this.loader = new r(i) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(i, a, o) { t(i), this.loader.load(i, a, o) } } } createFragmentLoader() { const { fLoader: e } = this.config, t = this.applyFragmentData, r = e || this.config.loader; return class { constructor(i) { this.loader = void 0, this.loader = new r(i) } get stats() { return this.loader.stats } get context() { return this.loader.context } destroy() { this.loader.destroy() } abort() { this.loader.abort() } load(i, a, o) { t(i), this.loader.load(i, a, o) } } } } const m5 = 3e5; class g5 extends Pr { constructor(e) { super("content-steering", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners() } registerListeners() { const e = this.hls; e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(k.MANIFEST_PARSED, this.onManifestParsed, this), e.on(k.ERROR, this.onError, this) } unregisterListeners() { const e = this.hls; e && (e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(k.MANIFEST_PARSED, this.onManifestParsed, this), e.off(k.ERROR, this.onError, this)) } pathways() { return (this.levels || []).reduce((e, t) => (e.indexOf(t.pathwayId) === -1 && e.push(t.pathwayId), e), []) } get pathwayPriority() { return this._pathwayPriority } set pathwayPriority(e) { this.updatePathwayPriority(e) } startLoad() { if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) { if (this.updated) { const e = this.timeToLoad * 1e3 - (performance.now() - this.updated); if (e > 0) { this.scheduleRefresh(this.uri, e); return } } this.loadSteeringManifest(this.uri) } } stopLoad() { this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout() } clearTimeout() { this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1) } destroy() { this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null } removeLevel(e) { const t = this.levels; t && (this.levels = t.filter(r => r !== e)) } onManifestLoading() { this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null } onManifestLoaded(e, t) { const { contentSteering: r } = t; r !== null && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad()) } onManifestParsed(e, t) { this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks } onError(e, t) { const { errorAction: r } = t; if (r?.action === $t.SendAlternateToPenaltyBox && r.flags === vr.MoveAllAlternatesMatchingHost) { const s = this.levels; let i = this._pathwayPriority, a = this.pathwayId; if (t.context) { const { groupId: o, pathwayId: c, type: u } = t.context; o && s ? a = this.getPathwayForGroupId(o, u, a) : c && (a = c) } a in this.penalizedPathways || (this.penalizedPathways[a] = performance.now()), !i && s && (i = this.pathways()), i && i.length > 1 && (this.updatePathwayPriority(i), r.resolved = this.pathwayId !== a), t.details === J.BUFFER_APPEND_ERROR && !t.fatal ? r.resolved = !0 : r.resolved || this.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${a} levels: ${s && s.length} priorities: ${it(i)} penalized: ${it(this.penalizedPathways)}`) } } filterParsedLevels(e) { this.levels = e; let t = this.getLevelsForPathway(this.pathwayId); if (t.length === 0) { const r = e[0].pathwayId; this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), t = this.getLevelsForPathway(r), this.pathwayId = r } return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t } getLevelsForPathway(e) { return this.levels === null ? [] : this.levels.filter(t => e === t.pathwayId) } updatePathwayPriority(e) { this._pathwayPriority = e; let t; const r = this.penalizedPathways, s = performance.now(); Object.keys(r).forEach(i => { s - r[i] > m5 && delete r[i] }); for (let i = 0; i < e.length; i++) { const a = e[i]; if (a in r) continue; if (a === this.pathwayId) return; const o = this.hls.nextLoadLevel, c = this.hls.levels[o]; if (t = this.getLevelsForPathway(a), t.length > 0) { this.log(`Setting Pathway to "${a}"`), this.pathwayId = a, sw(t), this.hls.trigger(k.LEVELS_UPDATED, { levels: t }); const u = this.hls.levels[o]; c && u && this.levels && (u.attrs["STABLE-VARIANT-ID"] !== c.attrs["STABLE-VARIANT-ID"] && u.bitrate !== c.bitrate && this.log(`Unstable Pathways change from bitrate ${c.bitrate} to ${u.bitrate}`), this.hls.nextLoadLevel = o); break } } } getPathwayForGroupId(e, t, r) { const s = this.getLevelsForPathway(r).concat(this.levels || []); for (let i = 0; i < s.length; i++)if (t === He.AUDIO_TRACK && s[i].hasAudioGroup(e) || t === He.SUBTITLE_TRACK && s[i].hasSubtitleGroup(e)) return s[i].pathwayId; return r } clonePathways(e) { const t = this.levels; if (!t) return; const r = {}, s = {}; e.forEach(i => { const { ID: a, "BASE-ID": o, "URI-REPLACEMENT": c } = i; if (t.some(f => f.pathwayId === a)) return; const u = this.getLevelsForPathway(o).map(f => { const h = new gt(f.attrs); h["PATHWAY-ID"] = a; const p = h.AUDIO && `${h.AUDIO}_clone_${a}`, v = h.SUBTITLES && `${h.SUBTITLES}_clone_${a}`; p && (r[h.AUDIO] = p, h.AUDIO = p), v && (s[h.SUBTITLES] = v, h.SUBTITLES = v); const g = $w(f.uri, h["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", c), y = new eo({ attrs: h, audioCodec: f.audioCodec, bitrate: f.bitrate, height: f.height, name: f.name, url: g, videoCodec: f.videoCodec, width: f.width }); if (f.audioGroups) for (let w = 1; w < f.audioGroups.length; w++)y.addGroupId("audio", `${f.audioGroups[w]}_clone_${a}`); if (f.subtitleGroups) for (let w = 1; w < f.subtitleGroups.length; w++)y.addGroupId("text", `${f.subtitleGroups[w]}_clone_${a}`); return y }); t.push(...u), Qv(this.audioTracks, r, c, a), Qv(this.subtitleTracks, s, c, a) }) } loadSteeringManifest(e) { const t = this.hls.config, r = t.loader; this.loader && this.loader.destroy(), this.loader = new r(t); let s; try { s = new self.URL(e) } catch { this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`); return } if (s.protocol !== "data:") { const f = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0; s.searchParams.set("_HLS_pathway", this.pathwayId), s.searchParams.set("_HLS_throughput", "" + f) } const i = { responseType: "json", url: s.href }, a = t.steeringManifestLoadPolicy.default, o = a.errorRetry || a.timeoutRetry || {}, c = { loadPolicy: a, timeout: a.maxLoadTimeMs, maxRetry: o.maxNumRetry || 0, retryDelay: o.retryDelayMs || 0, maxRetryDelay: o.maxRetryDelayMs || 0 }, u = { onSuccess: (f, h, p, v) => { this.log(`Loaded steering manifest: "${s}"`); const g = f.data; if (g?.VERSION !== 1) { this.log(`Steering VERSION ${g.VERSION} not supported!`); return } this.updated = performance.now(), this.timeToLoad = g.TTL; const { "RELOAD-URI": y, "PATHWAY-CLONES": w, "PATHWAY-PRIORITY": T } = g; if (y) try { this.uri = new self.URL(y, s).href } catch { this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${y}`); return } this.scheduleRefresh(this.uri || p.url), w && this.clonePathways(w); const S = { steeringManifest: g, url: s.toString() }; this.hls.trigger(k.STEERING_MANIFEST_LOADED, S), T && this.updatePathwayPriority(T) }, onError: (f, h, p, v) => { if (this.log(`Error loading steering manifest: ${f.code} ${f.text} (${h.url})`), this.stopLoad(), f.code === 410) { this.enabled = !1, this.log(`Steering manifest ${h.url} no longer available`); return } let g = this.timeToLoad * 1e3; if (f.code === 429) { const y = this.loader; if (typeof y?.getResponseHeader == "function") { const w = y.getResponseHeader("Retry-After"); w && (g = parseFloat(w) * 1e3) } this.log(`Steering manifest ${h.url} rate limited`); return } this.scheduleRefresh(this.uri || h.url, g) }, onTimeout: (f, h, p) => { this.log(`Timeout loading steering manifest (${h.url})`), this.scheduleRefresh(this.uri || h.url) } }; this.log(`Requesting steering manifest: ${s}`), this.loader.load(i, c, u) } scheduleRefresh(e, t = this.timeToLoad * 1e3) { this.clearTimeout(), this.reloadTimer = self.setTimeout(() => { var r; const s = (r = this.hls) == null ? void 0 : r.media; if (s && !s.ended) { this.loadSteeringManifest(e); return } this.scheduleRefresh(e, this.timeToLoad * 1e3) }, t) } } function Qv(n, e, t, r) { n && Object.keys(e).forEach(s => { const i = n.filter(a => a.groupId === s).map(a => { const o = nt({}, a); return o.details = void 0, o.attrs = new gt(o.attrs), o.url = o.attrs.URI = $w(a.url, a.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t), o.groupId = o.attrs["GROUP-ID"] = e[s], o.attrs["PATHWAY-ID"] = r, o }); n.push(...i) }) } function $w(n, e, t, r) { const { HOST: s, PARAMS: i, [t]: a } = r; let o; e && (o = a?.[e], o && (n = o)); const c = new self.URL(n); return s && !o && (c.host = s), i && Object.keys(i).sort().forEach(u => { u && c.searchParams.set(u, i[u]) }), c.href } class Oi extends Pr {
    constructor(e) { super("eme", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = Oi.CDMCleanupPromise ? [Oi.CDMCleanupPromise] : [], this.bannedKeyIds = {}, this.onMediaEncrypted = t => { const { initDataType: r, initData: s } = t, i = `"${t.type}" event: init data type: "${r}"`; if (this.debug(i), s !== null) { if (!this.keyFormatPromise) { let a = Object.keys(this.keySystemAccessPromises); a.length || (a = $a(this.config)); const o = a.map(pf).filter(c => !!c); this.keyFormatPromise = this.getKeyFormatPromise(o) } this.keyFormatPromise.then(a => { const o = rc(a); if (r !== "sinf" || o !== xt.FAIRPLAY) { this.log(`Ignoring "${t.type}" event with init data type: "${r}" for selected key-system ${o}`); return } let c; try { const v = kt(new Uint8Array(s)), g = wp(JSON.parse(v).sinf), y = Ob(g); if (!y) throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc"); c = new Uint8Array(y.subarray(8, 24)) } catch (v) { this.warn(`${i} Failed to parse sinf: ${v}`); return } const u = or(c), { keyIdToKeySessionPromise: f, mediaKeySessions: h } = this; let p = f[u]; for (let v = 0; v < h.length; v++) { const g = h[v], y = g.decryptdata; if (!y.keyId) continue; const w = or(y.keyId); if (yp(c, y.keyId) || y.uri.replace(/-/g, "").indexOf(u) !== -1) { if (p = f[w], !p) continue; if (y.pssh) break; delete f[w], y.pssh = new Uint8Array(s), y.keyId = c, p = f[u] = p.then(() => this.generateRequestWithPreferredKeySession(g, r, s, "encrypted-event-key-match")), p.catch(T => this.handleError(T)); break } } p || this.handleError(new Error(`Key ID ${u} not encountered in playlist. Key-system sessions ${h.length}.`)) }).catch(a => this.handleError(a)) } }, this.onWaitingForKey = t => { this.log(`"${t.type}" event`) }, this.hls = e, this.config = e.config, this.registerListeners() } destroy() { this.onDestroying(), this.onMediaDetached(); const e = this.config; e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null } registerListeners() { this.hls.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(k.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(k.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(k.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(k.DESTROYING, this.onDestroying, this) } unregisterListeners() { this.hls.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(k.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(k.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(k.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(k.DESTROYING, this.onDestroying, this) } getLicenseServerUrl(e) { const { drmSystems: t, widevineLicenseUrl: r } = this.config, s = t?.[e]; if (s) return s.licenseUrl; if (e === xt.WIDEVINE && r) return r } getLicenseServerUrlOrThrow(e) { const t = this.getLicenseServerUrl(e); if (t === void 0) throw new Error(`no license server URL configured for key-system "${e}"`); return t } getServerCertificateUrl(e) { const { drmSystems: t } = this.config, r = t?.[e]; if (r) return r.serverCertificateUrl; this.log(`No Server Certificate in config.drmSystems["${e}"]`) } attemptKeySystemAccess(e) { const t = this.hls.levels, r = (a, o, c) => !!a && c.indexOf(a) === o, s = t.map(a => a.audioCodec).filter(r), i = t.map(a => a.videoCodec).filter(r); return s.length + i.length === 0 && i.push("avc1.42e01e"), new Promise((a, o) => { const c = u => { const f = u.shift(); this.getMediaKeysPromise(f, s, i).then(h => a({ keySystem: f, mediaKeys: h })).catch(h => { u.length ? c(u) : h instanceof xr ? o(h) : o(new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_NO_ACCESS, error: h, fatal: !0 }, h.message)) }) }; c(e) }) } requestMediaKeySystemAccess(e, t) { const { requestMediaKeySystemAccessFunc: r } = this.config; if (typeof r != "function") { let s = `Configured requestMediaKeySystemAccess is not a function ${r}`; return Qb === null && self.location.protocol === "http:" && (s = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(s)) } return r(e, t) } getMediaKeysPromise(e, t, r) { var s; const i = X_(e, t, r, this.config.drmSystemOptions || {}); let a = this.keySystemAccessPromises[e], o = (s = a) == null ? void 0 : s.keySystemAccess; if (!o) { this.log(`Requesting encrypted media "${e}" key-system access with config: ${it(i)}`), o = this.requestMediaKeySystemAccess(e, i); const c = a = this.keySystemAccessPromises[e] = { keySystemAccess: o }; return o.catch(u => { this.log(`Failed to obtain access to key-system "${e}": ${u}`) }), o.then(u => { this.log(`Access for key-system "${u.keySystem}" obtained`); const f = this.fetchServerCertificate(e); this.log(`Create media-keys for "${e}"`); const h = c.mediaKeys = u.createMediaKeys().then(p => (this.log(`Media-keys created for "${e}"`), c.hasMediaKeys = !0, f.then(v => v ? this.setMediaKeysServerCertificate(p, e, v) : p))); return h.catch(p => { this.error(`Failed to create media-keys for "${e}"}: ${p}`) }), h }) } return o.then(() => a.mediaKeys) } createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: r }) { this.log(`Creating key-system session "${t}" keyId: ${or(e.keyId || [])} keyUri: ${e.uri}`); const s = r.createSession(), i = { decryptdata: e, keySystem: t, mediaKeys: r, mediaKeysSession: s, keyStatus: "status-pending" }; return this.mediaKeySessions.push(i), i } renewKeySession(e) { const t = e.decryptdata; if (t.pssh) { const r = this.createMediaKeySessionContext(e), s = Ul(t), i = "cenc"; this.keyIdToKeySessionPromise[s] = this.generateRequestWithPreferredKeySession(r, i, t.pssh.buffer, "expired") } else this.warn("Could not renew expired session. Missing pssh initData."); this.removeSession(e) } updateKeySession(e, t) {
      const r = e.mediaKeysSession; return this.log(`Updating key-session "${r.sessionId}" for keyId ${or(e.decryptdata.keyId || [])}
      } (data length: ${t.byteLength})`), r.update(t)
    } getSelectedKeySystemFormats() { return Object.keys(this.keySystemAccessPromises).map(e => ({ keySystem: e, hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys })).filter(({ hasMediaKeys: e }) => !!e).map(({ keySystem: e }) => pf(e)).filter(e => !!e) } getKeySystemAccess(e) { return this.getKeySystemSelectionPromise(e).then(({ keySystem: t, mediaKeys: r }) => this.attemptSetMediaKeys(t, r)) } selectKeySystem(e) { return new Promise((t, r) => { this.getKeySystemSelectionPromise(e).then(({ keySystem: s }) => { const i = pf(s); i ? t(i) : r(new Error(`Unable to find format for key-system "${s}"`)) }).catch(r) }) } selectKeySystemFormat(e) { const t = Object.keys(e.levelkeys || {}); return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise } getKeyFormatPromise(e) { const t = $a(this.config), r = e.map(rc).filter(s => !!s && t.indexOf(s) !== -1); return this.selectKeySystem(r) } getKeyStatus(e) { const { mediaKeySessions: t } = this; for (let r = 0; r < t.length; r++) { const s = x5(e, t[r]); if (s) return s } } loadKey(e) { const t = e.keyInfo.decryptdata, r = Ul(t), s = this.bannedKeyIds[r]; if (s || this.getKeyStatus(t) === "internal-error") { const o = Zv(s || "internal-error", t); return this.handleError(o, e.frag), Promise.reject(o) } const i = `(keyId: ${r} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`; this.log(`Starting session for key ${i}`); const a = this.keyIdToKeySessionPromise[r]; if (!a) { const o = this.getKeySystemForKeyPromise(t).then(({ keySystem: c, mediaKeys: u }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`), this.attemptSetMediaKeys(c, u).then(() => (this.throwIfDestroyed(), this.createMediaKeySessionContext({ keySystem: c, mediaKeys: u, decryptdata: t }))))).then(c => { const u = "cenc", f = t.pssh ? t.pssh.buffer : null; return this.generateRequestWithPreferredKeySession(c, u, f, "playlist-key") }); return o.catch(c => this.handleError(c, e.frag)), this.keyIdToKeySessionPromise[r] = o, o } return a.catch(o => { if (o instanceof xr) { const c = et({}, o.data); this.getKeyStatus(t) === "internal-error" && (c.decryptdata = t); const u = new xr(c, o.message); this.handleError(u, e.frag) } }), a } throwIfDestroyed(e = "Invalid state") { if (!this.hls) throw new Error("invalid state") } handleError(e, t) { if (this.hls) if (e instanceof xr) { t && (e.data.frag = t); const r = e.data.decryptdata; this.error(`${e.message}${r ? ` (${or(r.keyId || [])})` : ""}`), this.hls.trigger(k.ERROR, e.data) } else this.error(e.message), this.hls.trigger(k.ERROR, { type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_NO_KEYS, error: e, fatal: !0 }) } getKeySystemForKeyPromise(e) { const t = Ul(e), r = this.keyIdToKeySessionPromise[t]; if (!r) { const s = rc(e.keyFormat), i = s ? [s] : $a(this.config); return this.attemptKeySystemAccess(i) } return r } getKeySystemSelectionPromise(e) { if (e.length || (e = $a(this.config)), e.length === 0) throw new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_NO_CONFIGURED_LICENSE, fatal: !0 }, `Missing key-system license configuration options ${it({ drmSystems: this.config.drmSystems })}`); return this.attemptKeySystemAccess(e) } attemptSetMediaKeys(e, t) { if (this.mediaKeys === t) return Promise.resolve(); const r = this.setMediaKeysQueue.slice(); this.log(`Setting media-keys for "${e}"`); const s = Promise.all(r).then(() => { if (!this.media) throw this.mediaKeys = null, new Error("Attempted to set mediaKeys without media element attached"); return this.media.setMediaKeys(t) }); return this.mediaKeys = t, this.setMediaKeysQueue.push(s), s.then(() => { this.log(`Media-keys set for "${e}"`), r.push(s), this.setMediaKeysQueue = this.setMediaKeysQueue.filter(i => r.indexOf(i) === -1) }) } generateRequestWithPreferredKeySession(e, t, r, s) { var i; const a = (i = this.config.drmSystems) == null || (i = i[e.keySystem]) == null ? void 0 : i.generateRequest; if (a) try { const g = a.call(this.hls, t, r, e); if (!g) throw new Error("Invalid response from configured generateRequest filter"); t = g.initDataType, r = g.initData ? g.initData : null, e.decryptdata.pssh = r ? new Uint8Array(r) : null } catch (g) { if (this.warn(g.message), this.hls && this.hls.config.debug) throw g } if (r === null) return this.log(`Skipping key-session request for "${s}" (no initData)`), Promise.resolve(e); const o = Ul(e.decryptdata), c = e.decryptdata.uri; this.log(`Generating key-session request for "${s}" keyId: ${o} URI: ${c} (init data type: ${t} length: ${r.byteLength})`); const u = new Ep, f = e._onmessage = g => { const y = e.mediaKeysSession; if (!y) { u.emit("error", new Error("invalid state")); return } const { messageType: w, message: T } = g; this.log(`"${w}" message event for session "${y.sessionId}" message size: ${T.byteLength}`), w === "license-request" || w === "license-renewal" ? this.renewLicense(e, T).catch(S => { u.eventNames().length ? u.emit("error", S) : this.handleError(S) }) : w === "license-release" ? e.keySystem === xt.FAIRPLAY && this.updateKeySession(e, Eh("acknowledged")).then(() => this.removeSession(e)).catch(S => this.handleError(S)) : this.warn(`unhandled media key message type "${w}"`) }, h = (g, y) => { y.keyStatus = g; let w; g.startsWith("usable") ? u.emit("resolved") : g === "internal-error" || g === "output-restricted" || g === "output-downscaled" ? w = Zv(g, y.decryptdata) : g === "expired" ? w = new Error(`key expired (keyId: ${o})`) : g === "released" ? w = new Error("key released") : g === "status-pending" || this.warn(`unhandled key status change "${g}" (keyId: ${o})`), w && (u.eventNames().length ? u.emit("error", w) : this.handleError(w)) }, p = e._onkeystatuseschange = g => { if (!e.mediaKeysSession) { u.emit("error", new Error("invalid state")); return } const w = this.getKeyStatuses(e); if (!Object.keys(w).some(I => w[I] !== "status-pending")) return; if (w[o] === "expired") { this.log(`Expired key ${it(w)} in key-session "${e.mediaKeysSession.sessionId}"`), this.renewKeySession(e); return } let S = w[o]; if (S) h(S, e); else { var E; e.keyStatusTimeouts || (e.keyStatusTimeouts = {}), (E = e.keyStatusTimeouts)[o] || (E[o] = self.setTimeout(() => { if (!e.mediaKeysSession || !this.mediaKeys) return; const C = this.getKeyStatus(e.decryptdata); if (C && C !== "status-pending") return this.log(`No status for keyId ${o} in key-session "${e.mediaKeysSession.sessionId}". Using session key-status ${C} from other session.`), h(C, e); this.log(`key status for ${o} in key-session "${e.mediaKeysSession.sessionId}" timed out after 0ms`), S = "internal-error", h(S, e) }, 0)), this.log(`No status for keyId ${o} (${it(w)}).`) } }; Yt(e.mediaKeysSession, "message", f), Yt(e.mediaKeysSession, "keystatuseschange", p); const v = new Promise((g, y) => { u.on("error", y), u.on("resolved", g) }); return e.mediaKeysSession.generateRequest(t, r).then(() => { this.log(`Request generated for key-session "${e.mediaKeysSession.sessionId}" keyId: ${o} URI: ${c}`) }).catch(g => { throw new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_NO_SESSION, error: g, decryptdata: e.decryptdata, fatal: !1 }, `Error generating key-session request: ${g}`) }).then(() => v).catch(g => (u.removeAllListeners(), this.removeSession(e).then(() => { throw g }))).then(() => (u.removeAllListeners(), e)) } getKeyStatuses(e) { const t = {}; return e.mediaKeysSession.keyStatuses.forEach((r, s) => { if (typeof s == "string" && typeof r == "object") { const o = s; s = r, r = o } const i = "buffer" in s ? new Uint8Array(s.buffer, s.byteOffset, s.byteLength) : new Uint8Array(s); e.keySystem === xt.PLAYREADY && i.length === 16 && Xb(i); const a = or(i); r === "internal-error" && (this.bannedKeyIds[a] = r), this.log(`key status change "${r}" for keyStatuses keyId: ${a} key-session "${e.mediaKeysSession.sessionId}"`), t[a] = r }), t } fetchServerCertificate(e) { const t = this.config, r = t.loader, s = new r(t), i = this.getServerCertificateUrl(e); return i ? (this.log(`Fetching server certificate for "${e}"`), new Promise((a, o) => { const c = { responseType: "arraybuffer", url: i }, u = t.certLoadPolicy.default, f = { loadPolicy: u, timeout: u.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }, h = { onSuccess: (p, v, g, y) => { a(p.data) }, onError: (p, v, g, y) => { o(new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: g, response: et({ url: c.url, data: void 0 }, p) }, `"${e}" certificate request failed (${i}). Status: ${p.code} (${p.text})`)) }, onTimeout: (p, v, g) => { o(new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED, fatal: !0, networkDetails: g, response: { url: c.url, data: void 0 } }, `"${e}" certificate request timed out (${i})`)) }, onAbort: (p, v, g) => { o(new Error("aborted")) } }; s.load(c, f, h) })) : Promise.resolve() } setMediaKeysServerCertificate(e, t, r) { return new Promise((s, i) => { e.setServerCertificate(r).then(a => { this.log(`setServerCertificate ${a ? "success" : "not supported by CDM"} (${r.byteLength}) on "${t}"`), s(e) }).catch(a => { i(new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED, error: a, fatal: !0 }, a.message)) }) }) } renewLicense(e, t) { return this.requestLicense(e, new Uint8Array(t)).then(r => this.updateKeySession(e, new Uint8Array(r)).catch(s => { throw new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_SESSION_UPDATE_FAILED, decryptdata: e.decryptdata, error: s, fatal: !1 }, s.message) })) } unpackPlayReadyKeyMessage(e, t) { const r = String.fromCharCode.apply(null, new Uint16Array(t.buffer)); if (!r.includes("PlayReadyKeyMessage")) return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), t; const s = new DOMParser().parseFromString(r, "application/xml"), i = s.querySelectorAll("HttpHeader"); if (i.length > 0) { let f; for (let h = 0, p = i.length; h < p; h++) { var a, o; f = i[h]; const v = (a = f.querySelector("name")) == null ? void 0 : a.textContent, g = (o = f.querySelector("value")) == null ? void 0 : o.textContent; v && g && e.setRequestHeader(v, g) } } const c = s.querySelector("Challenge"), u = c?.textContent; if (!u) throw new Error("Cannot find <Challenge> in key message"); return Eh(atob(u)) } setupLicenseXHR(e, t, r, s) { const i = this.config.licenseXhrSetup; return i ? Promise.resolve().then(() => { if (!r.decryptdata) throw new Error("Key removed"); return i.call(this.hls, e, t, r, s) }).catch(a => { if (!r.decryptdata) throw a; return e.open("POST", t, !0), i.call(this.hls, e, t, r, s) }).then(a => (e.readyState || e.open("POST", t, !0), { xhr: e, licenseChallenge: a || s })) : (e.open("POST", t, !0), Promise.resolve({ xhr: e, licenseChallenge: s })) } requestLicense(e, t) { const r = this.config.keyLoadPolicy.default; return new Promise((s, i) => { const a = this.getLicenseServerUrlOrThrow(e.keySystem); this.log(`Sending license request to URL: ${a}`); const o = new XMLHttpRequest; o.responseType = "arraybuffer", o.onreadystatechange = () => { if (!this.hls || !e.mediaKeysSession) return i(new Error("invalid state")); if (o.readyState === 4) if (o.status === 200) { this._requestLicenseFailureCount = 0; let c = o.response; this.log(`License received ${c instanceof ArrayBuffer ? c.byteLength : c}`); const u = this.config.licenseResponseCallback; if (u) try { c = u.call(this.hls, o, a, e) } catch (f) { this.error(f) } s(c) } else { const c = r.errorRetry, u = c ? c.maxNumRetry : 0; if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > u || o.status >= 400 && o.status < 500) i(new xr({ type: Ee.KEY_SYSTEM_ERROR, details: J.KEY_SYSTEM_LICENSE_REQUEST_FAILED, decryptdata: e.decryptdata, fatal: !0, networkDetails: o, response: { url: a, data: void 0, code: o.status, text: o.statusText } }, `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`)); else { const f = u - this._requestLicenseFailureCount + 1; this.warn(`Retrying license request, ${f} attempts left`), this.requestLicense(e, t).then(s, i) } } }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = o, this.setupLicenseXHR(o, a, e, t).then(({ xhr: c, licenseChallenge: u }) => { e.keySystem == xt.PLAYREADY && (u = this.unpackPlayReadyKeyMessage(c, u)), c.send(u) }).catch(i) }) } onDestroying() { this.unregisterListeners(), this._clear() } onMediaAttached(e, t) { if (!this.config.emeEnabled) return; const r = t.media; this.media = r, Yt(r, "encrypted", this.onMediaEncrypted), Yt(r, "waitingforkey", this.onWaitingForKey) } onMediaDetached() { const e = this.media; e && (lr(e, "encrypted", this.onMediaEncrypted), lr(e, "waitingforkey", this.onWaitingForKey), this.media = null, this.mediaKeys = null) } _clear() { var e; if (this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, this.bannedKeyIds = {}, !this.mediaKeys && !this.mediaKeySessions.length) return; const t = this.media, r = this.mediaKeySessions.slice(); this.mediaKeySessions = [], this.mediaKeys = null, to.clearKeyUriToKeyIdMap(); const s = r.length; Oi.CDMCleanupPromise = Promise.all(r.map(i => this.removeSession(i)).concat((t == null || (e = t.setMediaKeys(null)) == null ? void 0 : e.catch(i => { this.log(`Could not clear media keys: ${i}`), this.hls && this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR, fatal: !1, error: new Error(`Could not clear media keys: ${i}`) }) })) || Promise.resolve())).catch(i => { this.log(`Could not close sessions and clear media keys: ${i}`), this.hls && this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR, fatal: !1, error: new Error(`Could not close sessions and clear media keys: ${i}`) }) }).then(() => { s && this.log("finished closing key sessions and clearing media keys") }) } onManifestLoading() { this.keyFormatPromise = null, this.bannedKeyIds = {} } onManifestLoaded(e, { sessionKeys: t }) { if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) { const r = t.reduce((s, i) => (s.indexOf(i.keyFormat) === -1 && s.push(i.keyFormat), s), []); this.log(`Selecting key-system from session-keys ${r.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(r) } } removeSession(e) { const { mediaKeysSession: t, licenseXhr: r, decryptdata: s } = e; if (t) { this.log(`Remove licenses and keys and close session "${t.sessionId}" keyId: ${or(s?.keyId || [])}`), e._onmessage && (t.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0; const i = this.mediaKeySessions.indexOf(e); i > -1 && this.mediaKeySessions.splice(i, 1); const { keyStatusTimeouts: a } = e; a && Object.keys(a).forEach(u => self.clearTimeout(a[u])); const { drmSystemOptions: o } = this.config; return (Z_(o) ? new Promise((u, f) => { self.setTimeout(() => f(new Error("MediaKeySession.remove() timeout")), 8e3), t.remove().then(u).catch(f) }) : Promise.resolve()).catch(u => { this.log(`Could not remove session: ${u}`), this.hls && this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR, fatal: !1, error: new Error(`Could not remove session: ${u}`) }) }).then(() => t.close()).catch(u => { this.log(`Could not close session: ${u}`), this.hls && this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR, fatal: !1, error: new Error(`Could not close session: ${u}`) }) }) } return Promise.resolve() }
  } Oi.CDMCleanupPromise = void 0; function Ul(n) { if (!n) throw new Error("Could not read keyId of undefined decryptdata"); if (n.keyId === null) throw new Error("keyId is null"); return or(n.keyId) } function x5(n, e) { if (n.keyId && e.mediaKeysSession.keyStatuses.has(n.keyId)) return e.mediaKeysSession.keyStatuses.get(n.keyId); if (n.matches(e.decryptdata)) return e.keyStatus } class xr extends Error { constructor(e, t) { super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error } } function Zv(n, e) { const t = n === "output-restricted", r = t ? J.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : J.KEY_SYSTEM_STATUS_INTERNAL_ERROR; return new xr({ type: Ee.KEY_SYSTEM_ERROR, details: r, fatal: !1, decryptdata: e }, t ? "HDCP level output restricted" : `key status changed to "${n}"`) } class v5 { constructor(e) { this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners() } setStreamController(e) { this.streamController = e } registerListeners() { this.hls.on(k.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(k.MEDIA_DETACHING, this.onMediaDetaching, this) } unregisterListeners() { this.hls.off(k.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(k.MEDIA_DETACHING, this.onMediaDetaching, this) } destroy() { this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null } onMediaAttaching(e, t) { const r = this.hls.config; if (r.capLevelOnFPSDrop) { const s = t.media instanceof self.HTMLVideoElement ? t.media : null; this.media = s, s && typeof s.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod) } } onMediaDetaching() { this.media = null } checkFPS(e, t, r) { const s = performance.now(); if (t) { if (this.lastTime) { const i = s - this.lastTime, a = r - this.lastDroppedFrames, o = t - this.lastDecodedFrames, c = 1e3 * a / i, u = this.hls; if (u.trigger(k.FPS_DROP, { currentDropped: a, currentDecoded: o, totalDroppedFrames: r }), c > 0 && a > u.config.fpsDroppedMonitoringThreshold * o) { let f = u.currentLevel; u.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + f), f > 0 && (u.autoLevelCapping === -1 || u.autoLevelCapping >= f) && (f = f - 1, u.trigger(k.FPS_DROP_LEVEL_CAPPING, { level: f, droppedLevel: u.currentLevel }), u.autoLevelCapping = f, this.streamController.nextLevelSwitch()) } } this.lastTime = s, this.lastDroppedFrames = r, this.lastDecodedFrames = t } } checkFPSInterval() { const e = this.media; if (e) if (this.isVideoPlaybackQualityAvailable) { const t = e.getVideoPlaybackQuality(); this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames) } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount) } } function Bw(n, e) { let t; try { t = new Event("addtrack") } catch { t = document.createEvent("Event"), t.initEvent("addtrack", !1, !1) } t.track = n, e.dispatchEvent(t) } function Uw(n, e) { const t = n.mode; if (t === "disabled" && (n.mode = "hidden"), n.cues && !n.cues.getCueById(e.id)) try { if (n.addCue(e), !n.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`) } catch (r) { tt.debug(`[texttrack-utils]: ${r}`); try { const s = new self.TextTrackCue(e.startTime, e.endTime, e.text); s.id = e.id, n.addCue(s) } catch (s) { tt.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${s}`) } } t === "disabled" && (n.mode = t) } function ki(n, e) { const t = n.mode; if (t === "disabled" && (n.mode = "hidden"), n.cues) for (let r = n.cues.length; r--;)e && n.cues[r].removeEventListener("enter", e), n.removeCue(n.cues[r]); t === "disabled" && (n.mode = t) } function Ph(n, e, t, r) { const s = n.mode; if (s === "disabled" && (n.mode = "hidden"), n.cues && n.cues.length > 0) { const i = b5(n.cues, e, t); for (let a = 0; a < i.length; a++)(!r || r(i[a])) && n.removeCue(i[a]) } s === "disabled" && (n.mode = s) } function y5(n, e) { if (e <= n[0].startTime) return 0; const t = n.length - 1; if (e > n[t].endTime) return -1; let r = 0, s = t, i; for (; r <= s;)if (i = Math.floor((s + r) / 2), e < n[i].startTime) s = i - 1; else if (e > n[i].startTime && r < t) r = i + 1; else return i; return n[r].startTime - e < e - n[s].startTime ? r : s } function b5(n, e, t) { const r = [], s = y5(n, e); if (s > -1) for (let i = s, a = n.length; i < a; i++) { const o = n[i]; if (o.startTime >= e && o.endTime <= t) r.push(o); else if (o.startTime > t) return r } return r } function ac(n) { const e = []; for (let t = 0; t < n.length; t++) { const r = n[t]; (r.kind === "subtitles" || r.kind === "captions") && r.label && e.push(n[t]) } return e } class w5 extends Rp { constructor(e) { super(e, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.onTextTracksChanged = () => { if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return; let t = null; const r = ac(this.media.textTracks); for (let i = 0; i < r.length; i++)if (r[i].mode === "hidden") t = r[i]; else if (r[i].mode === "showing") { t = r[i]; break } const s = this.findTrackForTextTrack(t); this.subtitleTrack !== s && this.setSubtitleTrack(s) }, this.registerListeners() } destroy() { this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy() } get subtitleDisplay() { return this._subtitleDisplay } set subtitleDisplay(e) { this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes() } registerListeners() { const { hls: e } = this; e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_PARSED, this.onManifestParsed, this), e.on(k.LEVEL_LOADING, this.onLevelLoading, this), e.on(k.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(k.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(k.ERROR, this.onError, this) } unregisterListeners() { const { hls: e } = this; e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_PARSED, this.onManifestParsed, this), e.off(k.LEVEL_LOADING, this.onLevelLoading, this), e.off(k.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(k.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(k.ERROR, this.onError, this) } onMediaAttached(e, t) { this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange)) } pollTrackChange(e) { self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e) } onMediaDetaching(e, t) { const r = this.media; if (!r) return; const s = !!t.transferMedia; if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || r.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, s) return; ac(r.textTracks).forEach(a => { ki(a) }) } onManifestLoading() { this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0 } onManifestParsed(e, t) { this.tracks = t.subtitleTracks } onSubtitleTrackLoaded(e, t) { const { id: r, groupId: s, details: i } = t, a = this.tracksInGroup[r]; if (!a || a.groupId !== s) { this.warn(`Subtitle track with id:${r} and group:${s} not found in active group ${a?.groupId}`); return } const o = a.details; a.details = t.details, this.log(`Subtitle track ${r} "${a.name}" lang:${a.lang} group:${s} loaded [${i.startSN}-${i.endSN}]`), r === this.trackId && this.playlistLoaded(r, t, o) } onLevelLoading(e, t) { this.switchLevel(t.level) } onLevelSwitching(e, t) { this.switchLevel(t.level) } switchLevel(e) { const t = this.hls.levels[e]; if (!t) return; const r = t.subtitleGroups || null, s = this.groupIds; let i = this.currentTrack; if (!r || s?.length !== r?.length || r != null && r.some(a => s?.indexOf(a) === -1)) { this.groupIds = r, this.trackId = -1, this.currentTrack = null; const a = this.tracks.filter(f => !r || r.indexOf(f.groupId) !== -1); if (a.length) this.selectDefaultTrack && !a.some(f => f.default) && (this.selectDefaultTrack = !1), a.forEach((f, h) => { f.id = h }); else if (!i && !this.tracksInGroup.length) return; this.tracksInGroup = a; const o = this.hls.config.subtitlePreference; if (!i && o) { this.selectDefaultTrack = !1; const f = cn(o, a); if (f > -1) i = a[f]; else { const h = cn(o, this.tracks); i = this.tracks[h] } } let c = this.findTrackId(i); c === -1 && i && (c = this.findTrackId(null)); const u = { subtitleTracks: a }; this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${r?.join(",")}" group-id`), this.hls.trigger(k.SUBTITLE_TRACKS_UPDATED, u), c !== -1 && this.trackId === -1 && this.setSubtitleTrack(c) } } findTrackId(e) { const t = this.tracksInGroup, r = this.selectDefaultTrack; for (let s = 0; s < t.length; s++) { const i = t[s]; if (!(r && !i.default || !r && !e) && (!e || Hs(i, e))) return s } if (e) { for (let s = 0; s < t.length; s++) { const i = t[s]; if (io(e.attrs, i.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) return s } for (let s = 0; s < t.length; s++) { const i = t[s]; if (io(e.attrs, i.attrs, ["LANGUAGE"])) return s } } return -1 } findTrackForTextTrack(e) { if (e) { const t = this.tracksInGroup; for (let r = 0; r < t.length; r++) { const s = t[r]; if (Ch(s, e)) return r } } return -1 } onError(e, t) { t.fatal || !t.context || t.context.type === He.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t) } get allSubtitleTracks() { return this.tracks } get subtitleTracks() { return this.tracksInGroup } get subtitleTrack() { return this.trackId } set subtitleTrack(e) { this.selectDefaultTrack = !1, this.setSubtitleTrack(e) } setSubtitleOption(e) { if (this.hls.config.subtitlePreference = e, e) { if (e.id === -1) return this.setSubtitleTrack(-1), null; const t = this.allSubtitleTracks; if (this.selectDefaultTrack = !1, t.length) { const r = this.currentTrack; if (r && Hs(e, r)) return r; const s = cn(e, this.tracksInGroup); if (s > -1) { const i = this.tracksInGroup[s]; return this.setSubtitleTrack(s), i } else { if (r) return null; { const i = cn(e, t); if (i > -1) return t[i] } } } } return null } loadPlaylist(e) { super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e) } loadingPlaylist(e, t) { super.loadingPlaylist(e, t); const r = e.id, s = e.groupId, i = this.getUrlWithDirectives(e.url, t), a = e.details, o = a?.age; this.log(`Loading subtitle ${r} "${e.name}" lang:${e.lang} group:${s}${t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${i}`), this.hls.trigger(k.SUBTITLE_TRACK_LOADING, { url: i, id: r, groupId: s, deliveryDirectives: t || null, track: e }) } toggleTrackModes() { const { media: e } = this; if (!e) return; const t = ac(e.textTracks), r = this.currentTrack; let s; if (r && (s = t.filter(i => Ch(r, i))[0], s || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`)), [].slice.call(t).forEach(i => { i.mode !== "disabled" && i !== s && (i.mode = "disabled") }), s) { const i = this.subtitleDisplay ? "showing" : "hidden"; s.mode !== i && (s.mode = i) } } setSubtitleTrack(e) { const t = this.tracksInGroup; if (!this.media) { this.queuedDefaultTrack = e; return } if (e < -1 || e >= t.length || !ge(e)) { this.warn(`Invalid subtitle track id: ${e}`); return } this.selectDefaultTrack = !1; const r = this.currentTrack, s = t[e] || null; if (this.trackId = e, this.currentTrack = s, this.toggleTrackModes(), !s) { this.hls.trigger(k.SUBTITLE_TRACK_SWITCH, { id: e }); return } const i = !!s.details && !s.details.live; if (e === this.trackId && s === r && i) return; this.log(`Switching to subtitle-track ${e}` + (s ? ` "${s.name}" lang:${s.lang} group:${s.groupId}` : "")); const { id: a, groupId: o = "", name: c, type: u, url: f } = s; this.hls.trigger(k.SUBTITLE_TRACK_SWITCH, { id: a, groupId: o, name: c, type: u, url: f }); const h = this.switchParams(s.url, r?.details, s.details); this.loadPlaylist(h) } } function S5() { try { return crypto.randomUUID() } catch { try { const e = URL.createObjectURL(new Blob), t = e.toString(); return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1) } catch { let t = new Date().getTime(); return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, s => { const i = (t + Math.random() * 16) % 16 | 0; return t = Math.floor(t / 16), (s == "x" ? i : i & 3 | 8).toString(16) }) } } } function Wa(n) { let e = 5381, t = n.length; for (; t;)e = e * 33 ^ n.charCodeAt(--t); return (e >>> 0).toString() } const Mi = .025; let _c = (function (n) { return n[n.Point = 0] = "Point", n[n.Range = 1] = "Range", n })({}); function E5(n, e, t) { return `${n.identifier}-${t + 1}-${Wa(e)}` } class T5 { constructor(e, t) { this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = { skip: !1, jump: !1 }, this.snapOptions = { out: !1, in: !1 }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = t, this.dateRange = e, this.setDateRange(e) } setDateRange(e) { this.dateRange = e, this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions) } reset() { var e; this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null) } isAssetPastPlayoutLimit(e) { var t; if (e > 0 && e >= this.assetList.length) return !0; const r = this.playoutLimit; return e <= 0 || isNaN(r) ? !1 : r === 0 ? !0 : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) > r } findAssetIndex(e) { return this.assetList.indexOf(e) } get identifier() { return this.dateRange.id } get startDate() { return this.dateRange.startDate } get startTime() { const e = this.dateRange.startTime; if (this.snapOptions.out) { const t = this.dateRange.tagAnchor; if (t) return Ef(e, t) } return e } get startOffset() { return this.cue.pre ? 0 : this.startTime } get startIsAligned() { if (this.startTime === 0 || this.snapOptions.out) return !0; const e = this.dateRange.tagAnchor; if (e) { const t = this.dateRange.startTime, r = Ef(t, e); return t - r < .1 } return !1 } get resumptionOffset() { const e = this.resumeOffset, t = ge(e) ? e : this.duration; return this.cumulativeDuration + t } get resumeTime() { const e = this.startOffset + this.resumptionOffset; if (this.snapOptions.in) { const t = this.resumeAnchor; if (t) return Ef(e, t) } return e } get appendInPlace() { return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < Mi)) } set appendInPlace(e) { if (this.appendInPlaceStarted) { this.resetOnResume = !e; return } this.appendInPlaceDisabled = !e } get timelineStart() { return this._timelineStart !== null ? this._timelineStart : this.startTime } set timelineStart(e) { this._timelineStart = e } get duration() { const e = this.playoutLimit; let t; return this._duration !== null ? t = this._duration : this.dateRange.duration ? t = this.dateRange.duration : t = this.dateRange.plannedDuration || 0, !isNaN(e) && e < t && (t = e), t } set duration(e) { this._duration = e } get cue() { return this.dateRange.cue } get timelineOccupancy() { return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? _c.Range : _c.Point } get supplementsPrimary() { return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY" } get contentMayVary() { return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO" } get assetUrl() { return this.dateRange.attr["X-ASSET-URI"] } get assetListUrl() { return this.dateRange.attr["X-ASSET-LIST"] } get baseUrl() { return this.base.url } get assetListLoaded() { return this.assetList.length > 0 || this.assetListResponse !== null } toString() { return A5(this) } } function Ef(n, e) { return n - e.start < e.duration / 2 && !(Math.abs(n - (e.start + e.duration)) < Mi) ? e.start : e.start + e.duration } function zw(n, e, t) { const r = new self.URL(n, t); return r.protocol !== "data:" && r.searchParams.set("_HLS_primary_id", e), r } function Tf(n, e) { for (; (t = n.assetList[++e]) != null && t.error;)var t; return e } function A5(n) { return `["${n.identifier}" ${n.cue.pre ? "<pre>" : n.cue.post ? "<post>" : ""}${n.timelineStart.toFixed(2)}-${n.resumeTime.toFixed(2)}]` } function Li(n) { const e = n.timelineStart, t = n.duration || 0; return `["${n.identifier}" ${e.toFixed(2)}-${(e + t).toFixed(2)}]` } class I5 { constructor(e, t, r, s) { this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () => { this.reachedPlayout(this.currentTime) && this.hls && this.hls.trigger(k.PLAYOUT_LIMIT_REACHED, {}) }; const i = this.hls = new e(t); this.interstitial = r, this.assetItem = s; const a = () => { this.hasDetails = !0 }; i.once(k.LEVEL_LOADED, a), i.once(k.AUDIO_TRACK_LOADED, a), i.once(k.SUBTITLE_TRACK_LOADED, a), i.on(k.MEDIA_ATTACHING, (o, { media: c }) => { this.removeMediaListeners(), this.mediaAttached = c, this.interstitial.playoutLimit && (c.addEventListener("timeupdate", this.checkPlayout), this.appendInPlace && i.on(k.BUFFER_APPENDED, () => { const f = this.bufferedEnd; this.reachedPlayout(f) && (this._bufferedEosTime = f, i.trigger(k.BUFFERED_TO_END, void 0)) })) }) } get appendInPlace() { return this.interstitial.appendInPlace } loadSource() { const e = this.hls; if (e) if (e.url) e.levels.length && !e.started && e.startLoad(-1, !0); else { let t = this.assetItem.uri; try { t = zw(t, e.config.primarySessionId || "").href } catch { } e.loadSource(t) } } bufferedInPlaceToEnd(e) { var t; if (!this.appendInPlace) return !1; if ((t = this.hls) != null && t.bufferedToEnd) return !0; if (!e) return !1; const r = Math.min(this._bufferedEosTime || 1 / 0, this.duration), s = this.timelineOffset, i = Me.bufferInfo(e, s, 0); return this.getAssetTime(i.end) >= r - .02 } reachedPlayout(e) { const r = this.interstitial.playoutLimit; return this.startOffset + e >= r } get destroyed() { var e; return !((e = this.hls) != null && e.userConfig) } get assetId() { return this.assetItem.identifier } get interstitialId() { return this.assetItem.parentIdentifier } get media() { var e; return ((e = this.hls) == null ? void 0 : e.media) || null } get bufferedEnd() { const e = this.media || this.mediaAttached; if (!e) return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime; const t = Me.bufferInfo(e, e.currentTime, .001); return this.getAssetTime(t.end) } get currentTime() { const e = this.media || this.mediaAttached; return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0 } get duration() { const e = this.assetItem.duration; if (!e) return 0; const t = this.interstitial.playoutLimit; if (t) { const r = t - this.startOffset; if (r > 0 && r < e) return r } return e } get remaining() { const e = this.duration; return e ? Math.max(0, e - this.currentTime) : 0 } get startOffset() { return this.assetItem.startOffset } get timelineOffset() { var e; return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0 } set timelineOffset(e) { const t = this.timelineOffset; if (e !== t) { const r = e - t; if (Math.abs(r) > 1 / 9e4 && this.hls) { if (this.hasDetails) throw new Error("Cannot set timelineOffset after playlists are loaded"); this.hls.config.timelineOffset = e } } } getAssetTime(e) { const t = this.timelineOffset, r = this.duration; return Math.min(Math.max(0, e - t), r) } removeMediaListeners() { const e = this.mediaAttached; e && (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener("timeupdate", this.checkPlayout)) } bufferSnapShot() { if (this.mediaAttached) { var e; (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd) } } destroy() { this.removeMediaListeners(), this.hls && this.hls.destroy(), this.hls = null, this.tracks = this.mediaAttached = this.checkPlayout = null } attachMedia(e) { var t; this.loadSource(), (t = this.hls) == null || t.attachMedia(e) } detachMedia() { var e; this.removeMediaListeners(), this.mediaAttached = null, (e = this.hls) == null || e.detachMedia() } resumeBuffering() { var e; (e = this.hls) == null || e.resumeBuffering() } pauseBuffering() { var e; (e = this.hls) == null || e.pauseBuffering() } transferMedia() { var e; return this.bufferSnapShot(), ((e = this.hls) == null ? void 0 : e.transferMedia()) || null } resetDetails() { const e = this.hls; if (e && this.hasDetails) { e.stopLoad(); const t = r => delete r.details; e.levels.forEach(t), e.allAudioTracks.forEach(t), e.allSubtitleTracks.forEach(t), this.hasDetails = !1 } } on(e, t, r) { var s; (s = this.hls) == null || s.on(e, t) } once(e, t, r) { var s; (s = this.hls) == null || s.once(e, t) } off(e, t, r) { var s; (s = this.hls) == null || s.off(e, t) } toString() { var e; return `HlsAssetPlayer: ${Li(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}` } } const Jv = .033; class L5 extends Pr { constructor(e, t) { super("interstitials-sched", t), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = { primary: 0, playout: 0, integrated: 0 }, this.onScheduleUpdate = e } destroy() { this.reset(), this.onScheduleUpdate = null } reset() { this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach(e => e.reset()), this.events = this.items = null } resetErrorsInRange(e, t) { return this.events ? this.events.reduce((r, s) => e <= s.startOffset && t > s.startOffset ? (delete s.error, r + 1) : r, 0) : 0 } get duration() { const e = this.items; return e ? e[e.length - 1].end : 0 } get length() { return this.items ? this.items.length : 0 } getEvent(e) { return e && this.eventMap[e] || null } hasEvent(e) { return e in this.eventMap } findItemIndex(e, t) { if (e.event) return this.findEventIndex(e.event.identifier); let r = -1; e.nextEvent ? r = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (r = this.findEventIndex(e.previousEvent.identifier) + 1); const s = this.items; if (s) for (s[r] || (t === void 0 && (t = e.start), r = this.findItemIndexAtTime(t)); r >= 0 && (i = s[r]) != null && i.event;) { var i; r-- } return r } findItemIndexAtTime(e, t) { const r = this.items; if (r) for (let s = 0; s < r.length; s++) { let i = r[s]; if (t && t !== "primary" && (i = i[t]), e === i.start || e > i.start && e < i.end) return s } return -1 } findJumpRestrictedIndex(e, t) { const r = this.items; if (r) for (let s = e; s <= t && r[s]; s++) { const i = r[s].event; if (i != null && i.restrictions.jump && !i.appendInPlace) return s } return -1 } findEventIndex(e) { const t = this.items; if (t) for (let s = t.length; s--;) { var r; if (((r = t[s].event) == null ? void 0 : r.identifier) === e) return s } return -1 } findAssetIndex(e, t) { const r = e.assetList, s = r.length; if (s > 1) for (let i = 0; i < s; i++) { const a = r[i]; if (!a.error) { const o = a.timelineStart; if (t === o || t > o && (t < o + (a.duration || 0) || i === s - 1)) return i } } return 0 } get assetIdAtEnd() { var e; const t = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event; if (t) { const r = t.assetList, s = r[r.length - 1]; if (s) return s.identifier } return null } parseInterstitialDateRanges(e, t) { const r = e.main.details, { dateRanges: s } = r, i = this.events, a = this.parseDateRanges(s, { url: r.url }, t), o = Object.keys(s), c = i ? i.filter(u => !o.includes(u.identifier)) : []; a.length && a.sort((u, f) => { const h = u.cue.pre, p = u.cue.post, v = f.cue.pre, g = f.cue.post; if (h && !v) return -1; if (v && !h || p && !g) return 1; if (g && !p) return -1; if (!h && !v && !p && !g) { const y = u.startTime, w = f.startTime; if (y !== w) return y - w } return u.dateRange.tagOrder - f.dateRange.tagOrder }), this.events = a, c.forEach(u => { this.removeEvent(u) }), this.updateSchedule(e, c) } updateSchedule(e, t = [], r = !1) { const s = this.events || []; if (s.length || t.length || this.length < 2) { const i = this.items, a = this.parseSchedule(s, e); (r || t.length || i?.length !== a.length || a.some((c, u) => Math.abs(c.playout.start - i[u].playout.start) > .005 || Math.abs(c.playout.end - i[u].playout.end) > .005)) && (this.items = a, this.onScheduleUpdate(t, i)) } } parseDateRanges(e, t, r) { const s = [], i = Object.keys(e); for (let a = 0; a < i.length; a++) { const o = i[a], c = e[o]; if (c.isInterstitial) { let u = this.eventMap[o]; u ? u.setDateRange(c) : (u = new T5(c, t), this.eventMap[o] = u, r === !1 && (u.appendInPlace = r)), s.push(u) } } return s } parseSchedule(e, t) { const r = [], s = t.main.details, i = s.live ? 1 / 0 : s.edge; let a = 0; if (e = e.filter(c => !c.error && !(c.cue.once && c.hasPlayed)), e.length) { this.resolveOffsets(e, t); let c = 0, u = 0; if (e.forEach((f, h) => { const p = f.cue.pre, v = f.cue.post, g = e[h - 1] || null, y = f.appendInPlace, w = v ? i : f.startOffset, T = f.duration, S = f.timelineOccupancy === _c.Range ? T : 0, E = f.resumptionOffset, I = g?.startTime === w, C = w + f.cumulativeDuration; let D = y ? C + T : w + E; if (p || !v && w <= 0) { const N = u; u += S, f.timelineStart = C; const P = a; a += T, r.push({ event: f, start: C, end: D, playout: { start: P, end: a }, integrated: { start: N, end: u } }) } else if (w <= i) { if (!I) { const _ = w - c; if (_ > Jv) { const M = c, $ = u; u += _; const B = a; a += _; const V = { previousEvent: e[h - 1] || null, nextEvent: f, start: M, end: M + _, playout: { start: B, end: a }, integrated: { start: $, end: u } }; r.push(V) } else _ > 0 && g && (g.cumulativeDuration += _, r[r.length - 1].end = w) } v && (D = C), f.timelineStart = C; const N = u; u += S; const P = a; a += T, r.push({ event: f, start: C, end: D, playout: { start: P, end: a }, integrated: { start: N, end: u } }) } else return; const R = f.resumeTime; v || R > i ? c = i : c = R }), c < i) { var o; const f = c, h = u, p = i - c; u += p; const v = a; a += p, r.push({ previousEvent: ((o = r[r.length - 1]) == null ? void 0 : o.event) || null, nextEvent: null, start: c, end: f + p, playout: { start: v, end: a }, integrated: { start: h, end: u } }) } this.setDurations(i, a, u) } else r.push({ previousEvent: null, nextEvent: null, start: 0, end: i, playout: { start: 0, end: i }, integrated: { start: 0, end: i } }), this.setDurations(i, i, i); return r } setDurations(e, t, r) { this.durations = { primary: e, playout: t, integrated: r } } resolveOffsets(e, t) { const r = t.main.details, s = r.live ? 1 / 0 : r.edge; let i = 0, a = -1; e.forEach((o, c) => { const u = o.cue.pre, f = o.cue.post, h = u ? 0 : f ? s : o.startTime; this.updateAssetDurations(o), a === h ? o.cumulativeDuration = i : (i = 0, a = h), !f && o.snapOptions.in && (o.resumeAnchor = Xs(null, r.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0), o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, t) || (o.appendInPlace = !1)), !o.appendInPlace && c + 1 < e.length && e[c + 1].startTime - e[c].resumeTime < Jv && (e[c + 1].appendInPlace = !1, e[c + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`)); const v = ge(o.resumeOffset) ? o.resumeOffset : o.duration; i += v }) } primaryCanResumeInPlaceAt(e, t) { const r = e.resumeTime, s = e.startTime + e.resumptionOffset; return Math.abs(r - s) > Mi ? (this.log(`"${e.identifier}" resumption ${r} not aligned with estimated timeline end ${s}`), !1) : !Object.keys(t).some(a => { const o = t[a].details, c = o.edge; if (r >= c) return this.log(`"${e.identifier}" resumption ${r} past ${a} playlist end ${c}`), !1; const u = Xs(null, o.fragments, r); if (!u) return this.log(`"${e.identifier}" resumption ${r} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`), !0; const f = a === "audio" ? .175 : 0; return Math.abs(u.start - r) < Mi + f || Math.abs(u.end - r) < Mi + f ? !1 : (this.log(`"${e.identifier}" resumption ${r} not aligned with ${a} fragment bounds (${u.start}-${u.end} sn: ${u.sn} cc: ${u.cc})`), !0) }) } updateAssetDurations(e) { if (!e.assetListLoaded) return; const t = e.timelineStart; let r = 0, s = !1, i = !1; for (let a = 0; a < e.assetList.length; a++) { const o = e.assetList[a], c = t + r; o.startOffset = r, o.timelineStart = c, s || (s = o.duration === null), i || (i = !!o.error); const u = o.error ? 0 : o.duration || 0; r += u } s && !i ? e.duration = Math.max(r, e.duration) : e.duration = r } removeEvent(e) { e.reset(), delete this.eventMap[e.identifier] } } function Br(n) { return `[${n.event ? '"' + n.event.identifier + '"' : "primary"}: ${n.start.toFixed(2)}-${n.end.toFixed(2)}]` } class C5 { constructor(e) { this.hls = void 0, this.hls = e } destroy() { this.hls = null } loadAssetList(e, t) { const r = e.assetListUrl; let s; try { s = zw(r, this.hls.sessionId, e.baseUrl) } catch (p) { const v = this.assignAssetListError(e, J.ASSET_LIST_LOAD_ERROR, p, r); this.hls.trigger(k.ERROR, v); return } t && s.protocol !== "data:" && s.searchParams.set("_HLS_start_offset", "" + t); const i = this.hls.config, a = i.loader, o = new a(i), c = { responseType: "json", url: s.href }, u = i.interstitialAssetListLoadPolicy.default, f = { loadPolicy: u, timeout: u.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }, h = { onSuccess: (p, v, g, y) => { const w = p.data, T = w?.ASSETS; if (!Array.isArray(T)) { const S = this.assignAssetListError(e, J.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), g.url, v, y); this.hls.trigger(k.ERROR, S); return } e.assetListResponse = w, this.hls.trigger(k.ASSET_LIST_LOADED, { event: e, assetListResponse: w, networkDetails: y }) }, onError: (p, v, g, y) => { const w = this.assignAssetListError(e, J.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${p.code} ${p.text} (${v.url})`), v.url, y, g); this.hls.trigger(k.ERROR, w) }, onTimeout: (p, v, g) => { const y = this.assignAssetListError(e, J.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${v.url})`), v.url, p, g); this.hls.trigger(k.ERROR, y) } }; return o.load(c, f, h), this.hls.trigger(k.ASSET_LIST_LOADING, { event: e }), o } assignAssetListError(e, t, r, s, i, a) { return e.error = r, { type: Ee.NETWORK_ERROR, details: t, fatal: !1, interstitial: e, url: s, error: r, networkDetails: a, stats: i } } } function ey(n) { n?.play().catch(() => { }) } function zl(n, e) { return `[${n}] Advancing timeline position to ${e}` } class k5 extends Pr {
    constructor(e, t) {
      super("interstitials", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () => { this.shouldPlay = !0 }, this.onPause = () => { this.shouldPlay = !1 }, this.onSeeking = () => { const r = this.currentTime; if (r === void 0 || this.playbackDisabled || !this.schedule) return; const s = r - this.timelinePos; if (Math.abs(s) < 1 / 7056e5) return; const a = s <= -.01; this.timelinePos = r, this.bufferedPos = r; const o = this.playingItem; if (!o) { this.checkBuffer(); return } if (a && this.schedule.resetErrorsInRange(r, r - s) && this.updateSchedule(!0), this.checkBuffer(), a && r < o.start || r >= o.end) { var c; const v = this.findItemIndex(o); let g = this.schedule.findItemIndexAtTime(r); if (g === -1 && (g = v + (a ? -1 : 1), this.log(`seeked ${a ? "back " : ""}to position not covered by schedule ${r} (resolving from ${v} to ${g})`)), !this.isInterstitial(o) && (c = this.media) != null && c.paused && (this.shouldPlay = !1), !a && g > v) { const y = this.schedule.findJumpRestrictedIndex(v + 1, g); if (y > v) { this.setSchedulePosition(y); return } } this.setSchedulePosition(g); return } const u = this.playingAsset; if (!u) { if (this.playingLastItem && this.isInterstitial(o)) { const v = o.event.assetList[0]; v && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(r, v)) } return } const f = u.timelineStart, h = u.duration || 0; if (a && r < f || r >= f + h) { var p; (p = o.event) != null && p.appendInPlace && (this.clearInterstitial(o.event, o), this.flushFrontBuffer(r)), this.setScheduleToAssetAtTime(r, u) } }, this.onTimeupdate = () => { const r = this.currentTime; if (r === void 0 || this.playbackDisabled) return; if (r > this.timelinePos) this.timelinePos = r, r > this.bufferedPos && this.checkBuffer(); else return; const s = this.playingItem; if (!s || this.playingLastItem) return; if (r >= s.end) { this.timelinePos = s.end; const o = this.findItemIndex(s); this.setSchedulePosition(o + 1) } const i = this.playingAsset; if (!i) return; const a = i.timelineStart + (i.duration || 0); r >= a && this.setScheduleToAssetAtTime(r, i) }, this.onScheduleUpdate = (r, s) => {
        const i = this.schedule; if (!i) return; const a = this.playingItem, o = i.events || [], c = i.items || [], u = i.durations, f = r.map(y => y.identifier), h = !!(o.length || f.length); (h || s) && this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${c.map(y => Br(y))} pos: ${this.timelinePos}`), f.length && this.log(`Removed events ${f}`); let p = null, v = null; a && (p = this.updateItem(a, this.timelinePos), this.itemsMatch(a, p) ? this.playingItem = p : this.waitingItem = this.endedItem = null), this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem); const g = this.bufferingItem; if (g && (v = this.updateItem(g, this.bufferedPos), this.itemsMatch(g, v) ? this.bufferingItem = v : g.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(g.event, null))), r.forEach(y => { y.assetList.forEach(w => { this.clearAssetPlayer(w.identifier, null) }) }), this.playerQueue.forEach(y => { if (y.interstitial.appendInPlace) { const w = y.assetItem.timelineStart, T = y.timelineOffset - w; if (T) try { y.timelineOffset = w } catch (S) { Math.abs(T) > Mi && this.warn(`${S} ("${y.assetId}" ${y.timelineOffset}->${w})`) } } }), h || s) { if (this.hls.trigger(k.INTERSTITIALS_UPDATED, { events: o.slice(0), schedule: c.slice(0), durations: u, removedIds: f }), this.isInterstitial(a) && f.includes(a.event.identifier)) { this.warn(`Interstitial "${a.event.identifier}" removed while playing`), this.primaryFallback(a.event); return } a && this.trimInPlace(p, a), g && v !== p && this.trimInPlace(v, g), this.checkBuffer() }
      }, this.hls = e, this.HlsPlayerClass = t, this.assetListLoader = new C5(e), this.schedule = new L5(this.onScheduleUpdate, e.logger), this.registerListeners()
    } registerListeners() { const e = this.hls; e && (e.on(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(k.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(k.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(k.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(k.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(k.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(k.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(k.BUFFER_APPENDED, this.onBufferAppended, this), e.on(k.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(k.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(k.MEDIA_ENDED, this.onMediaEnded, this), e.on(k.ERROR, this.onError, this), e.on(k.DESTROYING, this.onDestroying, this)) } unregisterListeners() { const e = this.hls; e && (e.off(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(k.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(k.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(k.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(k.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(k.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(k.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(k.BUFFER_CODECS, this.onBufferCodecs, this), e.off(k.BUFFER_APPENDED, this.onBufferAppended, this), e.off(k.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(k.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(k.MEDIA_ENDED, this.onMediaEnded, this), e.off(k.ERROR, this.onError, this), e.off(k.DESTROYING, this.onDestroying, this)) } startLoad() { this.resumeBuffering() } stopLoad() { this.pauseBuffering() } resumeBuffering() { var e; (e = this.getBufferingPlayer()) == null || e.resumeBuffering() } pauseBuffering() { var e; (e = this.getBufferingPlayer()) == null || e.pauseBuffering() } destroy() { this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null, this.hls = this.HlsPlayerClass = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null } onDestroying() { const e = this.primaryMedia || this.media; e && this.removeMediaListeners(e) } removeMediaListeners(e) { lr(e, "play", this.onPlay), lr(e, "pause", this.onPause), lr(e, "seeking", this.onSeeking), lr(e, "timeupdate", this.onTimeupdate) } onMediaAttaching(e, t) { const r = this.media = t.media; Yt(r, "seeking", this.onSeeking), Yt(r, "timeupdate", this.onTimeupdate), Yt(r, "play", this.onPlay), Yt(r, "pause", this.onPause) } onMediaAttached(e, t) { const r = this.effectivePlayingItem, s = this.detachedData; if (this.detachedData = null, r === null) this.checkStart(); else if (!s) { this.clearScheduleState(); const i = this.findItemIndex(r); this.setSchedulePosition(i) } } clearScheduleState() { this.log("clear schedule state"), this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null } onMediaDetaching(e, t) { const r = !!t.transferMedia, s = this.media; if (this.media = null, !r && (s && this.removeMediaListeners(s), this.detachedData)) { const i = this.getBufferingPlayer(); i && (this.log(`Removing schedule state for detachedData and ${i}`), this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, i.detachMedia()), this.shouldPlay = !1 } } get interstitialsManager() { if (!this.hls) return null; if (this.manager) return this.manager; const e = this, t = () => e.bufferingItem || e.waitingItem, r = h => h && e.getAssetPlayer(h.identifier), s = (h, p, v, g, y) => { if (h) { let w = h[p].start; const T = h.event; if (T) { if (p === "playout" || T.timelineOccupancy !== _c.Point) { const S = r(v); S?.interstitial === T && (w += S.assetItem.startOffset + S[y]) } } else { const S = g === "bufferedPos" ? a() : e[g]; w += S - h.start } return w } return 0 }, i = (h, p) => { var v; if (h !== 0 && p !== "primary" && (v = e.schedule) != null && v.length) { var g; const y = e.schedule.findItemIndexAtTime(h), w = (g = e.schedule.items) == null ? void 0 : g[y]; if (w) { const T = w[p].start - w.start; return h + T } } return h }, a = () => { const h = e.bufferedPos; return h === Number.MAX_VALUE ? o("primary") : Math.max(h, 0) }, o = h => { var p, v; return (p = e.primaryDetails) != null && p.live ? e.primaryDetails.edge : ((v = e.schedule) == null ? void 0 : v.durations[h]) || 0 }, c = (h, p) => { var v, g; const y = e.effectivePlayingItem; if (y != null && (v = y.event) != null && v.restrictions.skip || !e.schedule) return; e.log(`seek to ${h} "${p}"`); const w = e.effectivePlayingItem, T = e.schedule.findItemIndexAtTime(h, p), S = (g = e.schedule.items) == null ? void 0 : g[T], E = e.getBufferingPlayer(), I = E?.interstitial, C = I?.appendInPlace, D = w && e.itemsMatch(w, S); if (w && (C || D)) { const R = r(e.playingAsset), N = R?.media || e.primaryMedia; if (N) { const P = p === "primary" ? N.currentTime : s(w, p, e.playingAsset, "timelinePos", "currentTime"), _ = h - P, M = (C ? P : N.currentTime) + _; if (M >= 0 && (!R || C || M <= R.duration)) { N.currentTime = M; return } } } if (S) { let R = h; if (p !== "primary") { const P = S[p].start, _ = h - P; R = S.start + _ } const N = !e.isInterstitial(S); if ((!e.isInterstitial(w) || w.event.appendInPlace) && (N || S.event.appendInPlace)) { const P = e.media || (C ? E?.media : null); P && (P.currentTime = R) } else if (w) { const P = e.findItemIndex(w); if (T > P) { const M = e.schedule.findJumpRestrictedIndex(P + 1, T); if (M > P) { e.setSchedulePosition(M); return } } let _ = 0; if (N) e.timelinePos = R, e.checkBuffer(); else { const M = S.event.assetList, $ = h - (S[p] || S).start; for (let B = M.length; B--;) { const V = M[B]; if (V.duration && $ >= V.startOffset && $ < V.startOffset + V.duration) { _ = B; break } } } e.setSchedulePosition(T, _) } } }, u = () => { const h = e.effectivePlayingItem; if (e.isInterstitial(h)) return h; const p = t(); return e.isInterstitial(p) ? p : null }, f = { get bufferedEnd() { const h = t(), p = e.bufferingItem; if (p && p === h) { var v; return s(p, "playout", e.bufferingAsset, "bufferedPos", "bufferedEnd") - p.playout.start || ((v = e.bufferingAsset) == null ? void 0 : v.startOffset) || 0 } return 0 }, get currentTime() { const h = u(), p = e.effectivePlayingItem; return p && p === h ? s(p, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - p.playout.start : 0 }, set currentTime(h) { const p = u(), v = e.effectivePlayingItem; v && v === p && c(h + v.playout.start, "playout") }, get duration() { const h = u(); return h ? h.playout.end - h.playout.start : 0 }, get assetPlayers() { var h; const p = (h = u()) == null ? void 0 : h.event.assetList; return p ? p.map(v => e.getAssetPlayer(v.identifier)) : [] }, get playingIndex() { var h; const p = (h = u()) == null ? void 0 : h.event; return p && e.effectivePlayingAsset ? p.findAssetIndex(e.effectivePlayingAsset) : -1 }, get scheduleItem() { return u() } }; return this.manager = { get events() { var h; return ((h = e.schedule) == null || (h = h.events) == null ? void 0 : h.slice(0)) || [] }, get schedule() { var h; return ((h = e.schedule) == null || (h = h.items) == null ? void 0 : h.slice(0)) || [] }, get interstitialPlayer() { return u() ? f : null }, get playerQueue() { return e.playerQueue.slice(0) }, get bufferingAsset() { return e.bufferingAsset }, get bufferingItem() { return t() }, get bufferingIndex() { const h = t(); return e.findItemIndex(h) }, get playingAsset() { return e.effectivePlayingAsset }, get playingItem() { return e.effectivePlayingItem }, get playingIndex() { const h = e.effectivePlayingItem; return e.findItemIndex(h) }, primary: { get bufferedEnd() { return a() }, get currentTime() { const h = e.timelinePos; return h > 0 ? h : 0 }, set currentTime(h) { c(h, "primary") }, get duration() { return o("primary") }, get seekableStart() { var h; return ((h = e.primaryDetails) == null ? void 0 : h.fragmentStart) || 0 } }, integrated: { get bufferedEnd() { return s(t(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd") }, get currentTime() { return s(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime") }, set currentTime(h) { c(h, "integrated") }, get duration() { return o("integrated") }, get seekableStart() { var h; return i(((h = e.primaryDetails) == null ? void 0 : h.fragmentStart) || 0, "integrated") } }, skip: () => { const h = e.effectivePlayingItem, p = h?.event; if (p && !p.restrictions.skip) { const v = e.findItemIndex(h); if (p.appendInPlace) { const g = h.playout.start + h.event.duration; c(g + .001, "playout") } else e.advanceAfterAssetEnded(p, v, 1 / 0) } } } } get effectivePlayingItem() { return this.waitingItem || this.playingItem || this.endedItem } get effectivePlayingAsset() { return this.playingAsset || this.endedAsset } get playingLastItem() { var e; const t = this.playingItem, r = (e = this.schedule) == null ? void 0 : e.items; return !this.playbackStarted || !t || !r ? !1 : this.findItemIndex(t) === r.length - 1 } get playbackStarted() { return this.effectivePlayingItem !== null } get currentTime() { var e, t; if (this.mediaSelection === null) return; const r = this.waitingItem || this.playingItem; if (this.isInterstitial(r) && !r.event.appendInPlace) return; let s = this.media; !s && (e = this.bufferingItem) != null && (e = e.event) != null && e.appendInPlace && (s = this.primaryMedia); const i = (t = s) == null ? void 0 : t.currentTime; if (!(i === void 0 || !ge(i))) return i } get primaryMedia() { var e; return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null } isInterstitial(e) { return !!(e != null && e.event) } retreiveMediaSource(e, t) { const r = this.getAssetPlayer(e); r && this.transferMediaFromPlayer(r, t) } transferMediaFromPlayer(e, t) { const r = e.interstitial.appendInPlace, s = e.media; if (r && s === this.primaryMedia) { if (this.bufferingAsset = null, (!t || this.isInterstitial(t) && !t.event.appendInPlace) && t && s) { this.detachedData = { media: s }; return } const i = e.transferMedia(); this.log(`transfer MediaSource from ${e} ${it(i)}`), this.detachedData = i } else t && s && (this.shouldPlay || (this.shouldPlay = !s.paused)) } transferMediaTo(e, t) { var r, s; if (e.media === t) return; let i = null; const a = this.hls, o = e !== a, c = o && e.interstitial.appendInPlace, u = (r = this.detachedData) == null ? void 0 : r.mediaSource; let f; if (a.media) c && (i = a.transferMedia(), this.detachedData = i), f = "Primary"; else if (u) { const g = this.getBufferingPlayer(); g ? (i = g.transferMedia(), f = `${g}`) : f = "detached MediaSource" } else f = "detached media"; if (!i) { if (u) i = this.detachedData, this.log(`using detachedData: MediaSource ${it(i)}`); else if (!this.detachedData || a.media === t) { const g = this.playerQueue; g.length > 1 && g.forEach(y => { if (o && y.interstitial.appendInPlace !== c) { const w = y.interstitial; this.clearInterstitial(y.interstitial, null), w.appendInPlace = !1, w.appendInPlace && this.warn(`Could not change append strategy for queued assets ${w}`) } }), this.hls.detachMedia(), this.detachedData = { media: t } } } const h = i && "mediaSource" in i && ((s = i.mediaSource) == null ? void 0 : s.readyState) !== "closed", p = h && i ? i : t; this.log(`${h ? "transfering MediaSource" : "attaching media"} to ${o ? e : "Primary"} from ${f} (media.currentTime: ${t.currentTime})`); const v = this.schedule; if (p === i && v) { const g = o && e.assetId === v.assetIdAtEnd; p.overrides = { duration: v.duration, endOfStream: !o || g, cueRemoval: !o } } e.attachMedia(p) } onInterstitialCueEnter() { this.onTimeupdate() } checkStart() { const e = this.schedule, t = e?.events; if (!t || this.playbackDisabled || !this.media) return; this.bufferedPos === -1 && (this.bufferedPos = 0); const r = this.timelinePos, s = this.effectivePlayingItem; if (r === -1) { const i = this.hls.startPosition; if (this.log(zl("checkStart", i)), this.timelinePos = i, t.length && t[0].cue.pre) { const a = e.findEventIndex(t[0].identifier); this.setSchedulePosition(a) } else if (i >= 0 || !this.primaryLive) { const a = this.timelinePos = i > 0 ? i : 0, o = e.findItemIndexAtTime(a); this.setSchedulePosition(o) } } else if (s && !this.playingItem) { const i = e.findItemIndex(s); this.setSchedulePosition(i) } } advanceAssetBuffering(e, t) { const r = e.event, s = r.findAssetIndex(t), i = Tf(r, s); if (!r.isAssetPastPlayoutLimit(i)) this.bufferedToEvent(e, i); else if (this.schedule) { var a; const o = (a = this.schedule.items) == null ? void 0 : a[this.findItemIndex(e) + 1]; o && this.bufferedToItem(o) } } advanceAfterAssetEnded(e, t, r) { const s = Tf(e, r); if (e.isAssetPastPlayoutLimit(s)) { if (this.schedule) { const i = this.schedule.items; if (i) { const a = t + 1, o = i.length; if (a >= o) { this.setSchedulePosition(-1); return } const c = e.resumeTime; this.timelinePos < c && (this.log(zl("advanceAfterAssetEnded", c)), this.timelinePos = c, e.appendInPlace && this.advanceInPlace(c), this.checkBuffer(this.bufferedPos < c)), this.setSchedulePosition(a) } } } else { if (e.appendInPlace) { const i = e.assetList[s]; i && this.advanceInPlace(i.timelineStart) } this.setSchedulePosition(t, s) } } setScheduleToAssetAtTime(e, t) { const r = this.schedule; if (!r) return; const s = t.parentIdentifier, i = r.getEvent(s); if (i) { const a = r.findEventIndex(s), o = r.findAssetIndex(i, e); this.advanceAfterAssetEnded(i, a, o - 1) } } setSchedulePosition(e, t) { var r; const s = (r = this.schedule) == null ? void 0 : r.items; if (!s || this.playbackDisabled) return; const i = e >= 0 ? s[e] : null; this.log(`setSchedulePosition ${e}, ${t} (${i && Br(i)}) pos: ${this.timelinePos}`); const a = this.waitingItem || this.playingItem, o = this.playingLastItem; if (this.isInterstitial(a)) { const f = a.event, h = this.playingAsset, p = h?.identifier, v = p ? this.getAssetPlayer(p) : null; if (v && p && (!this.eventItemsMatch(a, i) || t !== void 0 && p !== f.assetList[t].identifier)) { var c; const g = f.findAssetIndex(h); if (this.log(`INTERSTITIAL_ASSET_ENDED ${g + 1}/${f.assetList.length} ${Li(h)}`), this.endedAsset = h, this.playingAsset = null, this.hls.trigger(k.INTERSTITIAL_ASSET_ENDED, { asset: h, assetListIndex: g, event: f, schedule: s.slice(0), scheduleIndex: e, player: v }), a !== this.playingItem) { this.itemsMatch(a, this.playingItem) && !this.playingAsset && this.advanceAfterAssetEnded(f, this.findItemIndex(this.playingItem), g); return } this.retreiveMediaSource(p, i), v.media && !((c = this.detachedData) != null && c.mediaSource) && v.detachMedia() } if (!this.eventItemsMatch(a, i) && (this.endedItem = a, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${f} ${Br(a)}`), f.hasPlayed = !0, this.hls.trigger(k.INTERSTITIAL_ENDED, { event: f, schedule: s.slice(0), scheduleIndex: e }), f.cue.once)) { var u; this.updateSchedule(); const g = (u = this.schedule) == null ? void 0 : u.items; if (i && g) { const y = this.findItemIndex(i); this.advanceSchedule(y, g, t, a, o) } return } } this.advanceSchedule(e, s, t, a, o) } advanceSchedule(e, t, r, s, i) { const a = this.schedule; if (!a) return; const o = t[e] || null, c = this.primaryMedia, u = this.playerQueue; if (u.length && u.forEach(f => { const h = f.interstitial, p = a.findEventIndex(h.identifier); (p < e || p > e + 1) && this.clearInterstitial(h, o) }), this.isInterstitial(o)) { this.timelinePos = Math.min(Math.max(this.timelinePos, o.start), o.end); const f = o.event; if (r === void 0) { r = a.findAssetIndex(f, this.timelinePos); const g = Tf(f, r - 1); if (f.isAssetPastPlayoutLimit(g) || f.appendInPlace && this.timelinePos === o.end) { this.advanceAfterAssetEnded(f, e, r); return } r = g } const h = this.waitingItem; this.assetsBuffered(o, c) || this.setBufferingItem(o); let p = this.preloadAssets(f, r); if (this.eventItemsMatch(o, h || s) || (this.waitingItem = o, this.log(`INTERSTITIAL_STARTED ${Br(o)} ${f.appendInPlace ? "append in place" : ""}`), this.hls.trigger(k.INTERSTITIAL_STARTED, { event: f, schedule: t.slice(0), scheduleIndex: e })), !f.assetListLoaded) { this.log(`Waiting for ASSET-LIST to complete loading ${f}`); return } if (f.assetListLoader && (f.assetListLoader.destroy(), f.assetListLoader = void 0), !c) { this.log(`Waiting for attachMedia to start Interstitial ${f}`); return } this.waitingItem = this.endedItem = null, this.playingItem = o; const v = f.assetList[r]; if (!v) { this.advanceAfterAssetEnded(f, e, r || 0); return } if (p || (p = this.getAssetPlayer(v.identifier)), p === null || p.destroyed) { const g = f.assetList.length; this.warn(`asset ${r + 1}/${g} player destroyed ${f}`), p = this.createAssetPlayer(f, v, r), p.loadSource() } if (!this.eventItemsMatch(o, this.bufferingItem) && f.appendInPlace && this.isAssetBuffered(v)) return; this.startAssetPlayer(p, r, t, e, c), this.shouldPlay && ey(p.media) } else o ? (this.resumePrimary(o, e, s), this.shouldPlay && ey(this.hls.media)) : i && this.isInterstitial(s) && (this.endedItem = null, this.playingItem = s, s.event.appendInPlace || this.attachPrimary(a.durations.primary, null)) } get playbackDisabled() { return this.hls.config.enableInterstitialPlayback === !1 } get primaryDetails() { var e; return (e = this.mediaSelection) == null ? void 0 : e.main.details } get primaryLive() { var e; return !!((e = this.primaryDetails) != null && e.live) } resumePrimary(e, t, r) { var s, i; if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${Br(e)}`), !((s = this.detachedData) != null && s.mediaSource)) { let o = this.timelinePos; (o < e.start || o >= e.end) && (o = this.getPrimaryResumption(e, t), this.log(zl("resumePrimary", o)), this.timelinePos = o), this.attachPrimary(o, e) } if (!r) return; const a = (i = this.schedule) == null ? void 0 : i.items; a && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${Br(e)}`), this.hls.trigger(k.INTERSTITIALS_PRIMARY_RESUMED, { schedule: a.slice(0), scheduleIndex: t }), this.checkBuffer()) } getPrimaryResumption(e, t) { const r = e.start; if (this.primaryLive) { const s = this.primaryDetails; if (t === 0) return this.hls.startPosition; if (s && (r < s.fragmentStart || r > s.edge)) return this.hls.liveSyncPosition || -1 } return r } isAssetBuffered(e) { const t = this.getAssetPlayer(e.identifier); return t != null && t.hls ? t.hls.bufferedToEnd : Me.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0) } attachPrimary(e, t, r) { t ? this.setBufferingItem(t) : this.bufferingItem = this.playingItem, this.bufferingAsset = null; const s = this.primaryMedia; if (!s) return; const i = this.hls; i.media ? this.checkBuffer() : (this.transferMediaTo(i, s), r && this.startLoadingPrimaryAt(e, r)), r || (this.log(zl("attachPrimary", e)), this.timelinePos = e, this.startLoadingPrimaryAt(e, r)) } startLoadingPrimaryAt(e, t) { var r; const s = this.hls; !s.loadingEnabled || !s.media || Math.abs((((r = s.mainForwardBufferInfo) == null ? void 0 : r.start) || s.media.currentTime) - e) > .5 ? s.startLoad(e, t) : s.bufferingEnabled || s.resumeBuffering() } onManifestLoading() { var e; this.stopLoad(), (e = this.schedule) == null || e.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(k.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(k.BUFFER_CODECS, this.onBufferCodecs, this) } onLevelUpdated(e, t) { if (t.level === -1 || !this.schedule) return; const r = this.hls.levels[t.level]; if (!r.details) return; const s = et(et({}, this.mediaSelection || this.altSelection), {}, { main: r }); this.mediaSelection = s, this.schedule.parseInterstitialDateRanges(s, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart() } onAudioTrackUpdated(e, t) { const r = this.hls.audioTracks[t.id], s = this.mediaSelection; if (!s) { this.altSelection = et(et({}, this.altSelection), {}, { audio: r }); return } const i = et(et({}, s), {}, { audio: r }); this.mediaSelection = i } onSubtitleTrackUpdated(e, t) { const r = this.hls.subtitleTracks[t.id], s = this.mediaSelection; if (!s) { this.altSelection = et(et({}, this.altSelection), {}, { subtitles: r }); return } const i = et(et({}, s), {}, { subtitles: r }); this.mediaSelection = i } onAudioTrackSwitching(e, t) { const r = dv(t); this.playerQueue.forEach(({ hls: s }) => s && (s.setAudioOption(t) || s.setAudioOption(r))) } onSubtitleTrackSwitch(e, t) { const r = dv(t); this.playerQueue.forEach(({ hls: s }) => s && (s.setSubtitleOption(t) || t.id !== -1 && s.setSubtitleOption(r))) } onBufferCodecs(e, t) { const r = t.tracks; r && (this.requiredTracks = r) } onBufferAppended(e, t) { this.checkBuffer() } onBufferFlushed(e, t) { const r = this.playingItem; if (r && !this.itemsMatch(r, this.bufferingItem) && !this.isInterstitial(r)) { const s = this.timelinePos; this.bufferedPos = s, this.checkBuffer() } } onBufferedToEnd(e) { if (!this.schedule) return; const t = this.schedule.events; if (this.bufferedPos < Number.MAX_VALUE && t) { for (let s = 0; s < t.length; s++) { const i = t[s]; if (i.cue.post) { var r; const a = this.schedule.findEventIndex(i.identifier), o = (r = this.schedule.items) == null ? void 0 : r[a]; this.isInterstitial(o) && this.eventItemsMatch(o, this.bufferingItem) && this.bufferedToItem(o, 0); break } } this.bufferedPos = Number.MAX_VALUE } } onMediaEnded(e) { const t = this.playingItem; if (!this.playingLastItem && t) { const r = this.findItemIndex(t); this.setSchedulePosition(r + 1) } else this.shouldPlay = !1 } updateItem(e, t) { var r; const s = (r = this.schedule) == null ? void 0 : r.items; if (e && s) { const i = this.findItemIndex(e, t); return s[i] || null } return null } trimInPlace(e, t) { if (this.isInterstitial(e) && e.event.appendInPlace && t.end - e.end > .25) { e.event.assetList.forEach((i, a) => { e.event.isAssetPastPlayoutLimit(a) && this.clearAssetPlayer(i.identifier, null) }); const r = e.end + .25, s = Me.bufferInfo(this.primaryMedia, r, 0); (s.end > r || (s.nextStart || 0) > r) && (this.log(`trim buffered interstitial ${Br(e)} (was ${Br(t)})`), this.attachPrimary(r, null, !0), this.flushFrontBuffer(r)) } } itemsMatch(e, t) { return !!t && (e === t || e.event && t.event && this.eventItemsMatch(e, t) || !e.event && !t.event && this.findItemIndex(e) === this.findItemIndex(t)) } eventItemsMatch(e, t) { var r; return !!t && (e === t || e.event.identifier === ((r = t.event) == null ? void 0 : r.identifier)) } findItemIndex(e, t) { return e && this.schedule ? this.schedule.findItemIndex(e, t) : -1 } updateSchedule(e = !1) { var t; const r = this.mediaSelection; r && ((t = this.schedule) == null || t.updateSchedule(r, [], e)) } checkBuffer(e) { var t; const r = (t = this.schedule) == null ? void 0 : t.items; if (!r) return; const s = Me.bufferInfo(this.primaryMedia, this.timelinePos, 0); e && (this.bufferedPos = this.timelinePos), e || (e = s.len < 1), this.updateBufferedPos(s.end, r, e) } updateBufferedPos(e, t, r) { const s = this.schedule, i = this.bufferingItem; if (this.bufferedPos > e || !s) return; if (t.length === 1 && this.itemsMatch(t[0], i)) { this.bufferedPos = e; return } const a = this.playingItem, o = this.findItemIndex(a); let c = s.findItemIndexAtTime(e); if (this.bufferedPos < e) { var u; const f = this.findItemIndex(i), h = Math.min(f + 1, t.length - 1), p = t[h]; if ((c === -1 && i && e >= i.end || (u = p.event) != null && u.appendInPlace && e + .01 >= p.start) && (c = h), this.isInterstitial(i)) { const v = i.event; if (h - o > 1 && v.appendInPlace === !1 || v.assetList.length === 0 && v.assetListLoader) return } if (this.bufferedPos = e, c > f && c > o) this.bufferedToItem(p); else { const v = this.primaryDetails; this.primaryLive && v && e > v.edge - v.targetduration && p.start < v.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(p) && this.preloadAssets(p.event, 0) } } else r && a && !this.itemsMatch(a, i) && (c === o ? this.bufferedToItem(a) : c === o + 1 && this.bufferedToItem(t[c])) } assetsBuffered(e, t) { return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some(s => { const i = this.getAssetPlayer(s.identifier); return !(i != null && i.bufferedInPlaceToEnd(t)) }) } setBufferingItem(e) { const t = this.bufferingItem, r = this.schedule; if (!this.itemsMatch(e, t) && r) { const { items: s, events: i } = r; if (!s || !i) return t; const a = this.isInterstitial(e), o = this.getBufferingPlayer(); this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos)); const c = o ? o.remaining : t ? t.end - this.timelinePos : 0; if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${Br(e)}` + (t ? ` (${c.toFixed(2)} remaining)` : "")), !this.playbackDisabled) if (a) { const u = r.findAssetIndex(e.event, this.bufferedPos); e.event.assetList.forEach((f, h) => { const p = this.getAssetPlayer(f.identifier); p && (h === u && p.loadSource(), p.resumeBuffering()) }) } else this.hls.resumeBuffering(), this.playerQueue.forEach(u => u.pauseBuffering()); this.hls.trigger(k.INTERSTITIALS_BUFFERED_TO_BOUNDARY, { events: i.slice(0), schedule: s.slice(0), bufferingIndex: this.findItemIndex(e), playingIndex: this.findItemIndex(this.playingItem) }) } else this.bufferingItem !== e && (this.bufferingItem = e); return t } bufferedToItem(e, t = 0) { const r = this.setBufferingItem(e); if (!this.playbackDisabled) { if (this.isInterstitial(e)) this.bufferedToEvent(e, t); else if (r !== null) { this.bufferingAsset = null; const s = this.detachedData; s ? s.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e) } } } preloadPrimary(e) { const t = this.findItemIndex(e), r = this.getPrimaryResumption(e, t); this.startLoadingPrimaryAt(r) } bufferedToEvent(e, t) { const r = e.event, s = r.assetList.length === 0 && !r.assetListLoader, i = r.cue.once; if (s || !i) { const a = this.preloadAssets(r, t); if (a != null && a.interstitial.appendInPlace) { const o = this.primaryMedia; o && this.bufferAssetPlayer(a, o) } } } preloadAssets(e, t) { const r = e.assetUrl, s = e.assetList.length, i = s === 0 && !e.assetListLoader, a = e.cue.once; if (i) { const c = e.timelineStart; if (e.appendInPlace) { var o; const p = this.playingItem; !this.isInterstitial(p) && (p == null || (o = p.nextEvent) == null ? void 0 : o.identifier) === e.identifier && this.flushFrontBuffer(c + .25) } let u, f = 0; if (!this.playingItem && this.primaryLive && (f = this.hls.startPosition, f === -1 && (f = this.hls.liveSyncPosition || 0)), f && !(e.cue.pre || e.cue.post)) { const p = f - c; p > 0 && (u = Math.round(p * 1e3) / 1e3) } if (this.log(`Load interstitial asset ${t + 1}/${r ? 1 : s} ${e}${u ? ` live-start: ${f} start-offset: ${u}` : ""}`), r) return this.createAsset(e, 0, 0, c, e.duration, r); const h = this.assetListLoader.loadAssetList(e, u); h && (e.assetListLoader = h) } else if (!a && s) { for (let u = t; u < s; u++) { const f = e.assetList[u], h = this.getAssetPlayerQueueIndex(f.identifier); (h === -1 || this.playerQueue[h].destroyed) && !f.error && this.createAssetPlayer(e, f, u) } const c = e.assetList[t]; if (c) { const u = this.getAssetPlayer(c.identifier); return u && u.loadSource(), u } } return null } flushFrontBuffer(e) { const t = this.requiredTracks; if (!t) return; this.log(`Removing front buffer starting at ${e}`), Object.keys(t).forEach(s => { this.hls.trigger(k.BUFFER_FLUSHING, { startOffset: e, endOffset: 1 / 0, type: s }) }) } getAssetPlayerQueueIndex(e) { const t = this.playerQueue; for (let r = 0; r < t.length; r++)if (e === t[r].assetId) return r; return -1 } getAssetPlayer(e) { const t = this.getAssetPlayerQueueIndex(e); return this.playerQueue[t] || null } getBufferingPlayer() { const { playerQueue: e, primaryMedia: t } = this; if (t) { for (let r = 0; r < e.length; r++)if (e[r].media === t) return e[r] } return null } createAsset(e, t, r, s, i, a) { const o = { parentIdentifier: e.identifier, identifier: E5(e, a, t), duration: i, startOffset: r, timelineStart: s, uri: a }; return this.createAssetPlayer(e, o, t) } createAssetPlayer(e, t, r) { const s = this.hls, i = s.userConfig; let a = i.videoPreference; const o = s.loadLevelObj || s.levels[s.currentLevel]; (a || o) && (a = nt({}, a), o.videoCodec && (a.videoCodec = o.videoCodec), o.videoRange && (a.allowedVideoRanges = [o.videoRange])); const c = s.audioTracks[s.audioTrack], u = s.subtitleTracks[s.subtitleTrack]; let f = 0; if (this.primaryLive || e.appendInPlace) { const I = this.timelinePos - t.timelineStart; if (I > 1) { const C = t.duration; C && I < C && (f = I) } } const h = t.identifier, p = et(et({}, i), {}, { maxMaxBufferLength: Math.min(180, s.config.maxMaxBufferLength), autoStartLoad: !0, startFragPrefetch: !0, primarySessionId: s.sessionId, assetPlayerId: h, abrEwmaDefaultEstimate: s.bandwidthEstimate, interstitialsController: void 0, startPosition: f, liveDurationInfinity: !1, testBandwidth: !1, videoPreference: a, audioPreference: c || i.audioPreference, subtitlePreference: u || i.subtitlePreference }); e.appendInPlace && (e.appendInPlaceStarted = !0, t.timelineStart && (p.timelineOffset = t.timelineStart)); const v = p.cmcd; v != null && v.sessionId && v.contentId && (p.cmcd = nt({}, v, { contentId: Wa(t.uri) })), this.getAssetPlayer(h) && this.warn(`Duplicate date range identifier ${e} and asset ${h}`); const g = new I5(this.HlsPlayerClass, p, e, t); this.playerQueue.push(g), e.assetList[r] = t; let y = !0; const w = I => { if (I.live) { var C; const N = new Error(`Interstitials MUST be VOD assets ${e}`), P = { fatal: !0, type: Ee.OTHER_ERROR, details: J.INTERSTITIAL_ASSET_ITEM_ERROR, error: N }, _ = ((C = this.schedule) == null ? void 0 : C.findEventIndex(e.identifier)) || -1; this.handleAssetItemError(P, e, _, r, N.message); return } const D = I.edge - I.fragmentStart, R = t.duration; (y || R === null || D > R) && (y = !1, this.log(`Interstitial asset "${h}" duration change ${R} > ${D}`), t.duration = D, this.updateSchedule()) }; g.on(k.LEVEL_UPDATED, (I, { details: C }) => w(C)), g.on(k.LEVEL_PTS_UPDATED, (I, { details: C }) => w(C)), g.on(k.EVENT_CUE_ENTER, () => this.onInterstitialCueEnter()); const T = (I, C) => { const D = this.getAssetPlayer(h); if (D && C.tracks) { D.off(k.BUFFER_CODECS, T), D.tracks = C.tracks; const R = this.primaryMedia; this.bufferingAsset === D.assetItem && R && !D.media && this.bufferAssetPlayer(D, R) } }; g.on(k.BUFFER_CODECS, T); const S = () => { var I; const C = this.getAssetPlayer(h); if (this.log(`buffered to end of asset ${C}`), !C || !this.schedule) return; const D = this.schedule.findEventIndex(e.identifier), R = (I = this.schedule.items) == null ? void 0 : I[D]; this.isInterstitial(R) && this.advanceAssetBuffering(R, t) }; g.on(k.BUFFERED_TO_END, S); const E = I => () => { if (!this.getAssetPlayer(h) || !this.schedule) return; this.shouldPlay = !0; const D = this.schedule.findEventIndex(e.identifier); this.advanceAfterAssetEnded(e, D, I) }; return g.once(k.MEDIA_ENDED, E(r)), g.once(k.PLAYOUT_LIMIT_REACHED, E(1 / 0)), g.on(k.ERROR, (I, C) => { if (!this.schedule) return; const D = this.getAssetPlayer(h); if (C.details === J.BUFFER_STALLED_ERROR) { if (D != null && D.appendInPlace) { this.handleInPlaceStall(e); return } this.onTimeupdate(), this.checkBuffer(!0); return } this.handleAssetItemError(C, e, this.schedule.findEventIndex(e.identifier), r, `Asset player error ${C.error} ${e}`) }), g.on(k.DESTROYING, () => { if (!this.getAssetPlayer(h) || !this.schedule) return; const C = new Error(`Asset player destroyed unexpectedly ${h}`), D = { fatal: !0, type: Ee.OTHER_ERROR, details: J.INTERSTITIAL_ASSET_ITEM_ERROR, error: C }; this.handleAssetItemError(D, e, this.schedule.findEventIndex(e.identifier), r, C.message) }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${Li(t)}`), this.hls.trigger(k.INTERSTITIAL_ASSET_PLAYER_CREATED, { asset: t, assetListIndex: r, event: e, player: g }), g } clearInterstitial(e, t) { e.assetList.forEach(r => { this.clearAssetPlayer(r.identifier, t) }), e.reset() } resetAssetPlayer(e) { const t = this.getAssetPlayerQueueIndex(e); if (t !== -1) { this.log(`reset asset player "${e}" after error`); const r = this.playerQueue[t]; this.transferMediaFromPlayer(r, null), r.resetDetails() } } clearAssetPlayer(e, t) { const r = this.getAssetPlayerQueueIndex(e); if (r !== -1) { const s = this.playerQueue[r]; this.log(`clear ${s} toSegment: ${t && Br(t)}`), this.transferMediaFromPlayer(s, t), this.playerQueue.splice(r, 1), s.destroy() } } emptyPlayerQueue() { let e; for (; e = this.playerQueue.pop();)e.destroy(); this.playerQueue = [] } startAssetPlayer(e, t, r, s, i) { const { interstitial: a, assetItem: o, assetId: c } = e, u = a.assetList.length, f = this.playingAsset; this.endedAsset = null, this.playingAsset = o, (!f || f.identifier !== c) && (f && (this.clearAssetPlayer(f.identifier, r[s]), delete f.error), this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${u} ${Li(o)}`), this.hls.trigger(k.INTERSTITIAL_ASSET_STARTED, { asset: o, assetListIndex: t, event: a, schedule: r.slice(0), scheduleIndex: s, player: e })), this.bufferAssetPlayer(e, i) } bufferAssetPlayer(e, t) { var r, s; if (!this.schedule) return; const { interstitial: i, assetItem: a } = e, o = this.schedule.findEventIndex(i.identifier), c = (r = this.schedule.items) == null ? void 0 : r[o]; if (!c) return; e.loadSource(), this.setBufferingItem(c), this.bufferingAsset = a; const u = this.getBufferingPlayer(); if (u === e) return; const f = i.appendInPlace; if (f && u?.interstitial.appendInPlace === !1) return; const h = u?.tracks || ((s = this.detachedData) == null ? void 0 : s.tracks) || this.requiredTracks; if (f && a !== this.playingAsset) { if (!e.tracks) { this.log(`Waiting for track info before buffering ${e}`); return } if (h && !Lb(h, e.tracks)) { const p = new Error(`Asset ${Li(a)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(h)}')`), v = { fatal: !0, type: Ee.OTHER_ERROR, details: J.INTERSTITIAL_ASSET_ITEM_ERROR, error: p }, g = i.findAssetIndex(a); this.handleAssetItemError(v, i, o, g, p.message); return } } this.transferMediaTo(e, t) } handleInPlaceStall(e) { const t = this.schedule, r = this.primaryMedia; if (!t || !r) return; const s = r.currentTime, i = t.findAssetIndex(e, s), a = e.assetList[i]; if (a) { const o = this.getAssetPlayer(a.identifier); if (o) { const c = o.currentTime || s - a.timelineStart, u = o.duration - c; if (this.warn(`Stalled at ${c} of ${c + u} in ${o} ${e} (media.currentTime: ${s})`), c && (u / r.playbackRate < .5 || o.bufferedInPlaceToEnd(r)) && o.hls) { const f = t.findEventIndex(e.identifier); this.advanceAfterAssetEnded(e, f, i) } } } } advanceInPlace(e) { const t = this.primaryMedia; t && t.currentTime < e && (t.currentTime = e) } handleAssetItemError(e, t, r, s, i) { if (e.details === J.BUFFER_STALLED_ERROR) return; const a = t.assetList[s] || null; if (this.warn(`INTERSTITIAL_ASSET_ERROR ${a && Li(a)} ${e.error}`), !this.schedule) return; const o = a?.identifier || "", c = this.getAssetPlayerQueueIndex(o), u = this.playerQueue[c] || null, f = this.schedule.items, h = nt({}, e, { fatal: !1, errorAction: Ni(!0), asset: a, assetListIndex: s, event: t, schedule: f, scheduleIndex: r, player: u }); if (this.hls.trigger(k.INTERSTITIAL_ASSET_ERROR, h), !e.fatal) return; const p = this.playingAsset, v = this.bufferingAsset, g = new Error(i); if (a && (this.clearAssetPlayer(o, null), a.error = g), !t.assetList.some(y => !y.error)) t.error = g; else for (let y = s; y < t.assetList.length; y++)this.resetAssetPlayer(t.assetList[y].identifier); this.updateSchedule(!0), t.error ? this.primaryFallback(t) : p && p.identifier === o ? this.advanceAfterAssetEnded(t, r, s) : v && v.identifier === o && this.isInterstitial(this.bufferingItem) && this.advanceAssetBuffering(this.bufferingItem, v) } primaryFallback(e) { const t = e.timelineStart, r = this.effectivePlayingItem; if (r) { this.log(`Fallback to primary from event "${e.identifier}" start: ${t} pos: ${this.timelinePos} playing: ${Br(r)} error: ${e.error}`); let s = this.timelinePos; s === -1 && (s = this.hls.startPosition); const i = this.updateItem(r, s); if (this.itemsMatch(r, i) && this.clearInterstitial(e, null), e.appendInPlace && (this.attachPrimary(t, null), this.flushFrontBuffer(t)), !this.schedule) return; const a = this.schedule.findItemIndexAtTime(s); this.setSchedulePosition(a) } else this.checkStart() } onAssetListLoaded(e, t) { var r, s; const i = t.event, a = i.identifier, o = t.assetListResponse.ASSETS; if (!((r = this.schedule) != null && r.hasEvent(a))) return; const c = i.timelineStart, u = i.duration; let f = 0; o.forEach((y, w) => { const T = parseFloat(y.DURATION); this.createAsset(i, w, f, c + f, T, y.URI), f += T }), i.duration = f, this.log(`Loaded asset-list with duration: ${f} (was: ${u}) ${i}`); const h = this.waitingItem, p = h?.event.identifier === a; this.updateSchedule(); const v = (s = this.bufferingItem) == null ? void 0 : s.event; if (p) { var g; const y = this.schedule.findEventIndex(a), w = (g = this.schedule.items) == null ? void 0 : g[y]; if (w) { if (!this.playingItem && this.timelinePos > w.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== y) { i.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${i}`), this.updateSchedule(!0), this.primaryFallback(i); return } this.setBufferingItem(w) } this.setSchedulePosition(y) } else if (v?.identifier === a) { const y = i.assetList[0]; if (y) { const w = this.getAssetPlayer(y.identifier); if (v.appendInPlace) { const T = this.primaryMedia; w && T && this.bufferAssetPlayer(w, T) } else w && w.loadSource() } } } onError(e, t) { if (this.schedule) switch (t.details) { case J.ASSET_LIST_PARSING_ERROR: case J.ASSET_LIST_LOAD_ERROR: case J.ASSET_LIST_LOAD_TIMEOUT: { const r = t.interstitial; r && (this.updateSchedule(!0), this.primaryFallback(r)); break } case J.BUFFER_STALLED_ERROR: { const r = this.endedItem || this.waitingItem || this.playingItem; if (this.isInterstitial(r) && r.event.appendInPlace) { this.handleInPlaceStall(r.event); return } this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`), this.onTimeupdate(), this.checkBuffer(!0); break } } }
  } const ty = 500; class R5 extends Sp { constructor(e, t, r) { super(e, t, r, "subtitle-stream-controller", ve.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners() } onHandlerDestroying() { this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null } registerListeners() { super.registerListeners(); const { hls: e } = this; e.on(k.LEVEL_LOADED, this.onLevelLoaded, this), e.on(k.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(k.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(k.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(k.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(k.BUFFER_FLUSHING, this.onBufferFlushing, this) } unregisterListeners() { super.unregisterListeners(); const { hls: e } = this; e.off(k.LEVEL_LOADED, this.onLevelLoaded, this), e.off(k.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(k.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(k.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(k.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(k.BUFFER_FLUSHING, this.onBufferFlushing, this) } startLoad(e, t) { this.stopLoad(), this.state = se.IDLE, this.setInterval(ty), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick() } onManifestLoading() { super.onManifestLoading(), this.mainDetails = null } onMediaDetaching(e, t) { this.tracksBuffered = [], super.onMediaDetaching(e, t) } onLevelLoaded(e, t) { this.mainDetails = t.details } onSubtitleFragProcessed(e, t) { const { frag: r, success: s } = t; if (this.fragContextChanged(r) || (At(r) && (this.fragPrevious = r), this.state = se.IDLE), !s) return; const i = this.tracksBuffered[this.currentTrackId]; if (!i) return; let a; const o = r.start; for (let u = 0; u < i.length; u++)if (o >= i[u].start && o <= i[u].end) { a = i[u]; break } const c = r.start + r.duration; a ? a.end = c : (a = { start: o, end: c }, i.push(a)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null), this.media && this.tick() } onBufferFlushing(e, t) { const { startOffset: r, endOffset: s } = t; if (r === 0 && s !== Number.POSITIVE_INFINITY) { const i = s - 1; if (i <= 0) return; t.endOffsetSubtitles = Math.max(0, i), this.tracksBuffered.forEach(a => { for (let o = 0; o < a.length;) { if (a[o].end <= i) { a.shift(); continue } else if (a[o].start < i) a[o].start = i; else break; o++ } }), this.fragmentTracker.removeFragmentsInRange(r, i, ve.SUBTITLE) } } onError(e, t) { const r = t.frag; r?.type === ve.SUBTITLE && (t.details === J.FRAG_GAP && this.fragmentTracker.fragBuffered(r, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== se.STOPPED && (this.state = se.IDLE)) } onSubtitleTracksUpdated(e, { subtitleTracks: t }) { if (this.levels && Lw(this.levels, t)) { this.levels = t.map(r => new eo(r)); return } this.tracksBuffered = [], this.levels = t.map(r => { const s = new eo(r); return this.tracksBuffered[s.id] = [], s }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, ve.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null } onSubtitleTrackSwitch(e, t) { var r; if (this.currentTrackId = t.id, !((r = this.levels) != null && r.length) || this.currentTrackId === -1) { this.clearInterval(); return } const s = this.levels[this.currentTrackId]; s != null && s.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, s && this.state !== se.STOPPED && this.setInterval(ty) } onSubtitleTrackLoaded(e, t) { var r; const { currentTrackId: s, levels: i } = this, { details: a, id: o } = t; if (!i) { this.warn(`Subtitle tracks were reset while loading level ${o}`); return } const c = i[o]; if (o >= i.length || !c) return; this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges; let u = 0; if (a.live || (r = c.details) != null && r.live) { if (a.deltaUpdateFailed) return; const h = this.mainDetails; if (!h) { this.startFragRequested = !1; return } const p = h.fragments[0]; if (!c.details) a.hasProgramDateTime && h.hasProgramDateTime ? (kc(a, h), u = a.fragmentStart) : p && (u = p.start, Ah(a, u)); else { var f; u = this.alignPlaylists(a, c.details, (f = this.levelLastLoaded) == null ? void 0 : f.details), u === 0 && p && (u = p.start, Ah(a, u)) } h && !this.startFragRequested && this.setStartPosition(h, u) } c.details = a, this.levelLastLoaded = c, o === s && (this.hls.trigger(k.SUBTITLE_TRACK_UPDATED, { details: a, id: o, groupId: t.groupId }), this.tick(), a.live && !this.fragCurrent && this.media && this.state === se.IDLE && (Xs(null, a.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), c.details = void 0))) } _handleFragmentLoadComplete(e) { const { frag: t, payload: r } = e, s = t.decryptdata, i = this.hls; if (!this.fragContextChanged(t) && r && r.byteLength > 0 && s != null && s.key && s.iv && Di(s.method)) { const a = performance.now(); this.decrypter.decrypt(new Uint8Array(r), s.key.buffer, s.iv.buffer, bp(s.method)).catch(o => { throw i.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.FRAG_DECRYPT_ERROR, fatal: !1, error: o, reason: o.message, frag: t }), o }).then(o => { const c = performance.now(); i.trigger(k.FRAG_DECRYPTED, { frag: t, payload: o, stats: { tstart: a, tdecrypt: c } }) }).catch(o => { this.warn(`${o.name}: ${o.message}`), this.state = se.IDLE }) } } doTick() { if (!this.media) { this.state = se.IDLE; return } if (this.state === se.IDLE) { const { currentTrackId: e, levels: t } = this, r = t?.[e]; if (!r || !t.length || !r.details || this.waitForLive(r)) return; const { config: s } = this, i = this.getLoadPosition(), a = Me.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], i, s.maxBufferHole), { end: o, len: c } = a, u = r.details, f = this.hls.maxBufferLength + u.levelTargetDuration; if (c > f) return; const h = u.fragments, p = h.length, v = u.edge; let g = null; const y = this.fragPrevious; if (o < v) { const S = s.maxFragLookUpTolerance, E = o > v - S ? 0 : S; g = Xs(y, h, Math.max(h[0].start, o), E), !g && y && y.start < h[0].start && (g = h[0]) } else g = h[p - 1]; if (g = this.filterReplacedPrimary(g, r.details), !g) return; const w = g.sn - u.startSN, T = h[w - 1]; if (T && T.cc === g.cc && this.fragmentTracker.getState(T) === Rt.NOT_LOADED && (g = T), this.fragmentTracker.getState(g) === Rt.NOT_LOADED) { const S = this.mapToInitFragWhenRequired(g); S && this.loadFragment(S, r, o) } } } loadFragment(e, t, r) { At(e) ? super.loadFragment(e, t, r) : this._loadInitSegment(e, t) } get mediaBufferTimeRanges() { return new _5(this.tracksBuffered[this.currentTrackId] || []) } } class _5 { constructor(e) { this.buffered = void 0; const t = (r, s, i) => { if (s = s >>> 0, s > i - 1) throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${s}) is greater than the maximum bound (${i})`); return e[s][r] }; this.buffered = { get length() { return e.length }, end(r) { return t("end", r, e.length) }, start(r) { return t("start", r, e.length) } } } } const P5 = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, Vw = n => String.fromCharCode(P5[n] || n), Ur = 15, An = 100, N5 = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, D5 = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, O5 = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, M5 = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, j5 = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"]; class F5 { constructor() { this.time = null, this.verboseLevel = 0 } log(e, t) { if (this.verboseLevel >= e) { const r = typeof t == "function" ? t() : t; tt.log(`${this.time} [${e}] ${r}`) } } } const $s = function (e) { const t = []; for (let r = 0; r < e.length; r++)t.push(e[r].toString(16)); return t }; class Gw { constructor() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } reset() { this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1 } setStyles(e) { const t = ["foreground", "underline", "italics", "background", "flash"]; for (let r = 0; r < t.length; r++) { const s = t[r]; e.hasOwnProperty(s) && (this[s] = e[s]) } } isDefault() { return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash } equals(e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash } copy(e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash } toString() { return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash } } class $5 { constructor() { this.uchar = " ", this.penState = new Gw } reset() { this.uchar = " ", this.penState.reset() } setChar(e, t) { this.uchar = e, this.penState.copy(t) } setPenState(e) { this.penState.copy(e) } equals(e) { return this.uchar === e.uchar && this.penState.equals(e.penState) } copy(e) { this.uchar = e.uchar, this.penState.copy(e.penState) } isEmpty() { return this.uchar === " " && this.penState.isDefault() } } class B5 { constructor(e) { this.chars = [], this.pos = 0, this.currPenState = new Gw, this.cueStartTime = null, this.logger = void 0; for (let t = 0; t < An; t++)this.chars.push(new $5); this.logger = e } equals(e) { for (let t = 0; t < An; t++)if (!this.chars[t].equals(e.chars[t])) return !1; return !0 } copy(e) { for (let t = 0; t < An; t++)this.chars[t].copy(e.chars[t]) } isEmpty() { let e = !0; for (let t = 0; t < An; t++)if (!this.chars[t].isEmpty()) { e = !1; break } return e } setCursor(e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > An && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = An) } moveCursor(e) { const t = this.pos + e; if (e > 1) for (let r = this.pos + 1; r < t + 1; r++)this.chars[r].setPenState(this.currPenState); this.setCursor(t) } backSpace() { this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState) } insertChar(e) { e >= 144 && this.backSpace(); const t = Vw(e); if (this.pos >= An) { this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!"); return } this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1) } clearFromPos(e) { let t; for (t = e; t < An; t++)this.chars[t].reset() } clear() { this.clearFromPos(0), this.pos = 0, this.currPenState.reset() } clearToEndOfRow() { this.clearFromPos(this.pos) } getTextString() { const e = []; let t = !0; for (let r = 0; r < An; r++) { const s = this.chars[r].uchar; s !== " " && (t = !1), e.push(s) } return t ? "" : e.join("") } setPenStyles(e) { this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState) } } class Af {
    constructor(e) { this.rows = [], this.currRow = Ur - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0; for (let t = 0; t < Ur; t++)this.rows.push(new B5(e)); this.logger = e } reset() { for (let e = 0; e < Ur; e++)this.rows[e].clear(); this.currRow = Ur - 1 } equals(e) { let t = !0; for (let r = 0; r < Ur; r++)if (!this.rows[r].equals(e.rows[r])) { t = !1; break } return t } copy(e) { for (let t = 0; t < Ur; t++)this.rows[t].copy(e.rows[t]) } isEmpty() { let e = !0; for (let t = 0; t < Ur; t++)if (!this.rows[t].isEmpty()) { e = !1; break } return e } backSpace() { this.rows[this.currRow].backSpace() } clearToEndOfRow() { this.rows[this.currRow].clearToEndOfRow() } insertChar(e) { this.rows[this.currRow].insertChar(e) } setPen(e) { this.rows[this.currRow].setPenStyles(e) } moveCursor(e) { this.rows[this.currRow].moveCursor(e) } setCursor(e) { this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e) } setPAC(e) { this.logger.log(2, () => "pacData = " + it(e)); let t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (let o = 0; o < Ur; o++)this.rows[o].clear(); const i = this.currRow + 1 - this.nrRollUpRows, a = this.lastOutputScreen; if (a) { const o = a.rows[i].cueStartTime, c = this.logger.time; if (o !== null && c !== null && o < c) for (let u = 0; u < this.nrRollUpRows; u++)this.rows[t - this.nrRollUpRows + u + 1].copy(a.rows[i + u]) } } this.currRow = t; const r = this.rows[this.currRow]; if (e.indent !== null) { const i = e.indent, a = Math.max(i - 1, 0); r.setCursor(e.indent), e.color = r.chars[a].penState.foreground } const s = { foreground: e.color, underline: e.underline, italics: e.italics, background: "black", flash: !1 }; this.setPen(s) } setBkgData(e) { this.logger.log(2, () => "bkgData = " + it(e)), this.backSpace(), this.setPen(e), this.insertChar(32) } setRollUpRows(e) { this.nrRollUpRows = e } rollUp() { if (this.nrRollUpRows === null) { this.logger.log(3, "roll_up but nrRollUpRows not set yet"); return } this.logger.log(1, () => this.getDisplayText()); const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0]; t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up") } getDisplayText(e) {
      e = e || !1; const t = []; let r = "", s = -1; for (let i = 0; i < Ur; i++) { const a = this.rows[i].getTextString(); a && (s = i + 1, e ? t.push("Row " + s + ": '" + a + "'") : t.push(a.trim())) } return t.length > 0 && (e ? r = "[" + t.join(" | ") + "]" : r = t.join(`
`)), r
    } getTextAndFormat() { return this.rows }
  } class ry { constructor(e, t, r) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new Af(r), this.nonDisplayedMemory = new Af(r), this.lastOutputScreen = new Af(r), this.currRollUpRow = this.displayedMemory.rows[Ur - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r } reset() { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Ur - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null } getHandler() { return this.outputFilter } setHandler(e) { this.outputFilter = e } setPAC(e) { this.writeScreen.setPAC(e) } setBkgData(e) { this.writeScreen.setBkgData(e) } setMode(e) { e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e) } insertChars(e) { for (let r = 0; r < e.length; r++)this.writeScreen.insertChar(e[r]); const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP"; this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate()) } ccRCL() { this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON") } ccBS() { this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate()) } ccAOF() { } ccAON() { } ccDER() { this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate() } ccRU(e) { this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e) } ccFON() { this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({ flash: !0 }) } ccRDC() { this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON") } ccTR() { this.logger.log(2, "TR"), this.setMode("MODE_TEXT") } ccRTD() { this.logger.log(2, "RTD"), this.setMode("MODE_TEXT") } ccEDM() { this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0) } ccCR() { this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0) } ccENM() { this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset() } ccEOC() { if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") { const e = this.displayedMemory; this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText()) } this.outputDataUpdate(!0) } ccTO(e) { this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e) } ccMIDROW(e) { const t = { flash: !1 }; if (t.underline = e % 2 === 1, t.italics = e >= 46, t.italics) t.foreground = "white"; else { const r = Math.floor(e / 2) - 16, s = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"]; t.foreground = s[r] } this.logger.log(2, "MIDROW: " + it(t)), this.writeScreen.setPen(t) } outputDataUpdate(e = !1) { const t = this.logger.time; t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory)) } cueSplitAtTime(e) { this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e)) } } class ny { constructor(e, t, r) { this.channels = void 0, this.currentChannel = 0, this.cmdHistory = z5(), this.logger = void 0; const s = this.logger = new F5; this.channels = [null, new ry(e, t, s), new ry(e + 1, r, s)] } getHandler(e) { return this.channels[e].getHandler() } setHandler(e, t) { this.channels[e].setHandler(t) } addData(e, t) { this.logger.time = e; for (let r = 0; r < t.length; r += 2) { const s = t[r] & 127, i = t[r + 1] & 127; let a = !1, o = null; if (s === 0 && i === 0) continue; this.logger.log(3, () => "[" + $s([t[r], t[r + 1]]) + "] -> (" + $s([s, i]) + ")"); const c = this.cmdHistory; if (s >= 16 && s <= 31) { if (U5(s, i, c)) { Vl(null, null, c), this.logger.log(3, () => "Repeated command (" + $s([s, i]) + ") is dropped"); continue } Vl(s, i, this.cmdHistory), a = this.parseCmd(s, i), a || (a = this.parseMidrow(s, i)), a || (a = this.parsePAC(s, i)), a || (a = this.parseBackgroundAttributes(s, i)) } else Vl(null, null, c); if (!a && (o = this.parseChars(s, i), o)) { const f = this.currentChannel; f && f > 0 ? this.channels[f].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?") } !a && !o && this.logger.log(2, () => "Couldn't parse cleaned data " + $s([s, i]) + " orig: " + $s([t[r], t[r + 1]])) } } parseCmd(e, t) { const r = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47, s = (e === 23 || e === 31) && t >= 33 && t <= 35; if (!(r || s)) return !1; const i = e === 20 || e === 21 || e === 23 ? 1 : 2, a = this.channels[i]; return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? a.ccRCL() : t === 33 ? a.ccBS() : t === 34 ? a.ccAOF() : t === 35 ? a.ccAON() : t === 36 ? a.ccDER() : t === 37 ? a.ccRU(2) : t === 38 ? a.ccRU(3) : t === 39 ? a.ccRU(4) : t === 40 ? a.ccFON() : t === 41 ? a.ccRDC() : t === 42 ? a.ccTR() : t === 43 ? a.ccRTD() : t === 44 ? a.ccEDM() : t === 45 ? a.ccCR() : t === 46 ? a.ccENM() : t === 47 && a.ccEOC() : a.ccTO(t - 32), this.currentChannel = i, !0 } parseMidrow(e, t) { let r = 0; if ((e === 17 || e === 25) && t >= 32 && t <= 47) { if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1; const s = this.channels[r]; return s ? (s.ccMIDROW(t), this.logger.log(3, () => "MIDROW (" + $s([e, t]) + ")"), !0) : !1 } return !1 } parsePAC(e, t) { let r; const s = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127, i = (e === 16 || e === 24) && t >= 64 && t <= 95; if (!(s || i)) return !1; const a = e <= 23 ? 1 : 2; t >= 64 && t <= 95 ? r = a === 1 ? N5[e] : O5[e] : r = a === 1 ? D5[e] : M5[e]; const o = this.channels[a]; return o ? (o.setPAC(this.interpretPAC(r, t)), this.currentChannel = a, !0) : !1 } interpretPAC(e, t) { let r; const s = { color: null, italics: !1, indent: null, underline: !1, row: e }; return t > 95 ? r = t - 96 : r = t - 64, s.underline = (r & 1) === 1, r <= 13 ? s.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (s.italics = !0, s.color = "white") : s.indent = Math.floor((r - 16) / 2) * 4, s } parseChars(e, t) { let r, s = null, i = null; if (e >= 25 ? (r = 2, i = e - 8) : (r = 1, i = e), i >= 17 && i <= 19) { let a; i === 17 ? a = t + 80 : i === 18 ? a = t + 112 : a = t + 144, this.logger.log(2, () => "Special char '" + Vw(a) + "' in channel " + r), s = [a] } else e >= 32 && e <= 127 && (s = t === 0 ? [e] : [e, t]); return s && this.logger.log(3, () => "Char codes =  " + $s(s).join(",")), s } parseBackgroundAttributes(e, t) { const r = (e === 16 || e === 24) && t >= 32 && t <= 47, s = (e === 23 || e === 31) && t >= 45 && t <= 47; if (!(r || s)) return !1; let i; const a = {}; e === 16 || e === 24 ? (i = Math.floor((t - 32) / 2), a.background = j5[i], t % 2 === 1 && (a.background = a.background + "_semi")) : t === 45 ? a.background = "transparent" : (a.foreground = "black", t === 47 && (a.underline = !0)); const o = e <= 23 ? 1 : 2; return this.channels[o].setBkgData(a), !0 } reset() { for (let e = 0; e < Object.keys(this.channels).length; e++) { const t = this.channels[e]; t && t.reset() } Vl(null, null, this.cmdHistory) } cueSplitAtTime(e) { for (let t = 0; t < this.channels.length; t++) { const r = this.channels[t]; r && r.cueSplitAtTime(e) } } } function Vl(n, e, t) { t.a = n, t.b = e } function U5(n, e, t) { return t.a === n && t.b === e } function z5() { return { a: null, b: null } } var Dp = (function () { if (Cc != null && Cc.VTTCue) return self.VTTCue; const n = ["", "lr", "rl"], e = ["start", "middle", "end", "left", "right"]; function t(o, c) { if (typeof c != "string" || !Array.isArray(o)) return !1; const u = c.toLowerCase(); return ~o.indexOf(u) ? u : !1 } function r(o) { return t(n, o) } function s(o) { return t(e, o) } function i(o, ...c) { let u = 1; for (; u < arguments.length; u++) { const f = arguments[u]; for (const h in f) o[h] = f[h] } return o } function a(o, c, u) { const f = this, h = { enumerable: !0 }; f.hasBeenReset = !1; let p = "", v = !1, g = o, y = c, w = u, T = null, S = "", E = !0, I = "auto", C = "start", D = 50, R = "middle", N = 50, P = "middle"; Object.defineProperty(f, "id", i({}, h, { get: function () { return p }, set: function (_) { p = "" + _ } })), Object.defineProperty(f, "pauseOnExit", i({}, h, { get: function () { return v }, set: function (_) { v = !!_ } })), Object.defineProperty(f, "startTime", i({}, h, { get: function () { return g }, set: function (_) { if (typeof _ != "number") throw new TypeError("Start time must be set to a number."); g = _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "endTime", i({}, h, { get: function () { return y }, set: function (_) { if (typeof _ != "number") throw new TypeError("End time must be set to a number."); y = _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "text", i({}, h, { get: function () { return w }, set: function (_) { w = "" + _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "region", i({}, h, { get: function () { return T }, set: function (_) { T = _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "vertical", i({}, h, { get: function () { return S }, set: function (_) { const M = r(_); if (M === !1) throw new SyntaxError("An invalid or illegal string was specified."); S = M, this.hasBeenReset = !0 } })), Object.defineProperty(f, "snapToLines", i({}, h, { get: function () { return E }, set: function (_) { E = !!_, this.hasBeenReset = !0 } })), Object.defineProperty(f, "line", i({}, h, { get: function () { return I }, set: function (_) { if (typeof _ != "number" && _ !== "auto") throw new SyntaxError("An invalid number or illegal string was specified."); I = _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "lineAlign", i({}, h, { get: function () { return C }, set: function (_) { const M = s(_); if (!M) throw new SyntaxError("An invalid or illegal string was specified."); C = M, this.hasBeenReset = !0 } })), Object.defineProperty(f, "position", i({}, h, { get: function () { return D }, set: function (_) { if (_ < 0 || _ > 100) throw new Error("Position must be between 0 and 100."); D = _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "positionAlign", i({}, h, { get: function () { return R }, set: function (_) { const M = s(_); if (!M) throw new SyntaxError("An invalid or illegal string was specified."); R = M, this.hasBeenReset = !0 } })), Object.defineProperty(f, "size", i({}, h, { get: function () { return N }, set: function (_) { if (_ < 0 || _ > 100) throw new Error("Size must be between 0 and 100."); N = _, this.hasBeenReset = !0 } })), Object.defineProperty(f, "align", i({}, h, { get: function () { return P }, set: function (_) { const M = s(_); if (!M) throw new SyntaxError("An invalid or illegal string was specified."); P = M, this.hasBeenReset = !0 } })), f.displayState = void 0 } return a.prototype.getCueAsHTML = function () { return self.WebVTT.convertCueToDOMTree(self, this.text) }, a })(); class V5 { decode(e, t) { if (!e) return ""; if (typeof e != "string") throw new Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(e)) } } function Hw(n) { function e(r, s, i, a) { return (r | 0) * 3600 + (s | 0) * 60 + (i | 0) + parseFloat(a || 0) } const t = n.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/); return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null } class G5 { constructor() { this.values = Object.create(null) } set(e, t) { !this.get(e) && t !== "" && (this.values[e] = t) } get(e, t, r) { return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t } has(e) { return e in this.values } alt(e, t, r) { for (let s = 0; s < r.length; ++s)if (t === r[s]) { this.set(e, t); break } } integer(e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)) } percent(e, t) { if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) { const r = parseFloat(t); if (r >= 0 && r <= 100) return this.set(e, r), !0 } return !1 } } function Ww(n, e, t, r) { const s = r ? n.split(r) : [n]; for (const i in s) { if (typeof s[i] != "string") continue; const a = s[i].split(t); if (a.length !== 2) continue; const o = a[0], c = a[1]; e(o, c) } } const Nh = new Dp(0, 0, ""), Gl = Nh.align === "middle" ? "middle" : "center"; function H5(n, e, t) { const r = n; function s() { const o = Hw(n); if (o === null) throw new Error("Malformed timestamp: " + r); return n = n.replace(/^[^\sa-zA-Z-]+/, ""), o } function i(o, c) { const u = new G5; Ww(o, function (p, v) { let g; switch (p) { case "region": for (let y = t.length - 1; y >= 0; y--)if (t[y].id === v) { u.set(p, t[y].region); break } break; case "vertical": u.alt(p, v, ["rl", "lr"]); break; case "line": g = v.split(","), u.integer(p, g[0]), u.percent(p, g[0]) && u.set("snapToLines", !1), u.alt(p, g[0], ["auto"]), g.length === 2 && u.alt("lineAlign", g[1], ["start", Gl, "end"]); break; case "position": g = v.split(","), u.percent(p, g[0]), g.length === 2 && u.alt("positionAlign", g[1], ["start", Gl, "end", "line-left", "line-right", "auto"]); break; case "size": u.percent(p, v); break; case "align": u.alt(p, v, ["start", Gl, "end", "left", "right"]); break } }, /:/, /\s/), c.region = u.get("region", null), c.vertical = u.get("vertical", ""); let f = u.get("line", "auto"); f === "auto" && Nh.line === -1 && (f = -1), c.line = f, c.lineAlign = u.get("lineAlign", "start"), c.snapToLines = u.get("snapToLines", !0), c.size = u.get("size", 100), c.align = u.get("align", Gl); let h = u.get("position", "auto"); h === "auto" && Nh.position === 50 && (h = c.align === "start" || c.align === "left" ? 0 : c.align === "end" || c.align === "right" ? 100 : 50), c.position = h } function a() { n = n.replace(/^\s+/, "") } if (a(), e.startTime = s(), a(), n.slice(0, 3) !== "-->") throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r); n = n.slice(3), a(), e.endTime = s(), a(), i(n, e) } function Kw(n) {
    return n.replace(/<br(?: \/)?>/gi, `
`)
  } class W5 {
    constructor() { this.state = "INITIAL", this.buffer = "", this.decoder = new V5, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0 } parse(e) {
      const t = this; e && (t.buffer += t.decoder.decode(e, { stream: !0 })); function r() {
        let i = t.buffer, a = 0; for (i = Kw(i); a < i.length && i[a] !== "\r" && i[a] !== `
`;)++a; const o = i.slice(0, a); return i[a] === "\r" && ++a, i[a] === `
`&& ++a, t.buffer = i.slice(a), o
      } function s(i) { Ww(i, function (a, o) { }, /:/) } try {
        let i = ""; if (t.state === "INITIAL") { if (!/\r\n|\n/.test(t.buffer)) return this; i = r(); const o = i.match(/^()?WEBVTT([ \t].*)?$/); if (!(o != null && o[0])) throw new Error("Malformed WebVTT signature."); t.state = "HEADER" } let a = !1; for (; t.buffer;) {
          if (!/\r\n|\n/.test(t.buffer)) return this; switch (a ? a = !1 : i = r(), t.state) {
            case "HEADER": /:/.test(i) ? s(i) : i || (t.state = "ID"); continue; case "NOTE": i || (t.state = "ID"); continue; case "ID": if (/^NOTE($|[ \t])/.test(i)) { t.state = "NOTE"; break } if (!i) continue; if (t.cue = new Dp(0, 0, ""), t.state = "CUE", i.indexOf("-->") === -1) { t.cue.id = i; continue } case "CUE": if (!t.cue) { t.state = "BADCUE"; continue } try { H5(i, t.cue, t.regionList) } catch { t.cue = null, t.state = "BADCUE"; continue } t.state = "CUETEXT"; continue; case "CUETEXT": {
              const o = i.indexOf("-->") !== -1; if (!i || o && (a = !0)) { t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID"; continue } if (t.cue === null) continue; t.cue.text && (t.cue.text += `
`), t.cue.text += i
            } continue; case "BADCUE": i || (t.state = "ID")
          }
        }
      } catch { t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE" } return this
    } flush() {
      const e = this; try {
        if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT") throw new Error("Malformed WebVTT signature.")
      } catch (t) { e.onparsingerror && e.onparsingerror(t) } return e.onflush && e.onflush(), this
    }
  } const K5 = /\r\n|\n\r|\n|\r/g, If = function (e, t, r = 0) { return e.slice(r, r + t.length) === t }, q5 = function (e) { let t = parseInt(e.slice(-3)); const r = parseInt(e.slice(-6, -4)), s = parseInt(e.slice(-9, -7)), i = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0; if (!ge(t) || !ge(r) || !ge(s) || !ge(i)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`); return t += 1e3 * r, t += 60 * 1e3 * s, t += 3600 * 1e3 * i, t }; function Op(n, e, t) { return Wa(n.toString()) + Wa(e.toString()) + Wa(t) } const Y5 = function (e, t, r) { let s = e[t], i = e[s.prevCC]; if (!i || !i.new && s.new) { e.ccOffset = e.presentationOffset = s.start, s.new = !1; return } for (; (a = i) != null && a.new;) { var a; e.ccOffset += s.start - i.start, s.new = !1, s = i, i = e[s.prevCC] } e.presentationOffset = r }; function X5(n, e, t, r, s, i, a) {
    const o = new W5, c = wr(new Uint8Array(n)).trim().replace(K5, `
`).split(`
`), u = [], f = e ? rN(e.baseTime, e.timescale) : 0; let h = "00:00.000", p = 0, v = 0, g, y = !0; o.oncue = function (w) { const T = t[r]; let S = t.ccOffset; const E = (p - f) / 9e4; if (T != null && T.new && (v !== void 0 ? S = t.ccOffset = T.start : Y5(t, r, E)), E) { if (!e) { g = new Error("Missing initPTS for VTT MPEGTS"); return } S = E - t.presentationOffset } const I = w.endTime - w.startTime, C = kr((w.startTime + S - v) * 9e4, s * 9e4) / 9e4; w.startTime = Math.max(C, 0), w.endTime = Math.max(C + I, 0); const D = w.text.trim(); w.text = decodeURIComponent(encodeURIComponent(D)), w.id || (w.id = Op(w.startTime, w.endTime, D)), w.endTime > 0 && u.push(w) }, o.onparsingerror = function (w) { g = w }, o.onflush = function () { if (g) { a(g); return } i(u) }, c.forEach(w => {
      if (y) if (If(w, "X-TIMESTAMP-MAP=")) { y = !1, w.slice(16).split(",").forEach(T => { If(T, "LOCAL:") ? h = T.slice(6) : If(T, "MPEGTS:") && (p = parseInt(T.slice(7))) }); try { v = q5(h) / 1e3 } catch (T) { g = T } return } else w === "" && (y = !1); o.parse(w + `
`)
    }), o.flush()
  } const Lf = "stpp.ttml.im1t", qw = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, Yw = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, Q5 = { left: "start", center: "center", right: "end", start: "start", end: "end" }; function sy(n, e, t, r) { const s = ze(new Uint8Array(n), ["mdat"]); if (s.length === 0) { r(new Error("Could not parse IMSC1 mdat")); return } const i = s.map(o => wr(o)), a = tN(e.baseTime, 1, e.timescale); try { i.forEach(o => t(Z5(o, a))) } catch (o) { r(o) } } function Z5(n, e) { const s = new DOMParser().parseFromString(n, "text/xml").getElementsByTagName("tt")[0]; if (!s) throw new Error("Invalid ttml"); const i = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 }, a = Object.keys(i).reduce((h, p) => (h[p] = s.getAttribute(`ttp:${p}`) || i[p], h), {}), o = s.getAttribute("xml:space") !== "preserve", c = iy(Cf(s, "styling", "style")), u = iy(Cf(s, "layout", "region")), f = Cf(s, "body", "[begin]"); return [].map.call(f, h => { const p = Xw(h, o); if (!p || !h.hasAttribute("begin")) return null; const v = Rf(h.getAttribute("begin"), a), g = Rf(h.getAttribute("dur"), a); let y = Rf(h.getAttribute("end"), a); if (v === null) throw ay(h); if (y === null) { if (g === null) throw ay(h); y = v + g } const w = new Dp(v - e, y - e, p); w.id = Op(w.startTime, w.endTime, w.text); const T = u[h.getAttribute("region")], S = c[h.getAttribute("style")], E = J5(T, S, c), { textAlign: I } = E; if (I) { const C = Q5[I]; C && (w.lineAlign = C), w.align = I } return nt(w, E), w }).filter(h => h !== null) } function Cf(n, e, t) { const r = n.getElementsByTagName(e)[0]; return r ? [].slice.call(r.querySelectorAll(t)) : [] } function iy(n) { return n.reduce((e, t) => { const r = t.getAttribute("xml:id"); return r && (e[r] = t), e }, {}) } function Xw(n, e) {
    return [].slice.call(n.childNodes).reduce((t, r, s) => {
      var i; return r.nodeName === "br" && s ? t + `
`: (i = r.childNodes) != null && i.length ? Xw(r, e) : e ? t + r.textContent.trim().replace(/\s+/g, " ") : t + r.textContent
    }, "")
  } function J5(n, e, t) { const r = "http://www.w3.org/ns/ttml#styling"; let s = null; const i = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"], a = n != null && n.hasAttribute("style") ? n.getAttribute("style") : null; return a && t.hasOwnProperty(a) && (s = t[a]), i.reduce((o, c) => { const u = kf(e, r, c) || kf(n, r, c) || kf(s, r, c); return u && (o[c] = u), o }, {}) } function kf(n, e, t) { return n && n.hasAttributeNS(e, t) ? n.getAttributeNS(e, t) : null } function ay(n) { return new Error(`Could not parse ttml timestamp ${n}`) } function Rf(n, e) { if (!n) return null; let t = Hw(n); return t === null && (qw.test(n) ? t = eD(n, e) : Yw.test(n) && (t = tD(n, e))), t } function eD(n, e) { const t = qw.exec(n), r = (t[4] | 0) + (t[5] | 0) / e.subFrameRate; return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + r / e.frameRate } function tD(n, e) { const t = Yw.exec(n), r = Number(t[1]); switch (t[2]) { case "h": return r * 3600; case "m": return r * 60; case "ms": return r * 1e3; case "f": return r / e.frameRate; case "t": return r / e.tickRate }return r } class Hl { constructor(e, t) { this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t } dispatchCue() { this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null) } newCue(e, t, r) { (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName) } reset() { this.cueRanges = [], this.startTime = null } } class rD { constructor(e) { this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = ly(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = { textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode }, textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode }, textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode }, textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode } }, e.on(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(k.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(k.FRAG_LOADING, this.onFragLoading, this), e.on(k.FRAG_LOADED, this.onFragLoaded, this), e.on(k.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(k.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(k.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(k.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(k.BUFFER_FLUSHING, this.onBufferFlushing, this) } destroy() { const { hls: e } = this; e.off(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(k.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(k.FRAG_LOADING, this.onFragLoading, this), e.off(k.FRAG_LOADED, this.onFragLoaded, this), e.off(k.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(k.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(k.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(k.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(k.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0 } initCea608Parsers() { const e = new Hl(this, "textTrack1"), t = new Hl(this, "textTrack2"), r = new Hl(this, "textTrack3"), s = new Hl(this, "textTrack4"); this.cea608Parser1 = new ny(1, e, t), this.cea608Parser2 = new ny(3, r, s) } addCues(e, t, r, s, i) { let a = !1; for (let o = i.length; o--;) { const c = i[o], u = nD(c[0], c[1], t, r); if (u >= 0 && (c[0] = Math.min(c[0], t), c[1] = Math.max(c[1], r), a = !0, u / (r - t) > .5)) return } if (a || i.push([t, r]), this.config.renderTextTracksNatively) { const o = this.captionsTracks[e]; this.Cues.newCue(o, t, r, s) } else { const o = this.Cues.newCue(null, t, r, s); this.hls.trigger(k.CUES_PARSED, { type: "captions", cues: o, track: e }) } } onInitPtsFound(e, { frag: t, id: r, initPTS: s, timescale: i, trackId: a }) { const { unparsedVttFrags: o } = this; r === ve.MAIN && (this.initPTS[t.cc] = { baseTime: s, timescale: i, trackId: a }), o.length && (this.unparsedVttFrags = [], o.forEach(c => { this.initPTS[c.frag.cc] ? this.onFragLoaded(k.FRAG_LOADED, c) : this.hls.trigger(k.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: c.frag, error: new Error("Subtitle discontinuity domain does not match main") }) })) } getExistingTrack(e, t) { const { media: r } = this; if (r) for (let s = 0; s < r.textTracks.length; s++) { const i = r.textTracks[s]; if (oy(i, { name: e, lang: t, characteristics: "transcribes-spoken-dialog,describes-music-and-sound" })) return i } return null } createCaptionsTrack(e) { this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e) } createNativeTrack(e) { if (this.captionsTracks[e]) return; const { captionsProperties: t, captionsTracks: r, media: s } = this, { label: i, languageCode: a } = t[e], o = this.getExistingTrack(i, a); if (o) r[e] = o, ki(r[e]), Bw(r[e], s); else { const c = this.createTextTrack("captions", i, a); c && (c[e] = !0, r[e] = c) } } createNonNativeTrack(e) { if (this.nonNativeCaptionsTracks[e]) return; const t = this.captionsProperties[e]; if (!t) return; const r = t.label, s = { _id: e, label: r, kind: "captions", default: t.media ? !!t.media.default : !1, closedCaptions: t.media }; this.nonNativeCaptionsTracks[e] = s, this.hls.trigger(k.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [s] }) } createTextTrack(e, t, r) { const s = this.media; if (s) return s.addTextTrack(e, t, r) } onMediaAttaching(e, t) { this.media = t.media, t.mediaSource || this._cleanTracks() } onMediaDetaching(e, t) { const r = !!t.transferMedia; if (this.media = null, r) return; const { captionsTracks: s } = this; Object.keys(s).forEach(i => { ki(s[i]), delete s[i] }), this.nonNativeCaptionsTracks = {} } onManifestLoading() { this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = ly(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset()) } _cleanTracks() { const { media: e } = this; if (!e) return; const t = e.textTracks; if (t) for (let r = 0; r < t.length; r++)ki(t[r]) } onSubtitleTracksUpdated(e, t) { const r = t.subtitleTracks || [], s = r.some(i => i.textCodec === Lf); if (this.config.enableWebVTT || s && this.config.enableIMSC1) { if (Lw(this.tracks, r)) { this.tracks = r; return } if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) { const a = this.media, o = a ? ac(a.textTracks) : null; if (this.tracks.forEach((c, u) => { let f; if (o) { let h = null; for (let p = 0; p < o.length; p++)if (o[p] && oy(o[p], c)) { h = o[p], o[p] = null; break } h && (f = h) } if (f) ki(f); else { const h = Qw(c); f = this.createTextTrack(h, c.name, c.lang), f && (f.mode = "disabled") } f && this.textTracks.push(f) }), o != null && o.length) { const c = o.filter(u => u !== null).map(u => u.label); c.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${c.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`) } } else if (this.tracks.length) { const a = this.tracks.map(o => ({ label: o.name, kind: o.type.toLowerCase(), default: o.default, subtitleTrack: o })); this.hls.trigger(k.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: a }) } } } onManifestLoaded(e, t) { this.config.enableCEA708Captions && t.captions && t.captions.forEach(r => { const s = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId); if (!s) return; const i = `textTrack${s[1]}`, a = this.captionsProperties[i]; a && (a.label = r.name, r.lang && (a.languageCode = r.lang), a.media = r) }) } closedCaptionsForLevel(e) { const t = this.hls.levels[e.level]; return t?.attrs["CLOSED-CAPTIONS"] } onFragLoading(e, t) { if (this.enabled && t.frag.type === ve.MAIN) { var r, s; const { cea608Parser1: i, cea608Parser2: a, lastSn: o } = this, { cc: c, sn: u } = t.frag, f = (r = (s = t.part) == null ? void 0 : s.index) != null ? r : -1; i && a && (u !== o + 1 || u === o && f !== this.lastPartIndex + 1 || c !== this.lastCc) && (i.reset(), a.reset()), this.lastCc = c, this.lastSn = u, this.lastPartIndex = f } } onFragLoaded(e, t) { const { frag: r, payload: s } = t; if (r.type === ve.SUBTITLE) if (s.byteLength) { const i = r.decryptdata, a = "stats" in t; if (i == null || !i.encrypted || a) { const o = this.tracks[r.level], c = this.vttCCs; c[r.cc] || (c[r.cc] = { start: r.start, prevCC: this.prevCC, new: !0 }, this.prevCC = r.cc), o && o.textCodec === Lf ? this._parseIMSC1(r, s) : this._parseVTTs(t) } } else this.hls.trigger(k.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: r, error: new Error("Empty subtitle payload") }) } _parseIMSC1(e, t) { const r = this.hls; sy(t, this.initPTS[e.cc], s => { this._appendCues(s, e.level), r.trigger(k.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e }) }, s => { r.logger.log(`Failed to parse IMSC1: ${s}`), r.trigger(k.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e, error: s }) }) } _parseVTTs(e) { var t; const { frag: r, payload: s } = e, { initPTS: i, unparsedVttFrags: a } = this, o = i.length - 1; if (!i[r.cc] && o === -1) { a.push(e); return } const c = this.hls, u = (t = r.initSegment) != null && t.data ? Rr(r.initSegment.data, new Uint8Array(s)).buffer : s; X5(u, this.initPTS[r.cc], this.vttCCs, r.cc, r.start, f => { this._appendCues(f, r.level), c.trigger(k.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: r }) }, f => { const h = f.message === "Missing initPTS for VTT MPEGTS"; h ? a.push(e) : this._fallbackToIMSC1(r, s), c.logger.log(`Failed to parse VTT cue: ${f}`), !(h && o > r.cc) && c.trigger(k.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: r, error: f }) }) } _fallbackToIMSC1(e, t) { const r = this.tracks[e.level]; r.textCodec || sy(t, this.initPTS[e.cc], () => { r.textCodec = Lf, this._parseIMSC1(e, t) }, () => { r.textCodec = "wvtt" }) } _appendCues(e, t) { const r = this.hls; if (this.config.renderTextTracksNatively) { const s = this.textTracks[t]; if (!s || s.mode === "disabled") return; e.forEach(i => Uw(s, i)) } else { const s = this.tracks[t]; if (!s) return; const i = s.default ? "default" : "subtitles" + t; r.trigger(k.CUES_PARSED, { type: "subtitles", cues: e, track: i }) } } onFragDecrypted(e, t) { const { frag: r } = t; r.type === ve.SUBTITLE && this.onFragLoaded(k.FRAG_LOADED, t) } onSubtitleTracksCleared() { this.tracks = [], this.captionsTracks = {} } onFragParsingUserdata(e, t) { if (!this.enabled || !this.config.enableCEA708Captions) return; const { frag: r, samples: s } = t; if (!(r.type === ve.MAIN && this.closedCaptionsForLevel(r) === "NONE")) for (let i = 0; i < s.length; i++) { const a = s[i].bytes; if (a) { this.cea608Parser1 || this.initCea608Parsers(); const o = this.extractCea608Data(a); this.cea608Parser1.addData(s[i].pts, o[0]), this.cea608Parser2.addData(s[i].pts, o[1]) } } } onBufferFlushing(e, { startOffset: t, endOffset: r, endOffsetSubtitles: s, type: i }) { const { media: a } = this; if (!(!a || a.currentTime < r)) { if (!i || i === "video") { const { captionsTracks: o } = this; Object.keys(o).forEach(c => Ph(o[c], t, r)) } if (this.config.renderTextTracksNatively && t === 0 && s !== void 0) { const { textTracks: o } = this; Object.keys(o).forEach(c => Ph(o[c], t, s)) } } } extractCea608Data(e) { const t = [[], []], r = e[0] & 31; let s = 2; for (let i = 0; i < r; i++) { const a = e[s++], o = 127 & e[s++], c = 127 & e[s++]; if (o === 0 && c === 0) continue; if ((4 & a) !== 0) { const f = 3 & a; (f === 0 || f === 1) && (t[f].push(o), t[f].push(c)) } } return t } } function Qw(n) { return n.characteristics && /transcribes-spoken-dialog/gi.test(n.characteristics) && /describes-music-and-sound/gi.test(n.characteristics) ? "captions" : "subtitles" } function oy(n, e) { return !!n && n.kind === Qw(e) && Ch(e, n) } function nD(n, e, t, r) { return Math.min(e, r) - Math.max(n, t) } function ly() { return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !0 } } } const sD = /\s/, iD = { newCue(n, e, t, r) { const s = []; let i, a, o, c, u; const f = self.VTTCue || self.TextTrackCue; for (let p = 0; p < r.rows.length; p++)if (i = r.rows[p], o = !0, c = 0, u = "", !i.isEmpty()) { var h; for (let y = 0; y < i.chars.length; y++)sD.test(i.chars[y].uchar) && o ? c++ : (u += i.chars[y].uchar, o = !1); i.cueStartTime = e, e === t && (t += 1e-4), c >= 16 ? c-- : c++; const v = Kw(u.trim()), g = Op(e, t, v); n != null && (h = n.cues) != null && h.getCueById(g) || (a = new f(e, t, v), a.id = g, a.line = p + 1, a.align = "left", a.position = 10 + Math.min(80, Math.floor(c * 8 / 32) * 10), s.push(a)) } return n && s.length && (s.sort((p, v) => p.line === "auto" || v.line === "auto" ? 0 : p.line > 8 && v.line > 8 ? v.line - p.line : p.line - v.line), s.forEach(p => Uw(n, p))), s } }; function aD() { if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try { return new self.ReadableStream({}), !0 } catch { } return !1 } const oD = /(\d+)-(\d+)\/(\d+)/; class cy { constructor(e) { this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || dD, this.controller = new self.AbortController, this.stats = new fp } destroy() { this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null } abortInternal() { this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort()) } abort() { var e; this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response) } load(e, t, r) { const s = this.stats; if (s.loading.start) throw new Error("Loader can only be used once."); s.loading.start = self.performance.now(); const i = lD(e, this.controller.signal), a = e.responseType === "arraybuffer", o = a ? "byteLength" : "length", { maxTimeToFirstByteMs: c, maxLoadTimeMs: u } = t.loadPolicy; this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, i), self.clearTimeout(this.requestTimeout), t.timeout = c && ge(c) ? c : u, this.requestTimeout = self.setTimeout(() => { this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(s, e, this.response)) }, t.timeout), (so(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then(h => { var p; this.response = this.loader = h; const v = Math.max(self.performance.now(), s.loading.start); if (self.clearTimeout(this.requestTimeout), t.timeout = u, this.requestTimeout = self.setTimeout(() => { this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(s, e, this.response)) }, u - (v - s.loading.start)), !h.ok) { const { status: y, statusText: w } = h; throw new fD(w || "fetch, bad network response", y, h) } s.loading.first = v, s.total = uD(h.headers) || s.total; const g = (p = this.callbacks) == null ? void 0 : p.onProgress; return g && ge(t.highWaterMark) ? this.loadProgressively(h, s, e, t.highWaterMark, g) : a ? h.arrayBuffer() : e.responseType === "json" ? h.json() : h.text() }).then(h => { var p, v; const g = this.response; if (!g) throw new Error("loader destroyed"); self.clearTimeout(this.requestTimeout), s.loading.end = Math.max(self.performance.now(), s.loading.first); const y = h[o]; y && (s.loaded = s.total = y); const w = { url: g.url, data: h, code: g.status }, T = (p = this.callbacks) == null ? void 0 : p.onProgress; T && !ge(t.highWaterMark) && T(s, e, h, g), (v = this.callbacks) == null || v.onSuccess(w, s, e, g) }).catch(h => { var p; if (self.clearTimeout(this.requestTimeout), s.aborted) return; const v = h && h.code || 0, g = h ? h.message : null; (p = this.callbacks) == null || p.onError({ code: v, text: g }, e, h ? h.details : null, s) }) } getCacheAge() { let e = null; if (this.response) { const t = this.response.headers.get("age"); e = t ? parseFloat(t) : null } return e } getResponseHeader(e) { return this.response ? this.response.headers.get(e) : null } loadProgressively(e, t, r, s = 0, i) { const a = new ow, o = e.body.getReader(), c = () => o.read().then(u => { if (u.done) return a.dataLength && i(t, r, a.flush().buffer, e), Promise.resolve(new ArrayBuffer(0)); const f = u.value, h = f.length; return t.loaded += h, h < s || a.dataLength ? (a.push(f), a.dataLength >= s && i(t, r, a.flush().buffer, e)) : i(t, r, f.buffer, e), c() }).catch(() => Promise.reject()); return c() } } function lD(n, e) { const t = { method: "GET", mode: "cors", credentials: "same-origin", signal: e, headers: new self.Headers(nt({}, n.headers)) }; return n.rangeEnd && t.headers.set("Range", "bytes=" + n.rangeStart + "-" + String(n.rangeEnd - 1)), t } function cD(n) { const e = oD.exec(n); if (e) return parseInt(e[2]) - parseInt(e[1]) + 1 } function uD(n) { const e = n.get("Content-Range"); if (e) { const r = cD(e); if (ge(r)) return r } const t = n.get("Content-Length"); if (t) return parseInt(t) } function dD(n, e) { return new self.Request(n.url, e) } class fD extends Error { constructor(e, t, r) { super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = r } } const hD = /^age:\s*[\d.]+\s*$/im; class Zw { constructor(e) { this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new fp, this.retryDelay = 0 } destroy() { this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null } abortInternal() { const e = this.loader; self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort())) } abort() { var e; this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader) } load(e, t, r) { if (this.stats.loading.start) throw new Error("Loader can only be used once."); this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal() } loadInternal() { const { config: e, context: t } = this; if (!e || !t) return; const r = this.loader = new self.XMLHttpRequest, s = this.stats; s.loading.first = 0, s.loaded = 0, s.aborted = !1; const i = this.xhrSetup; i ? Promise.resolve().then(() => { if (!(this.loader !== r || this.stats.aborted)) return i(r, t.url) }).catch(a => { if (!(this.loader !== r || this.stats.aborted)) return r.open("GET", t.url, !0), i(r, t.url) }).then(() => { this.loader !== r || this.stats.aborted || this.openAndSendXhr(r, t, e) }).catch(a => { var o; (o = this.callbacks) == null || o.onError({ code: r.status, text: a.message }, t, r, s) }) : this.openAndSendXhr(r, t, e) } openAndSendXhr(e, t, r) { e.readyState || e.open("GET", t.url, !0); const s = t.headers, { maxTimeToFirstByteMs: i, maxLoadTimeMs: a } = r.loadPolicy; if (s) for (const o in s) e.setRequestHeader(o, s[o]); t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = i && ge(i) ? i : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send() } readystatechange() { const { context: e, loader: t, stats: r } = this; if (!e || !t) return; const s = t.readyState, i = this.config; if (!r.aborted && s >= 2 && (r.loading.first === 0 && (r.loading.first = Math.max(self.performance.now(), r.loading.start), i.timeout !== i.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), i.timeout = i.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), s === 4)) { self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null; const u = t.status, f = t.responseType === "text" ? t.responseText : null; if (u >= 200 && u < 300) { const g = f ?? t.response; if (g != null) { var a, o; r.loading.end = Math.max(self.performance.now(), r.loading.first); const y = t.responseType === "arraybuffer" ? g.byteLength : g.length; r.loaded = r.total = y, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first); const w = (a = this.callbacks) == null ? void 0 : a.onProgress; w && w(r, e, g, t); const T = { url: t.responseURL, data: g, code: u }; (o = this.callbacks) == null || o.onSuccess(T, r, e, t); return } } const h = i.loadPolicy.errorRetry, p = r.retry, v = { url: e.url, data: void 0, code: u }; if (Lc(h, p, !1, v)) this.retry(h); else { var c; tt.error(`${u} while loading ${e.url}`), (c = this.callbacks) == null || c.onError({ code: u, text: t.statusText }, e, t, r) } } } loadtimeout() { if (!this.config) return; const e = this.config.loadPolicy.timeoutRetry, t = this.stats.retry; if (Lc(e, t, !0)) this.retry(e); else { var r; tt.warn(`timeout while loading ${(r = this.context) == null ? void 0 : r.url}`); const s = this.callbacks; s && (this.abortInternal(), s.onTimeout(this.stats, this.context, this.loader)) } } retry(e) { const { context: t, stats: r } = this; this.retryDelay = gp(e, r.retry), r.retry++, tt.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t?.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay) } loadprogress(e) { const t = this.stats; t.loaded = e.loaded, e.lengthComputable && (t.total = e.total) } getCacheAge() { let e = null; if (this.loader && hD.test(this.loader.getAllResponseHeaders())) { const t = this.loader.getResponseHeader("age"); e = t ? parseFloat(t) : null } return e } getResponseHeader(e) { return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null } } const pD = { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: null, errorRetry: null }, mD = et(et({ autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, ignoreDevicePixelRatio: !1, maxDevicePixelRatio: Number.POSITIVE_INFINITY, preferManagedMediaSource: !0, initialLiveManifestSize: 1, maxBufferLength: 30, backBufferLength: 1 / 0, frontBufferFlushThreshold: 1 / 0, startOnSegmentBoundary: !1, maxBufferSize: 60 * 1e3 * 1e3, maxFragLookUpTolerance: .25, maxBufferHole: .1, detectStallWithCurrentTimeMs: 1250, highBufferWatchdogPeriod: 2, nudgeOffset: .1, nudgeMaxRetry: 3, nudgeOnVideoHole: !0, liveSyncMode: "edge", liveSyncDurationCount: 3, liveSyncOnStallIncrease: 1, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, maxLiveSyncPlaybackRate: 1, liveDurationInfinity: !1, liveBackBufferLength: null, maxMaxBufferLength: 600, enableWorker: !0, workerPath: null, enableSoftwareAES: !0, startLevel: void 0, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: .2, appendErrorMaxRetry: 3, ignorePlaylistParsingErrors: !1, loader: Zw, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, licenseResponseCallback: void 0, abrController: I_, bufferController: xN, capLevelController: _p, errorController: __, fpsController: v5, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrEwmaDefaultEstimateMax: 5e6, abrBandWidthFactor: .95, abrBandWidthUpFactor: .7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, drmSystems: {}, drmSystemOptions: {}, requestMediaKeySystemAccessFunc: Qb, requireKeySystemAccessOnStart: !1, testBandwidth: !0, progressive: !1, lowLatencyMode: !0, cmcd: void 0, enableDateRangeMetadataCues: !0, enableEmsgMetadataCues: !0, enableEmsgKLVMetadata: !1, enableID3MetadataCues: !0, enableInterstitialPlayback: !0, interstitialAppendInPlace: !0, interstitialLiveLookAhead: 10, useMediaCapabilities: !0, preserveManualLevelOnError: !1, certLoadPolicy: { default: pD }, keyLoadPolicy: { default: { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" }, errorRetry: { maxNumRetry: 8, retryDelayMs: 1e3, maxRetryDelayMs: 2e4, backoff: "linear" } } }, manifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1 / 0, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, playlistLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, fragLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 12e4, timeoutRetry: { maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, steeringManifestLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 2e4, timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, interstitialAssetListLoadPolicy: { default: { maxTimeToFirstByteMs: 1e4, maxLoadTimeMs: 3e4, timeoutRetry: { maxNumRetry: 0, retryDelayMs: 0, maxRetryDelayMs: 0 }, errorRetry: { maxNumRetry: 0, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 } } }, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3 }, gD()), {}, { subtitleStreamController: R5, subtitleTrackController: w5, timelineController: rD, audioStreamController: hN, audioTrackController: pN, emeController: Oi, cmcdController: p5, contentSteeringController: g5, interstitialsController: k5 }); function gD() { return { cueHandler: iD, enableWebVTT: !0, enableIMSC1: !0, enableCEA708Captions: !0, captionsTextTrack1Label: "English", captionsTextTrack1LanguageCode: "en", captionsTextTrack2Label: "Spanish", captionsTextTrack2LanguageCode: "es", captionsTextTrack3Label: "Unknown CC", captionsTextTrack3LanguageCode: "", captionsTextTrack4Label: "Unknown CC", captionsTextTrack4LanguageCode: "", renderTextTracksNatively: !0 } } function xD(n, e, t) { if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'); if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'); const r = Dh(n), s = ["manifest", "level", "frag"], i = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"]; return s.forEach(a => { const o = `${a === "level" ? "playlist" : a}LoadPolicy`, c = e[o] === void 0, u = []; i.forEach(f => { const h = `${a}Loading${f}`, p = e[h]; if (p !== void 0 && c) { u.push(h); const v = r[o].default; switch (e[o] = { default: v }, f) { case "TimeOut": v.maxLoadTimeMs = p, v.maxTimeToFirstByteMs = p; break; case "MaxRetry": v.errorRetry.maxNumRetry = p, v.timeoutRetry.maxNumRetry = p; break; case "RetryDelay": v.errorRetry.retryDelayMs = p, v.timeoutRetry.retryDelayMs = p; break; case "MaxRetryTimeout": v.errorRetry.maxRetryDelayMs = p, v.timeoutRetry.maxRetryDelayMs = p; break } } }), u.length && t.warn(`hls.js config: "${u.join('", "')}" setting(s) are deprecated, use "${o}": ${it(e[o])}`) }), et(et({}, r), e) } function Dh(n) { return n && typeof n == "object" ? Array.isArray(n) ? n.map(Dh) : Object.keys(n).reduce((e, t) => (e[t] = Dh(n[t]), e), {}) : n } function vD(n, e) { const t = n.loader; t !== cy && t !== Zw ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), n.progressive = !1) : aD() && (n.loader = cy, n.progressive = !0, n.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader")) } const oc = 2, yD = .1, bD = .05, wD = 100; class SD extends Kb { constructor(e, t) { super("gap-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () => { this.ended = 0, this.waiting = 0 }, this.onMediaWaiting = () => { var r; (r = this.media) != null && r.seeking || (this.waiting = self.performance.now(), this.tick()) }, this.onMediaEnded = () => { if (this.hls) { var r; this.ended = ((r = this.media) == null ? void 0 : r.currentTime) || 1, this.hls.trigger(k.MEDIA_ENDED, { stalled: !1 }) } }, this.hls = e, this.fragmentTracker = t, this.registerListeners() } registerListeners() { const { hls: e } = this; e && (e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.BUFFER_APPENDED, this.onBufferAppended, this)) } unregisterListeners() { const { hls: e } = this; e && (e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.BUFFER_APPENDED, this.onBufferAppended, this)) } destroy() { super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0 } onMediaAttached(e, t) { this.setInterval(wD), this.mediaSource = t.mediaSource; const r = this.media = t.media; Yt(r, "playing", this.onMediaPlaying), Yt(r, "waiting", this.onMediaWaiting), Yt(r, "ended", this.onMediaEnded) } onMediaDetaching(e, t) { this.clearInterval(); const { media: r } = this; r && (lr(r, "playing", this.onMediaPlaying), lr(r, "waiting", this.onMediaWaiting), lr(r, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0 } onBufferAppended(e, t) { this.buffered = t.timeRanges } get hasBuffered() { return Object.keys(this.buffered).length > 0 } tick() { var e; if (!((e = this.media) != null && e.readyState) || !this.hasBuffered) return; const t = this.media.currentTime; this.poll(t, this.lastCurrentTime), this.lastCurrentTime = t } poll(e, t) { var r, s; const i = (r = this.hls) == null ? void 0 : r.config; if (!i) return; const a = this.media; if (!a) return; const { seeking: o } = a, c = this.seeking && !o, u = !this.seeking && o, f = a.paused && !o || a.ended || a.playbackRate === 0; if (this.seeking = o, e !== t) { t && (this.ended = 0), this.moved = !0, o || (this.nudgeRetry = 0, i.nudgeOnVideoHole && !f && e > t && this.nudgeOnVideoHole(e, t)), this.waiting === 0 && this.stallResolved(e); return } if (u || c) { c && this.stallResolved(e); return } if (f) { this.nudgeRetry = 0, this.stallResolved(e), !this.ended && a.ended && this.hls && (this.ended = e || 1, this.hls.trigger(k.MEDIA_ENDED, { stalled: !1 })); return } if (!Me.getBuffered(a).length) { this.nudgeRetry = 0; return } const h = Me.bufferInfo(a, e, 0), p = h.nextStart || 0, v = this.fragmentTracker; if (o && v && this.hls) { const D = uy(this.hls.inFlightFragments, e), R = h.len > oc, N = !p || D || p - e > oc && !v.getPartialFragment(e); if (R || N) return; this.moved = !1 } const g = (s = this.hls) == null ? void 0 : s.latestLevelDetails; if (!this.moved && this.stalled !== null && v) { if (!(h.len > 0) && !p) return; const R = Math.max(p, h.start || 0) - e, P = !!(g != null && g.live) ? g.targetduration * 2 : oc, _ = Wl(e, v); if (R > 0 && (R <= P || _)) { a.paused || this._trySkipBufferHole(_); return } } const y = i.detectStallWithCurrentTimeMs, w = self.performance.now(), T = this.waiting; let S = this.stalled; if (S === null) if (T > 0 && w - T < y) S = this.stalled = T; else { this.stalled = w; return } const E = w - S; if (!o && (E >= y || T) && this.hls) { var I; if (((I = this.mediaSource) == null ? void 0 : I.readyState) === "ended" && !(g != null && g.live) && Math.abs(e - (g?.edge || 0)) < 1) { if (this.ended) return; this.ended = e || 1, this.hls.trigger(k.MEDIA_ENDED, { stalled: !0 }); return } if (this._reportStall(h), !this.media || !this.hls) return } const C = Me.bufferInfo(a, e, i.maxBufferHole); this._tryFixBufferStall(C, E, e) } stallResolved(e) { const t = this.stalled; if (t && this.hls && (this.stalled = null, this.stallReported)) { const r = self.performance.now() - t; this.log(`playback not stuck anymore @${e}, after ${Math.round(r)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(k.STALL_RESOLVED, {}) } } nudgeOnVideoHole(e, t) { var r; const s = this.buffered.video; if (this.hls && this.media && this.fragmentTracker && (r = this.buffered.audio) != null && r.length && s && s.length > 1 && e > s.end(0)) { const i = Me.bufferedInfo(Me.timeRangesToArray(this.buffered.audio), e, 0); if (i.len > 1 && t >= i.start) { const a = Me.timeRangesToArray(s), o = Me.bufferedInfo(a, t, 0).bufferedIndex; if (o > -1 && o < a.length - 1) { const c = Me.bufferedInfo(a, e, 0).bufferedIndex, u = a[o].end, f = a[o + 1].start; if ((c === -1 || c > o) && f - u < 1 && e - u < 2) { const h = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${u} -> ${f} buffered index: ${c}`); this.warn(h.message), this.media.currentTime += 1e-6; let p = Wl(e, this.fragmentTracker); p && "fragment" in p ? p = p.fragment : p || (p = void 0); const v = Me.bufferInfo(this.media, e, 0); this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_SEEK_OVER_HOLE, fatal: !1, error: h, reason: h.message, frag: p, buffer: v.len, bufferInfo: v }) } } } } } _tryFixBufferStall(e, t, r) { var s, i; const { fragmentTracker: a, media: o } = this, c = (s = this.hls) == null ? void 0 : s.config; if (!o || !a || !c) return; const u = (i = this.hls) == null ? void 0 : i.latestLevelDetails, f = Wl(r, a); if ((f || u != null && u.live && r < u.fragmentStart) && (this._trySkipBufferHole(f) || !this.media)) return; const h = e.buffered, p = this.adjacentTraversal(e, r); (h && h.length > 1 && e.len > c.maxBufferHole || e.nextStart && (e.nextStart - r < c.maxBufferHole || p)) && (t > c.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(e)) } adjacentTraversal(e, t) { const r = this.fragmentTracker, s = e.nextStart; if (r && s) { const i = r.getFragAtPos(t, ve.MAIN), a = r.getFragAtPos(s, ve.MAIN); if (i && a) return a.sn - i.sn < 2 } return !1 } _reportStall(e) { const { hls: t, media: r, stallReported: s, stalled: i } = this; if (!s && i !== null && r && t) { this.stallReported = !0; const a = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${it(e)})`); this.warn(a.message), t.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_STALLED_ERROR, fatal: !1, error: a, buffer: e.len, bufferInfo: e, stalled: { start: i } }) } } _trySkipBufferHole(e) { var t; const { fragmentTracker: r, media: s } = this, i = (t = this.hls) == null ? void 0 : t.config; if (!s || !r || !i) return 0; const a = s.currentTime, o = Me.bufferInfo(s, a, 0), c = a < o.start ? o.start : o.nextStart; if (c && this.hls) { const f = o.len <= i.maxBufferHole, h = o.len > 0 && o.len < 1 && s.readyState < 3, p = c - a; if (p > 0 && (f || h)) { if (p > i.maxBufferHole) { let g = !1; if (a === 0) { const y = r.getAppendedFrag(0, ve.MAIN); y && c < y.end && (g = !0) } if (!g && e) { var u; if (!((u = this.hls.loadLevelObj) != null && u.details) || uy(this.hls.inFlightFragments, c)) return 0; let w = !1, T = e.end; for (; T < c;) { const S = Wl(T, r); if (S) T += S.duration; else { w = !0; break } } if (w) return 0 } } const v = Math.max(c + bD, a + yD); if (this.warn(`skipping hole, adjusting currentTime from ${a} to ${v}`), this.moved = !0, s.currentTime = v, !(e != null && e.gap)) { const g = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${v}`), y = { type: Ee.MEDIA_ERROR, details: J.BUFFER_SEEK_OVER_HOLE, fatal: !1, error: g, reason: g.message, buffer: o.len, bufferInfo: o }; e && ("fragment" in e ? y.part = e : y.frag = e), this.hls.trigger(k.ERROR, y) } return v } } return 0 } _tryNudgeBuffer(e) { const { hls: t, media: r, nudgeRetry: s } = this, i = t?.config; if (!r || !i) return 0; const a = r.currentTime; if (this.nudgeRetry++, s < i.nudgeMaxRetry) { const o = a + (s + 1) * i.nudgeOffset, c = new Error(`Nudging 'currentTime' from ${a} to ${o}`); this.warn(c.message), r.currentTime = o, t.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_NUDGE_ON_STALL, error: c, fatal: !1, buffer: e.len, bufferInfo: e }) } else { const o = new Error(`Playhead still not moving while enough data buffered @${a} after ${i.nudgeMaxRetry} nudges`); this.error(o.message), t.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.BUFFER_STALLED_ERROR, error: o, fatal: !0, buffer: e.len, bufferInfo: e }) } } } function uy(n, e) { const t = dy(n.main); if (t && t.start <= e) return t; const r = dy(n.audio); return r && r.start <= e ? r : null } function dy(n) { if (!n) return null; switch (n.state) { case se.IDLE: case se.STOPPED: case se.ENDED: case se.ERROR: return null }return n.frag } function Wl(n, e) { return e.getAppendedFrag(n, ve.MAIN) || e.getPartialFragment(n) } const ED = .25; function Oh() { if (!(typeof self > "u")) return self.VTTCue || self.TextTrackCue } function _f(n, e, t, r, s) { let i = new n(e, t, ""); try { i.value = r, s && (i.type = s) } catch { i = new n(e, t, it(s ? et({ type: s }, r) : r)) } return i } const Kl = (() => { const n = Oh(); try { n && new n(0, Number.POSITIVE_INFINITY, "") } catch { return Number.MAX_VALUE } return Number.POSITIVE_INFINITY })(); class TD { constructor(e) { this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.assetCue = void 0, this.onEventCueEnter = () => { this.hls && this.hls.trigger(k.EVENT_CUE_ENTER, {}) }, this.hls = e, this._registerListeners() } destroy() { this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null } _registerListeners() { const { hls: e } = this; e && (e.on(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(k.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(k.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this)) } _unregisterListeners() { const { hls: e } = this; e && (e.off(k.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(k.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(k.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this)) } onMediaAttaching(e, t) { var r; this.media = t.media, ((r = t.overrides) == null ? void 0 : r.cueRemoval) === !1 && (this.removeCues = !1) } onMediaAttached() { var e; const t = (e = this.hls) == null ? void 0 : e.latestLevelDetails; t && this.updateDateRangeCues(t) } onMediaDetaching(e, t) { this.media = null, !t.transferMedia && (this.id3Track && (this.removeCues && ki(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {}) } onManifestLoading() { this.dateRangeCuesAppended = {} } createTrack(e) { const t = this.getID3Track(e.textTracks); return t.mode = "hidden", t } getID3Track(e) { if (this.media) { for (let t = 0; t < e.length; t++) { const r = e[t]; if (r.kind === "metadata" && r.label === "id3") return Bw(r, this.media), r } return this.media.addTextTrack("metadata", "id3") } } onFragParsingMetadata(e, t) { if (!this.media || !this.hls) return; const { enableEmsgMetadataCues: r, enableID3MetadataCues: s } = this.hls.config; if (!r && !s) return; const { samples: i } = t; this.id3Track || (this.id3Track = this.createTrack(this.media)); const a = Oh(); if (a) for (let o = 0; o < i.length; o++) { const c = i[o].type; if (c === br.emsg && !r || !s) continue; const u = pw(i[o].data), f = i[o].pts; let h = f + i[o].duration; h > Kl && (h = Kl), h - f <= 0 && (h = f + ED); for (let v = 0; v < u.length; v++) { const g = u[v]; if (!mw(g)) { this.updateId3CueEnds(f, c); const y = _f(a, f, h, g, c); y && this.id3Track.addCue(y) } } } } updateId3CueEnds(e, t) { var r; const s = (r = this.id3Track) == null ? void 0 : r.cues; if (s) for (let i = s.length; i--;) { const a = s[i]; a.type === t && a.startTime < e && a.endTime === Kl && (a.endTime = e) } } onBufferFlushing(e, { startOffset: t, endOffset: r, type: s }) { const { id3Track: i, hls: a } = this; if (!a) return; const { config: { enableEmsgMetadataCues: o, enableID3MetadataCues: c } } = a; if (i && (o || c)) { let u; s === "audio" ? u = f => f.type === br.audioId3 && c : s === "video" ? u = f => f.type === br.emsg && o : u = f => f.type === br.audioId3 && c || f.type === br.emsg && o, Ph(i, t, r, u) } } onLevelUpdated(e, { details: t }) { this.updateDateRangeCues(t, !0) } onLevelPtsUpdated(e, t) { Math.abs(t.drift) > .01 && this.updateDateRangeCues(t.details) } updateDateRangeCues(e, t) { if (!this.hls || !this.media) return; const { assetPlayerId: r, timelineOffset: s, enableDateRangeMetadataCues: i, interstitialsController: a } = this.hls.config; if (!i) return; const o = Oh(); if (r && s && !a) { const { fragmentStart: y, fragmentEnd: w } = e; let T = this.assetCue; T ? (T.startTime = y, T.endTime = w) : o && (T = this.assetCue = _f(o, y, w, { assetPlayerId: this.hls.config.assetPlayerId }, "hlsjs.interstitial.asset"), T && (T.id = r, this.id3Track || (this.id3Track = this.createTrack(this.media)), this.id3Track.addCue(T), T.addEventListener("enter", this.onEventCueEnter))) } if (!e.hasProgramDateTime) return; const { id3Track: c } = this, { dateRanges: u } = e, f = Object.keys(u); let h = this.dateRangeCuesAppended; if (c && t) { var p; if ((p = c.cues) != null && p.length) { const y = Object.keys(h).filter(w => !f.includes(w)); for (let w = y.length; w--;) { var v; const T = y[w], S = (v = h[T]) == null ? void 0 : v.cues; delete h[T], S && Object.keys(S).forEach(E => { const I = S[E]; if (I) { I.removeEventListener("enter", this.onEventCueEnter); try { c.removeCue(I) } catch { } } }) } } else h = this.dateRangeCuesAppended = {} } const g = e.fragments[e.fragments.length - 1]; if (!(f.length === 0 || !ge(g?.programDateTime))) { this.id3Track || (this.id3Track = this.createTrack(this.media)); for (let y = 0; y < f.length; y++) { const w = f[y], T = u[w], S = T.startTime, E = h[w], I = E?.cues || {}; let C = E?.durationKnown || !1, D = Kl; const { duration: R, endDate: N } = T; if (N && R !== null) D = S + R, C = !0; else if (T.endOnNext && !C) { const _ = f.reduce((M, $) => { if ($ !== T.id) { const B = u[$]; if (B.class === T.class && B.startDate > T.startDate && (!M || T.startDate < M.startDate)) return B } return M }, null); _ && (D = _.startTime, C = !0) } const P = Object.keys(T.attr); for (let _ = 0; _ < P.length; _++) { const M = P[_]; if (!G_(M)) continue; const $ = I[M]; if ($) C && !(E != null && E.durationKnown) ? $.endTime = D : Math.abs($.startTime - S) > .01 && ($.startTime = S, $.endTime = D); else if (o) { let B = T.attr[M]; H_(M) && (B = Cb(B)); const W = _f(o, S, D, { key: M, data: B }, br.dateRange); W && (W.id = w, this.id3Track.addCue(W), I[M] = W, a && (M === "X-ASSET-LIST" || M === "X-ASSET-URL") && W.addEventListener("enter", this.onEventCueEnter)) } } h[w] = { cues: I, dateRange: T, durationKnown: C } } } } } class AD { constructor(e) { this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () => { const { media: t } = this, r = this.levelDetails; if (!t || !r) return; this.currentTime = t.currentTime; const s = this.computeLatency(); if (s === null) return; this._latency = s; const { lowLatencyMode: i, maxLiveSyncPlaybackRate: a } = this.config; if (!i || a === 1 || !r.live) return; const o = this.targetLatency; if (o === null) return; const c = s - o, u = Math.min(this.maxLatency, o + r.targetduration); if (c < u && c > .05 && this.forwardBufferLength > 1) { const h = Math.min(2, Math.max(1, a)), p = Math.round(2 / (1 + Math.exp(-.75 * c - this.edgeStalled)) * 20) / 20, v = Math.min(h, Math.max(1, p)); this.changeMediaPlaybackRate(t, v) } else t.playbackRate !== 1 && t.playbackRate !== 0 && this.changeMediaPlaybackRate(t, 1) }, this.hls = e, this.config = e.config, this.registerListeners() } get levelDetails() { var e; return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null } get latency() { return this._latency || 0 } get maxLatency() { const { config: e } = this; if (e.liveMaxLatencyDuration !== void 0) return e.liveMaxLatencyDuration; const t = this.levelDetails; return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0 } get targetLatency() { const e = this.levelDetails; if (e === null || this.hls === null) return null; const { holdBack: t, partHoldBack: r, targetduration: s } = e, { liveSyncDuration: i, liveSyncDurationCount: a, lowLatencyMode: o } = this.config, c = this.hls.userConfig; let u = o && r || t; (this._targetLatencyUpdated || c.liveSyncDuration || c.liveSyncDurationCount || u === 0) && (u = i !== void 0 ? i : a * s); const f = s; return u + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, f) } set targetLatency(e) { this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0 } get liveSyncPosition() { const e = this.estimateLiveEdge(), t = this.targetLatency; if (e === null || t === null) return null; const r = this.levelDetails; if (r === null) return null; const s = r.edge, i = e - t - this.edgeStalled, a = s - r.totalduration, o = s - (this.config.lowLatencyMode && r.partTarget || r.targetduration); return Math.min(Math.max(a, i), o) } get drift() { const e = this.levelDetails; return e === null ? 1 : e.drift } get edgeStalled() { const e = this.levelDetails; if (e === null) return 0; const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3; return Math.max(e.age - t, 0) } get forwardBufferLength() { const { media: e } = this, t = this.levelDetails; if (!e || !t) return 0; const r = e.buffered.length; return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime } destroy() { this.unregisterListeners(), this.onMediaDetaching(), this.hls = null } registerListeners() { const { hls: e } = this; e && (e.on(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(k.ERROR, this.onError, this)) } unregisterListeners() { const { hls: e } = this; e && (e.off(k.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(k.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(k.ERROR, this.onError, this)) } onMediaAttached(e, t) { this.media = t.media, this.media.addEventListener("timeupdate", this.onTimeupdate) } onMediaDetaching() { this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null) } onManifestLoading() { this._latency = null, this.stallCount = 0 } onLevelUpdated(e, { details: t }) { t.advanced && this.onTimeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate) } onError(e, t) { var r; t.details === J.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && (r = this.levelDetails) != null && r.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency")) } changeMediaPlaybackRate(e, t) { var r, s; e.playbackRate !== t && ((r = this.hls) == null || r.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(s = this.targetLatency) == null ? void 0 : s.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${t}`), e.playbackRate = t) } estimateLiveEdge() { const e = this.levelDetails; return e === null ? null : e.edge + e.age } computeLatency() { const e = this.estimateLiveEdge(); return e === null ? null : e - this.currentTime } } class ID extends Rp { constructor(e, t) { super(e, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners() } _registerListeners() { const { hls: e } = this; e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(k.LEVEL_LOADED, this.onLevelLoaded, this), e.on(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(k.FRAG_BUFFERED, this.onFragBuffered, this), e.on(k.ERROR, this.onError, this) } _unregisterListeners() { const { hls: e } = this; e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(k.LEVEL_LOADED, this.onLevelLoaded, this), e.off(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(k.FRAG_BUFFERED, this.onFragBuffered, this), e.off(k.ERROR, this.onError, this) } destroy() { this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy() } stopLoad() { this._levels.forEach(t => { t.loadError = 0, t.fragmentError = 0 }), super.stopLoad() } resetLevels() { this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1 } onManifestLoading(e, t) { this.resetLevels() } onManifestLoaded(e, t) { const r = this.hls.config.preferManagedMediaSource, s = [], i = {}, a = {}; let o = !1, c = !1, u = !1; t.levels.forEach(f => { const h = f.attrs; let { audioCodec: p, videoCodec: v } = f; p && (f.audioCodec = p = Ec(p, r) || void 0), v && (v = f.videoCodec = o_(v)); const { width: g, height: y, unknownCodecs: w } = f, T = w?.length || 0; if (o || (o = !!(g && y)), c || (c = !!v), u || (u = !!p), T || p && !this.isAudioSupported(p) || v && !this.isVideoSupported(v)) { this.log(`Some or all CODECS not supported "${h.CODECS}"`); return } const { CODECS: S, "FRAME-RATE": E, "HDCP-LEVEL": I, "PATHWAY-ID": C, RESOLUTION: D, "VIDEO-RANGE": R } = h, P = `${`${C || "."}-`}${f.bitrate}-${D}-${E}-${S}-${R}-${I}`; if (i[P]) if (i[P].uri !== f.url && !f.attrs["PATHWAY-ID"]) { const _ = a[P] += 1; f.attrs["PATHWAY-ID"] = new Array(_ + 1).join("."); const M = this.createLevel(f); i[P] = M, s.push(M) } else i[P].addGroupId("audio", h.AUDIO), i[P].addGroupId("text", h.SUBTITLES); else { const _ = this.createLevel(f); i[P] = _, a[P] = 1, s.push(_) } }), this.filterAndSortMediaOptions(s, t, o, c, u) } createLevel(e) { const t = new eo(e), r = e.supplemental; if (r != null && r.videoCodec && !this.isVideoSupported(r.videoCodec)) { const s = new Error(`SUPPLEMENTAL-CODECS not supported "${r.videoCodec}"`); this.log(s.message), t.supportedResult = $b(s, []) } return t } isAudioSupported(e) { return Za(e, "audio", this.hls.config.preferManagedMediaSource) } isVideoSupported(e) { return Za(e, "video", this.hls.config.preferManagedMediaSource) } filterAndSortMediaOptions(e, t, r, s, i) { var a; let o = [], c = [], u = e; const f = ((a = t.stats) == null ? void 0 : a.parsing) || {}; if ((r || s) && i && (u = u.filter(({ videoCodec: S, videoRange: E, width: I, height: C }) => (!!S || !!(I && C)) && x_(E))), u.length === 0) { Promise.resolve().then(() => { if (this.hls) { let S = "no level with compatible codecs found in manifest", E = S; t.levels.length && (E = `one or more CODECS in variant not supported: ${it(t.levels.map(C => C.attrs.CODECS).filter((C, D, R) => R.indexOf(C) === D))}`, this.warn(E), S += ` (${E})`); const I = new Error(S); this.hls.trigger(k.ERROR, { type: Ee.MEDIA_ERROR, details: J.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: t.url, error: I, reason: E }) } }), f.end = performance.now(); return } t.audioTracks && (o = t.audioTracks.filter(S => !S.audioCodec || this.isAudioSupported(S.audioCodec)), fy(o)), t.subtitles && (c = t.subtitles, fy(c)); const h = u.slice(0); u.sort((S, E) => { if (S.attrs["HDCP-LEVEL"] !== E.attrs["HDCP-LEVEL"]) return (S.attrs["HDCP-LEVEL"] || "") > (E.attrs["HDCP-LEVEL"] || "") ? 1 : -1; if (r && S.height !== E.height) return S.height - E.height; if (S.frameRate !== E.frameRate) return S.frameRate - E.frameRate; if (S.videoRange !== E.videoRange) return Tc.indexOf(S.videoRange) - Tc.indexOf(E.videoRange); if (S.videoCodec !== E.videoCodec) { const I = iv(S.videoCodec), C = iv(E.videoCodec); if (I !== C) return C - I } if (S.uri === E.uri && S.codecSet !== E.codecSet) { const I = Sc(S.codecSet), C = Sc(E.codecSet); if (I !== C) return C - I } return S.averageBitrate !== E.averageBitrate ? S.averageBitrate - E.averageBitrate : 0 }); let p = h[0]; if (this.steering && (u = this.steering.filterParsedLevels(u), u.length !== h.length)) { for (let S = 0; S < h.length; S++)if (h[S].pathwayId === u[0].pathwayId) { p = h[S]; break } } this._levels = u; for (let S = 0; S < u.length; S++)if (u[S] === p) { var v; this._firstLevel = S; const E = p.bitrate, I = this.hls.bandwidthEstimate; if (this.log(`manifest loaded, ${u.length} level(s) found, first bitrate: ${E}`), ((v = this.hls.userConfig) == null ? void 0 : v.abrEwmaDefaultEstimate) === void 0) { const C = Math.min(E, this.hls.config.abrEwmaDefaultEstimateMax); C > I && I === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = C) } break } const g = i && !s, y = this.hls.config, w = !!(y.audioStreamController && y.audioTrackController), T = { levels: u, audioTracks: o, subtitleTracks: c, sessionData: t.sessionData, sessionKeys: t.sessionKeys, firstLevel: this._firstLevel, stats: t.stats, audio: i, video: s, altAudio: w && !g && o.some(S => !!S.url) }; f.end = performance.now(), this.hls.trigger(k.MANIFEST_PARSED, T) } get levels() { return this._levels.length === 0 ? null : this._levels } get loadLevelObj() { return this.currentLevel } get level() { return this.currentLevelIndex } set level(e) { const t = this._levels; if (t.length === 0) return; if (e < 0 || e >= t.length) { const f = new Error("invalid level idx"), h = e < 0; if (this.hls.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.LEVEL_SWITCH_ERROR, level: e, fatal: h, error: f, reason: f.message }), h) return; e = Math.min(e, t.length - 1) } const r = this.currentLevelIndex, s = this.currentLevel, i = s ? s.attrs["PATHWAY-ID"] : void 0, a = t[e], o = a.attrs["PATHWAY-ID"]; if (this.currentLevelIndex = e, this.currentLevel = a, r === e && s && i === o) return; this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${o ? " with Pathway " + o : ""} from level ${r}${i ? " with Pathway " + i : ""}`); const c = { level: e, attrs: a.attrs, details: a.details, bitrate: a.bitrate, averageBitrate: a.averageBitrate, maxBitrate: a.maxBitrate, realBitrate: a.realBitrate, width: a.width, height: a.height, codecSet: a.codecSet, audioCodec: a.audioCodec, videoCodec: a.videoCodec, audioGroups: a.audioGroups, subtitleGroups: a.subtitleGroups, loaded: a.loaded, loadError: a.loadError, fragmentError: a.fragmentError, name: a.name, id: a.id, uri: a.uri, url: a.url, urlId: 0, audioGroupIds: a.audioGroupIds, textGroupIds: a.textGroupIds }; this.hls.trigger(k.LEVEL_SWITCHING, c); const u = a.details; if (!u || u.live) { const f = this.switchParams(a.uri, s?.details, u); this.loadPlaylist(f) } } get manualLevel() { return this.manualLevelIndex } set manualLevel(e) { this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e) } get firstLevel() { return this._firstLevel } set firstLevel(e) { this._firstLevel = e } get startLevel() { if (this._startLevel === void 0) { const e = this.hls.config.startLevel; return e !== void 0 ? e : this.hls.firstAutoLevel } return this._startLevel } set startLevel(e) { this._startLevel = e } get pathways() { return this.steering ? this.steering.pathways() : [] } get pathwayPriority() { return this.steering ? this.steering.pathwayPriority : null } set pathwayPriority(e) { if (this.steering) { const t = this.steering.pathways(), r = e.filter(s => t.indexOf(s) !== -1); if (e.length < 1) { this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${t}`); return } this.steering.pathwayPriority = r } } onError(e, t) { t.fatal || !t.context || t.context.type === He.LEVEL && t.context.level === this.level && this.checkRetry(t) } onFragBuffered(e, { frag: t }) { if (t !== void 0 && t.type === ve.MAIN) { const r = t.elementaryStreams; if (!Object.keys(r).some(i => !!r[i])) return; const s = this._levels[t.level]; s != null && s.loadError && (this.log(`Resetting level error count of ${s.loadError} on frag buffered`), s.loadError = 0) } } onLevelLoaded(e, t) { var r; const { level: s, details: i } = t, a = t.levelInfo; if (!a) { var o; this.warn(`Invalid level index ${s}`), (o = t.deliveryDirectives) != null && o.skip && (i.deltaUpdateFailed = !0); return } if (a === this.currentLevel || t.withoutMultiVariant) { a.fragmentError === 0 && (a.loadError = 0); let c = a.details; c === t.details && c.advanced && (c = void 0), this.playlistLoaded(s, t, c) } else (r = t.deliveryDirectives) != null && r.skip && (i.deltaUpdateFailed = !0) } loadPlaylist(e) { super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e) } loadingPlaylist(e, t) { super.loadingPlaylist(e, t); const r = this.getUrlWithDirectives(e.uri, t), s = this.currentLevelIndex, i = e.attrs["PATHWAY-ID"], a = e.details, o = a?.age; this.log(`Loading level index ${s}${t?.msn !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${i ? " Pathway " + i : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${r}`), this.hls.trigger(k.LEVEL_LOADING, { url: r, level: s, levelInfo: e, pathwayId: e.attrs["PATHWAY-ID"], id: 0, deliveryDirectives: t || null }) } get nextLoadLevel() { return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel } set nextLoadLevel(e) { this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e) } removeLevel(e) { var t; if (this._levels.length === 1) return; const r = this._levels.filter((i, a) => a !== e ? !0 : (this.steering && this.steering.removeLevel(i), i === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, i.details && i.details.fragments.forEach(o => o.level = -1)), !1)); sw(r), this._levels = r, this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex); const s = r.length - 1; this._firstLevel = Math.min(this._firstLevel, s), this._startLevel && (this._startLevel = Math.min(this._startLevel, s)), this.hls.trigger(k.LEVELS_UPDATED, { levels: r }) } onLevelsUpdated(e, { levels: t }) { this._levels = t } checkMaxAutoUpdated() { const { autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: r } = this.hls; this._maxAutoLevel !== t && (this._maxAutoLevel = t, this.hls.trigger(k.MAX_AUTO_LEVEL_UPDATED, { autoLevelCapping: e, levels: this.levels, maxAutoLevel: t, minAutoLevel: this.hls.minAutoLevel, maxHdcpLevel: r })) } } function fy(n) { const e = {}; n.forEach(t => { const r = t.groupId || ""; t.id = e[r] = e[r] || 0, e[r]++ }) } function Jw() { return self.SourceBuffer || self.WebKitSourceBuffer } function eS() { if (!bs()) return !1; const e = Jw(); return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function" } function LD() { if (!eS()) return !1; const n = bs(); return typeof n?.isTypeSupported == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(e => n.isTypeSupported(Ja(e, "video"))) || ["mp4a.40.2", "fLaC"].some(e => n.isTypeSupported(Ja(e, "audio")))) } function CD() { var n; const e = Jw(); return typeof (e == null || (n = e.prototype) == null ? void 0 : n.changeType) == "function" } const kD = 100; class RD extends Sp { constructor(e, t, r) { super(e, t, r, "stream-controller", ve.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () => { this.tick() }, this.onMediaSeeked = () => { const s = this.media, i = s ? s.currentTime : null; if (i === null || !ge(i) || (this.log(`Media seeked to ${i.toFixed(3)}`), !this.getBufferedFrag(i))) return; const a = this.getFwdBufferInfoAtPos(s, i, ve.MAIN, 0); if (a === null || a.len === 0) { this.warn(`Main forward buffer length at ${i} on "seeked" event ${a ? a.len : "empty"})`); return } this.tick() }, this.registerListeners() } registerListeners() { super.registerListeners(); const { hls: e } = this; e.on(k.MANIFEST_PARSED, this.onManifestParsed, this), e.on(k.LEVEL_LOADING, this.onLevelLoading, this), e.on(k.LEVEL_LOADED, this.onLevelLoaded, this), e.on(k.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(k.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(k.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(k.BUFFER_CREATED, this.onBufferCreated, this), e.on(k.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(k.FRAG_BUFFERED, this.onFragBuffered, this) } unregisterListeners() { super.unregisterListeners(); const { hls: e } = this; e.off(k.MANIFEST_PARSED, this.onManifestParsed, this), e.off(k.LEVEL_LOADED, this.onLevelLoaded, this), e.off(k.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(k.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(k.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(k.BUFFER_CREATED, this.onBufferCreated, this), e.off(k.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(k.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(k.FRAG_BUFFERED, this.onFragBuffered, this) } onHandlerDestroying() { this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying() } startLoad(e, t) { if (this.levels) { const { lastCurrentTime: r, hls: s } = this; if (this.stopLoad(), this.setInterval(kD), this.level = -1, !this.startFragRequested) { let i = s.startLevel; i === -1 && (s.config.testBandwidth && this.levels.length > 1 ? (i = 0, this.bitrateTest = !0) : i = s.firstAutoLevel), s.nextLoadLevel = i, this.level = s.loadLevel, this._hasEnoughToStart = !!t } r > 0 && e === -1 && !t && (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r), this.state = se.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick() } else this._forceStartLoad = !0, this.state = se.STOPPED } stopLoad() { this._forceStartLoad = !1, super.stopLoad() } doTick() { switch (this.state) { case se.WAITING_LEVEL: { const { levels: e, level: t } = this, r = e?.[t], s = r?.details; if (s && (!s.live || this.levelLastLoaded === r && !this.waitForLive(r))) { if (this.waitForCdnTuneIn(s)) break; this.state = se.IDLE; break } else if (this.hls.nextLoadLevel !== this.level) { this.state = se.IDLE; break } break } case se.FRAG_LOADING_WAITING_RETRY: this.checkRetryDate(); break }this.state === se.IDLE && this.doTickIdle(), this.onTickEnd() } onTickEnd() { var e; super.onTickEnd(), (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged() } doTickIdle() { const { hls: e, levelLastLoaded: t, levels: r, media: s } = this; if (t === null || !s && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly) return; const i = this.buffering ? e.nextLoadLevel : e.loadLevel; if (!(r != null && r[i])) return; const a = r[i], o = this.getMainFwdBufferInfo(); if (o === null) return; const c = this.getLevelDetails(); if (c && this._streamEnded(o, c)) { const y = {}; this.altAudio === 2 && (y.type = "video"), this.hls.trigger(k.BUFFER_EOS, y), this.state = se.ENDED; return } if (!this.buffering) return; e.loadLevel !== i && e.manualLevel === -1 && this.log(`Adapting to level ${i} from level ${this.level}`), this.level = e.nextLoadLevel = i; const u = a.details; if (!u || this.state === se.WAITING_LEVEL || this.waitForLive(a)) { this.level = i, this.state = se.WAITING_LEVEL, this.startFragRequested = !1; return } const f = o.len, h = this.getMaxBufferLength(a.maxBitrate); if (f >= h) return; this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null); const p = this.backtrackFragment ? this.backtrackFragment.start : o.end; let v = this.getNextFragment(p, u); if (this.couldBacktrack && !this.fragPrevious && v && At(v) && this.fragmentTracker.getState(v) !== Rt.OK) { var g; const w = ((g = this.backtrackFragment) != null ? g : v).sn - u.startSN, T = u.fragments[w - 1]; T && v.cc === T.cc && (v = T, this.fragmentTracker.removeFragment(T)) } else this.backtrackFragment && o.len && (this.backtrackFragment = null); if (v && this.isLoopLoading(v, p)) { if (!v.gap) { const w = this.audioOnly && !this.altAudio ? st.AUDIO : st.VIDEO, T = (w === st.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; T && this.afterBufferFlushed(T, w, ve.MAIN) } v = this.getNextFragmentLoopLoading(v, u, o, ve.MAIN, h) } v && (v.initSegment && !v.initSegment.data && !this.bitrateTest && (v = v.initSegment), this.loadFragment(v, a, p)) } loadFragment(e, t, r) { const s = this.fragmentTracker.getState(e); s === Rt.NOT_LOADED || s === Rt.PARTIAL ? At(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : super.loadFragment(e, t, r) : this._loadInitSegment(e, t) : this.clearTrackerIfNeeded(e) } getBufferedFrag(e) { return this.fragmentTracker.getBufferedFrag(e, ve.MAIN) } followingBufferedFrag(e) { return e ? this.getBufferedFrag(e.end + .5) : null } immediateLevelSwitch() { this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY) } nextLevelSwitch() { const { levels: e, media: t } = this; if (t != null && t.readyState) { let r; const s = this.getAppendedFrag(t.currentTime); s && s.start > 1 && this.flushMainBuffer(0, s.start - 1); const i = this.getLevelDetails(); if (i != null && i.live) { const o = this.getMainFwdBufferInfo(); if (!o || o.len < i.targetduration * 2) return } if (!t.paused && e) { const o = this.hls.nextLoadLevel, c = e[o], u = this.fragLastKbps; u && this.fragCurrent ? r = this.fragCurrent.duration * c.maxBitrate / (1e3 * u) + 1 : r = 0 } else r = 0; const a = this.getBufferedFrag(t.currentTime + r); if (a) { const o = this.followingBufferedFrag(a); if (o) { this.abortCurrentFrag(); const c = o.maxStartPTS ? o.maxStartPTS : o.start, u = o.duration, f = Math.max(a.end, c + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, u * (this.couldBacktrack ? .5 : .125)), u * (this.couldBacktrack ? .75 : .25))); this.flushMainBuffer(f, Number.POSITIVE_INFINITY) } } } } abortCurrentFrag() { const e = this.fragCurrent; switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) { case se.KEY_LOADING: case se.FRAG_LOADING: case se.FRAG_LOADING_WAITING_RETRY: case se.PARSING: case se.PARSED: this.state = se.IDLE; break }this.nextLoadPosition = this.getLoadPosition() } flushMainBuffer(e, t) { super.flushMainBuffer(e, t, this.altAudio === 2 ? "video" : null) } onMediaAttached(e, t) { super.onMediaAttached(e, t); const r = t.media; Yt(r, "playing", this.onMediaPlaying), Yt(r, "seeked", this.onMediaSeeked) } onMediaDetaching(e, t) { const { media: r } = this; r && (lr(r, "playing", this.onMediaPlaying), lr(r, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, t), !t.transferMedia && (this._hasEnoughToStart = !1) } onManifestLoading() { super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(k.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1 } onManifestParsed(e, t) { let r = !1, s = !1; for (let i = 0; i < t.levels.length; i++) { const a = t.levels[i].audioCodec; a && (r = r || a.indexOf("mp4a.40.2") !== -1, s = s || a.indexOf("mp4a.40.5") !== -1) } this.audioCodecSwitch = r && s && !CD(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1 } onLevelLoading(e, t) { const { levels: r } = this; if (!r || this.state !== se.IDLE) return; const s = t.levelInfo; (!s.details || s.details.live && (this.levelLastLoaded !== s || s.details.expired) || this.waitForCdnTuneIn(s.details)) && (this.state = se.WAITING_LEVEL) } onLevelLoaded(e, t) { var r; const { levels: s, startFragRequested: i } = this, a = t.level, o = t.details, c = o.totalduration; if (!s) { this.warn(`Levels were reset while loading level ${a}`); return } this.log(`Level ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${c}`); const u = t.levelInfo, f = this.fragCurrent; f && (this.state === se.FRAG_LOADING || this.state === se.FRAG_LOADING_WAITING_RETRY) && f.level !== t.level && f.loader && this.abortCurrentFrag(); let h = 0; if (o.live || (r = u.details) != null && r.live) { var p; if (this.checkLiveUpdate(o), o.deltaUpdateFailed) return; h = this.alignPlaylists(o, u.details, (p = this.levelLastLoaded) == null ? void 0 : p.details) } if (u.details = o, this.levelLastLoaded = u, i || this.setStartPosition(o, h), this.hls.trigger(k.LEVEL_UPDATED, { details: o, level: a }), this.state === se.WAITING_LEVEL) { if (this.waitForCdnTuneIn(o)) return; this.state = se.IDLE } i && o.live && this.synchronizeToLiveEdge(o), this.tick() } synchronizeToLiveEdge(e) { const { config: t, media: r } = this; if (!r) return; const s = this.hls.liveSyncPosition, i = this.getLoadPosition(), a = e.fragmentStart, o = e.edge, c = i >= a - t.maxFragLookUpTolerance && i <= o; if (s !== null && r.duration > s && (i < s || !c)) { const f = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration; if ((!c && r.readyState < 4 || i < o - f) && (this._hasEnoughToStart || (this.nextLoadPosition = s), r.readyState)) if (this.warn(`Playback: ${i.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${s.toFixed(3)}`), this.config.liveSyncMode === "buffered") { var u; const h = Me.bufferInfo(r, s, 0); if (!((u = h.buffered) != null && u.length)) { r.currentTime = s; return } if (h.start <= i) { r.currentTime = s; return } const { nextStart: v } = Me.bufferedInfo(h.buffered, i, 0); v && (r.currentTime = v) } else r.currentTime = s } } _handleFragmentLoadProgress(e) { var t; const r = e.frag, { part: s, payload: i } = e, { levels: a } = this; if (!a) { this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`); return } const o = a[r.level]; if (!o) { this.warn(`Level ${r.level} not found on progress`); return } const c = o.details; if (!c) { this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r); return } const u = o.videoCodec, f = c.PTSKnown || !c.live, h = (t = r.initSegment) == null ? void 0 : t.data, p = this._getAudioCodec(o), v = this.transmuxer = this.transmuxer || new Iw(this.hls, ve.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), g = s ? s.index : -1, y = g !== -1, w = new vp(r.level, r.sn, r.stats.chunkCount, i.byteLength, g, y), T = this.initPTS[r.cc]; v.push(i, h, p, u, r, s, c.totalduration, f, w, T) } onAudioTrackSwitching(e, t) { const r = this.hls, s = this.altAudio === 2; if (Ac(t.url, r)) this.altAudio = 1; else { if (this.mediaBuffer !== this.media) { this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media; const a = this.fragCurrent; a && (this.log("Switching to main audio track, cancel main fragment load"), a.abortRequests(), this.fragmentTracker.removeFragment(a)), this.resetTransmuxer(), this.resetLoadingState() } else this.audioOnly && this.resetTransmuxer(); if (s) { this.fragmentTracker.removeAllFragments(), r.once(k.BUFFER_FLUSHED, () => { this.hls && this.hls.trigger(k.AUDIO_TRACK_SWITCHED, t) }), r.trigger(k.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: null }); return } r.trigger(k.AUDIO_TRACK_SWITCHED, t) } } onAudioTrackSwitched(e, t) { const r = Ac(t.url, this.hls); if (r) { const s = this.videoBuffer; s && this.mediaBuffer !== s && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = s) } this.altAudio = r ? 2 : 0, this.tick() } onBufferCreated(e, t) { const r = t.tracks; let s, i, a = !1; for (const o in r) { const c = r[o]; if (c.id === "main") { if (i = o, s = c, o === "video") { const u = r[o]; u && (this.videoBuffer = u.buffer) } } else a = !0 } a && s ? (this.log(`Alternate track found, use ${i}.buffered to schedule main fragment loading`), this.mediaBuffer = s.buffer) : this.mediaBuffer = this.media } onFragBuffered(e, t) { const { frag: r, part: s } = t, i = r.type === ve.MAIN; if (i) { if (this.fragContextChanged(r)) { this.warn(`Fragment ${r.sn}${s ? " p: " + s.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === se.PARSED && (this.state = se.IDLE); return } const o = s ? s.stats : r.stats; this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)), At(r) && (this.fragPrevious = r), this.fragBufferedComplete(r, s) } const a = this.media; a && (!this._hasEnoughToStart && Me.getBuffered(a).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), i && this.tick()) } get hasEnoughToStart() { return this._hasEnoughToStart } onError(e, t) { var r; if (t.fatal) { this.state = se.ERROR; return } switch (t.details) { case J.FRAG_GAP: case J.FRAG_PARSING_ERROR: case J.FRAG_DECRYPT_ERROR: case J.FRAG_LOAD_ERROR: case J.FRAG_LOAD_TIMEOUT: case J.KEY_LOAD_ERROR: case J.KEY_LOAD_TIMEOUT: this.onFragmentOrKeyLoadError(ve.MAIN, t); break; case J.LEVEL_LOAD_ERROR: case J.LEVEL_LOAD_TIMEOUT: case J.LEVEL_PARSING_ERROR: !t.levelRetry && this.state === se.WAITING_LEVEL && ((r = t.context) == null ? void 0 : r.type) === He.LEVEL && (this.state = se.IDLE); break; case J.BUFFER_ADD_CODEC_ERROR: case J.BUFFER_APPEND_ERROR: if (t.parent !== "main") return; this.reduceLengthAndFlushBuffer(t) && this.resetLoadingState(); break; case J.BUFFER_FULL_ERROR: if (t.parent !== "main") return; this.reduceLengthAndFlushBuffer(t) && (!this.config.interstitialsController && this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY)); break; case J.INTERNAL_EXCEPTION: this.recoverWorkerError(t); break } } onFragLoadEmergencyAborted() { this.state = se.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate() } onBufferFlushed(e, { type: t }) { if (t !== st.AUDIO || !this.altAudio) { const r = (t === st.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media; r && (this.afterBufferFlushed(r, t, ve.MAIN), this.tick()) } } onLevelsUpdated(e, t) { this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)), this.levels = t.levels } swapAudioCodec() { this.audioCodecSwap = !this.audioCodecSwap } seekToStartPos() { const { media: e } = this; if (!e) return; const t = e.currentTime; let r = this.startPosition; if (r >= 0 && t < r) { if (e.seeking) { this.log(`could not seek to ${r}, already seeking at ${t}`); return } const s = this.timelineOffset; s && r && (r += s); const i = this.getLevelDetails(), a = Me.getBuffered(e), o = a.length ? a.start(0) : 0, c = o - r, u = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance); (this.config.startOnSegmentBoundary || c > 0 && (c < u || this.loadingParts && c < 2 * (i?.partTarget || 0))) && (this.log(`adjusting start position by ${c} to match buffer start`), r += c, this.startPosition = r), t < r && (this.log(`seek to target start position ${r} from current time ${t} buffer start ${o}`), e.currentTime = r) } } _getAudioCodec(e) { let t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"), t } _loadBitrateTestFrag(e, t) { e.bitrateTest = !0, this._doFragLoad(e, t).then(r => { const { hls: s } = this, i = r?.frag; if (!i || this.fragContextChanged(i)) return; t.fragmentError = 0, this.state = se.IDLE, this.startFragRequested = !1, this.bitrateTest = !1; const a = i.stats; a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), s.trigger(k.FRAG_LOADED, r), i.bitrateTest = !1 }).catch(r => { this.state === se.STOPPED || this.state === se.ERROR || (this.warn(r), this.resetFragmentLoading(e)) }) } _handleTransmuxComplete(e) { const t = this.playlistType, { hls: r } = this, { remuxResult: s, chunkMeta: i } = e, a = this.getCurrentContext(i); if (!a) { this.resetWhenMissingContext(i); return } const { frag: o, part: c, level: u } = a, { video: f, text: h, id3: p, initSegment: v } = s, { details: g } = u, y = this.altAudio ? void 0 : s.audio; if (this.fragContextChanged(o)) { this.fragmentTracker.removeFragment(o); return } if (this.state = se.PARSING, v) { const w = v.tracks; if (w) { const I = o.initSegment || o; if (this.unhandledEncryptionError(v, o)) return; this._bufferInitSegment(u, w, I, i), r.trigger(k.FRAG_PARSING_INIT_SEGMENT, { frag: I, id: t, tracks: w }) } const T = v.initPTS, S = v.timescale, E = this.initPTS[o.cc]; if (ge(T) && (!E || E.baseTime !== T || E.timescale !== S)) { const I = v.trackId; this.initPTS[o.cc] = { baseTime: T, timescale: S, trackId: I }, r.trigger(k.INIT_PTS_FOUND, { frag: o, id: t, initPTS: T, timescale: S, trackId: I }) } } if (f && g) { y && f.type === "audiovideo" && this.logMuxedErr(o); const w = g.fragments[o.sn - 1 - g.startSN], T = o.sn === g.startSN, S = !w || o.cc > w.cc; if (s.independent !== !1) { const { startPTS: E, endPTS: I, startDTS: C, endDTS: D } = f; if (c) c.elementaryStreams[f.type] = { startPTS: E, endPTS: I, startDTS: C, endDTS: D }; else if (f.firstKeyFrame && f.independent && i.id === 1 && !S && (this.couldBacktrack = !0), f.dropped && f.independent) { const R = this.getMainFwdBufferInfo(), N = (R ? R.end : this.getLoadPosition()) + this.config.maxBufferHole, P = f.firstKeyFramePTS ? f.firstKeyFramePTS : E; if (!T && N < P - this.config.maxBufferHole && !S) { this.backtrack(o); return } else S && (o.gap = !0); o.setElementaryStreamInfo(f.type, o.start, I, o.start, D, !0) } else T && E - (g.appliedTimelineOffset || 0) > oc && (o.gap = !0); o.setElementaryStreamInfo(f.type, E, I, C, D), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(f, o, c, i, T || S) } else if (T || S) o.gap = !0; else { this.backtrack(o); return } } if (y) { const { startPTS: w, endPTS: T, startDTS: S, endDTS: E } = y; c && (c.elementaryStreams[st.AUDIO] = { startPTS: w, endPTS: T, startDTS: S, endDTS: E }), o.setElementaryStreamInfo(st.AUDIO, w, T, S, E), this.bufferFragmentData(y, o, c, i) } if (g && p != null && p.samples.length) { const w = { id: t, frag: o, details: g, samples: p.samples }; r.trigger(k.FRAG_PARSING_METADATA, w) } if (g && h) { const w = { id: t, frag: o, details: g, samples: h.samples }; r.trigger(k.FRAG_PARSING_USERDATA, w) } } logMuxedErr(e) { this.warn(`${At(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`) } _bufferInitSegment(e, t, r, s) { if (this.state !== se.PARSING) return; this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && (delete t.audio, t.audiovideo && this.logMuxedErr(r)); const { audio: i, video: a, audiovideo: o } = t; if (i) { const u = e.audioCodec; let f = ec(i.codec, u); f === "mp4a" && (f = "mp4a.40.5"); const h = navigator.userAgent.toLowerCase(); if (this.audioCodecSwitch) { f && (f.indexOf("mp4a.40.5") !== -1 ? f = "mp4a.40.2" : f = "mp4a.40.5"); const p = i.metadata; p && "channelCount" in p && (p.channelCount || 1) !== 1 && h.indexOf("firefox") === -1 && (f = "mp4a.40.5") } f && f.indexOf("mp4a.40.5") !== -1 && h.indexOf("android") !== -1 && i.container !== "audio/mpeg" && (f = "mp4a.40.2", this.log(`Android: force audio codec to ${f}`)), u && u !== f && this.log(`Swapping manifest audio codec "${u}" for "${f}"`), i.levelCodec = f, i.id = ve.MAIN, this.log(`Init audio buffer, container:${i.container}, codecs[selected/level/parsed]=[${f || ""}/${u || ""}/${i.codec}]`), delete t.audiovideo } if (a) { a.levelCodec = e.videoCodec, a.id = ve.MAIN; const u = a.codec; if (u?.length === 4) switch (u) { case "hvc1": case "hev1": a.codec = "hvc1.1.6.L120.90"; break; case "av01": a.codec = "av01.0.04M.08"; break; case "avc1": a.codec = "avc1.42e01e"; break }this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${u}]${a.codec !== u ? " parsed-corrected=" + a.codec : ""}${a.supplemental ? " supplemental=" + a.supplemental : ""}`), delete t.audiovideo } o && (this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`), delete t.video, delete t.audio); const c = Object.keys(t); if (c.length) { if (this.hls.trigger(k.BUFFER_CODECS, t), !this.hls) return; c.forEach(u => { const h = t[u].initSegment; h != null && h.byteLength && this.hls.trigger(k.BUFFER_APPENDING, { type: u, data: h, frag: r, part: null, chunkMeta: s, parent: r.type }) }) } this.tickImmediate() } getMainFwdBufferInfo() { const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media; return this.getFwdBufferInfo(e, ve.MAIN) } get maxBufferLength() { const { levels: e, level: t } = this, r = e?.[t]; return r ? this.getMaxBufferLength(r.maxBitrate) : this.config.maxBufferLength } backtrack(e) { this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = se.IDLE } checkFragmentChanged() { const e = this.media; let t = null; if (e && e.readyState > 1 && e.seeking === !1) { const r = e.currentTime; if (Me.isBuffered(e, r) ? t = this.getAppendedFrag(r) : Me.isBuffered(e, r + .1) && (t = this.getAppendedFrag(r + .1)), t) { this.backtrackFragment = null; const s = this.fragPlaying, i = t.level; (!s || t.sn !== s.sn || s.level !== i) && (this.fragPlaying = t, this.hls.trigger(k.FRAG_CHANGED, { frag: t }), (!s || s.level !== i) && this.hls.trigger(k.LEVEL_SWITCHED, { level: i })) } } } get nextLevel() { const e = this.nextBufferedFrag; return e ? e.level : -1 } get currentFrag() { var e; if (this.fragPlaying) return this.fragPlaying; const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime; return ge(t) ? this.getAppendedFrag(t) : null } get currentProgramDateTime() { var e; const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime; if (ge(t)) { const r = this.getLevelDetails(), s = this.currentFrag || (r ? Xs(null, r.fragments, t) : null); if (s) { const i = s.programDateTime; if (i !== null) { const a = i + (t - s.start) * 1e3; return new Date(a) } } } return null } get currentLevel() { const e = this.currentFrag; return e ? e.level : -1 } get nextBufferedFrag() { const e = this.currentFrag; return e ? this.followingBufferedFrag(e) : null } get forceStartLoad() { return this._forceStartLoad } } class _D extends Pr { constructor(e, t) { super("key-loader", t), this.config = void 0, this.keyIdToKeyInfo = {}, this.emeController = null, this.config = e } abort(e) { for (const r in this.keyIdToKeyInfo) { const s = this.keyIdToKeyInfo[r].loader; if (s) { var t; if (e && e !== ((t = s.context) == null ? void 0 : t.frag.type)) return; s.abort() } } } detach() { for (const e in this.keyIdToKeyInfo) { const t = this.keyIdToKeyInfo[e]; (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyIdToKeyInfo[e] } } destroy() { this.detach(); for (const e in this.keyIdToKeyInfo) { const t = this.keyIdToKeyInfo[e].loader; t && t.destroy() } this.keyIdToKeyInfo = {} } createKeyLoadError(e, t = J.KEY_LOAD_ERROR, r, s, i) { return new Cn({ type: Ee.NETWORK_ERROR, details: t, fatal: !1, frag: e, response: i, error: r, networkDetails: s }) } loadClear(e, t, r) { if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) { if (t.length) for (let s = 0, i = t.length; s < i; s++) { const a = t[s]; if (e.cc <= a.cc && (!At(e) || !At(a) || e.sn < a.sn) || !r && s == i - 1) return this.emeController.selectKeySystemFormat(a).then(o => { if (!this.emeController) return; a.setKeyFormat(o); const c = rc(o); if (c) return this.emeController.getKeySystemAccess([c]) }) } if (this.config.requireKeySystemAccessOnStart) { const s = $a(this.config); if (s.length) return this.emeController.getKeySystemAccess(s) } } return null } load(e) { return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then(t => this.loadInternal(e, t)) : this.loadInternal(e) } loadInternal(e, t) { var r, s; t && e.setKeyFormat(t); const i = e.decryptdata; if (!i) { const u = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController && this.config.emeEnabled})`); return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, u)) } const a = i.uri; if (!a) return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`))); const o = Pf(i); let c = this.keyIdToKeyInfo[o]; if ((r = c) != null && r.decryptdata.key) return i.key = c.decryptdata.key, Promise.resolve({ frag: e, keyInfo: c }); if (this.emeController && (s = c) != null && s.keyLoadPromise) switch (this.emeController.getKeyStatus(c.decryptdata)) { case "usable": case "usable-in-future": return c.keyLoadPromise.then(f => { const { keyInfo: h } = f; return i.key = h.decryptdata.key, { frag: e, keyInfo: h } }) }switch (this.log(`${this.keyIdToKeyInfo[o] ? "Rel" : "L"}oading${i.keyId ? " keyId: " + or(i.keyId) : ""} URI: ${i.uri} from ${e.type} ${e.level}`), c = this.keyIdToKeyInfo[o] = { decryptdata: i, keyLoadPromise: null, loader: null, mediaKeySessionContext: null }, i.method) { case "SAMPLE-AES": case "SAMPLE-AES-CENC": case "SAMPLE-AES-CTR": return i.keyFormat === "identity" ? this.loadKeyHTTP(c, e) : this.loadKeyEME(c, e); case "AES-128": case "AES-256": case "AES-256-CTR": return this.loadKeyHTTP(c, e); default: return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${i.method}"`))) } } loadKeyEME(e, t) { const r = { frag: t, keyInfo: e }; if (this.emeController && this.config.emeEnabled) { const s = this.emeController.loadKey(r); return (e.keyLoadPromise = s.then(i => (e.mediaKeySessionContext = i, r))).catch(i => { throw e.keyLoadPromise = null, "data" in i && (i.data.frag = t), i }) } return Promise.resolve(r) } loadKeyHTTP(e, t) { const r = this.config, s = r.loader, i = new s(r); return t.keyLoader = e.loader = i, e.keyLoadPromise = new Promise((a, o) => { const c = { keyInfo: e, frag: t, responseType: "arraybuffer", url: e.decryptdata.uri }, u = r.keyLoadPolicy.default, f = { loadPolicy: u, timeout: u.maxLoadTimeMs, maxRetry: 0, retryDelay: 0, maxRetryDelay: 0 }, h = { onSuccess: (p, v, g, y) => { const { frag: w, keyInfo: T } = g, S = Pf(T.decryptdata); if (!w.decryptdata || T !== this.keyIdToKeyInfo[S]) return o(this.createKeyLoadError(w, J.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), y)); T.decryptdata.key = w.decryptdata.key = new Uint8Array(p.data), w.keyLoader = null, T.loader = null, a({ frag: w, keyInfo: T }) }, onError: (p, v, g, y) => { this.resetLoader(v), o(this.createKeyLoadError(t, J.KEY_LOAD_ERROR, new Error(`HTTP Error ${p.code} loading key ${p.text}`), g, et({ url: c.url, data: void 0 }, p))) }, onTimeout: (p, v, g) => { this.resetLoader(v), o(this.createKeyLoadError(t, J.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), g)) }, onAbort: (p, v, g) => { this.resetLoader(v), o(this.createKeyLoadError(t, J.INTERNAL_ABORTED, new Error("key loading aborted"), g)) } }; i.load(c, f, h) }) } resetLoader(e) { const { frag: t, keyInfo: r, url: s } = e, i = r.loader; t.keyLoader === i && (t.keyLoader = null, r.loader = null); const a = Pf(r.decryptdata) || s; delete this.keyIdToKeyInfo[a], i && i.destroy() } } function Pf(n) { if (n.keyFormat !== qt.FAIRPLAY) { const e = n.keyId; if (e) return or(e) } return n.uri } function hy(n) { const { type: e } = n; switch (e) { case He.AUDIO_TRACK: return ve.AUDIO; case He.SUBTITLE_TRACK: return ve.SUBTITLE; default: return ve.MAIN } } function Nf(n, e) { let t = n.url; return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url), t } class PD { constructor(e) { this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners() } startLoad(e) { } stopLoad() { this.destroyInternalLoaders() } registerListeners() { const { hls: e } = this; e.on(k.MANIFEST_LOADING, this.onManifestLoading, this), e.on(k.LEVEL_LOADING, this.onLevelLoading, this), e.on(k.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(k.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(k.LEVELS_UPDATED, this.onLevelsUpdated, this) } unregisterListeners() { const { hls: e } = this; e.off(k.MANIFEST_LOADING, this.onManifestLoading, this), e.off(k.LEVEL_LOADING, this.onLevelLoading, this), e.off(k.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(k.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(k.LEVELS_UPDATED, this.onLevelsUpdated, this) } createInternalLoader(e) { const t = this.hls.config, r = t.pLoader, s = t.loader, i = r || s, a = new i(t); return this.loaders[e.type] = a, a } getInternalLoader(e) { return this.loaders[e.type] } resetInternalLoader(e) { this.loaders[e] && delete this.loaders[e] } destroyInternalLoaders() { for (const e in this.loaders) { const t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e) } } destroy() { this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders() } onManifestLoading(e, t) { const { url: r } = t; this.variableList = null, this.load({ id: null, level: 0, responseType: "text", type: He.MANIFEST, url: r, deliveryDirectives: null, levelOrTrack: null }) } onLevelLoading(e, t) { const { id: r, level: s, pathwayId: i, url: a, deliveryDirectives: o, levelInfo: c } = t; this.load({ id: r, level: s, pathwayId: i, responseType: "text", type: He.LEVEL, url: a, deliveryDirectives: o, levelOrTrack: c }) } onAudioTrackLoading(e, t) { const { id: r, groupId: s, url: i, deliveryDirectives: a, track: o } = t; this.load({ id: r, groupId: s, level: null, responseType: "text", type: He.AUDIO_TRACK, url: i, deliveryDirectives: a, levelOrTrack: o }) } onSubtitleTrackLoading(e, t) { const { id: r, groupId: s, url: i, deliveryDirectives: a, track: o } = t; this.load({ id: r, groupId: s, level: null, responseType: "text", type: He.SUBTITLE_TRACK, url: i, deliveryDirectives: a, levelOrTrack: o }) } onLevelsUpdated(e, t) { const r = this.loaders[He.LEVEL]; if (r) { const s = r.context; s && !t.levels.some(i => i === s.levelOrTrack) && (r.abort(), delete this.loaders[He.LEVEL]) } } load(e) { var t; const r = this.hls.config; let s = this.getInternalLoader(e); if (s) { const u = this.hls.logger, f = s.context; if (f && f.levelOrTrack === e.levelOrTrack && (f.url === e.url || f.deliveryDirectives && !e.deliveryDirectives)) { f.url === e.url ? u.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : u.log(`[playlist-loader]: ignore ${e.url} in favor of ${f.url}`); return } u.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), s.abort() } let i; if (e.type === He.MANIFEST ? i = r.manifestLoadPolicy.default : i = nt({}, r.playlistLoadPolicy.default, { timeoutRetry: null, errorRetry: null }), s = this.createInternalLoader(e), ge((t = e.deliveryDirectives) == null ? void 0 : t.part)) { let u; if (e.type === He.LEVEL && e.level !== null ? u = this.hls.levels[e.level].details : e.type === He.AUDIO_TRACK && e.id !== null ? u = this.hls.audioTracks[e.id].details : e.type === He.SUBTITLE_TRACK && e.id !== null && (u = this.hls.subtitleTracks[e.id].details), u) { const f = u.partTarget, h = u.targetduration; if (f && h) { const p = Math.max(f * 3, h * .8) * 1e3; i = nt({}, i, { maxTimeToFirstByteMs: Math.min(p, i.maxTimeToFirstByteMs), maxLoadTimeMs: Math.min(p, i.maxTimeToFirstByteMs) }) } } } const a = i.errorRetry || i.timeoutRetry || {}, o = { loadPolicy: i, timeout: i.maxLoadTimeMs, maxRetry: a.maxNumRetry || 0, retryDelay: a.retryDelayMs || 0, maxRetryDelay: a.maxRetryDelayMs || 0 }, c = { onSuccess: (u, f, h, p) => { const v = this.getInternalLoader(h); this.resetInternalLoader(h.type); const g = u.data; f.parsing.start = performance.now(), un.isMediaPlaylist(g) || h.type !== He.MANIFEST ? this.handleTrackOrLevelPlaylist(u, f, h, p || null, v) : this.handleMasterPlaylist(u, f, h, p) }, onError: (u, f, h, p) => { this.handleNetworkError(f, h, !1, u, p) }, onTimeout: (u, f, h) => { this.handleNetworkError(f, h, !0, void 0, u) } }; s.load(e, o, c) } checkAutostartLoad() { if (!this.hls) return; const { config: { autoStartLoad: e, startPosition: t }, forceStartLoad: r } = this.hls; (e || r) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${t}`), this.hls.startLoad(t)) } handleMasterPlaylist(e, t, r, s) { const i = this.hls, a = e.data, o = Nf(e, r), c = un.parseMasterPlaylist(a, o); if (c.playlistParsingError) { t.parsing.end = performance.now(), this.handleManifestParsingError(e, r, c.playlistParsingError, s, t); return } const { contentSteering: u, levels: f, sessionData: h, sessionKeys: p, startTimeOffset: v, variableList: g } = c; this.variableList = g, f.forEach(S => { const { unknownCodecs: E } = S; if (E) { const { preferManagedMediaSource: I } = this.hls.config; let { audioCodec: C, videoCodec: D } = S; for (let R = E.length; R--;) { const N = E[R]; Za(N, "audio", I) ? (S.audioCodec = C = C ? `${C},${N}` : N, $i.audio[C.substring(0, 4)] = 2, E.splice(R, 1)) : Za(N, "video", I) && (S.videoCodec = D = D ? `${D},${N}` : N, $i.video[D.substring(0, 4)] = 2, E.splice(R, 1)) } } }); const { AUDIO: y = [], SUBTITLES: w, "CLOSED-CAPTIONS": T } = un.parseMasterPlaylistMedia(a, o, c); y.length && !y.some(E => !E.url) && f[0].audioCodec && !f[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), y.unshift({ type: "main", name: "main", groupId: "main", default: !1, autoselect: !1, forced: !1, id: -1, attrs: new gt({}), bitrate: 0, url: "" })), i.trigger(k.MANIFEST_LOADED, { levels: f, audioTracks: y, subtitles: w, captions: T, contentSteering: u, url: o, stats: t, networkDetails: s, sessionData: h, sessionKeys: p, startTimeOffset: v, variableList: g }) } handleTrackOrLevelPlaylist(e, t, r, s, i) { const a = this.hls, { id: o, level: c, type: u } = r, f = Nf(e, r), h = ge(c) ? c : ge(o) ? o : 0, p = hy(r), v = un.parseLevelPlaylist(e.data, f, h, p, 0, this.variableList); if (u === He.MANIFEST) { const g = { attrs: new gt({}), bitrate: 0, details: v, name: "", url: f }; v.requestScheduled = t.loading.start + tw(v, 0), a.trigger(k.MANIFEST_LOADED, { levels: [g], audioTracks: [], url: f, stats: t, networkDetails: s, sessionData: null, sessionKeys: null, contentSteering: null, startTimeOffset: null, variableList: null }) } t.parsing.end = performance.now(), r.levelDetails = v, this.handlePlaylistLoaded(v, e, t, r, s, i) } handleManifestParsingError(e, t, r, s, i) { this.hls.trigger(k.ERROR, { type: Ee.NETWORK_ERROR, details: J.MANIFEST_PARSING_ERROR, fatal: t.type === He.MANIFEST, url: e.url, err: r, error: r, reason: r.message, response: e, context: t, networkDetails: s, stats: i }) } handleNetworkError(e, t, r = !1, s, i) { let a = `A network ${r ? "timeout" : "error" + (s ? " (status " + s.code + ")" : "")} occurred while loading ${e.type}`; e.type === He.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === He.AUDIO_TRACK || e.type === He.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`); const o = new Error(a); this.hls.logger.warn(`[playlist-loader]: ${a}`); let c = J.UNKNOWN, u = !1; const f = this.getInternalLoader(e); switch (e.type) { case He.MANIFEST: c = r ? J.MANIFEST_LOAD_TIMEOUT : J.MANIFEST_LOAD_ERROR, u = !0; break; case He.LEVEL: c = r ? J.LEVEL_LOAD_TIMEOUT : J.LEVEL_LOAD_ERROR, u = !1; break; case He.AUDIO_TRACK: c = r ? J.AUDIO_TRACK_LOAD_TIMEOUT : J.AUDIO_TRACK_LOAD_ERROR, u = !1; break; case He.SUBTITLE_TRACK: c = r ? J.SUBTITLE_TRACK_LOAD_TIMEOUT : J.SUBTITLE_LOAD_ERROR, u = !1; break }f && this.resetInternalLoader(e.type); const h = { type: Ee.NETWORK_ERROR, details: c, fatal: u, url: e.url, loader: f, context: e, error: o, networkDetails: t, stats: i }; if (s) { const p = t?.url || e.url; h.response = et({ url: p, data: void 0 }, s) } this.hls.trigger(k.ERROR, h) } handlePlaylistLoaded(e, t, r, s, i, a) { const o = this.hls, { type: c, level: u, levelOrTrack: f, id: h, groupId: p, deliveryDirectives: v } = s, g = Nf(t, s), y = hy(s); let w = typeof s.level == "number" && y === ve.MAIN ? u : void 0; const T = e.playlistParsingError; if (T) { if (this.hls.logger.warn(`${T} ${e.url}`), !o.config.ignorePlaylistParsingErrors) { o.trigger(k.ERROR, { type: Ee.NETWORK_ERROR, details: J.LEVEL_PARSING_ERROR, fatal: !1, url: g, error: T, reason: T.message, response: t, context: s, level: w, parent: y, networkDetails: i, stats: r }); return } e.playlistParsingError = null } if (!e.fragments.length) { const S = e.playlistParsingError = new Error("No Segments found in Playlist"); o.trigger(k.ERROR, { type: Ee.NETWORK_ERROR, details: J.LEVEL_EMPTY_ERROR, fatal: !1, url: g, error: S, reason: S.message, response: t, context: s, level: w, parent: y, networkDetails: i, stats: r }); return } switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), c) { case He.MANIFEST: case He.LEVEL: if (w) { if (!f) w = 0; else if (f !== o.levels[w]) { const S = o.levels.indexOf(f); S > -1 && (w = S) } } o.trigger(k.LEVEL_LOADED, { details: e, levelInfo: f || o.levels[0], level: w || 0, id: h || 0, stats: r, networkDetails: i, deliveryDirectives: v, withoutMultiVariant: c === He.MANIFEST }); break; case He.AUDIO_TRACK: o.trigger(k.AUDIO_TRACK_LOADED, { details: e, track: f, id: h || 0, groupId: p || "", stats: r, networkDetails: i, deliveryDirectives: v }); break; case He.SUBTITLE_TRACK: o.trigger(k.SUBTITLE_TRACK_LOADED, { details: e, track: f, id: h || 0, groupId: p || "", stats: r, networkDetails: i, deliveryDirectives: v }); break } } } class Rn { static get version() { return ro } static isMSESupported() { return eS() } static isSupported() { return LD() } static getMediaSource() { return bs() } static get Events() { return k } static get MetadataSchema() { return br } static get ErrorTypes() { return Ee } static get ErrorDetails() { return J } static get DefaultConfig() { return Rn.defaultConfig ? Rn.defaultConfig : mD } static set DefaultConfig(e) { Rn.defaultConfig = e } constructor(e = {}) { this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Ep, this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1; const t = this.logger = FR(e.debug || !1, "Hls instance", e.assetPlayerId), r = this.config = xD(Rn.DefaultConfig, e, t); this.userConfig = e, r.progressive && vD(r, t); const { abrController: s, bufferController: i, capLevelController: a, errorController: o, fpsController: c } = r, u = new o(this), f = this.abrController = new s(this), h = new P_(this), p = r.interstitialsController, v = p ? this.interstitialsController = new p(this, Rn) : null, g = this.bufferController = new i(this, h), y = this.capLevelController = new a(this), w = new c(this), T = new PD(this), S = r.contentSteeringController, E = S ? new S(this) : null, I = this.levelController = new ID(this, E), C = new TD(this), D = new _D(this.config, this.logger), R = this.streamController = new RD(this, h, D), N = this.gapController = new SD(this, h); y.setStreamController(R), w.setStreamController(R); const P = [T, I, R]; v && P.splice(1, 0, v), E && P.splice(1, 0, E), this.networkControllers = P; const _ = [f, g, N, y, w, C, h]; this.audioTrackController = this.createController(r.audioTrackController, P); const M = r.audioStreamController; M && P.push(this.audioStreamController = new M(this, h, D)), this.subtitleTrackController = this.createController(r.subtitleTrackController, P); const $ = r.subtitleStreamController; $ && P.push(this.subtititleStreamController = new $(this, h, D)), this.createController(r.timelineController, _), D.emeController = this.emeController = this.createController(r.emeController, _), this.cmcdController = this.createController(r.cmcdController, _), this.latencyController = this.createController(AD, _), this.coreComponents = _, P.push(u); const B = u.onErrorOut; typeof B == "function" && this.on(k.ERROR, B, u), this.on(k.MANIFEST_LOADED, T.onManifestLoaded, T) } createController(e, t) { if (e) { const r = new e(this); return t && t.push(r), r } return null } on(e, t, r = this) { this._emitter.on(e, t, r) } once(e, t, r = this) { this._emitter.once(e, t, r) } removeAllListeners(e) { this._emitter.removeAllListeners(e) } off(e, t, r = this, s) { this._emitter.off(e, t, r, s) } listeners(e) { return this._emitter.listeners(e) } emit(e, t, r) { return this._emitter.emit(e, t, r) } trigger(e, t) { if (this.config.debug) return this.emit(e, e, t); try { return this.emit(e, e, t) } catch (r) { if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + r.message + '". Here is a stacktrace:', r), !this.triggeringException) { this.triggeringException = !0; const s = e === k.ERROR; this.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.INTERNAL_EXCEPTION, fatal: s, event: e, error: r }), this.triggeringException = !1 } } return !1 } listenerCount(e) { return this._emitter.listenerCount(e) } destroy() { this.logger.log("destroy"), this.trigger(k.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach(t => t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach(t => t.destroy()), this.coreComponents.length = 0; const e = this.config; e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null } attachMedia(e) { if (!e || "media" in e && !e.media) { const i = new Error(`attachMedia failed: invalid argument (${e})`); this.trigger(k.ERROR, { type: Ee.OTHER_ERROR, details: J.ATTACH_MEDIA_ERROR, fatal: !0, error: i }); return } this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia()); const t = "media" in e, r = t ? e.media : e, s = t ? e : { media: r }; this._media = r, this.trigger(k.MEDIA_ATTACHING, s) } detachMedia() { this.logger.log("detachMedia"), this.trigger(k.MEDIA_DETACHING, {}), this._media = null } transferMedia() { this._media = null; const e = this.bufferController.transferMedia(); return this.trigger(k.MEDIA_DETACHING, { transferMedia: e }), e } loadSource(e) { this.stopLoad(); const t = this.media, r = this._url, s = this._url = dp.buildAbsoluteURL(self.location.href, e, { alwaysNormalize: !0 }); this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${s}`), t && r && (r !== s || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(k.MANIFEST_LOADING, { url: e }) } get url() { return this._url } get hasEnoughToStart() { return this.streamController.hasEnoughToStart } get startPosition() { return this.streamController.startPositionValue } startLoad(e = -1, t) { this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`), this.started = !0, this.resumeBuffering(); for (let r = 0; r < this.networkControllers.length && (this.networkControllers[r].startLoad(e, t), !(!this.started || !this.networkControllers)); r++); } stopLoad() { this.logger.log("stopLoad"), this.started = !1; for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++); } get loadingEnabled() { return this.started } get bufferingEnabled() { return this.streamController.bufferingEnabled } resumeBuffering() { this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach(e => { e.resumeBuffering && e.resumeBuffering() })) } pauseBuffering() { this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach(e => { e.pauseBuffering && e.pauseBuffering() })) } get inFlightFragments() { const e = { [ve.MAIN]: this.streamController.inFlightFrag }; return this.audioStreamController && (e[ve.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (e[ve.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e } swapAudioCodec() { this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec() } recoverMediaError() { this.logger.log("recoverMediaError"); const e = this._media, t = e?.currentTime; this.detachMedia(), e && (this.attachMedia(e), t && this.startLoad(t)) } removeLevel(e) { this.levelController.removeLevel(e) } get sessionId() { let e = this._sessionId; return e || (e = this._sessionId = S5()), e } get levels() { const e = this.levelController.levels; return e || [] } get latestLevelDetails() { return this.streamController.getLevelDetails() || null } get loadLevelObj() { return this.levelController.loadLevelObj } get currentLevel() { return this.streamController.currentLevel } set currentLevel(e) { this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch() } get nextLevel() { return this.streamController.nextLevel } set nextLevel(e) { this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch() } get loadLevel() { return this.levelController.level } set loadLevel(e) { this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e } get nextLoadLevel() { return this.levelController.nextLoadLevel } set nextLoadLevel(e) { this.levelController.nextLoadLevel = e } get firstLevel() { return Math.max(this.levelController.firstLevel, this.minAutoLevel) } set firstLevel(e) { this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e } get startLevel() { const e = this.levelController.startLevel; return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e } set startLevel(e) { this.logger.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e } get capLevelToPlayerSize() { return this.config.capLevelToPlayerSize } set capLevelToPlayerSize(e) { const t = !!e; t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t) } get autoLevelCapping() { return this._autoLevelCapping } get bandwidthEstimate() { const { bwEstimator: e } = this.abrController; return e ? e.getEstimate() : NaN } set bandwidthEstimate(e) { this.abrController.resetEstimator(e) } get abrEwmaDefaultEstimate() { const { bwEstimator: e } = this.abrController; return e ? e.defaultEstimate : NaN } get ttfbEstimate() { const { bwEstimator: e } = this.abrController; return e ? e.getEstimateTTFB() : NaN } set autoLevelCapping(e) { this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated()) } get maxHdcpLevel() { return this._maxHdcpLevel } set maxHdcpLevel(e) { g_(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated()) } get autoLevelEnabled() { return this.levelController.manualLevel === -1 } get manualLevel() { return this.levelController.manualLevel } get minAutoLevel() { const { levels: e, config: { minAutoBitrate: t } } = this; if (!e) return 0; const r = e.length; for (let s = 0; s < r; s++)if (e[s].maxBitrate >= t) return s; return 0 } get maxAutoLevel() { const { levels: e, autoLevelCapping: t, maxHdcpLevel: r } = this; let s; if (t === -1 && e != null && e.length ? s = e.length - 1 : s = t, r) for (let i = s; i--;) { const a = e[i].attrs["HDCP-LEVEL"]; if (a && a <= r) return i } return s } get firstAutoLevel() { return this.abrController.firstAutoLevel } get nextAutoLevel() { return this.abrController.nextAutoLevel } set nextAutoLevel(e) { this.abrController.nextAutoLevel = e } get playingDate() { return this.streamController.currentProgramDateTime } get mainForwardBufferInfo() { return this.streamController.getMainFwdBufferInfo() } get maxBufferLength() { return this.streamController.maxBufferLength } setAudioOption(e) { var t; return ((t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)) || null } setSubtitleOption(e) { var t; return ((t = this.subtitleTrackController) == null ? void 0 : t.setSubtitleOption(e)) || null } get allAudioTracks() { const e = this.audioTrackController; return e ? e.allAudioTracks : [] } get audioTracks() { const e = this.audioTrackController; return e ? e.audioTracks : [] } get audioTrack() { const e = this.audioTrackController; return e ? e.audioTrack : -1 } set audioTrack(e) { const t = this.audioTrackController; t && (t.audioTrack = e) } get allSubtitleTracks() { const e = this.subtitleTrackController; return e ? e.allSubtitleTracks : [] } get subtitleTracks() { const e = this.subtitleTrackController; return e ? e.subtitleTracks : [] } get subtitleTrack() { const e = this.subtitleTrackController; return e ? e.subtitleTrack : -1 } get media() { return this._media } set subtitleTrack(e) { const t = this.subtitleTrackController; t && (t.subtitleTrack = e) } get subtitleDisplay() { const e = this.subtitleTrackController; return e ? e.subtitleDisplay : !1 } set subtitleDisplay(e) { const t = this.subtitleTrackController; t && (t.subtitleDisplay = e) } get lowLatencyMode() { return this.config.lowLatencyMode } set lowLatencyMode(e) { this.config.lowLatencyMode = e } get liveSyncPosition() { return this.latencyController.liveSyncPosition } get latency() { return this.latencyController.latency } get maxLatency() { return this.latencyController.maxLatency } get targetLatency() { return this.latencyController.targetLatency } set targetLatency(e) { this.latencyController.targetLatency = e } get drift() { return this.latencyController.drift } get forceStartLoad() { return this.streamController.forceStartLoad } get pathways() { return this.levelController.pathways } get pathwayPriority() { return this.levelController.pathwayPriority } set pathwayPriority(e) { this.levelController.pathwayPriority = e } get bufferedToEnd() { var e; return !!((e = this.bufferController) != null && e.bufferedToEnd) } get interstitialsManager() { var e; return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null } getMediaDecodingInfo(e, t = this.allAudioTracks) { const r = zb(t); return Bb(e, r, navigator.mediaCapabilities) } } Rn.defaultConfig = void 0;/*!
 * artplayer.js v5.3.0
 * Github: https://github.com/zhw2590582/ArtPlayer
 * (c) 2017-2025 Harvey Zack
 * Released under the MIT License.
 */(function (n, e, t, r, s, i, a, o) { var c = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}, u = typeof c[r] == "function" && c[r], f = u.i || {}, h = u.cache || {}, p = typeof Us < "u" && typeof Us.require == "function" && Us.require.bind(Us); function v(w, T) { if (!h[w]) { if (!n[w]) { if (s[w]) return s[w]; var S = typeof c[r] == "function" && c[r]; if (!T && S) return S(w, !0); if (u) return u(w, !0); if (p && typeof w == "string") return p(w); var E = Error("Cannot find module '" + w + "'"); throw E.code = "MODULE_NOT_FOUND", E } C.resolve = function (D) { var R = n[w][1][D]; return R ?? D }, C.cache = {}; var I = h[w] = new v.Module(w); n[w][0].call(I.exports, C, I, I.exports, c) } return h[w].exports; function C(D) { var R = C.resolve(D); return R === !1 ? {} : v(R) } } v.isParcelRequire = !0, v.Module = function (w) { this.id = w, this.bundle = v, this.require = p, this.exports = {} }, v.modules = n, v.cache = h, v.parent = u, v.distDir = void 0, v.publicUrl = void 0, v.devServer = void 0, v.i = f, v.register = function (w, T) { n[w] = [function (S, E) { E.exports = T }, {}] }, Object.defineProperty(v, "root", { get: function () { return c[r] } }), c[r] = v; for (var g = 0; g < e.length; g++)v(e[g]); { var y = v(t); typeof rS == "object" && typeof Us < "u" ? Us.exports = y : typeof define == "function" && define.amd && define(function () { return y }) } })({
    esqvp: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("bundle-text:./style/index.less"), a = s.interopDefault(i), o = n("option-validator"), c = s.interopDefault(o), u = n("../package.json"), f = n("./config"), h = s.interopDefault(f), p = n("./contextmenu"), v = s.interopDefault(p), g = n("./control"), y = s.interopDefault(g), w = n("./events"), T = s.interopDefault(w), S = n("./hotkey"), E = s.interopDefault(S), I = n("./i18n"), C = s.interopDefault(I), D = n("./icons"), R = s.interopDefault(D), N = n("./info"), P = s.interopDefault(N), _ = n("./layer"), M = s.interopDefault(_), $ = n("./loading"), B = s.interopDefault($), V = n("./mask"), W = s.interopDefault(V), U = n("./notice"), q = s.interopDefault(U), z = n("./player"), X = s.interopDefault(z), Z = n("./plugins"), F = s.interopDefault(Z), H = n("./scheme"), ae = s.interopDefault(H), he = n("./setting"), de = s.interopDefault(he), pe = n("./storage"), Ce = s.interopDefault(pe), Ie = n("./subtitle"), Pe = s.interopDefault(Ie), Ve = n("./template"), rt = s.interopDefault(Ve), ft = n("./utils"), je = n("./utils/emitter"), Oe = s.interopDefault(je); let ot = 0, Le = []; class ie extends Oe.default { constructor(qe, Ze) { if (super(), !ft.isBrowser) throw Error("Artplayer can only be used in the browser environment"); this.id = ++ot; let vt = ft.mergeDeep(ie.option, qe); if (vt.container = qe.container, this.option = (0, c.default)(vt, ae.default), this.isLock = !1, this.isReady = !1, this.isFocus = !1, this.isInput = !1, this.isRotate = !1, this.isDestroy = !1, this.template = new rt.default(this), this.events = new T.default(this), this.storage = new Ce.default(this), this.icons = new R.default(this), this.i18n = new C.default(this), this.notice = new q.default(this), this.player = new X.default(this), this.layers = new M.default(this), this.controls = new y.default(this), this.contextmenu = new v.default(this), this.subtitle = new Pe.default(this), this.info = new P.default(this), this.loading = new B.default(this), this.hotkey = new E.default(this), this.mask = new W.default(this), this.setting = new de.default(this), this.plugins = new F.default(this), typeof Ze == "function" && this.on("ready", () => Ze.call(this, this)), ie.DEBUG) { let Et = _t => console.log(`[ART.${this.id}] -> ${_t}`); Et(`Version@${ie.version}`); for (let _t = 0; _t < h.default.events.length; _t++)this.on(`video:${h.default.events[_t]}`, dr => Et(`Event@${dr.type}`)) } Le.push(this) } static get instances() { return Le } static get version() { return u.version } static get config() { return h.default } static get utils() { return ft } static get scheme() { return ae.default } static get Emitter() { return Oe.default } static get validator() { return c.default } static get kindOf() { return c.default.kindOf } static get html() { return rt.default.html } static get option() { return { id: "", container: "#artplayer", url: "", poster: "", type: "", theme: "#f00", volume: .7, isLive: !1, muted: !1, autoplay: !1, autoSize: !1, autoMini: !1, loop: !1, flip: !1, playbackRate: !1, aspectRatio: !1, screenshot: !1, setting: !1, hotkey: !0, pip: !1, mutex: !0, backdrop: !0, fullscreen: !1, fullscreenWeb: !1, subtitleOffset: !1, miniProgressBar: !1, useSSR: !1, playsInline: !0, lock: !1, gesture: !0, fastForward: !1, autoPlayback: !1, autoOrientation: !1, airplay: !1, proxy: void 0, layers: [], contextmenu: [], controls: [], settings: [], quality: [], highlight: [], plugins: [], thumbnails: { url: "", number: 60, column: 10, width: 0, height: 0, scale: 1 }, subtitle: { url: "", type: "", style: {}, name: "", escape: !0, encoding: "utf-8", onVttLoad: qe => qe }, moreVideoAttr: { controls: !1, preload: ft.isSafari ? "auto" : "metadata" }, i18n: {}, icons: {}, cssVar: {}, customType: {}, lang: navigator?.language.toLowerCase() } } get proxy() { return this.events.proxy } get query() { return this.template.query } get video() { return this.template.$video } destroy(qe = !0) { ie.REMOVE_SRC_WHEN_DESTROY && this.video.removeAttribute("src"), this.events.destroy(), this.template.destroy(qe), Le.splice(Le.indexOf(this), 1), this.isDestroy = !0, this.emit("destroy") } } t.default = ie, ie.STYLE = a.default, ie.DEBUG = !1, ie.CONTEXTMENU = !0, ie.NOTICE_TIME = 2e3, ie.SETTING_WIDTH = 250, ie.SETTING_ITEM_WIDTH = 200, ie.SETTING_ITEM_HEIGHT = 35, ie.RESIZE_TIME = 200, ie.SCROLL_TIME = 200, ie.SCROLL_GAP = 50, ie.AUTO_PLAYBACK_MAX = 10, ie.AUTO_PLAYBACK_MIN = 5, ie.AUTO_PLAYBACK_TIMEOUT = 3e3, ie.RECONNECT_TIME_MAX = 5, ie.RECONNECT_SLEEP_TIME = 1e3, ie.CONTROL_HIDE_TIME = 3e3, ie.DBCLICK_TIME = 300, ie.DBCLICK_FULLSCREEN = !0, ie.MOBILE_DBCLICK_PLAY = !0, ie.MOBILE_CLICK_PLAY = !1, ie.AUTO_ORIENTATION_TIME = 200, ie.INFO_LOOP_TIME = 1e3, ie.FAST_FORWARD_VALUE = 3, ie.FAST_FORWARD_TIME = 1e3, ie.TOUCH_MOVE_RATIO = .5, ie.VOLUME_STEP = .1, ie.SEEK_STEP = 5, ie.PLAYBACK_RATE = [.5, .75, 1, 1.25, 1.5, 2], ie.ASPECT_RATIO = ["default", "4:3", "16:9"], ie.FLIP = ["normal", "horizontal", "vertical"], ie.FULLSCREEN_WEB_IN_BODY = !1, ie.LOG_VERSION = !0, ie.USE_RAF = !1, ie.REMOVE_SRC_WHEN_DESTROY = !0, ft.isBrowser && (window.Artplayer = ie, ft.setStyleText("artplayer-style", a.default), setTimeout(() => { ie.LOG_VERSION && console.log(`%c ArtPlayer %c ${ie.version} %c https://artplayer.org`, "color: #fff; background: #5f5f5f", "color: #fff; background: #4bc729", "") }, 100)) }, { "bundle-text:./style/index.less": "2wh8D", "option-validator": "g7VGh", "../package.json": "lh3R5", "./config": "eJfh8", "./contextmenu": "9zso8", "./control": "dp1yk", "./events": "jmVSD", "./hotkey": "dswts", "./i18n": "d9ktO", "./icons": "fFHY0", "./info": "kZ0F8", "./layer": "j9lbi", "./loading": "bMjWd", "./mask": "k1nkQ", "./notice": "fPVaU", "./player": "uR0Sw", "./plugins": "cjxJL", "./scheme": "biLjm", "./setting": "bwLGT", "./storage": "kwqbK", "./subtitle": "k5613", "./template": "fwOA1", "./utils": "aBlEo", "./utils/emitter": "4NM7P", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "2wh8D": [function (n, e, t, r) { e.exports = '.art-video-player{--art-theme:red;--art-font-color:#fff;--art-background-color:#000;--art-text-shadow-color:#00000080;--art-transition-duration:.2s;--art-padding:10px;--art-border-radius:3px;--art-progress-height:6px;--art-progress-color:#ffffff40;--art-hover-color:#ffffff40;--art-loaded-color:#ffffff40;--art-state-size:80px;--art-state-opacity:.8;--art-bottom-height:100px;--art-bottom-offset:20px;--art-bottom-gap:5px;--art-highlight-width:8px;--art-highlight-color:#ffffff80;--art-control-height:46px;--art-control-opacity:.75;--art-control-icon-size:36px;--art-control-icon-scale:1.1;--art-volume-height:120px;--art-volume-handle-size:14px;--art-lock-size:36px;--art-indicator-scale:0;--art-indicator-size:16px;--art-fullscreen-web-index:9999;--art-settings-icon-size:24px;--art-settings-max-height:300px;--art-selector-max-height:300px;--art-contextmenus-min-width:250px;--art-subtitle-font-size:20px;--art-subtitle-gap:5px;--art-subtitle-bottom:15px;--art-subtitle-border:#000;--art-widget-background:#000000d9;--art-tip-background:#000000b3;--art-scrollbar-size:4px;--art-scrollbar-background:#ffffff40;--art-scrollbar-background-hover:#ffffff80;--art-mini-progress-height:2px}.art-bg-cover{background-position:50%;background-repeat:no-repeat;background-size:cover}.art-bottom-gradient{background-image:linear-gradient(#0000,#0006,#000);background-position:bottom;background-repeat:repeat-x}.art-backdrop-filter{backdrop-filter:saturate(180%)blur(20px);background-color:#000000bf!important}.art-truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.art-video-player{zoom:1;text-align:left;user-select:none;box-sizing:border-box;width:100%;height:100%;color:var(--art-font-color);background-color:var(--art-background-color);text-shadow:0 0 2px var(--art-text-shadow-color);-webkit-tap-highlight-color:#0000;-ms-touch-action:manipulation;touch-action:manipulation;-ms-high-contrast-adjust:none;direction:ltr;outline:0;margin:0 auto;padding:0;font-family:PingFang SC,Helvetica Neue,Microsoft YaHei,Roboto,Arial,sans-serif;font-size:14px;line-height:1.3;position:relative}.art-video-player *,.art-video-player :before,.art-video-player :after{box-sizing:border-box}.art-video-player ::-webkit-scrollbar{width:var(--art-scrollbar-size);height:var(--art-scrollbar-size)}.art-video-player ::-webkit-scrollbar-thumb{background-color:var(--art-scrollbar-background)}.art-video-player ::-webkit-scrollbar-thumb:hover{background-color:var(--art-scrollbar-background-hover)}.art-video-player img{vertical-align:top;max-width:100%}.art-video-player svg{fill:var(--art-font-color)}.art-video-player a{color:var(--art-font-color);text-decoration:none}.art-icon{justify-content:center;align-items:center;line-height:1;display:flex}.art-video-player.art-backdrop .art-contextmenus,.art-video-player.art-backdrop .art-info,.art-video-player.art-backdrop .art-settings,.art-video-player.art-backdrop .art-layer-auto-playback,.art-video-player.art-backdrop .art-selector-list,.art-video-player.art-backdrop .art-volume-inner{backdrop-filter:saturate(180%)blur(20px);background-color:#000000bf!important}.art-video{z-index:10;cursor:pointer;width:100%;height:100%;position:absolute;inset:0}.art-poster{z-index:11;pointer-events:none;background-position:50%;background-repeat:no-repeat;background-size:cover;width:100%;height:100%;position:absolute;inset:0}.art-video-player .art-subtitle{z-index:20;text-align:center;pointer-events:none;justify-content:center;align-items:center;gap:var(--art-subtitle-gap);width:100%;bottom:var(--art-subtitle-bottom);font-size:var(--art-subtitle-font-size);transition:bottom var(--art-transition-duration)ease;text-shadow:var(--art-subtitle-border)1px 0 1px,var(--art-subtitle-border)0 1px 1px,var(--art-subtitle-border)-1px 0 1px,var(--art-subtitle-border)0 -1px 1px,var(--art-subtitle-border)1px 1px 1px,var(--art-subtitle-border)-1px -1px 1px,var(--art-subtitle-border)1px -1px 1px,var(--art-subtitle-border)-1px 1px 1px;flex-direction:column;padding:0 5%;display:none;position:absolute}.art-video-player.art-subtitle-show .art-subtitle{display:flex}.art-video-player.art-control-show .art-subtitle{bottom:calc(var(--art-control-height) + var(--art-subtitle-bottom))}.art-danmuku{z-index:30;pointer-events:none;width:100%;height:100%;position:absolute;inset:0;overflow:hidden}.art-video-player .art-layers{z-index:40;pointer-events:none;width:100%;height:100%;display:none;position:absolute;inset:0}.art-video-player .art-layers .art-layer{pointer-events:auto}.art-video-player.art-layer-show .art-layers{display:flex}.art-video-player .art-mask{z-index:50;pointer-events:none;justify-content:center;align-items:center;width:100%;height:100%;display:flex;position:absolute;inset:0}.art-video-player .art-mask .art-state{opacity:0;width:var(--art-state-size);height:var(--art-state-size);transition:all var(--art-transition-duration)ease;justify-content:center;align-items:center;display:flex;transform:scale(2)}.art-video-player.art-mask-show .art-state{cursor:pointer;pointer-events:auto;opacity:var(--art-state-opacity);transform:scale(1)}.art-video-player.art-loading-show .art-state{display:none}.art-video-player .art-loading{z-index:70;pointer-events:none;justify-content:center;align-items:center;width:100%;height:100%;display:none;position:absolute;inset:0}.art-video-player.art-loading-show .art-loading{display:flex}.art-video-player .art-bottom{z-index:60;opacity:0;pointer-events:none;width:100%;height:100%;padding:0 var(--art-padding);transition:all var(--art-transition-duration)ease;background-size:100% var(--art-bottom-height);background-image:linear-gradient(#0000,#0006,#000);background-position:bottom;background-repeat:repeat-x;flex-direction:column;justify-content:flex-end;display:flex;position:absolute;inset:0;overflow:hidden}.art-video-player .art-bottom .art-controls,.art-video-player .art-bottom .art-progress{transform:translateY(var(--art-bottom-offset));transition:transform var(--art-transition-duration)ease}.art-video-player.art-control-show .art-bottom,.art-video-player.art-hover .art-bottom{opacity:1}.art-video-player.art-control-show .art-bottom .art-controls,.art-video-player.art-hover .art-bottom .art-controls,.art-video-player.art-control-show .art-bottom .art-progress,.art-video-player.art-hover .art-bottom .art-progress{transform:translateY(0)}.art-bottom .art-progress{z-index:0;pointer-events:auto;padding-bottom:var(--art-bottom-gap);position:relative}.art-bottom .art-progress .art-control-progress{cursor:pointer;height:var(--art-progress-height);justify-content:center;align-items:center;display:flex;position:relative}.art-bottom .art-progress .art-control-progress .art-control-progress-inner{width:100%;height:50%;transition:height var(--art-transition-duration)ease;background-color:var(--art-progress-color);align-items:center;display:flex;position:relative}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-hover{z-index:0;background-color:var(--art-hover-color);width:0%;height:100%;position:absolute;inset:0}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-loaded{z-index:10;background-color:var(--art-loaded-color);width:0%;height:100%;position:absolute;inset:0}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-played{z-index:20;background-color:var(--art-theme);width:0%;height:100%;position:absolute;inset:0}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-highlight{z-index:30;pointer-events:none;width:100%;height:100%;position:absolute;inset:0}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-highlight span{z-index:0;pointer-events:auto;width:100%;height:100%;transform:translateX(calc(var(--art-highlight-width)/-2));background-color:var(--art-highlight-color);position:absolute;inset:0 auto 0 0;width:var(--art-highlight-width)!important}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-indicator{z-index:40;width:var(--art-indicator-size);height:var(--art-indicator-size);transform:scale(var(--art-indicator-scale));margin-left:calc(var(--art-indicator-size)/-2);transition:transform var(--art-transition-duration)ease;border-radius:50%;justify-content:center;align-items:center;display:flex;position:absolute;left:0}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-indicator .art-icon{pointer-events:none;width:100%;height:100%}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-indicator:hover{transform:scale(1.2)!important}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-indicator:active{transform:scale(1)!important}.art-bottom .art-progress .art-control-progress .art-control-progress-inner .art-progress-tip{z-index:50;border-radius:var(--art-border-radius);white-space:nowrap;background-color:var(--art-tip-background);padding:3px 5px;font-size:12px;line-height:1;display:none;position:absolute;top:-25px;left:0}.art-bottom .art-progress .art-control-progress:hover .art-control-progress-inner{height:100%}.art-bottom .art-progress .art-control-thumbnails{bottom:calc(var(--art-bottom-gap) + 10px);border-radius:var(--art-border-radius);pointer-events:none;background-color:var(--art-widget-background);display:none;position:absolute;left:0;box-shadow:0 1px 3px #0003,0 1px 2px -1px #0003}.art-bottom:hover .art-progress .art-control-progress .art-control-progress-inner .art-progress-indicator{transform:scale(1)}.art-controls{z-index:10;pointer-events:auto;height:var(--art-control-height);justify-content:space-between;align-items:center;display:flex;position:relative}.art-controls .art-controls-left,.art-controls .art-controls-right{height:100%;display:flex}.art-controls .art-controls-center{flex:1;justify-content:center;align-items:center;height:100%;padding:0 10px;display:none}.art-controls .art-controls-right{justify-content:flex-end}.art-controls .art-control{cursor:pointer;white-space:nowrap;opacity:var(--art-control-opacity);min-height:var(--art-control-height);min-width:var(--art-control-height);transition:opacity var(--art-transition-duration)ease;flex-shrink:0;justify-content:center;align-items:center;display:flex}.art-controls .art-control .art-icon{height:var(--art-control-icon-size);width:var(--art-control-icon-size);transform:scale(var(--art-control-icon-scale));transition:transform var(--art-transition-duration)ease}.art-controls .art-control .art-icon:active{transform:scale(calc(var(--art-control-icon-scale)*.8))}.art-controls .art-control:hover{opacity:1}.art-control-volume{position:relative}.art-control-volume .art-volume-panel{text-align:center;cursor:default;opacity:0;pointer-events:none;left:0;right:0;bottom:var(--art-control-height);width:var(--art-control-height);height:var(--art-volume-height);transition:all var(--art-transition-duration)ease;justify-content:center;align-items:center;padding:0 5px;font-size:12px;display:flex;position:absolute;transform:translateY(10px)}.art-control-volume .art-volume-panel .art-volume-inner{border-radius:var(--art-border-radius);background-color:var(--art-widget-background);flex-direction:column;align-items:center;gap:10px;width:100%;height:100%;padding:10px 0 12px;display:flex}.art-control-volume .art-volume-panel .art-volume-inner .art-volume-slider{cursor:pointer;flex:1;justify-content:center;width:100%;display:flex;position:relative}.art-control-volume .art-volume-panel .art-volume-inner .art-volume-slider .art-volume-handle{border-radius:var(--art-border-radius);background-color:#ffffff40;justify-content:center;width:2px;display:flex;position:relative;overflow:hidden}.art-control-volume .art-volume-panel .art-volume-inner .art-volume-slider .art-volume-handle .art-volume-loaded{z-index:0;background-color:var(--art-theme);width:100%;height:100%;position:absolute;inset:0}.art-control-volume .art-volume-panel .art-volume-inner .art-volume-slider .art-volume-indicator{width:var(--art-volume-handle-size);height:var(--art-volume-handle-size);margin-top:calc(var(--art-volume-handle-size)/-2);background-color:var(--art-theme);transition:transform var(--art-transition-duration)ease;border-radius:100%;flex-shrink:0;position:absolute;transform:scale(1)}.art-control-volume .art-volume-panel .art-volume-inner .art-volume-slider:active .art-volume-indicator{transform:scale(.9)}.art-control-volume:hover .art-volume-panel{opacity:1;pointer-events:auto;transform:translateY(0)}.art-video-player .art-notice{z-index:80;width:100%;height:auto;padding:var(--art-padding);pointer-events:none;display:none;position:absolute;inset:0 0 auto}.art-video-player .art-notice .art-notice-inner{border-radius:var(--art-border-radius);background-color:var(--art-tip-background);padding:5px;line-height:1;display:inline-flex}.art-video-player.art-notice-show .art-notice{display:flex}.art-video-player .art-contextmenus{z-index:120;border-radius:var(--art-border-radius);background-color:var(--art-widget-background);min-width:var(--art-contextmenus-min-width);flex-direction:column;padding:5px 0;font-size:12px;display:none;position:absolute}.art-video-player .art-contextmenus .art-contextmenu{cursor:pointer;border-bottom:1px solid #ffffff1a;padding:10px 15px;display:flex}.art-video-player .art-contextmenus .art-contextmenu span{padding:0 8px}.art-video-player .art-contextmenus .art-contextmenu span:hover,.art-video-player .art-contextmenus .art-contextmenu span.art-current{color:var(--art-theme)}.art-video-player .art-contextmenus .art-contextmenu:hover{background-color:#ffffff1a}.art-video-player .art-contextmenus .art-contextmenu:last-child{border-bottom:none}.art-video-player.art-contextmenu-show .art-contextmenus{display:flex}.art-video-player .art-settings{z-index:90;border-radius:var(--art-border-radius);max-height:var(--art-settings-max-height);left:auto;right:var(--art-padding);bottom:var(--art-control-height);transition:all var(--art-transition-duration)ease;background-color:var(--art-widget-background);flex-direction:column;display:none;position:absolute;overflow:hidden auto}.art-video-player .art-settings .art-setting-panel{flex-direction:column;display:none}.art-video-player .art-settings .art-setting-panel.art-current{display:flex}.art-video-player .art-settings .art-setting-panel .art-setting-item{cursor:pointer;transition:background-color var(--art-transition-duration)ease;justify-content:space-between;align-items:center;padding:0 5px;display:flex;overflow:hidden}.art-video-player .art-settings .art-setting-panel .art-setting-item:hover{background-color:#ffffff1a}.art-video-player .art-settings .art-setting-panel .art-setting-item.art-current{color:var(--art-theme)}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-icon-check{visibility:hidden;height:15px}.art-video-player .art-settings .art-setting-panel .art-setting-item.art-current .art-icon-check{visibility:visible}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-setting-item-left{flex-shrink:0;justify-content:center;align-items:center;gap:5px;display:flex}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-setting-item-left .art-setting-item-left-icon{height:var(--art-settings-icon-size);width:var(--art-settings-icon-size);justify-content:center;align-items:center;display:flex}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-setting-item-right{justify-content:center;align-items:center;gap:5px;font-size:12px;display:flex}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-setting-item-right .art-setting-item-right-tooltip{white-space:nowrap;color:#ffffff80}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-setting-item-right .art-setting-item-right-icon{justify-content:center;align-items:center;min-width:32px;height:24px;display:flex}.art-video-player .art-settings .art-setting-panel .art-setting-item .art-setting-item-right .art-setting-range{appearance:none;background-color:#fff3;outline:none;width:80px;height:3px}.art-video-player .art-settings .art-setting-panel .art-setting-item-back{border-bottom:1px solid #ffffff1a}.art-video-player.art-setting-show .art-settings{display:flex}.art-video-player .art-info{left:var(--art-padding);top:var(--art-padding);z-index:100;border-radius:var(--art-border-radius);background-color:var(--art-widget-background);padding:10px;font-size:12px;display:none;position:absolute}.art-video-player .art-info .art-info-panel{flex-direction:column;gap:5px;display:flex}.art-video-player .art-info .art-info-panel .art-info-item{align-items:center;gap:5px;display:flex}.art-video-player .art-info .art-info-panel .art-info-item .art-info-title{text-align:right;width:100px}.art-video-player .art-info .art-info-panel .art-info-item .art-info-content{text-overflow:ellipsis;white-space:nowrap;user-select:all;width:250px;overflow:hidden}.art-video-player .art-info .art-info-close{cursor:pointer;position:absolute;top:5px;right:5px}.art-video-player.art-info-show .art-info{display:flex}.art-hide-cursor *{cursor:none!important}.art-video-player[data-aspect-ratio]{overflow:hidden}.art-video-player[data-aspect-ratio] .art-video{object-fit:fill;box-sizing:content-box}.art-fullscreen{--art-progress-height:8px;--art-indicator-size:20px;--art-control-height:60px;--art-control-icon-scale:1.3}.art-fullscreen-web{--art-progress-height:8px;--art-indicator-size:20px;--art-control-height:60px;--art-control-icon-scale:1.3;z-index:var(--art-fullscreen-web-index);width:100%;height:100%;position:fixed;inset:0}.art-mini-popup{z-index:9999;border-radius:var(--art-border-radius);cursor:move;user-select:none;background:#000;width:320px;height:180px;transition:opacity .2s;position:fixed;overflow:hidden;box-shadow:0 0 5px #00000080}.art-mini-popup svg{fill:#fff}.art-mini-popup .art-video{pointer-events:none}.art-mini-popup .art-mini-close{z-index:20;cursor:pointer;opacity:0;transition:opacity .2s;position:absolute;top:10px;right:10px}.art-mini-popup .art-mini-state{z-index:30;pointer-events:none;opacity:0;background-color:#00000040;justify-content:center;align-items:center;width:100%;height:100%;transition:opacity .2s;display:flex;position:absolute;inset:0}.art-mini-popup .art-mini-state .art-icon{opacity:.75;cursor:pointer;pointer-events:auto;transition:transform .2s;transform:scale(3)}.art-mini-popup .art-mini-state .art-icon:active{transform:scale(2.5)}.art-mini-popup.art-mini-dragging{opacity:.9}.art-mini-popup:hover .art-mini-close,.art-mini-popup:hover .art-mini-state{opacity:1}.art-video-player[data-flip=horizontal] .art-video{transform:scaleX(-1)}.art-video-player[data-flip=vertical] .art-video{transform:scaleY(-1)}.art-video-player .art-layer-lock{height:var(--art-lock-size);width:var(--art-lock-size);top:50%;left:var(--art-padding);background-color:var(--art-tip-background);border-radius:50%;justify-content:center;align-items:center;display:none;position:absolute;transform:translateY(-50%)}.art-video-player .art-layer-auto-playback{border-radius:var(--art-border-radius);left:var(--art-padding);bottom:calc(var(--art-control-height) + var(--art-bottom-gap) + 10px);background-color:var(--art-widget-background);align-items:center;gap:10px;padding:10px;line-height:1;display:none;position:absolute}.art-video-player .art-layer-auto-playback .art-auto-playback-close{cursor:pointer;justify-content:center;align-items:center;display:flex}.art-video-player .art-layer-auto-playback .art-auto-playback-close svg{width:15px;height:15px;fill:var(--art-theme)}.art-video-player .art-layer-auto-playback .art-auto-playback-jump{color:var(--art-theme);cursor:pointer}.art-video-player.art-lock .art-subtitle{bottom:var(--art-subtitle-bottom)!important}.art-video-player.art-mini-progress-bar .art-bottom,.art-video-player.art-lock .art-bottom{opacity:1;background-image:none;padding:0}.art-video-player.art-mini-progress-bar .art-bottom .art-controls,.art-video-player.art-lock .art-bottom .art-controls,.art-video-player.art-mini-progress-bar .art-bottom .art-progress,.art-video-player.art-lock .art-bottom .art-progress{transform:translateY(calc(var(--art-control-height) + var(--art-bottom-gap) + var(--art-progress-height)/4))}.art-video-player.art-mini-progress-bar .art-bottom .art-progress-indicator,.art-video-player.art-lock .art-bottom .art-progress-indicator{display:none!important}.art-video-player.art-control-show .art-layer-lock{display:flex}.art-control-selector{justify-content:center;display:flex;position:relative}.art-control-selector .art-selector-list{text-align:center;border-radius:var(--art-border-radius);opacity:0;pointer-events:none;bottom:var(--art-control-height);max-height:var(--art-selector-max-height);background-color:var(--art-widget-background);transition:all var(--art-transition-duration)ease;flex-direction:column;align-items:center;display:flex;position:absolute;overflow:hidden auto;transform:translateY(10px)}.art-control-selector .art-selector-list .art-selector-item{flex-shrink:0;justify-content:center;align-items:center;width:100%;padding:10px 15px;line-height:1;display:flex}.art-control-selector .art-selector-list .art-selector-item:hover{background-color:#ffffff1a}.art-control-selector .art-selector-list .art-selector-item:hover,.art-control-selector .art-selector-list .art-selector-item.art-current{color:var(--art-theme)}.art-control-selector:hover .art-selector-list{opacity:1;pointer-events:auto;transform:translateY(0)}[class*=hint--]{font-style:normal;display:inline-block;position:relative}[class*=hint--]:before,[class*=hint--]:after{visibility:hidden;opacity:0;z-index:1000000;pointer-events:none;transition:all .3s;position:absolute;transform:translate(0,0)}[class*=hint--]:hover:before,[class*=hint--]:hover:after{visibility:visible;opacity:1;transition-delay:.1s}[class*=hint--]:before{content:"";z-index:1000001;background:0 0;border:6px solid #0000;position:absolute}[class*=hint--]:after{color:#fff;white-space:nowrap;background:#000;padding:8px 10px;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:12px;line-height:12px}[class*=hint--][aria-label]:after{content:attr(aria-label)}[class*=hint--][data-hint]:after{content:attr(data-hint)}[aria-label=""]:before,[aria-label=""]:after,[data-hint=""]:before,[data-hint=""]:after{display:none!important}.hint--top-left:before,.hint--top-right:before,.hint--top:before{border-top-color:#000}.hint--bottom-left:before,.hint--bottom-right:before,.hint--bottom:before{border-bottom-color:#000}.hint--left:before{border-left-color:#000}.hint--right:before{border-right-color:#000}.hint--top:before{margin-bottom:-11px}.hint--top:before,.hint--top:after{bottom:100%;left:50%}.hint--top:before{left:calc(50% - 6px)}.hint--top:after{transform:translate(-50%)}.hint--top:hover:before{transform:translateY(-8px)}.hint--top:hover:after{transform:translate(-50%)translateY(-8px)}.hint--bottom:before{margin-top:-11px}.hint--bottom:before,.hint--bottom:after{top:100%;left:50%}.hint--bottom:before{left:calc(50% - 6px)}.hint--bottom:after{transform:translate(-50%)}.hint--bottom:hover:before{transform:translateY(8px)}.hint--bottom:hover:after{transform:translate(-50%)translateY(8px)}.hint--right:before{margin-bottom:-6px;margin-left:-11px}.hint--right:after{margin-bottom:-14px}.hint--right:before,.hint--right:after{bottom:50%;left:100%}.hint--right:hover:before,.hint--right:hover:after{transform:translate(8px)}.hint--left:before{margin-bottom:-6px;margin-right:-11px}.hint--left:after{margin-bottom:-14px}.hint--left:before,.hint--left:after{bottom:50%;right:100%}.hint--left:hover:before,.hint--left:hover:after{transform:translate(-8px)}.hint--top-left:before{margin-bottom:-11px}.hint--top-left:before,.hint--top-left:after{bottom:100%;left:50%}.hint--top-left:before{left:calc(50% - 6px)}.hint--top-left:after{margin-left:12px;transform:translate(-100%)}.hint--top-left:hover:before{transform:translateY(-8px)}.hint--top-left:hover:after{transform:translate(-100%)translateY(-8px)}.hint--top-right:before{margin-bottom:-11px}.hint--top-right:before,.hint--top-right:after{bottom:100%;left:50%}.hint--top-right:before{left:calc(50% - 6px)}.hint--top-right:after{margin-left:-12px;transform:translate(0)}.hint--top-right:hover:before,.hint--top-right:hover:after{transform:translateY(-8px)}.hint--bottom-left:before{margin-top:-11px}.hint--bottom-left:before,.hint--bottom-left:after{top:100%;left:50%}.hint--bottom-left:before{left:calc(50% - 6px)}.hint--bottom-left:after{margin-left:12px;transform:translate(-100%)}.hint--bottom-left:hover:before{transform:translateY(8px)}.hint--bottom-left:hover:after{transform:translate(-100%)translateY(8px)}.hint--bottom-right:before{margin-top:-11px}.hint--bottom-right:before,.hint--bottom-right:after{top:100%;left:50%}.hint--bottom-right:before{left:calc(50% - 6px)}.hint--bottom-right:after{margin-left:-12px;transform:translate(0)}.hint--bottom-right:hover:before,.hint--bottom-right:hover:after{transform:translateY(8px)}.hint--small:after,.hint--medium:after,.hint--large:after{white-space:normal;word-wrap:break-word;line-height:1.4em}.hint--small:after{width:80px}.hint--medium:after{width:150px}.hint--large:after{width:300px}[class*=hint--]:after{text-shadow:0 -1px #000;box-shadow:4px 4px 8px #0000004d}.hint--error:after{text-shadow:0 -1px #592726;background-color:#b34e4d}.hint--error.hint--top-left:before,.hint--error.hint--top-right:before,.hint--error.hint--top:before{border-top-color:#b34e4d}.hint--error.hint--bottom-left:before,.hint--error.hint--bottom-right:before,.hint--error.hint--bottom:before{border-bottom-color:#b34e4d}.hint--error.hint--left:before{border-left-color:#b34e4d}.hint--error.hint--right:before{border-right-color:#b34e4d}.hint--warning:after{text-shadow:0 -1px #6c5328;background-color:#c09854}.hint--warning.hint--top-left:before,.hint--warning.hint--top-right:before,.hint--warning.hint--top:before{border-top-color:#c09854}.hint--warning.hint--bottom-left:before,.hint--warning.hint--bottom-right:before,.hint--warning.hint--bottom:before{border-bottom-color:#c09854}.hint--warning.hint--left:before{border-left-color:#c09854}.hint--warning.hint--right:before{border-right-color:#c09854}.hint--info:after{text-shadow:0 -1px #1a3c4d;background-color:#3986ac}.hint--info.hint--top-left:before,.hint--info.hint--top-right:before,.hint--info.hint--top:before{border-top-color:#3986ac}.hint--info.hint--bottom-left:before,.hint--info.hint--bottom-right:before,.hint--info.hint--bottom:before{border-bottom-color:#3986ac}.hint--info.hint--left:before{border-left-color:#3986ac}.hint--info.hint--right:before{border-right-color:#3986ac}.hint--success:after{text-shadow:0 -1px #1a321a;background-color:#458746}.hint--success.hint--top-left:before,.hint--success.hint--top-right:before,.hint--success.hint--top:before{border-top-color:#458746}.hint--success.hint--bottom-left:before,.hint--success.hint--bottom-right:before,.hint--success.hint--bottom:before{border-bottom-color:#458746}.hint--success.hint--left:before{border-left-color:#458746}.hint--success.hint--right:before{border-right-color:#458746}.hint--always:after,.hint--always:before{opacity:1;visibility:visible}.hint--always.hint--top:before{transform:translateY(-8px)}.hint--always.hint--top:after{transform:translate(-50%)translateY(-8px)}.hint--always.hint--top-left:before{transform:translateY(-8px)}.hint--always.hint--top-left:after{transform:translate(-100%)translateY(-8px)}.hint--always.hint--top-right:before,.hint--always.hint--top-right:after{transform:translateY(-8px)}.hint--always.hint--bottom:before{transform:translateY(8px)}.hint--always.hint--bottom:after{transform:translate(-50%)translateY(8px)}.hint--always.hint--bottom-left:before{transform:translateY(8px)}.hint--always.hint--bottom-left:after{transform:translate(-100%)translateY(8px)}.hint--always.hint--bottom-right:before,.hint--always.hint--bottom-right:after{transform:translateY(8px)}.hint--always.hint--left:before,.hint--always.hint--left:after{transform:translate(-8px)}.hint--always.hint--right:before,.hint--always.hint--right:after{transform:translate(8px)}.hint--rounded:after{border-radius:4px}.hint--no-animate:before,.hint--no-animate:after{transition-duration:0s}.hint--bounce:before,.hint--bounce:after{-webkit-transition:opacity .3s,visibility .3s,-webkit-transform .3s cubic-bezier(.71,1.7,.77,1.24);-moz-transition:opacity .3s,visibility .3s,-moz-transform .3s cubic-bezier(.71,1.7,.77,1.24);transition:opacity .3s,visibility .3s,transform .3s cubic-bezier(.71,1.7,.77,1.24)}.hint--no-shadow:before,.hint--no-shadow:after{text-shadow:initial;box-shadow:initial}.hint--no-arrow:before{display:none}.art-video-player.art-mobile{--art-bottom-gap:10px;--art-control-height:38px;--art-control-icon-scale:1;--art-state-size:60px;--art-settings-max-height:180px;--art-selector-max-height:180px;--art-indicator-scale:1;--art-control-opacity:1}.art-video-player.art-mobile .art-controls-left{margin-left:calc(var(--art-padding)/-1)}.art-video-player.art-mobile .art-controls-right{margin-right:calc(var(--art-padding)/-1)}' }, {}], g7VGh: [function (n, e, t, r) { e.exports = (function () { function s(h) { return (s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (p) { return typeof p } : function (p) { return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p })(h) } var i = Object.prototype.toString, a = function (h) { if (h === void 0) return "undefined"; if (h === null) return "null"; var p = s(h); if (p === "boolean") return "boolean"; if (p === "string") return "string"; if (p === "number") return "number"; if (p === "symbol") return "symbol"; if (p === "function") return o(h) === "GeneratorFunction" ? "generatorfunction" : "function"; if (Array.isArray ? Array.isArray(h) : h instanceof Array) return "array"; if (h.constructor && typeof h.constructor.isBuffer == "function" && h.constructor.isBuffer(h)) return "buffer"; if ((function (v) { try { if (typeof v.length == "number" && typeof v.callee == "function") return !0 } catch (g) { if (g.message.indexOf("callee") !== -1) return !0 } return !1 })(h)) return "arguments"; if (h instanceof Date || typeof h.toDateString == "function" && typeof h.getDate == "function" && typeof h.setDate == "function") return "date"; if (h instanceof Error || typeof h.message == "string" && h.constructor && typeof h.constructor.stackTraceLimit == "number") return "error"; if (h instanceof RegExp || typeof h.flags == "string" && typeof h.ignoreCase == "boolean" && typeof h.multiline == "boolean" && typeof h.global == "boolean") return "regexp"; switch (o(h)) { case "Symbol": return "symbol"; case "Promise": return "promise"; case "WeakMap": return "weakmap"; case "WeakSet": return "weakset"; case "Map": return "map"; case "Set": return "set"; case "Int8Array": return "int8array"; case "Uint8Array": return "uint8array"; case "Uint8ClampedArray": return "uint8clampedarray"; case "Int16Array": return "int16array"; case "Uint16Array": return "uint16array"; case "Int32Array": return "int32array"; case "Uint32Array": return "uint32array"; case "Float32Array": return "float32array"; case "Float64Array": return "float64array" }if (typeof h.throw == "function" && typeof h.return == "function" && typeof h.next == "function") return "generator"; switch (p = i.call(h)) { case "[object Object]": return "object"; case "[object Map Iterator]": return "mapiterator"; case "[object Set Iterator]": return "setiterator"; case "[object String Iterator]": return "stringiterator"; case "[object Array Iterator]": return "arrayiterator" }return p.slice(8, -1).toLowerCase().replace(/\s/g, "") }; function o(h) { return h.constructor ? h.constructor.name : null } function c(h, p) { var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : ["option"]; return u(h, p, v), f(h, p, v), (function (g, y, w) { var T = a(y), S = a(g); if (T === "object") { if (S !== "object") throw Error("[Type Error]: '".concat(w.join("."), "' require 'object' type, but got '").concat(S, "'")); Object.keys(y).forEach(function (E) { var I = g[E], C = y[E], D = w.slice(); D.push(E), u(I, C, D), f(I, C, D), c(I, C, D) }) } if (T === "array") { if (S !== "array") throw Error("[Type Error]: '".concat(w.join("."), "' require 'array' type, but got '").concat(S, "'")); g.forEach(function (E, I) { var C = g[I], D = y[I] || y[0], R = w.slice(); R.push(I), u(C, D, R), f(C, D, R), c(C, D, R) }) } })(h, p, v), h } function u(h, p, v) { if (a(p) === "string") { var g = a(h); if (p[0] === "?" && (p = p.slice(1) + "|undefined"), !(-1 < p.indexOf("|") ? p.split("|").map(function (y) { return y.toLowerCase().trim() }).filter(Boolean).some(function (y) { return g === y }) : p.toLowerCase().trim() === g)) throw Error("[Type Error]: '".concat(v.join("."), "' require '").concat(p, "' type, but got '").concat(g, "'")) } } function f(h, p, v) { if (a(p) === "function") { var g = p(h, a(h), v); if (g !== !0) { var y = a(g); throw y === "string" ? Error(g) : y === "error" ? g : Error("[Validator Error]: The scheme for '".concat(v.join("."), "' validator require return true, but got '").concat(g, "'")) } } } return c.kindOf = a, c })() }, {}], lh3R5: [function (n, e, t, r) { e.exports = JSON.parse('{"name":"artplayer","version":"5.3.0","description":"ArtPlayer.js is a modern and full featured HTML5 video player","author":"Harvey Zack <laozhaochaguan@gmail.com>","license":"MIT","homepage":"https://artplayer.org","repository":{"type":"git","url":"git+https://github.com/zhw2590582/ArtPlayer.git"},"bugs":{"url":"https://github.com/zhw2590582/ArtPlayer/issues"},"keywords":["html5","video","player"],"exports":{".":{"types":"./types/artplayer.d.ts","import":"./dist/artplayer.mjs","require":"./dist/artplayer.js"},"./legacy":{"types":"./types/artplayer.d.ts","import":"./dist/artplayer.legacy.js","require":"./dist/artplayer.legacy.js"},"./i18n/*":{"types":"./types/i18n.d.ts","import":"./dist/i18n/*.mjs","require":"./dist/i18n/*.js"}},"main":"./dist/artplayer.js","module":"./dist/artplayer.mjs","types":"./types/artplayer.d.ts","typesVersions":{"*":{"i18n/*":["types/i18n.d.ts"],"legacy":["types/artplayer.d.ts"]}},"legacy":"./dist/artplayer.legacy.js","browserslist":"last 1 Chrome version","dependencies":{"option-validator":"^2.0.6"}}') }, {}], eJfh8: [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t), t.default = { properties: ["audioTracks", "autoplay", "buffered", "controller", "controls", "crossOrigin", "currentSrc", "currentTime", "defaultMuted", "defaultPlaybackRate", "duration", "ended", "error", "loop", "mediaGroup", "muted", "networkState", "paused", "playbackRate", "played", "preload", "readyState", "seekable", "seeking", "src", "startDate", "textTracks", "videoTracks", "volume"], methods: ["addTextTrack", "canPlayType", "load", "play", "pause"], events: ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], prototypes: ["width", "height", "videoWidth", "videoHeight", "poster", "webkitDecodedFrameCount", "webkitDroppedFrameCount", "playsInline", "webkitSupportsFullscreen", "webkitDisplayingFullscreen", "onenterpictureinpicture", "onleavepictureinpicture", "disablePictureInPicture", "cancelVideoFrameCallback", "requestVideoFrameCallback", "getVideoPlaybackQuality", "requestPictureInPicture", "webkitEnterFullScreen", "webkitEnterFullscreen", "webkitExitFullScreen", "webkitExitFullscreen"] } }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], loqXi: [function (n, e, t, r) { t.interopDefault = function (s) { return s && s.__esModule ? s : { default: s } }, t.defineInteropFlag = function (s) { Object.defineProperty(s, "__esModule", { value: !0 }) }, t.exportAll = function (s, i) { return Object.keys(s).forEach(function (a) { a === "default" || a === "__esModule" || Object.prototype.hasOwnProperty.call(i, a) || Object.defineProperty(i, a, { enumerable: !0, get: function () { return s[a] } }) }), i }, t.export = function (s, i, a) { Object.defineProperty(s, i, { enumerable: !0, get: a }) } }, {}], "9zso8": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("../utils"), a = n("../utils/component"), o = s.interopDefault(a), c = n("./aspectRatio"), u = s.interopDefault(c), f = n("./close"), h = s.interopDefault(f), p = n("./flip"), v = s.interopDefault(p), g = n("./info"), y = s.interopDefault(g), w = n("./playbackRate"), T = s.interopDefault(w), S = n("./version"), E = s.interopDefault(S); class I extends o.default { constructor(D) { super(D), this.name = "contextmenu", this.$parent = D.template.$contextmenu, i.isMobile || this.init() } init() { let { option: D, proxy: R, template: { $player: N, $contextmenu: P } } = this.art; D.playbackRate && this.add((0, T.default)({ name: "playbackRate", index: 10 })), D.aspectRatio && this.add((0, u.default)({ name: "aspectRatio", index: 20 })), D.flip && this.add((0, v.default)({ name: "flip", index: 30 })), this.add((0, y.default)({ name: "info", index: 40 })), this.add((0, E.default)({ name: "version", index: 50 })), this.add((0, h.default)({ name: "close", index: 60 })); for (let _ = 0; _ < D.contextmenu.length; _++)this.add(D.contextmenu[_]); R(N, "contextmenu", _ => { if (!this.art.constructor.CONTEXTMENU) return; _.preventDefault(), this.show = !0; let M = _.clientX, $ = _.clientY, { height: B, width: V, left: W, top: U } = (0, i.getRect)(N), { height: q, width: z } = (0, i.getRect)(P), X = M - W, Z = $ - U; M + z > W + V && (X = V - z), $ + q > U + B && (Z = B - q), (0, i.setStyles)(P, { top: `${Z}px`, left: `${X}px` }) }), R(N, "click", _ => { (0, i.includeFromEvent)(_, P) || (this.show = !1) }), this.art.on("blur", () => { this.show = !1 }) } } t.default = I }, { "../utils": "aBlEo", "../utils/component": "idCEj", "./aspectRatio": "6XHP2", "./close": "eF6AX", "./flip": "7Wg1P", "./info": "fjRnU", "./playbackRate": "hm1DY", "./version": "aJBeL", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], aBlEo: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./compatibility"); s.exportAll(i, t); var a = n("./dom"); s.exportAll(a, t); var o = n("./error"); s.exportAll(o, t); var c = n("./file"); s.exportAll(c, t); var u = n("./format"); s.exportAll(u, t); var f = n("./property"); s.exportAll(f, t); var h = n("./subtitle"); s.exportAll(h, t); var p = n("./time"); s.exportAll(p, t) }, { "./compatibility": "jg0yq", "./dom": "eANXw", "./error": "4FwTI", "./file": "i2JbS", "./format": "dy9GH", "./property": "jY49c", "./subtitle": "ke7ox", "./time": "f7gsx", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jg0yq: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "userAgent", () => i), s.export(t, "isSafari", () => a), s.export(t, "isIOS", () => o), s.export(t, "isIOS13", () => c), s.export(t, "isMobile", () => u), s.export(t, "isBrowser", () => f); let i = globalThis?.CUSTOM_USER_AGENT ?? (typeof navigator < "u" ? navigator.userAgent : ""), a = /^(?:(?!chrome|android).)*safari/i.test(i), o = /iPad|iPhone|iPod/i.test(i) && !window.MSStream, c = o || i.includes("Macintosh") && navigator.maxTouchPoints >= 1, u = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(i) || c, f = typeof window < "u" && typeof document < "u" }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], eANXw: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "query", () => a), s.export(t, "queryAll", () => o), s.export(t, "addClass", () => c), s.export(t, "removeClass", () => u), s.export(t, "hasClass", () => f), s.export(t, "append", () => h), s.export(t, "remove", () => p), s.export(t, "setStyle", () => v), s.export(t, "setStyles", () => g), s.export(t, "getStyle", () => y), s.export(t, "siblings", () => w), s.export(t, "inverseClass", () => T), s.export(t, "tooltip", () => S), s.export(t, "isInViewport", () => E), s.export(t, "includeFromEvent", () => I), s.export(t, "replaceElement", () => C), s.export(t, "createElement", () => D), s.export(t, "getIcon", () => R), s.export(t, "setStyleText", () => N), s.export(t, "supportsFlex", () => P), s.export(t, "getRect", () => _), s.export(t, "loadImg", () => M), s.export(t, "getComposedPath", () => $); var i = n("./compatibility"); function a(B, V = document) { return V.querySelector(B) } function o(B, V = document) { return Array.from(V.querySelectorAll(B)) } function c(B, V) { return B.classList.add(V) } function u(B, V) { return B.classList.remove(V) } function f(B, V) { return B.classList.contains(V) } function h(B, V) { return V instanceof Element ? B.appendChild(V) : B.insertAdjacentHTML("beforeend", String(V)), B.lastElementChild || B.lastChild } function p(B) { return B.parentNode.removeChild(B) } function v(B, V, W) { return B.style[V] = W, B } function g(B, V) { for (let W in V) v(B, W, V[W]); return B } function y(B, V, W = !0) { let U = window.getComputedStyle(B, null).getPropertyValue(V); return W ? Number.parseFloat(U) : U } function w(B) { return Array.from(B.parentElement.children).filter(V => V !== B) } function T(B, V) { w(B).forEach(W => u(W, V)), c(B, V) } function S(B, V, W = "top") { i.isMobile || (B.setAttribute("aria-label", V), c(B, "hint--rounded"), c(B, `hint--${W}`)) } function E(B, V = 0) { let W = B.getBoundingClientRect(), U = window.innerHeight || document.documentElement.clientHeight, q = window.innerWidth || document.documentElement.clientWidth, z = W.top - V <= U && W.top + W.height + V >= 0, X = W.left - V <= q + V && W.left + W.width + V >= 0; return z && X } function I(B, V) { return $(B).includes(V) } function C(B, V) { return V.parentNode.replaceChild(B, V), B } function D(B) { return document.createElement(B) } function R(B = "", V = "") { let W = D("i"); return c(W, "art-icon"), c(W, `art-icon-${B}`), h(W, V), W } function N(B, V) { let W = document.getElementById(B); W || ((W = document.createElement("style")).id = B, document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => { document.head.appendChild(W) }) : (document.head || document.documentElement).appendChild(W)), W.textContent = V } function P() { let B = document.createElement("div"); return B.style.display = "flex", B.style.display === "flex" } function _(B) { return B.getBoundingClientRect() } function M(B, V) { return new Promise((W, U) => { let q = new Image; q.onload = function () { if (V && V !== 1) { let z = document.createElement("canvas"), X = z.getContext("2d"); z.width = q.width * V, z.height = q.height * V, X.drawImage(q, 0, 0, z.width, z.height), z.toBlob(Z => { let F = URL.createObjectURL(Z), H = new Image; H.onload = function () { W(H) }, H.onerror = function () { URL.revokeObjectURL(F), U(Error(`Image load failed: ${B}`)) }, H.src = F }) } else W(q) }, q.onerror = function () { U(Error(`Image load failed: ${B}`)) }, q.src = B }) } function $(B) { if (B.composedPath) return B.composedPath(); let V = [], W = B.target; for (; W;)V.push(W), W = W.parentNode; return V.includes(window) || window === void 0 || V.push(window), V } }, { "./compatibility": "jg0yq", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "4FwTI": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "ArtPlayerError", () => i), s.export(t, "errorHandle", () => a); class i extends Error { constructor(c, u) { super(c), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, u || this.constructor), this.name = "ArtPlayerError" } } function a(o, c) { if (!o) throw new i(c); return o } }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], i2JbS: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a, o) { let c = document.createElement("a"); c.style.display = "none", c.href = a, c.download = o, document.body.appendChild(c), c.click(), document.body.removeChild(c) } s.defineInteropFlag(t), s.export(t, "getExt", () => function a(o) { return o.includes("?") ? a(o.split("?")[0]) : o.includes("#") ? a(o.split("#")[0]) : o.trim().toLowerCase().split(".").pop() }), s.export(t, "download", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], dy9GH: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(f, h, p) { return Math.max(Math.min(f, Math.max(h, p)), Math.min(h, p)) } function a(f) { return f.charAt(0).toUpperCase() + f.slice(1) } function o(f) { if (!f) return "00:00"; let h = Math.floor(f / 3600), p = Math.floor((f - 3600 * h) / 60), v = Math.floor(f - 3600 * h - 60 * p); return (h > 0 ? [h, p, v] : [p, v]).map(g => g < 10 ? `0${g}` : String(g)).join(":") } function c(f) { return f.replace(/[&<>'"]/g, h => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" })[h] || h) } function u(f) { let h = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&#39;": "'", "&quot;": '"' }, p = RegExp(`(${Object.keys(h).join("|")})`, "g"); return f.replace(p, v => h[v] || v) } s.defineInteropFlag(t), s.export(t, "clamp", () => i), s.export(t, "capitalize", () => a), s.export(t, "secondToTime", () => o), s.export(t, "escape", () => c), s.export(t, "unescape", () => u) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jY49c: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "def", () => i), s.export(t, "has", () => o), s.export(t, "get", () => c), s.export(t, "mergeDeep", () => function u(...f) { let h = p => p && typeof p == "object" && !Array.isArray(p); return f.reduce((p, v) => (Object.keys(v).forEach(g => { let y = p[g], w = v[g]; Array.isArray(y) && Array.isArray(w) ? p[g] = y.concat(...w) : h(y) && h(w) ? p[g] = u(y, w) : p[g] = w }), p), {}) }); let i = Object.defineProperty, { hasOwnProperty: a } = Object.prototype; function o(u, f) { return a.call(u, f) } function c(u, f) { return Object.getOwnPropertyDescriptor(u, f) } }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], ke7ox: [function (n, e, t, r) {
      var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(c) {
        return `WEBVTT \r
\r
`.concat(c.replace(/(\d\d:\d\d:\d\d)[,.](\d+)/g, (u, f, h) => { let p = h.slice(0, 3); return h.length === 1 && (p = `${h}00`), h.length === 2 && (p = `${h}0`), `${f},${p}` }).replace(/\{\\([ibu])\}/g, "</$1>").replace(/\{\\([ibu])1\}/g, "<$1>").replace(/\{([ibu])\}/g, "<$1>").replace(/\{\/([ibu])\}/g, "</$1>").replace(/(\d\d:\d\d:\d\d),(\d\d\d)/g, "$1.$2").replace(/\{[\s\S]*?\}/g, "").concat(`\r
\r
`))
      } function a(c) { return URL.createObjectURL(new Blob([c], { type: "text/vtt" })) } function o(c) {
        let u = RegExp("Dialogue:\\s\\d,(\\d+:\\d\\d:\\d\\d.\\d\\d),(\\d+:\\d\\d:\\d\\d.\\d\\d),([^,]*),([^,]*),(?:[^,]*,){4}([\\s\\S]*)$", "i"); function f(h = "") { return h.split(/[:.]/).map((p, v, g) => { if (v === g.length - 1) { if (p.length === 1) return `.${p}00`; if (p.length === 2) return `.${p}0` } else if (p.length === 1) return (v === 0 ? "0" : ":0") + p; return v === 0 ? p : v === g.length - 1 ? `.${p}` : `:${p}` }).join("") } return `WEBVTT ${c.split(/\r?\n/).map(h => {
          let p = h.match(u); return p ? {
            start: f(p[1].trim()), end: f(p[2].trim()), text: p[5].replace(/\{[\s\S]*?\}/g, "").replace(/(\\N)/g, `
`).trim().split(/\r?\n/).map(v => v.trim()).join(`
`)
          } : null
        }).filter(h => h).map((h, p) => h ? `${p + 1} ${h.start} --> ${h.end} ${h.text}` : "").filter(h => h.trim()).join(`

`)}`
      } s.defineInteropFlag(t), s.export(t, "srtToVtt", () => i), s.export(t, "vttToBlob", () => a), s.export(t, "assToVtt", () => o)
    }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], f7gsx: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(c = 0) { return new Promise(u => setTimeout(u, c)) } function a(c, u) { let f; return function (...h) { let p = () => (f = null, c.apply(this, h)); clearTimeout(f), f = setTimeout(p, u) } } function o(c, u) { let f = !1; return function (...h) { f || (c.apply(this, h), f = !0, setTimeout(() => { f = !1 }, u)) } } s.defineInteropFlag(t), s.export(t, "sleep", () => i), s.export(t, "debounce", () => a), s.export(t, "throttle", () => o) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], idCEj: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("option-validator"), a = s.interopDefault(i), o = n("../scheme"), c = n("./dom"), u = n("./error"); t.default = class { constructor(f) { this.id = 0, this.art = f, this.cache = new Map, this.add = this.add.bind(this), this.remove = this.remove.bind(this), this.update = this.update.bind(this) } get show() { return (0, c.hasClass)(this.art.template.$player, `art-${this.name}-show`) } set show(f) { let { $player: h } = this.art.template, p = `art-${this.name}-show`; f ? (0, c.addClass)(h, p) : (0, c.removeClass)(h, p), this.art.emit(this.name, f) } toggle() { this.show = !this.show } add(f) { let h = typeof f == "function" ? f(this.art) : f; if (h.html = h.html || "", (0, a.default)(h, o.ComponentOption), !this.$parent || !this.name || h.disable) return; let p = h.name || `${this.name}${this.id}`, v = this.cache.get(p); (0, u.errorHandle)(!v, `Can't add an existing [${p}] to the [${this.name}]`), this.id += 1; let g = (0, c.createElement)("div"); (0, c.addClass)(g, `art-${this.name}`), (0, c.addClass)(g, `art-${this.name}-${p}`); let y = Array.from(this.$parent.children); g.dataset.index = h.index || this.id; let w = y.find(S => Number(S.dataset.index) >= Number(g.dataset.index)); w ? w.insertAdjacentElement("beforebegin", g) : (0, c.append)(this.$parent, g), h.html && (0, c.append)(g, h.html), h.style && (0, c.setStyles)(g, h.style), h.tooltip && (0, c.tooltip)(g, h.tooltip); let T = []; if (h.click) { let S = this.art.events.proxy(g, "click", E => { E.preventDefault(), h.click.call(this.art, this, E) }); T.push(S) } return h.selector && ["left", "right"].includes(h.position) && this.selector(h, g, T), this[p] = g, this.cache.set(p, { $ref: g, events: T, option: h }), h.mounted && h.mounted.call(this.art, g), g } remove(f) { let h = this.cache.get(f); (0, u.errorHandle)(h, `Can't find [${f}] from the [${this.name}]`), h.option.beforeUnmount && h.option.beforeUnmount.call(this.art, h.$ref); for (let p = 0; p < h.events.length; p++)this.art.events.remove(h.events[p]); this.cache.delete(f), delete this[f], (0, c.remove)(h.$ref) } update(f) { let h = this.cache.get(f.name); return h && (f = Object.assign(h.option, f), this.remove(f.name)), this.add(f) } } }, { "option-validator": "g7VGh", "../scheme": "biLjm", "./dom": "eANXw", "./error": "4FwTI", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], biLjm: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "ComponentOption", () => v); var i = n("../utils"); let a = "array", o = "boolean", c = "string", u = "number", f = "object", h = "function"; function p(g, y, w) { return (0, i.errorHandle)(y === c || y === u || g instanceof Element, `${w.join(".")} require '${c}' or 'Element' type`) } let v = { html: p, disable: `?${o}`, name: `?${c}`, index: `?${u}`, style: `?${f}`, click: `?${h}`, mounted: `?${h}`, tooltip: `?${c}|${u}`, width: `?${u}`, selector: `?${a}`, onSelect: `?${h}`, switch: `?${o}`, onSwitch: `?${h}`, range: `?${a}`, onRange: `?${h}`, onChange: `?${h}` }; t.default = { id: c, container: p, url: c, poster: c, type: c, theme: c, lang: c, volume: u, isLive: o, muted: o, autoplay: o, autoSize: o, autoMini: o, loop: o, flip: o, playbackRate: o, aspectRatio: o, screenshot: o, setting: o, hotkey: o, pip: o, mutex: o, backdrop: o, fullscreen: o, fullscreenWeb: o, subtitleOffset: o, miniProgressBar: o, useSSR: o, playsInline: o, lock: o, gesture: o, fastForward: o, autoPlayback: o, autoOrientation: o, airplay: o, proxy: `?${h}`, plugins: [h], layers: [v], contextmenu: [v], settings: [v], controls: [{ ...v, position: (g, y, w) => { let T = ["top", "left", "right"]; return (0, i.errorHandle)(T.includes(g), `${w.join(".")} only accept ${T.toString()} as parameters`) } }], quality: [{ default: `?${o}`, html: c, url: c }], highlight: [{ time: u, text: c }], thumbnails: { url: c, number: u, column: u, width: u, height: u, scale: u }, subtitle: { url: c, name: c, type: c, style: f, escape: o, encoding: c, onVttLoad: h }, moreVideoAttr: f, i18n: f, icons: f, cssVar: f, customType: f } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "6XHP2": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => { let { i18n: u, constructor: { ASPECT_RATIO: f } } = c, h = f.map(p => `<span data-value="${p}">${p === "default" ? u.get("Default") : p}</span>`).join(""); return { ...o, html: `${u.get("Aspect Ratio")}: ${h}`, click: (p, v) => { let { value: g } = v.target.dataset; g && (c.aspectRatio = g, p.show = !1) }, mounted: p => { let v = (0, i.query)('[data-value="default"]', p); v && (0, i.inverseClass)(v, "art-current"), c.on("aspectRatio", g => { let y = (0, i.queryAll)("span", p).find(w => w.dataset.value === g); y && (0, i.inverseClass)(y, "art-current") }) } } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], eF6AX: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a) { return o => ({ ...a, html: o.i18n.get("Close"), click: c => { c.show = !1 } }) } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "7Wg1P": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => { let { i18n: u, constructor: { FLIP: f } } = c, h = f.map(p => `<span data-value="${p}">${u.get((0, i.capitalize)(p))}</span>`).join(""); return { ...o, html: `${u.get("Video Flip")}: ${h}`, click: (p, v) => { let { value: g } = v.target.dataset; g && (c.flip = g.toLowerCase(), p.show = !1) }, mounted: p => { let v = (0, i.query)('[data-value="normal"]', p); v && (0, i.inverseClass)(v, "art-current"), c.on("flip", g => { let y = (0, i.queryAll)("span", p).find(w => w.dataset.value === g); y && (0, i.inverseClass)(y, "art-current") }) } } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fjRnU: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a) { return o => ({ ...a, html: o.i18n.get("Video Info"), click: c => { o.info.show = !0, c.show = !1 } }) } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], hm1DY: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => { let { i18n: u, constructor: { PLAYBACK_RATE: f } } = c, h = f.map(p => `<span data-value="${p}">${p === 1 ? u.get("Normal") : p.toFixed(1)}</span>`).join(""); return { ...o, html: `${u.get("Play Speed")}: ${h}`, click: (p, v) => { let { value: g } = v.target.dataset; g && (c.playbackRate = Number(g), p.show = !1) }, mounted: p => { let v = (0, i.query)('[data-value="1"]', p); v && (0, i.inverseClass)(v, "art-current"), c.on("video:ratechange", () => { let g = (0, i.queryAll)("span", p).find(y => Number(y.dataset.value) === c.playbackRate); g && (0, i.inverseClass)(g, "art-current") }) } } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], aJBeL: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => function (a) { return { ...a, html: `<a href="https://artplayer.org" target="_blank">ArtPlayer ${i.version}</a>` } }); var i = n("../../package.json") }, { "../../package.json": "lh3R5", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], dp1yk: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("../utils"), a = n("../utils/component"), o = s.interopDefault(a), c = n("./airplay"), u = s.interopDefault(c), f = n("./fullscreen"), h = s.interopDefault(f), p = n("./fullscreenWeb"), v = s.interopDefault(p), g = n("./pip"), y = s.interopDefault(g), w = n("./playAndPause"), T = s.interopDefault(w), S = n("./progress"), E = s.interopDefault(S), I = n("./screenshot"), C = s.interopDefault(I), D = n("./setting"), R = s.interopDefault(D), N = n("./time"), P = s.interopDefault(N), _ = n("./volume"), M = s.interopDefault(_); class $ extends o.default { constructor(V) { super(V), this.isHover = !1, this.name = "control", this.timer = Date.now(); let { constructor: W } = V, { $player: U, $bottom: q } = this.art.template; V.on("mousemove", () => { i.isMobile || (this.show = !0) }), V.on("click", () => { i.isMobile ? this.toggle() : this.show = !0 }), V.on("document:mousemove", z => { this.isHover = (0, i.includeFromEvent)(z, q) }), V.on("video:timeupdate", () => { !V.setting.show && !this.isHover && !V.isInput && V.playing && this.show && Date.now() - this.timer >= W.CONTROL_HIDE_TIME && (this.show = !1) }), V.on("control", z => { z ? ((0, i.removeClass)(U, "art-hide-cursor"), (0, i.addClass)(U, "art-hover"), this.timer = Date.now()) : ((0, i.addClass)(U, "art-hide-cursor"), (0, i.removeClass)(U, "art-hover")) }), this.init() } init() { let { option: V } = this.art; V.isLive || this.add((0, E.default)({ name: "progress", position: "top", index: 10 })), this.add({ name: "thumbnails", position: "top", index: 20 }), this.add((0, T.default)({ name: "playAndPause", position: "left", index: 10 })), this.add((0, M.default)({ name: "volume", position: "left", index: 20 })), V.isLive || this.add((0, P.default)({ name: "time", position: "left", index: 30 })), V.quality.length && (0, i.sleep)().then(() => { this.art.quality = V.quality }), V.screenshot && !i.isMobile && this.add((0, C.default)({ name: "screenshot", position: "right", index: 20 })), V.setting && this.add((0, R.default)({ name: "setting", position: "right", index: 30 })), V.pip && this.add((0, y.default)({ name: "pip", position: "right", index: 40 })), V.airplay && window.WebKitPlaybackTargetAvailabilityEvent && this.add((0, u.default)({ name: "airplay", position: "right", index: 50 })), V.fullscreenWeb && this.add((0, v.default)({ name: "fullscreenWeb", position: "right", index: 60 })), V.fullscreen && this.add((0, h.default)({ name: "fullscreen", position: "right", index: 70 })); for (let W = 0; W < V.controls.length; W++)this.add(V.controls[W]) } add(V) { let W = typeof V == "function" ? V(this.art) : V, { $progress: U, $controlsLeft: q, $controlsRight: z } = this.art.template; switch (W.position) { case "top": this.$parent = U; break; case "left": this.$parent = q; break; case "right": this.$parent = z; break; default: (0, i.errorHandle)(!1, "Control option.position must one of 'top', 'left', 'right'") }super.add(W) } check(V) { V.$control_value.innerHTML = V.html; for (let W = 0; W < V.$control_option.length; W++) { let U = V.$control_option[W]; U.default = U === V, U.default && (0, i.inverseClass)(U.$control_item, "art-current") } } selector(V, W, U) { let { proxy: q } = this.art.events; (0, i.addClass)(W, "art-control-selector"); let z = (0, i.createElement)("div"); (0, i.addClass)(z, "art-selector-value"), (0, i.append)(z, V.html), W.textContent = "", (0, i.append)(W, z); let X = (0, i.createElement)("div"); (0, i.addClass)(X, "art-selector-list"), (0, i.append)(W, X); for (let F = 0; F < V.selector.length; F++) { let H = V.selector[F], ae = (0, i.createElement)("div"); (0, i.addClass)(ae, "art-selector-item"), H.default && (0, i.addClass)(ae, "art-current"), ae.dataset.index = F, ae.dataset.value = H.value, ae.innerHTML = H.html, (0, i.append)(X, ae), (0, i.def)(H, "$control_option", { get: () => V.selector }), (0, i.def)(H, "$control_item", { get: () => ae }), (0, i.def)(H, "$control_value", { get: () => z }) } let Z = q(X, "click", async F => { let H = (0, i.getComposedPath)(F), ae = V.selector.find(he => he.$control_item === H.find(de => he.$control_item === de)); this.check(ae), V.onSelect && (z.innerHTML = await V.onSelect.call(this.art, ae, ae.$control_item, F)) }); U.push(Z) } } t.default = $ }, { "../utils": "aBlEo", "../utils/component": "idCEj", "./airplay": "amOzz", "./fullscreen": "3GuBU", "./fullscreenWeb": "jj1KV", "./pip": "jMeHN", "./playAndPause": "u3h8M", "./progress": "1XZSS", "./screenshot": "dIscA", "./setting": "aqA0g", "./time": "ihweO", "./volume": "fJVWn", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], amOzz: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, tooltip: c.i18n.get("AirPlay"), mounted: u => { let { proxy: f, icons: h } = c; (0, i.append)(u, h.airplay), f(u, "click", () => c.airplay()) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "3GuBU": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, tooltip: c.i18n.get("Fullscreen"), mounted: u => { let { proxy: f, icons: h, i18n: p } = c, v = (0, i.append)(u, h.fullscreenOn), g = (0, i.append)(u, h.fullscreenOff); (0, i.setStyle)(g, "display", "none"), f(u, "click", () => { c.fullscreen = !c.fullscreen }), c.on("fullscreen", y => { y ? ((0, i.tooltip)(u, p.get("Exit Fullscreen")), (0, i.setStyle)(v, "display", "none"), (0, i.setStyle)(g, "display", "inline-flex")) : ((0, i.tooltip)(u, p.get("Fullscreen")), (0, i.setStyle)(v, "display", "inline-flex"), (0, i.setStyle)(g, "display", "none")) }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jj1KV: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, tooltip: c.i18n.get("Web Fullscreen"), mounted: u => { let { proxy: f, icons: h, i18n: p } = c, v = (0, i.append)(u, h.fullscreenWebOn), g = (0, i.append)(u, h.fullscreenWebOff); (0, i.setStyle)(g, "display", "none"), f(u, "click", () => { c.fullscreenWeb = !c.fullscreenWeb }), c.on("fullscreenWeb", y => { y ? ((0, i.tooltip)(u, p.get("Exit Web Fullscreen")), (0, i.setStyle)(v, "display", "none"), (0, i.setStyle)(g, "display", "inline-flex")) : ((0, i.tooltip)(u, p.get("Web Fullscreen")), (0, i.setStyle)(v, "display", "inline-flex"), (0, i.setStyle)(g, "display", "none")) }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jMeHN: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, tooltip: c.i18n.get("PIP Mode"), mounted: u => { let { proxy: f, icons: h, i18n: p } = c; (0, i.append)(u, h.pip), f(u, "click", () => { c.pip = !c.pip }), c.on("pip", v => { (0, i.tooltip)(u, p.get(v ? "Exit PIP Mode" : "PIP Mode")) }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], u3h8M: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, mounted: u => { let { proxy: f, icons: h, i18n: p } = c, v = (0, i.append)(u, h.play), g = (0, i.append)(u, h.pause); function y() { (0, i.setStyle)(v, "display", "flex"), (0, i.setStyle)(g, "display", "none") } function w() { (0, i.setStyle)(v, "display", "none"), (0, i.setStyle)(g, "display", "flex") } (0, i.tooltip)(v, p.get("Play")), (0, i.tooltip)(g, p.get("Pause")), f(v, "click", () => { c.play() }), f(g, "click", () => { c.pause() }), c.playing ? w() : y(), c.on("video:playing", () => { w() }), c.on("video:pause", () => { y() }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "1XZSS": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "getPosFromEvent", () => a), s.export(t, "setCurrentTime", () => o), s.export(t, "default", () => c); var i = n("../utils"); function a(u, f) { let { $progress: h } = u.template, { left: p } = (0, i.getRect)(h), v = i.isMobile ? f.touches[0].clientX : f.clientX, g = (0, i.clamp)(v - p, 0, h.clientWidth), y = g / h.clientWidth * u.duration, w = (0, i.secondToTime)(y), T = (0, i.clamp)(g / h.clientWidth, 0, 1); return { second: y, time: w, width: g, percentage: T } } function o(u, f) { if (u.isRotate) { let h = f.touches[0].clientY / u.height, p = h * u.duration; u.emit("setBar", "played", h, f), u.seek = p } else { let { second: h, percentage: p } = a(u, f); u.emit("setBar", "played", p, f), u.seek = h } } function c(u) { return f => { let { icons: h, option: p, proxy: v } = f; return { ...u, html: '<div class="art-control-progress-inner"><div class="art-progress-hover"></div><div class="art-progress-loaded"></div><div class="art-progress-played"></div><div class="art-progress-highlight"></div><div class="art-progress-indicator"></div><div class="art-progress-tip"></div></div>', mounted: g => { let y = null, w = !1, T = (0, i.query)(".art-progress-hover", g), S = (0, i.query)(".art-progress-loaded", g), E = (0, i.query)(".art-progress-played", g), I = (0, i.query)(".art-progress-highlight", g), C = (0, i.query)(".art-progress-indicator", g), D = (0, i.query)(".art-progress-tip", g); function R(N, P) { let { width: _, time: M } = P || a(f, N); D.textContent = M; let $ = D.clientWidth; _ <= $ / 2 ? (0, i.setStyle)(D, "left", 0) : _ > g.clientWidth - $ / 2 ? (0, i.setStyle)(D, "left", `${g.clientWidth - $}px`) : (0, i.setStyle)(D, "left", `${_ - $ / 2}px`) } h.indicator ? (0, i.append)(C, h.indicator) : (0, i.setStyle)(C, "backgroundColor", "var(--art-theme)"), f.on("setBar", function (N, P, _) { let M = N === "played" && _ && i.isMobile; N === "loaded" && (0, i.setStyle)(S, "width", `${100 * P}%`), N === "hover" && (0, i.setStyle)(T, "width", `${100 * P}%`), N === "played" && ((0, i.setStyle)(E, "width", `${100 * P}%`), (0, i.setStyle)(C, "left", `${100 * P}%`)), M && ((0, i.setStyle)(D, "display", "flex"), R(_, { width: g.clientWidth * P, time: (0, i.secondToTime)(P * f.duration) }), clearTimeout(y), y = setTimeout(() => { (0, i.setStyle)(D, "display", "none") }, 500)) }), f.on("video:loadedmetadata", function () { I.textContent = ""; for (let N = 0; N < p.highlight.length; N++) { let P = p.highlight[N], _ = (0, i.clamp)(P.time, 0, f.duration) / f.duration * 100, M = `<span data-text="${P.text}" data-time="${P.time}" style="left: ${_}%"></span>`; (0, i.append)(I, M) } }), f.constructor.USE_RAF ? f.on("raf", () => { f.emit("setBar", "played", f.played), f.emit("setBar", "loaded", f.loaded) }) : (f.on("video:timeupdate", () => { f.emit("setBar", "played", f.played) }), f.on("video:progress", () => { f.emit("setBar", "loaded", f.loaded) }), f.on("video:ended", () => { f.emit("setBar", "played", 1) })), f.emit("setBar", "loaded", f.loaded || 0), i.isMobile || (v(g, "click", N => { N.target !== C && o(f, N) }), v(g, "mousemove", N => { let { percentage: P } = a(f, N); if (f.emit("setBar", "hover", P, N), (0, i.setStyle)(D, "display", "flex"), (0, i.includeFromEvent)(N, I)) { let { width: _ } = a(f, N), { text: M } = N.target.dataset; D.textContent = M; let $ = D.clientWidth; _ <= $ / 2 ? (0, i.setStyle)(D, "left", 0) : _ > g.clientWidth - $ / 2 ? (0, i.setStyle)(D, "left", `${g.clientWidth - $}px`) : (0, i.setStyle)(D, "left", `${_ - $ / 2}px`) } else R(N) }), v(g, "mouseleave", N => { (0, i.setStyle)(D, "display", "none"), f.emit("setBar", "hover", 0, N) }), v(g, "mousedown", N => { w = N.button === 0 }), f.on("document:mousemove", N => { if (w) { let { second: P, percentage: _ } = a(f, N); f.emit("setBar", "played", _, N), f.seek = P } }), f.on("document:mouseup", () => { w && (w = !1) })) } } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], dIscA: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, tooltip: c.i18n.get("Screenshot"), mounted: u => { let { proxy: f, icons: h } = c; (0, i.append)(u, h.screenshot), f(u, "click", () => { c.screenshot() }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], aqA0g: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, tooltip: c.i18n.get("Show Setting"), mounted: u => { let { proxy: f, icons: h, i18n: p } = c; (0, i.append)(u, h.setting), f(u, "click", () => { c.setting.toggle(), c.setting.resize() }), c.on("setting", v => { (0, i.tooltip)(u, p.get(v ? "Hide Setting" : "Show Setting")) }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], ihweO: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, style: i.isMobile ? { fontSize: "12px", padding: "0 5px" } : { cursor: "auto", padding: "0 10px" }, mounted: u => { function f() { let p = `${(0, i.secondToTime)(c.currentTime)} / ${(0, i.secondToTime)(c.duration)}`; p !== u.textContent && (u.textContent = p) } f(); let h = ["video:loadedmetadata", "video:timeupdate", "video:progress"]; for (let p = 0; p < h.length; p++)c.on(h[p], f) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fJVWn: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return c => ({ ...o, mounted: u => { let { proxy: f, icons: h } = c, p = (0, i.append)(u, h.volume), v = (0, i.append)(u, h.volumeClose), g = (0, i.append)(u, '<div class="art-volume-panel"></div>'), y = (0, i.append)(g, '<div class="art-volume-inner"></div>'), w = (0, i.append)(y, '<div class="art-volume-val"></div>'), T = (0, i.append)(y, '<div class="art-volume-slider"></div>'), S = (0, i.append)(T, '<div class="art-volume-handle"></div>'), E = (0, i.append)(S, '<div class="art-volume-loaded"></div>'), I = (0, i.append)(T, '<div class="art-volume-indicator"></div>'); function C(R) { let { top: N, height: P } = (0, i.getRect)(T); return 1 - (R.clientY - N) / P } function D() { if (c.muted || c.volume === 0) (0, i.setStyle)(p, "display", "none"), (0, i.setStyle)(v, "display", "flex"), (0, i.setStyle)(I, "top", "100%"), (0, i.setStyle)(E, "top", "100%"), w.textContent = 0; else { let R = 100 * c.volume; (0, i.setStyle)(p, "display", "flex"), (0, i.setStyle)(v, "display", "none"), (0, i.setStyle)(I, "top", `${100 - R}%`), (0, i.setStyle)(E, "top", `${100 - R}%`), w.textContent = Math.floor(R) } } if (D(), c.on("video:volumechange", D), f(p, "click", () => { c.muted = !0 }), f(v, "click", () => { c.muted = !1 }), i.isMobile) (0, i.setStyle)(g, "display", "none"); else { let R = !1; f(T, "mousedown", N => { R = N.button === 0, c.volume = C(N) }), c.on("document:mousemove", N => { R && (c.muted = !1, c.volume = C(N)) }), c.on("document:mouseup", () => { R && (R = !1) }) } } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jmVSD: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./clickInit"), a = s.interopDefault(i), o = n("./gestureInit"), c = s.interopDefault(o), u = n("./globalInit"), f = s.interopDefault(u), h = n("./hoverInit"), p = s.interopDefault(h), v = n("./moveInit"), g = s.interopDefault(v), y = n("./resizeInit"), w = s.interopDefault(y), T = n("./updateInit"), S = s.interopDefault(T), E = n("./viewInit"), I = s.interopDefault(E); t.default = class { constructor(C) { this.destroyEvents = [], this.proxy = this.proxy.bind(this), this.hover = this.hover.bind(this), (0, a.default)(C, this), (0, p.default)(C, this), (0, g.default)(C, this), (0, w.default)(C, this), (0, c.default)(C, this), (0, I.default)(C, this), (0, f.default)(C, this), (0, S.default)(C, this) } proxy(C, D, R, N = {}) { if (Array.isArray(D)) return D.map(_ => this.proxy(C, _, R, N)); C.addEventListener(D, R, N); let P = () => C.removeEventListener(D, R, N); return this.destroyEvents.push(P), P } hover(C, D, R) { D && this.proxy(C, "mouseenter", D), R && this.proxy(C, "mouseleave", R) } remove(C) { let D = this.destroyEvents.indexOf(C); D > -1 && (C(), this.destroyEvents.splice(D, 1)) } destroy() { for (let C = 0; C < this.destroyEvents.length; C++)this.destroyEvents[C]() } } }, { "./clickInit": "i8G6V", "./gestureInit": "9wEzB", "./globalInit": "ikBrS", "./hoverInit": "jwNq0", "./moveInit": "eqSsP", "./resizeInit": "42JNz", "./updateInit": "7kM1M", "./viewInit": "2IW9m", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], i8G6V: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o, c) { let { constructor: u, template: { $player: f, $video: h } } = o; function p(g) { (0, i.includeFromEvent)(g, f) ? (o.isInput = g.target.tagName === "INPUT", o.isFocus = !0, o.emit("focus", g)) : (o.isInput = !1, o.isFocus = !1, o.emit("blur", g)) } o.on("document:click", p), o.on("document:contextmenu", p); let v = []; c.proxy(h, "click", g => { let y = Date.now(); v.push(y); let { MOBILE_CLICK_PLAY: w, DBCLICK_TIME: T, MOBILE_DBCLICK_PLAY: S, DBCLICK_FULLSCREEN: E } = u, I = v.filter(C => y - C <= T); switch (I.length) { case 1: o.emit("click", g), i.isMobile ? !o.isLock && w && o.toggle() : o.toggle(), v = I; break; case 2: o.emit("dblclick", g), i.isMobile ? !o.isLock && S && o.toggle() : E && (o.fullscreen = !o.fullscreen), v = []; break; default: v = [] } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "9wEzB": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => o); var i = n("../control/progress"), a = n("../utils"); function o(c, u) { if (a.isMobile && !c.option.isLive) { let { $video: f, $progress: h } = c.template, p = null, v = !1, g = 0, y = 0, w = 0, T = E => { if (E.touches.length === 1 && !c.isLock) { p === h && (0, i.setCurrentTime)(c, E), v = !0; let { pageX: I, pageY: C } = E.touches[0]; g = I, y = C, w = c.currentTime } }, S = E => { if (E.touches.length === 1 && v && c.duration) { let { pageX: I, pageY: C } = E.touches[0], D = (function (P, _, M, $) { let B = _ - $, V = M - P, W = 0; if (2 > Math.abs(V) && 2 > Math.abs(B)) return W; let U = 180 * Math.atan2(B, V) / Math.PI; return U >= -45 && U < 45 ? W = 4 : U >= 45 && U < 135 ? W = 1 : U >= -135 && U < -45 ? W = 2 : (U >= 135 && U <= 180 || U >= -180 && U < -135) && (W = 3), W })(g, y, I, C), R = [3, 4].includes(D), N = [1, 2].includes(D); if (R && !c.isRotate || N && c.isRotate) { let P = (0, a.clamp)((I - g) / c.width, -1, 1), _ = (0, a.clamp)((C - y) / c.height, -1, 1), M = c.isRotate ? _ : P, $ = p === f ? c.constructor.TOUCH_MOVE_RATIO : 1, B = (0, a.clamp)(w + c.duration * M * $, 0, c.duration); c.seek = B, c.emit("setBar", "played", (0, a.clamp)(B / c.duration, 0, 1), E), c.notice.show = `${(0, a.secondToTime)(B)} / ${(0, a.secondToTime)(c.duration)}` } } }; c.option.gesture && (u.proxy(f, "touchstart", E => { p = f, T(E) }), u.proxy(f, "touchmove", S)), u.proxy(h, "touchstart", E => { p = h, T(E) }), u.proxy(h, "touchmove", S), c.on("document:touchend", () => { v && (g = 0, y = 0, w = 0, v = !1, p = null) }) } } }, { "../control/progress": "1XZSS", "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], ikBrS: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a, o) { let c = ["click", "mouseup", "keydown", "touchend", "touchmove", "mousemove", "pointerup", "contextmenu", "pointermove", "visibilitychange", "webkitfullscreenchange"], u = ["resize", "scroll", "orientationchange"], f = []; function h(p = {}) { for (let g = 0; g < f.length; g++)o.remove(f[g]); f.length = 0; let { $player: v } = a.template; c.forEach(g => { let y = p.document || v.ownerDocument || document, w = o.proxy(y, g, T => { a.emit(`document:${g}`, T) }); f.push(w) }), u.forEach(g => { let y = p.window || v.ownerDocument?.defaultView || window, w = o.proxy(y, g, T => { a.emit(`window:${g}`, T) }); f.push(w) }) } h(), o.bindGlobalEvents = h } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jwNq0: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o, c) { let { $player: u } = o.template; c.hover(u, f => { (0, i.addClass)(u, "art-hover"), o.emit("hover", !0, f) }, f => { (0, i.removeClass)(u, "art-hover"), o.emit("hover", !1, f) }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], eqSsP: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a, o) { let { $player: c } = a.template; o.proxy(c, "mousemove", u => { a.emit("mousemove", u) }) } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "42JNz": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o, c) { let { option: u, constructor: f } = o; o.on("resize", () => { let { aspectRatio: p, notice: v } = o; o.state === "standard" && u.autoSize && o.autoSize(), o.aspectRatio = p, v.show = "" }); let h = (0, i.debounce)(() => o.emit("resize"), f.RESIZE_TIME); o.on("window:orientationchange", () => h()), o.on("window:resize", () => h()), screen && screen.orientation && screen.orientation.onchange && c.proxy(screen.orientation, "change", () => h()) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "7kM1M": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a) { if (a.constructor.USE_RAF) { let o = null; (function c() { a.playing && a.emit("raf"), a.isDestroy || (o = requestAnimationFrame(c)) })(), a.on("destroy", () => { cancelAnimationFrame(o) }) } } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "2IW9m": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { option: c, constructor: u, template: { $container: f } } = o, h = (0, i.throttle)(() => { o.emit("view", (0, i.isInViewport)(f, u.SCROLL_GAP)) }, u.SCROLL_TIME); o.on("window:scroll", () => h()), o.on("view", p => { c.autoMini && (o.mini = !p) }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], dswts: [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t); var s = n("./utils"); t.default = class { constructor(i) { this.art = i, this.keys = {}, i.option.hotkey && !s.isMobile && this.init() } init() { let { constructor: i } = this.art; this.add("Escape", () => { this.art.fullscreenWeb && (this.art.fullscreenWeb = !1) }), this.add("Space", () => { this.art.toggle() }), this.add("ArrowLeft", () => { this.art.backward = i.SEEK_STEP }), this.add("ArrowUp", () => { this.art.volume += i.VOLUME_STEP }), this.add("ArrowRight", () => { this.art.forward = i.SEEK_STEP }), this.add("ArrowDown", () => { this.art.volume -= i.VOLUME_STEP }), this.art.on("document:keydown", a => { if (this.art.isFocus) { let o = document.activeElement.tagName.toUpperCase(), c = document.activeElement.getAttribute("contenteditable"); if (o !== "INPUT" && o !== "TEXTAREA" && c !== "" && c !== "true" && !a.altKey && !a.ctrlKey && !a.metaKey && !a.shiftKey) { let u = this.keys[a.code]; if (u) { a.preventDefault(); for (let f = 0; f < u.length; f++)u[f].call(this.art, a); this.art.emit("hotkey", a) } } } this.art.emit("keydown", a) }) } add(i, a) { return this.keys[i] ? this.keys[i].push(a) : this.keys[i] = [a], this } remove(i, a) { if (this.keys[i]) { let o = this.keys[i].indexOf(a); o !== -1 && this.keys[i].splice(o, 1) } return this } } }, { "./utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], d9ktO: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("../utils"), a = n("./zh-cn"), o = s.interopDefault(a); t.default = class { constructor(c) { this.art = c, this.languages = { "zh-cn": o.default }, this.language = {}, this.update(c.option.i18n) } init() { let c = this.art.option.lang.toLowerCase(); this.language = this.languages[c] || {} } get(c) { return this.language[c] || c } update(c) { this.languages = (0, i.mergeDeep)(this.languages, c), this.init() } } }, { "../utils": "aBlEo", "./zh-cn": "3hyaR", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "3hyaR": [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t); let s = { "Video Info": "", Close: "", "Video Load Failed": "", Volume: "", Play: "", Pause: "", Rate: "", Mute: "", "Video Flip": "", Horizontal: "", Vertical: "", Reconnect: "", "Show Setting": "", "Hide Setting": "", Screenshot: "", "Play Speed": "", "Aspect Ratio": "", Default: "", Normal: "", Open: "", "Switch Video": "", "Switch Subtitle": "", Fullscreen: "", "Exit Fullscreen": "", "Web Fullscreen": "", "Exit Web Fullscreen": "", "Mini Player": "", "PIP Mode": "", "Exit PIP Mode": "", "PIP Not Supported": "", "Fullscreen Not Supported": "", "Subtitle Offset": "", "Last Seen": "", "Jump Play": "", AirPlay: "", "AirPlay Not Available": "" }; t.default = s, typeof window < "u" && (window["artplayer-i18n-zh-cn"] = s) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fFHY0: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("bundle-text:./airplay.svg"), a = s.interopDefault(i), o = n("bundle-text:./arrow-left.svg"), c = s.interopDefault(o), u = n("bundle-text:./arrow-right.svg"), f = s.interopDefault(u), h = n("bundle-text:./aspect-ratio.svg"), p = s.interopDefault(h), v = n("bundle-text:./check.svg"), g = s.interopDefault(v), y = n("bundle-text:./close.svg"), w = s.interopDefault(y), T = n("bundle-text:./config.svg"), S = s.interopDefault(T), E = n("bundle-text:./error.svg"), I = s.interopDefault(E), C = n("bundle-text:./flip.svg"), D = s.interopDefault(C), R = n("bundle-text:./fullscreen-off.svg"), N = s.interopDefault(R), P = n("bundle-text:./fullscreen-on.svg"), _ = s.interopDefault(P), M = n("bundle-text:./fullscreen-web-off.svg"), $ = s.interopDefault(M), B = n("bundle-text:./fullscreen-web-on.svg"), V = s.interopDefault(B), W = n("bundle-text:./loading.svg"), U = s.interopDefault(W), q = n("bundle-text:./lock.svg"), z = s.interopDefault(q), X = n("bundle-text:./pause.svg"), Z = s.interopDefault(X), F = n("bundle-text:./pip.svg"), H = s.interopDefault(F), ae = n("bundle-text:./play.svg"), he = s.interopDefault(ae), de = n("bundle-text:./playback-rate.svg"), pe = s.interopDefault(de), Ce = n("bundle-text:./screenshot.svg"), Ie = s.interopDefault(Ce), Pe = n("bundle-text:./setting.svg"), Ve = s.interopDefault(Pe), rt = n("bundle-text:./state.svg"), ft = s.interopDefault(rt), je = n("bundle-text:./switch-off.svg"), Oe = s.interopDefault(je), ot = n("bundle-text:./switch-on.svg"), Le = s.interopDefault(ot), ie = n("bundle-text:./unlock.svg"), _e = s.interopDefault(ie), qe = n("bundle-text:./volume-close.svg"), Ze = s.interopDefault(qe), vt = n("bundle-text:./volume.svg"), Et = s.interopDefault(vt), _t = n("../utils"); t.default = class { constructor(dr) { let Gr = { loading: U.default, state: ft.default, play: he.default, pause: Z.default, check: g.default, volume: Et.default, volumeClose: Ze.default, screenshot: Ie.default, setting: Ve.default, pip: H.default, arrowLeft: c.default, arrowRight: f.default, playbackRate: pe.default, aspectRatio: p.default, config: S.default, lock: z.default, flip: D.default, unlock: _e.default, fullscreenOff: N.default, fullscreenOn: _.default, fullscreenWebOff: $.default, fullscreenWebOn: V.default, switchOn: Le.default, switchOff: Oe.default, error: I.default, close: w.default, airplay: a.default, ...dr.option.icons }; for (let Zt in Gr) (0, _t.def)(this, Zt, { get: () => (0, _t.getIcon)(Zt, Gr[Zt]) }) } } }, { "bundle-text:./airplay.svg": "gkZgZ", "bundle-text:./arrow-left.svg": "kQyD4", "bundle-text:./arrow-right.svg": "64ztm", "bundle-text:./aspect-ratio.svg": "72LvA", "bundle-text:./check.svg": "4QmBo", "bundle-text:./close.svg": "j1hoe", "bundle-text:./config.svg": "hNZaT", "bundle-text:./error.svg": "dKh4l", "bundle-text:./flip.svg": "lIEIE", "bundle-text:./fullscreen-off.svg": "1533e", "bundle-text:./fullscreen-on.svg": "76ut3", "bundle-text:./fullscreen-web-off.svg": "3NzMk", "bundle-text:./fullscreen-web-on.svg": "12xHc", "bundle-text:./loading.svg": "iVcUF", "bundle-text:./lock.svg": "1J4so", "bundle-text:./pause.svg": "1KgkK", "bundle-text:./pip.svg": "4h4tM", "bundle-text:./play.svg": "jecAY", "bundle-text:./playback-rate.svg": "anPe9", "bundle-text:./screenshot.svg": "9BPYQ", "bundle-text:./setting.svg": "hsI9k", "bundle-text:./state.svg": "gr1ZU", "bundle-text:./switch-off.svg": "6kdAr", "bundle-text:./switch-on.svg": "ksdMo", "bundle-text:./unlock.svg": "iz5Qc", "bundle-text:./volume-close.svg": "3OZoa", "bundle-text:./volume.svg": "hRYA4", "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], gkZgZ: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path d="M16 1H2a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h3v-2H3V3h12v8h-2v2h3a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1"/><path d="M4 17h10l-5-6Z"/></svg>' }, {}], kQyD4: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path d="m19.41 20.09-4.58-4.59 4.58-4.59L18 9.5l-6 6 6 6Z"/></svg>' }, {}], "64ztm": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path d="m12.59 20.34 4.58-4.59-4.58-4.59L14 9.75l6 6-6 6Z"/></svg>' }, {}], "72LvA": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%;transform:translate(0)" viewBox="0 0 88 88"><defs><clipPath id="__lottie_element_216"><path d="M0 0h88v88H0Z"/></clipPath></defs><g clip-path="url(#__lottie_element_216)"><g style="display:block"><path d="m12.438-12.702-2.82 2.82c-.79.79-.79 2.05 0 2.83l7.07 7.07-7.07 7.07c-.79.79-.79 2.05 0 2.83l2.82 2.83c.79.78 2.05.78 2.83 1.4495849676166017e-7l11.32-11.31c.78-.78.78-2.05 0-2.83l-11.32-11.31C14.488-13.492 13.228-13.492 12.438-12.702m-24.88 0c-.74-.74-1.92-.78-2.7-.12l-.13.12-11.31 11.31a2 2 0 0 0-.12 2.7l.12.13 11.31 11.31a2 2 0 0 0 2.7.12l.13-.12 2.83-2.83c.74-.74.78-1.91.11-2.7l-.11-.13-7.07-7.07 7.07-7.07c.74-.74.78-1.91.11-2.7l-.11-.13ZM28-28c4.42 0 8 3.58 8 8v40c0 4.42-3.58 8-8 8h-56c-4.42 0-8-3.58-8-8v-40c0-4.42 3.58-8 8-8Z" style="--darkreader-inline-fill:#a8a6a4" transform="translate(44 44)"/></g></g></svg>' }, {}], "4QmBo": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%;height:100%" viewBox="0 0 24 24"><path d="M9 16.2 4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4Z"/></svg>' }, {}], j1hoe: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" class="icon" viewBox="0 0 1024 1024"><path d="m571.733 512 268.8-268.8c17.067-17.067 17.067-42.667 0-59.733C823.467 166.4 797.867 166.4 780.8 183.466L512 452.267l-268.8-268.8C226.133 166.4 200.533 166.4 183.467 183.466c-17.067 17.066-17.067 42.666 0 59.733l268.8 268.8-268.8 268.8c-17.067 17.067-17.067 42.667 0 59.733 8.533 8.534 19.2 12.8 29.866 12.8s21.334-4.266 29.867-12.8l268.8-268.8 268.8 268.8c8.533 8.534 19.2 12.8 29.867 12.8s21.333-4.266 29.866-12.8c17.067-17.066 17.067-42.666 0-59.733Z"/></svg>' }, {}], hNZaT: [function (n, e, t, r) { e.exports = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M15 17h6v1h-6Zm-4 0H3v1h8v2h1v-5h-1Zm3-9h1V3h-1v2H3v1h11Zm4-3v1h3V5ZM6 14h1V9H6v2H3v1h3Zm4-2h11v-1H10Z" style="--darkreader-inline-fill:#a8a6a4"/></svg>' }, {}], dKh4l: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 1024 1024"><path d="M593.818 168.55 949.82 763.76c26.153 43.746 10.732 99.738-34.447 125.052-14.397 8.069-30.72 12.308-47.37 12.308H155.976c-52.224 0-94.536-40.96-94.536-91.505 0-16.097 4.383-31.928 12.718-45.875l356.004-595.19c26.173-43.724 84.009-58.654 129.208-33.341a93.1 93.1 0 0 1 34.447 33.341M512 819.2a61.44 61.44 0 1 0 0-122.88 61.44 61.44 0 0 0 0 122.88m0-512a72.315 72.315 0 0 0-71.762 81.306l25.723 205.721a46.408 46.408 0 0 0 92.078 0l25.723-205.742A72.315 72.315 0 0 0 512 307.2"/></svg>' }, {}], lIEIE: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" class="icon" viewBox="0 0 1024 1024"><path d="M554.667 810.667V896h-85.333v-85.333Zm-384-632.662a42.67 42.67 0 0 1 34.987 18.219l203.903 291.328a42.67 42.67 0 0 1 0 48.896L205.611 827.776A42.667 42.667 0 0 1 128 803.328V220.672a42.667 42.667 0 0 1 42.667-42.667m682.666 0a42.667 42.667 0 0 1 42.368 37.717l.299 4.95v582.656a42.667 42.667 0 0 1-74.24 28.63l-3.413-4.182-203.904-291.328a42.67 42.67 0 0 1-3.03-43.861l3.03-5.035 203.946-291.328a42.67 42.67 0 0 1 34.944-18.219M554.667 640v85.333h-85.333V640Zm-358.4-320.896V716.8L335.957 512 196.31 319.104Zm358.4 150.23v85.333h-85.333v-85.333Zm0-170.667V384h-85.333v-85.333Zm0-170.667v85.333h-85.333V128Z"/></svg>' }, {}], "1533e": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" class="icon" viewBox="0 0 1024 1024"><path d="M768 298.667h170.667V384h-256V128H768ZM341.333 384h-256v-85.333H256V128h85.333ZM768 725.333V896h-85.333V640h256v85.333ZM341.333 640v256H256V725.333H85.333V640Z"/></svg>' }, {}], "76ut3": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" class="icon" viewBox="0 0 1024 1024"><path d="M625.778 256H768v142.222h113.778v-256h-256ZM256 398.222V256h142.222V142.222h-256v256Zm512 227.556V768H625.778v113.778h256v-256ZM398.222 768H256V625.778H142.222v256h256Z"/></svg>' }, {}], "3NzMk": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" class="icon" viewBox="0 0 1152 1024"><path d="M1075.2 0H76.8A76.8 76.8 0 0 0 0 76.8v870.4a76.8 76.8 0 0 0 76.8 76.8h998.4a76.8 76.8 0 0 0 76.8-76.8V76.8A76.8 76.8 0 0 0 1075.2 0M1024 128v768H128V128ZM896 512a64 64 0 0 1 7.488 127.552L896 640H768v128a64 64 0 0 1-56.512 63.552L704 832a64 64 0 0 1-63.552-56.512L640 768V582.592c0-34.496 25.024-66.112 61.632-70.208l8-.384Zm-640 0a64 64 0 0 1-7.488-127.552L256 384h128V256a64 64 0 0 1 56.512-63.552L448 192a64 64 0 0 1 63.552 56.512L512 256v185.408c0 34.432-25.024 66.112-61.632 70.144l-8 .448Z"/></svg>' }, {}], "12xHc": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" class="icon" viewBox="0 0 1152 1024"><path d="M1075.2 0H76.8A76.8 76.8 0 0 0 0 76.8v870.4a76.8 76.8 0 0 0 76.8 76.8h998.4a76.8 76.8 0 0 0 76.8-76.8V76.8A76.8 76.8 0 0 0 1075.2 0M1024 128v768H128V128Zm-576 64a64 64 0 0 1 7.488 127.552L448 320H320v128a64 64 0 0 1-56.512 63.552L256 512a64 64 0 0 1-63.552-56.512L192 448V262.592c0-34.432 25.024-66.112 61.632-70.144l8-.448Zm256 640a64 64 0 0 1-7.488-127.552L704 704h128V576a64 64 0 0 1 56.512-63.552L896 512a64 64 0 0 1 63.552 56.512L960 576v185.408c0 34.496-25.024 66.112-61.632 70.208l-8 .384Z"/></svg>' }, {}], iVcUF: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" class="uil-default" preserveAspectRatio="xMidYMid" viewBox="0 0 100 100"><path fill="none" d="M0 0h100v100H0Z" class="bk"/><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="translate(0 -30)"><animate attributeName="opacity" begin="-1s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(30 105.98 65)"><animate attributeName="opacity" begin="-0.9166666666666666s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(60 75.98 65)"><animate attributeName="opacity" begin="-0.8333333333333334s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(90 65 65)"><animate attributeName="opacity" begin="-0.75s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(120 58.66 65)"><animate attributeName="opacity" begin="-0.6666666666666666s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(150 54.02 65)"><animate attributeName="opacity" begin="-0.5833333333333334s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="matrix(-1 0 0 -1 100 130)"><animate attributeName="opacity" begin="-0.5s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(210 45.98 65)"><animate attributeName="opacity" begin="-0.4166666666666667s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(240 41.34 65)"><animate attributeName="opacity" begin="-0.3333333333333333s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(-90 35 65)"><animate attributeName="opacity" begin="-0.25s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(-60 24.02 65)"><animate attributeName="opacity" begin="-0.16666666666666666s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect><rect width="6" height="20" x="47" y="40" rx="5" ry="5" transform="rotate(-30 -5.98 65)"><animate attributeName="opacity" begin="-0.08333333333333333s" dur="1s" from="1" repeatCount="indefinite" to="0"/></rect></svg>' }, {}], "1J4so": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" class="icon" viewBox="0 0 1024 1024"><path d="M298.667 426.667v-85.333a213.333 213.333 0 1 1 426.667 0v85.333H768A85.333 85.333 0 0 1 853.333 512v256A85.333 85.333 0 0 1 768 853.333H256A85.333 85.333 0 0 1 170.667 768V512A85.333 85.333 0 0 1 256 426.667ZM512 213.333a128 128 0 0 0-128 128v85.333h256v-85.333a128 128 0 0 0-128-128"/></svg>' }, {}], "1KgkK": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22"><path d="M7 3a2 2 0 0 0-2 2v12a2 2 0 1 0 4 0V5a2 2 0 0 0-2-2m8 0a2 2 0 0 0-2 2v12a2 2 0 1 0 4 0V5a2 2 0 0 0-2-2"/></svg>' }, {}], "4h4tM": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 1024 1024"><path d="M844.8 219.648H179.2c-6.144 0-10.24 4.608-10.24 10.752v563.2c0 5.632 4.096 10.24 10.24 10.24h256V896h-256A102.4 102.4 0 0 1 76.8 793.6V230.4c0-56.832 45.568-102.4 102.4-102.4h665.6a102.4 102.4 0 0 1 102.4 102.4v204.8h-92.16V230.4c0-6.144-4.608-10.752-10.24-10.752M614.4 588.8c-28.672 0-51.2 22.528-51.2 51.2v204.8c0 28.16 22.528 51.2 51.2 51.2H896c28.16 0 51.2-23.04 51.2-51.2V640c0-28.672-23.04-51.2-51.2-51.2Z"/></svg>' }, {}], jecAY: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22"><path d="M17.982 9.275 8.06 3.27A2.013 2.013 0 0 0 5 4.994v12.011a2.017 2.017 0 0 0 3.06 1.725l9.922-6.005a2.017 2.017 0 0 0 0-3.45"/></svg>' }, {}], anPe9: [function (n, e, t, r) { e.exports = '<svg width="24" height="24" viewBox="0 0 24 24"><path d="M10 8v8l6-4ZM6.3 5l-.6-.8C7.2 3 9 2.2 11 2l.1 1c-1.8.2-3.4.9-4.8 2M5 6.3l-.8-.6C3 7.2 2.2 9 2 11l1 .1c.2-1.8.9-3.4 2-4.8m0 11.4c-1.1-1.4-1.8-3.1-2-4.8L2 13c.2 2 1 3.8 2.2 5.4Zm6.1 3.3c-1.8-.2-3.4-.9-4.8-2l-.6.8C7.2 21 9 21.8 11 22ZM22 12c0-5.2-3.9-9.4-9-10l-.1 1c4.6.5 8.1 4.3 8.1 9s-3.5 8.5-8.1 9l.1 1c5.2-.5 9-4.8 9-10" style="--darkreader-inline-fill:#a8a6a4"/></svg>' }, {}], "9BPYQ": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 50 50"><path d="M19.402 6a5 5 0 0 0-4.902 4.012L14.098 12H9a5 5 0 0 0-5 5v21a5 5 0 0 0 5 5h32a5 5 0 0 0 5-5V17a5 5 0 0 0-5-5h-5.098l-.402-1.988A5 5 0 0 0 30.598 6ZM25 17c5.52 0 10 4.48 10 10s-4.48 10-10 10-10-4.48-10-10 4.48-10 10-10m0 2c-4.41 0-8 3.59-8 8s3.59 8 8 8 8-3.59 8-8-3.59-8-8-8"/></svg>' }, {}], hsI9k: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22"><circle cx="11" cy="11" r="2"/><path d="M19.164 8.861 17.6 8.6a7 7 0 0 0-1.186-2.099l.574-1.533a1 1 0 0 0-.436-1.217l-1.997-1.153a1 1 0 0 0-1.272.23l-1.008 1.225a7 7 0 0 0-2.55.001L8.716 2.829a1 1 0 0 0-1.272-.23L5.447 3.751a1 1 0 0 0-.436 1.217l.574 1.533A7 7 0 0 0 4.4 8.6l-1.564.261A1 1 0 0 0 2 9.847v2.306c0 .489.353.906.836.986l1.613.269a7 7 0 0 0 1.228 2.075l-.558 1.487a1 1 0 0 0 .436 1.217l1.997 1.153c.423.244.961.147 1.272-.23l1.04-1.263a7.1 7.1 0 0 0 2.272 0l1.04 1.263a1 1 0 0 0 1.272.23l1.997-1.153a1 1 0 0 0 .436-1.217l-.557-1.487c.521-.61.94-1.31 1.228-2.075l1.613-.269a1 1 0 0 0 .835-.986V9.847a1 1 0 0 0-.836-.986M11 15a4 4 0 1 1 0-8 4 4 0 0 1 0 8"/></svg>' }, {}], gr1ZU: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 24 24"><path d="M9.5 9.325v5.35q0 .575.525.875t1.025-.05l4.15-2.65q.475-.3.475-.85t-.475-.85L11.05 8.5q-.5-.35-1.025-.05t-.525.875M12 22q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12t.788-3.9 2.137-3.175q1.35-1.35 3.175-2.137T12 2t3.9.788 3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22"/></svg>' }, {}], "6kdAr": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" class="icon" viewBox="0 0 1740 1024"><path d="M511.898 1024h670.515c282.419-.41 511.18-229.478 511.18-511.898 0-282.419-228.761-511.488-511.18-511.897H511.898C229.478.615.717 229.683.717 512.102c0 282.42 228.761 511.488 511.18 511.898m-.564-975.36A464.589 464.589 0 1 1 48.025 513.024 463.87 463.87 0 0 1 511.335 48.435Z"/></svg>' }, {}], ksdMo: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" class="icon" viewBox="0 0 1664 1024"><path fill="#648ffc" d="M1152 0H512a512 512 0 0 0 0 1024h640a512 512 0 0 0 0-1024m0 960a448 448 0 1 1 448-448 448 448 0 0 1-448 448"/></svg>' }, {}], iz5Qc: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" class="icon" viewBox="0 0 1024 1024"><path d="m666.752 194.517-49.365 74.112A128 128 0 0 0 384 341.333l.043 85.334h384A85.333 85.333 0 0 1 853.376 512v256a85.333 85.333 0 0 1-85.333 85.333H256A85.333 85.333 0 0 1 170.667 768V512A85.333 85.333 0 0 1 256 426.667h42.667v-85.333a213.333 213.333 0 0 1 368.085-146.816"/></svg>' }, {}], "3OZoa": [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22"><path d="M15 11a4 4 0 0 0-2-3.465v2.636l1.865 1.865A4 4 0 0 0 15 11"/><path d="M13.583 5.583A6 6 0 0 1 17 11a6 6 0 0 1-.585 2.587l1.477 1.477a8 8 0 0 0-3.446-11.286 1 1 0 0 0-.863 1.805m5.195 13.195-2.121-2.121-1.414-1.414-1.415-1.415L13 13l-2-2-3.889-3.889-3.889-3.889a.999.999 0 1 0-1.414 1.414L5.172 8H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h1l4.188 3.35a.5.5 0 0 0 .812-.39v-3.131l2.587 2.587-.01.005a1 1 0 0 0 .86 1.806q.322-.154.627-.333l2.3 2.3a1.001 1.001 0 0 0 1.414-1.416M11 5.04a.5.5 0 0 0-.813-.39L8.682 5.854 11 8.172Z"/></svg>' }, {}], hRYA4: [function (n, e, t, r) { e.exports = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22"><path d="M10.188 4.65 6 8H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h1l4.188 3.35a.5.5 0 0 0 .812-.39V5.04a.498.498 0 0 0-.812-.39m4.258-.872a1 1 0 0 0-.862 1.804 6.002 6.002 0 0 1-.007 10.838 1 1 0 0 0 .86 1.806A8 8 0 0 0 19 11a8 8 0 0 0-4.554-7.222"/><path d="M15 11a4 4 0 0 0-2-3.465v6.93A4 4 0 0 0 15 11"/></svg>' }, {}], kZ0F8: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./utils"), a = n("./utils/component"), o = s.interopDefault(a); class c extends o.default { constructor(f) { super(f), this.name = "info", i.isMobile || this.init() } init() { let { proxy: f, constructor: h, template: { $infoPanel: p, $infoClose: v, $video: g } } = this.art; f(v, "click", () => { this.show = !1 }); let y = null, w = (0, i.queryAll)("[data-video]", p) || []; this.art.on("destroy", () => clearTimeout(y)), (function T() { for (let S = 0; S < w.length; S++) { let E = w[S], I = g[E.dataset.video], C = typeof I == "number" ? I.toFixed(2) : I; E.textContent !== C && (E.textContent = C) } y = setTimeout(T, h.INFO_LOOP_TIME) })() } } t.default = c }, { "./utils": "aBlEo", "./utils/component": "idCEj", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], j9lbi: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./utils/component"), a = s.interopDefault(i); class o extends a.default { constructor(u) { super(u); let { option: f, template: { $layer: h } } = u; this.name = "layer", this.$parent = h; for (let p = 0; p < f.layers.length; p++)this.add(f.layers[p]) } } t.default = o }, { "./utils/component": "idCEj", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], bMjWd: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./utils"), a = n("./utils/component"), o = s.interopDefault(a); class c extends o.default { constructor(f) { super(f), this.name = "loading", (0, i.append)(f.template.$loading, f.icons.loading) } } t.default = c }, { "./utils": "aBlEo", "./utils/component": "idCEj", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], k1nkQ: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./utils"), a = n("./utils/component"), o = s.interopDefault(a); class c extends o.default { constructor(f) { super(f), this.name = "mask"; let { template: h, icons: p, events: v } = f, g = (0, i.append)(h.$state, p.state), y = (0, i.append)(h.$state, p.error); (0, i.setStyle)(y, "display", "none"), f.on("destroy", () => { (0, i.setStyle)(g, "display", "none"), (0, i.setStyle)(y, "display", null) }), v.proxy(h.$state, "click", () => f.play()) } } t.default = c }, { "./utils": "aBlEo", "./utils/component": "idCEj", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fPVaU: [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t); var s = n("./utils"); t.default = class { constructor(i) { this.art = i, this.timer = null } set show(i) { let { constructor: a, template: { $player: o, $noticeInner: c } } = this.art; i ? (c.textContent = i instanceof Error ? i.message.trim() : i, (0, s.addClass)(o, "art-notice-show"), clearTimeout(this.timer), this.timer = setTimeout(() => { c.textContent = "", (0, s.removeClass)(o, "art-notice-show") }, a.NOTICE_TIME)) : (0, s.removeClass)(o, "art-notice-show") } get show() { let { template: { $player: i } } = this.art; return i.classList.contains("art-notice-show") } } }, { "./utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], uR0Sw: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("./airplayMix"), a = s.interopDefault(i), o = n("./aspectRatioMix"), c = s.interopDefault(o), u = n("./attrMix"), f = s.interopDefault(u), h = n("./autoHeightMix"), p = s.interopDefault(h), v = n("./autoSizeMix"), g = s.interopDefault(v), y = n("./cssVarMix"), w = s.interopDefault(y), T = n("./currentTimeMix"), S = s.interopDefault(T), E = n("./durationMix"), I = s.interopDefault(E), C = n("./eventInit"), D = s.interopDefault(C), R = n("./flipMix"), N = s.interopDefault(R), P = n("./fullscreenMix"), _ = s.interopDefault(P), M = n("./fullscreenWebMix"), $ = s.interopDefault(M), B = n("./loadedMix"), V = s.interopDefault(B), W = n("./miniMix"), U = s.interopDefault(W), q = n("./optionInit"), z = s.interopDefault(q), X = n("./pauseMix"), Z = s.interopDefault(X), F = n("./pipMix"), H = s.interopDefault(F), ae = n("./playbackRateMix"), he = s.interopDefault(ae), de = n("./playedMix"), pe = s.interopDefault(de), Ce = n("./playingMix"), Ie = s.interopDefault(Ce), Pe = n("./playMix"), Ve = s.interopDefault(Pe), rt = n("./posterMix"), ft = s.interopDefault(rt), je = n("./qualityMix"), Oe = s.interopDefault(je), ot = n("./rectMix"), Le = s.interopDefault(ot), ie = n("./screenshotMix"), _e = s.interopDefault(ie), qe = n("./seekMix"), Ze = s.interopDefault(qe), vt = n("./stateMix"), Et = s.interopDefault(vt), _t = n("./subtitleOffsetMix"), dr = s.interopDefault(_t), Gr = n("./switchMix"), Zt = s.interopDefault(Gr), Fn = n("./themeMix"), $n = s.interopDefault(Fn), Ts = n("./thumbnailsMix"), Hr = s.interopDefault(Ts), fr = n("./toggleMix"), Xc = s.interopDefault(fr), go = n("./typeMix"), xo = s.interopDefault(go), Qc = n("./urlMix"), Ki = s.interopDefault(Qc), qi = n("./volumeMix"), Yi = s.interopDefault(qi); t.default = class { constructor(Ue) { (0, Ki.default)(Ue), (0, f.default)(Ue), (0, Ve.default)(Ue), (0, Z.default)(Ue), (0, Xc.default)(Ue), (0, Ze.default)(Ue), (0, Yi.default)(Ue), (0, S.default)(Ue), (0, I.default)(Ue), (0, Zt.default)(Ue), (0, he.default)(Ue), (0, c.default)(Ue), (0, _e.default)(Ue), (0, _.default)(Ue), (0, $.default)(Ue), (0, H.default)(Ue), (0, V.default)(Ue), (0, pe.default)(Ue), (0, Ie.default)(Ue), (0, g.default)(Ue), (0, Le.default)(Ue), (0, N.default)(Ue), (0, U.default)(Ue), (0, ft.default)(Ue), (0, p.default)(Ue), (0, w.default)(Ue), (0, $n.default)(Ue), (0, xo.default)(Ue), (0, Et.default)(Ue), (0, dr.default)(Ue), (0, a.default)(Ue), (0, Oe.default)(Ue), (0, Hr.default)(Ue), (0, D.default)(Ue), (0, z.default)(Ue) } } }, { "./airplayMix": "d8BTB", "./aspectRatioMix": "aQNJl", "./attrMix": "5DA9e", "./autoHeightMix": "1swKn", "./autoSizeMix": "lSbiD", "./cssVarMix": "32Hp1", "./currentTimeMix": "kfZbu", "./durationMix": "eV1ag", "./eventInit": "f8NQq", "./flipMix": "ea3Qm", "./fullscreenMix": "ffXE3", "./fullscreenWebMix": "8tarF", "./loadedMix": "f9syH", "./miniMix": "dLuS7", "./optionInit": "d1F69", "./pauseMix": "kewk9", "./pipMix": "4XzDs", "./playbackRateMix": "jphfi", "./playedMix": "iNpeS", "./playingMix": "aBIWL", "./playMix": "hRBri", "./posterMix": "fgfXC", "./qualityMix": "17rUP", "./rectMix": "55qzI", "./screenshotMix": "bC6TG", "./seekMix": "j8GRO", "./stateMix": "cn7iR", "./subtitleOffsetMix": "2k4nP", "./switchMix": "6SU6j", "./themeMix": "7iMuh", "./thumbnailsMix": "6P0RS", "./toggleMix": "eNi78", "./typeMix": "7AUBD", "./urlMix": "cnlLL", "./volumeMix": "iX66j", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], d8BTB: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { i18n: c, notice: u, proxy: f, template: { $video: h } } = o, p = !0; window.WebKitPlaybackTargetAvailabilityEvent && h.webkitShowPlaybackTargetPicker ? f(h, "webkitplaybacktargetavailabilitychanged", v => { switch (v.availability) { case "available": p = !0; break; case "not-available": p = !1 } }) : p = !1, (0, i.def)(o, "airplay", { value() { p ? (h.webkitShowPlaybackTargetPicker(), o.emit("airplay")) : u.show = c.get("AirPlay Not Available") } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], aQNJl: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { i18n: c, notice: u, template: { $video: f, $player: h } } = o; (0, i.def)(o, "aspectRatio", { get: () => h.dataset.aspectRatio || "default", set(p) { if (p || (p = "default"), p === "default") (0, i.setStyle)(f, "width", null), (0, i.setStyle)(f, "height", null), (0, i.setStyle)(f, "margin", null), delete h.dataset.aspectRatio; else { let v = p.split(":").map(Number), { clientWidth: g, clientHeight: y } = h, w = v[0] / v[1]; g / y > w ? ((0, i.setStyle)(f, "width", `${w * y}px`), (0, i.setStyle)(f, "height", "100%"), (0, i.setStyle)(f, "margin", "0 auto")) : ((0, i.setStyle)(f, "width", "100%"), (0, i.setStyle)(f, "height", `${g / w}px`), (0, i.setStyle)(f, "margin", "auto 0")), h.dataset.aspectRatio = p } u.show = `${c.get("Aspect Ratio")}: ${p === "default" ? c.get("Default") : p}`, o.emit("aspectRatio", p) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "5DA9e": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $video: c } } = o; (0, i.def)(o, "attr", { value(u, f) { if (f === void 0) return c[u]; c[u] = f } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "1swKn": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $container: c, $video: u } } = o; (0, i.def)(o, "autoHeight", { value() { let { clientWidth: f } = c, { videoHeight: h, videoWidth: p } = u, v = f / p * h; (0, i.setStyle)(c, "height", `${v}px`), o.emit("autoHeight", v) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], lSbiD: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { $container: c, $player: u, $video: f } = o.template; (0, i.def)(o, "autoSize", { value() { let { videoWidth: h, videoHeight: p } = f, { width: v, height: g } = (0, i.getRect)(c), y = h / p; v / g > y ? ((0, i.setStyle)(u, "width", `${g * y / v * 100}%`), (0, i.setStyle)(u, "height", "100%")) : ((0, i.setStyle)(u, "width", "100%"), (0, i.setStyle)(u, "height", `${v / y / g * 100}%`)), o.emit("autoSize", { width: o.width, height: o.height }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "32Hp1": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { $player: c } = o.template; (0, i.def)(o, "cssVar", { value: (u, f) => f ? c.style.setProperty(u, f) : getComputedStyle(c).getPropertyValue(u) }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], kfZbu: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { $video: c } = o.template; (0, i.def)(o, "currentTime", { get: () => c.currentTime || 0, set: u => { Number.isNaN(u = Number.parseFloat(u)) || (c.currentTime = (0, i.clamp)(u, 0, o.duration)) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], eV1ag: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "duration", { get: () => { let { duration: c } = o.template.$video; return c === 1 / 0 ? 0 : c || 0 } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], f8NQq: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => c); var i = n("../config"), a = s.interopDefault(i), o = n("../utils"); function c(u) { let { i18n: f, notice: h, option: p, constructor: v, proxy: g, template: { $player: y, $video: w, $poster: T } } = u, S = 0; for (let E = 0; E < a.default.events.length; E++)g(w, a.default.events[E], I => { u.emit(`video:${I.type}`, I) }); u.on("video:canplay", () => { S = 0, u.loading.show = !1 }), u.once("video:canplay", () => { u.loading.show = !1, u.controls.show = !0, u.mask.show = !0, u.isReady = !0, u.emit("ready") }), u.on("video:ended", () => { p.loop ? (u.seek = 0, u.play(), u.controls.show = !1, u.mask.show = !1) : (u.controls.show = !0, u.mask.show = !0) }), u.on("video:error", async E => { S < v.RECONNECT_TIME_MAX ? (await (0, o.sleep)(v.RECONNECT_SLEEP_TIME), S += 1, u.url = p.url, h.show = `${f.get("Reconnect")}: ${S}`, u.emit("error", E, S)) : (u.mask.show = !0, u.loading.show = !1, u.controls.show = !0, (0, o.addClass)(y, "art-error"), await (0, o.sleep)(v.RECONNECT_SLEEP_TIME), h.show = f.get("Video Load Failed")) }), u.on("video:loadedmetadata", () => { u.emit("resize"), o.isMobile && (u.loading.show = !1, u.controls.show = !0, u.mask.show = !0) }), u.on("video:loadstart", () => { u.loading.show = !0, u.mask.show = !1, u.controls.show = !0 }), u.on("video:pause", () => { u.controls.show = !0, u.mask.show = !0 }), u.on("video:play", () => { u.mask.show = !1, (0, o.setStyle)(T, "display", "none") }), u.on("video:playing", () => { u.mask.show = !1 }), u.on("video:progress", () => { u.playing && (u.loading.show = !1) }), u.on("video:seeked", () => { u.loading.show = !1, u.mask.show = !0 }), u.on("video:seeking", () => { u.loading.show = !0, u.mask.show = !1 }), u.on("video:timeupdate", () => { u.mask.show = !1 }), u.on("video:waiting", () => { u.loading.show = !0, u.mask.show = !1 }) } }, { "../config": "eJfh8", "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], ea3Qm: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $player: c }, i18n: u, notice: f } = o; (0, i.def)(o, "flip", { get: () => c.dataset.flip || "normal", set(h) { h || (h = "normal"), h === "normal" ? delete c.dataset.flip : c.dataset.flip = h, f.show = `${u.get("Video Flip")}: ${u.get((0, i.capitalize)(h))}`, o.emit("flip", h) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], ffXE3: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => c); var i = n("../libs/screenfull"), a = s.interopDefault(i), o = n("../utils"); function c(u) { let { i18n: f, notice: h, template: { $video: p, $player: v } } = u; u.once("video:loadedmetadata", () => { a.default.isEnabled ? (a.default.on("change", () => { u.emit("fullscreen", a.default.isFullscreen), a.default.isFullscreen ? (u.state = "fullscreen", (0, o.addClass)(v, "art-fullscreen")) : (0, o.removeClass)(v, "art-fullscreen"), u.emit("resize") }), a.default.on("error", g => { u.emit("fullscreenError", g) }), (0, o.def)(u, "fullscreen", { get: () => a.default.isFullscreen, async set(g) { g ? await a.default.request(v) : await a.default.exit() } })) : p.webkitSupportsFullscreen ? (u.on("document:webkitfullscreenchange", () => { u.emit("fullscreen", u.fullscreen), u.emit("resize") }), (0, o.def)(u, "fullscreen", { get: () => document.fullscreenElement === p, set(g) { g ? (u.state = "fullscreen", p.webkitEnterFullscreen()) : p.webkitExitFullscreen() } })) : (0, o.def)(u, "fullscreen", { get: () => !1, set() { h.show = f.get("Fullscreen Not Supported") } }), (0, o.def)(u, "fullscreen", (0, o.get)(u, "fullscreen")) }) } }, { "../libs/screenfull": "iSPAQ", "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], iSPAQ: [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t); let s = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]], i = (() => { if (typeof document > "u") return !1; let c = s[0], u = {}; for (let f of s) if (f[1] in document) { for (let [h, p] of f.entries()) u[c[h]] = p; return u } return !1 })(), a = { change: i.fullscreenchange, error: i.fullscreenerror }, o = { request: (c = document.documentElement, u) => new Promise((f, h) => { let p = () => { o.off("change", p), f() }; o.on("change", p); let v = c[i.requestFullscreen](u); v instanceof Promise && v.then(p).catch(h) }), exit: () => new Promise((c, u) => { if (!o.isFullscreen) return void c(); let f = () => { o.off("change", f), c() }; o.on("change", f); let h = document[i.exitFullscreen](); h instanceof Promise && h.then(f).catch(u) }), toggle: (c, u) => o.isFullscreen ? o.exit() : o.request(c, u), onchange(c) { o.on("change", c) }, onerror(c) { o.on("error", c) }, on(c, u) { let f = a[c]; f && document.addEventListener(f, u, !1) }, off(c, u) { let f = a[c]; f && document.removeEventListener(f, u, !1) }, raw: i }; Object.defineProperties(o, { isFullscreen: { get: () => !!document[i.fullscreenElement] }, element: { enumerable: !0, get: () => document[i.fullscreenElement] }, isEnabled: { enumerable: !0, get: () => !!document[i.fullscreenEnabled] } }), t.default = o }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "8tarF": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { constructor: c, template: { $container: u, $player: f } } = o, h = ""; (0, i.def)(o, "fullscreenWeb", { get: () => (0, i.hasClass)(f, "art-fullscreen-web"), set(p) { p ? (h = f.style.cssText, c.FULLSCREEN_WEB_IN_BODY && (0, i.append)(document.body, f), o.state = "fullscreenWeb", (0, i.setStyle)(f, "width", "100%"), (0, i.setStyle)(f, "height", "100%"), (0, i.addClass)(f, "art-fullscreen-web"), o.emit("fullscreenWeb", !0)) : (c.FULLSCREEN_WEB_IN_BODY && (0, i.append)(u, f), h && (f.style.cssText = h, h = ""), (0, i.removeClass)(f, "art-fullscreen-web"), o.emit("fullscreenWeb", !1)), o.emit("resize") } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], f9syH: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { $video: c } = o.template; (0, i.def)(o, "loaded", { get: () => o.loadedTime / c.duration }), (0, i.def)(o, "loadedTime", { get: () => c.buffered.length ? c.buffered.end(c.buffered.length - 1) : 0 }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], dLuS7: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { icons: c, proxy: u, storage: f, template: { $player: h, $video: p } } = o, v = !1, g = 0, y = 0; function w() { let { $mini: E } = o.template; E && ((0, i.removeClass)(h, "art-mini"), (0, i.setStyle)(E, "display", "none"), h.prepend(p), o.emit("mini", !1)) } function T(E, I) { o.playing ? ((0, i.setStyle)(E, "display", "none"), (0, i.setStyle)(I, "display", "flex")) : ((0, i.setStyle)(E, "display", "flex"), (0, i.setStyle)(I, "display", "none")) } function S() { let { $mini: E } = o.template, I = (0, i.getRect)(E), C = window.innerHeight - I.height - 50, D = window.innerWidth - I.width - 50; f.set("top", C), f.set("left", D), (0, i.setStyle)(E, "top", `${C}px`), (0, i.setStyle)(E, "left", `${D}px`) } (0, i.def)(o, "mini", { get: () => (0, i.hasClass)(h, "art-mini"), set(E) { if (E) { o.state = "mini", (0, i.addClass)(h, "art-mini"); let I = (function () { let { $mini: R } = o.template; if (R) return (0, i.append)(R, p), (0, i.setStyle)(R, "display", "flex"); { let N = (0, i.createElement)("div"); (0, i.addClass)(N, "art-mini-popup"), (0, i.append)(document.body, N), o.template.$mini = N, (0, i.append)(N, p); let P = (0, i.append)(N, '<div class="art-mini-close"></div>'); (0, i.append)(P, c.close), u(P, "click", w); let _ = (0, i.append)(N, '<div class="art-mini-state"></div>'), M = (0, i.append)(_, c.play), $ = (0, i.append)(_, c.pause); return u(M, "click", () => o.play()), u($, "click", () => o.pause()), T(M, $), o.on("video:playing", () => T(M, $)), o.on("video:pause", () => T(M, $)), o.on("video:timeupdate", () => T(M, $)), u(N, "mousedown", B => { v = B.button === 0, g = B.pageX, y = B.pageY }), o.on("document:mousemove", B => { if (v) { (0, i.addClass)(N, "art-mini-dragging"); let V = B.pageX - g, W = B.pageY - y; (0, i.setStyle)(N, "transform", `translate(${V}px, ${W}px)`) } }), o.on("document:mouseup", () => { if (v) { v = !1, (0, i.removeClass)(N, "art-mini-dragging"); let B = (0, i.getRect)(N); f.set("left", B.left), f.set("top", B.top), (0, i.setStyle)(N, "left", `${B.left}px`), (0, i.setStyle)(N, "top", `${B.top}px`), (0, i.setStyle)(N, "transform", null) } }), N } })(), C = f.get("top"), D = f.get("left"); typeof C == "number" && typeof D == "number" ? ((0, i.setStyle)(I, "top", `${C}px`), (0, i.setStyle)(I, "left", `${D}px`), (0, i.isInViewport)(I) || S()) : S(), o.emit("mini", !0) } else w() } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], d1F69: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { option: c, storage: u, template: { $video: f, $poster: h } } = o; for (let v in c.moreVideoAttr) o.attr(v, c.moreVideoAttr[v]); c.muted && (o.muted = c.muted), c.volume && (f.volume = (0, i.clamp)(c.volume, 0, 1)); let p = u.get("volume"); for (let v in typeof p == "number" && (f.volume = (0, i.clamp)(p, 0, 1)), c.poster && (0, i.setStyle)(h, "backgroundImage", `url(${c.poster})`), c.autoplay && (f.autoplay = c.autoplay), c.playsInline && (f.playsInline = !0, f["webkit-playsinline"] = !0), c.theme && (c.cssVar["--art-theme"] = c.theme), c.cssVar) o.cssVar(v, c.cssVar[v]); o.url = c.url } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], kewk9: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $video: c }, i18n: u, notice: f } = o; (0, i.def)(o, "pause", { value() { let h = c.pause(); return f.show = u.get("Pause"), o.emit("pause"), h } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "4XzDs": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { i18n: c, notice: u, template: { $video: f } } = o; if (document.pictureInPictureEnabled) { let { template: { $video: h }, proxy: p, notice: v } = o; h.disablePictureInPicture = !1, (0, i.def)(o, "pip", { get: () => document.pictureInPictureElement, set(g) { g ? (o.state = "pip", h.requestPictureInPicture().catch(y => { throw v.show = y, y })) : document.exitPictureInPicture().catch(y => { throw v.show = y, y }) } }), p(h, "enterpictureinpicture", () => { o.emit("pip", !0) }), p(h, "leavepictureinpicture", () => { o.emit("pip", !1) }) } else if (f.webkitSupportsPresentationMode) { let { $video: h } = o.template; h.webkitSetPresentationMode("inline"), (0, i.def)(o, "pip", { get: () => h.webkitPresentationMode === "picture-in-picture", set(p) { p ? (o.state = "pip", h.webkitSetPresentationMode("picture-in-picture"), o.emit("pip", !0)) : (h.webkitSetPresentationMode("inline"), o.emit("pip", !1)) } }) } else (0, i.def)(o, "pip", { get: () => !1, set() { u.show = c.get("PIP Not Supported") } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jphfi: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $video: c }, i18n: u, notice: f } = o; (0, i.def)(o, "playbackRate", { get: () => c.playbackRate, set(h) { h ? h !== c.playbackRate && (c.playbackRate = h, f.show = `${u.get("Rate")}: ${h === 1 ? u.get("Normal") : `${h}x`}`) : o.playbackRate = 1 } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], iNpeS: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "played", { get: () => o.currentTime / o.duration }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], aBIWL: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { $video: c } = o.template; (0, i.def)(o, "playing", { get: () => typeof c.playing == "boolean" ? c.playing : c.currentTime > 0 && !c.paused && !c.ended && c.readyState > 2 }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], hRBri: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { i18n: c, notice: u, option: f, constructor: { instances: h }, template: { $video: p } } = o; (0, i.def)(o, "play", { async value() { let v = await p.play(); if (u.show = c.get("Play"), o.emit("play"), f.mutex) for (let g = 0; g < h.length; g++) { let y = h[g]; y !== o && y.pause() } return v } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fgfXC: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $poster: c } } = o; (0, i.def)(o, "poster", { get: () => { try { return c.style.backgroundImage.match(/"(.*)"/)[1] } catch { return "" } }, set(u) { (0, i.setStyle)(c, "backgroundImage", `url(${u})`) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "17rUP": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "quality", { set(c) { let { controls: u, notice: f, i18n: h } = o, p = c.find(v => v.default) || c[0]; u.update({ name: "quality", position: "right", index: 10, style: { marginRight: "10px" }, html: p?.html || "", selector: c, onSelect: async v => (await o.switchQuality(v.url), f.show = `${h.get("Switch Video")}: ${v.html}`, v.html) }) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "55qzI": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "rect", { get: () => (0, i.getRect)(o.template.$player) }); let c = ["bottom", "height", "left", "right", "top", "width"]; for (let u = 0; u < c.length; u++) { let f = c[u]; (0, i.def)(o, f, { get: () => o.rect[f] }) } (0, i.def)(o, "x", { get: () => o.left + window.pageXOffset }), (0, i.def)(o, "y", { get: () => o.top + window.pageYOffset }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], bC6TG: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { notice: c, template: { $video: u } } = o, f = (0, i.createElement)("canvas"); (0, i.def)(o, "getDataURL", { value: () => new Promise((h, p) => { try { f.width = u.videoWidth, f.height = u.videoHeight, f.getContext("2d").drawImage(u, 0, 0), h(f.toDataURL("image/png")) } catch (v) { c.show = v, p(v) } }) }), (0, i.def)(o, "getBlobUrl", { value: () => new Promise((h, p) => { try { f.width = u.videoWidth, f.height = u.videoHeight, f.getContext("2d").drawImage(u, 0, 0), f.toBlob(v => { h(URL.createObjectURL(v)) }) } catch (v) { c.show = v, p(v) } }) }), (0, i.def)(o, "screenshot", { value: async h => { let p = await o.getDataURL(), v = h || `artplayer_${(0, i.secondToTime)(u.currentTime)}`; return (0, i.download)(p, `${v}.png`), o.emit("screenshot", p), p } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], j8GRO: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { notice: c } = o; (0, i.def)(o, "seek", { set(u) { o.currentTime = u, o.duration && (c.show = `${(0, i.secondToTime)(o.currentTime)} / ${(0, i.secondToTime)(o.duration)}`), o.emit("seek", o.currentTime) } }), (0, i.def)(o, "forward", { set(u) { o.seek = o.currentTime + u } }), (0, i.def)(o, "backward", { set(u) { o.seek = o.currentTime - u } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], cn7iR: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let c = ["mini", "pip", "fullscreen", "fullscreenWeb"]; (0, i.def)(o, "state", { get: () => c.find(u => o[u]) || "standard", set(u) { for (let f = 0; f < c.length; f++) { let h = c[f]; h !== u && o[h] && (o[h] = !1) } } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "2k4nP": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { notice: c, i18n: u, template: f } = o; (0, i.def)(o, "subtitleOffset", { get: () => f.$track?.offset || 0, set(h) { let { cues: p } = o.subtitle; if (!f.$track || p.length === 0) return; let v = (0, i.clamp)(h, -10, 10); f.$track.offset = v; for (let g = 0; g < p.length; g++) { let y = p[g]; y.originalStartTime = y.originalStartTime ?? y.startTime, y.originalEndTime = y.originalEndTime ?? y.endTime, y.startTime = (0, i.clamp)(y.originalStartTime + v, 0, o.duration), y.endTime = (0, i.clamp)(y.originalEndTime + v, 0, o.duration) } o.subtitle.update(), c.show = `${u.get("Subtitle Offset")}: ${h}s`, o.emit("subtitleOffset", h) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "6SU6j": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { function c(u, f) { return new Promise((h, p) => { if (u === o.url) return; let { playing: v, aspectRatio: g, playbackRate: y } = o; o.pause(), o.url = u, o.notice.show = "", o.once("video:error", p), o.once("video:loadedmetadata", () => { o.currentTime = f }), o.once("video:canplay", async () => { o.playbackRate = y, o.aspectRatio = g, v && await o.play(), o.notice.show = "", h() }) }) } (0, i.def)(o, "switchQuality", { value: u => c(u, o.currentTime) }), (0, i.def)(o, "switchUrl", { value: u => c(u, 0) }), (0, i.def)(o, "switch", { set: o.switchUrl }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "7iMuh": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "theme", { get: () => o.cssVar("--art-theme"), set(c) { o.cssVar("--art-theme", c) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "6P0RS": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { events: c, option: u, template: { $progress: f, $video: h } } = o, p = null, v = null, g = !1, y = !1, w = !1; c.hover(f, () => { w = !0 }, () => { w = !1 }), o.on("setBar", async (T, S, E) => { let I = o.controls?.thumbnails, { url: C, scale: D } = u.thumbnails; if (!I || !C) return; let R = T === "played" && E && i.isMobile; if (T === "hover" || R) { if (g || (g = !0, v = await (0, i.loadImg)(C, D), y = !0), !y || !w) return; let N = f.clientWidth * S; (0, i.setStyle)(I, "display", "flex"), N > 0 && N < f.clientWidth ? (function (P) { let _ = o.controls?.thumbnails; if (!_) return; let { number: M, column: $, width: B, height: V, scale: W } = u.thumbnails, U = B * W || v.naturalWidth / $, q = V * W || U / (h.videoWidth / h.videoHeight), z = Math.floor(P / (f.clientWidth / M)), X = Math.ceil(z / $) - 1; (0, i.setStyle)(_, "backgroundImage", `url(${v.src})`), (0, i.setStyle)(_, "height", `${q}px`), (0, i.setStyle)(_, "width", `${U}px`), (0, i.setStyle)(_, "backgroundPosition", `-${(z % $ || $ - 1) * U}px -${X * q}px`), P <= U / 2 ? (0, i.setStyle)(_, "left", 0) : P > f.clientWidth - U / 2 ? (0, i.setStyle)(_, "left", `${f.clientWidth - U}px`) : (0, i.setStyle)(_, "left", `${P - U / 2}px`) })(N) : i.isMobile || (0, i.setStyle)(I, "display", "none"), R && (clearTimeout(p), p = setTimeout(() => { (0, i.setStyle)(I, "display", "none") }, 500)) } }), (0, i.def)(o, "thumbnails", { get: () => o.option.thumbnails, set(T) { T.url && !o.option.isLive && (o.option.thumbnails = T, clearTimeout(p), p = null, v = null, g = !1, y = !1) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], eNi78: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "toggle", { value: () => o.playing ? o.pause() : o.play() }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "7AUBD": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { (0, i.def)(o, "type", { get: () => o.option.type, set(c) { o.option.type = c } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], cnlLL: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { option: c, template: { $video: u } } = o; (0, i.def)(o, "url", { get: () => u.src, async set(f) { if (f) { let h = o.url, p = c.type || (0, i.getExt)(f), v = c.customType[p]; p && v ? (await (0, i.sleep)(), o.loading.show = !0, v.call(o, u, f, o)) : (URL.revokeObjectURL(h), u.src = f), h !== o.url && (o.option.url = f, o.isReady && h && o.once("video:canplay", () => { o.emit("restart", f) })) } else await (0, i.sleep)(), o.loading.show = !0 } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], iX66j: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { template: { $video: c }, i18n: u, notice: f, storage: h } = o; (0, i.def)(o, "volume", { get: () => c.volume || 0, set: p => { c.volume = (0, i.clamp)(p, 0, 1), f.show = `${u.get("Volume")}: ${Number.parseInt(100 * c.volume, 10)}`, c.volume !== 0 && h.set("volume", c.volume) } }), (0, i.def)(o, "muted", { get: () => c.muted, set: p => { c.muted = p, o.emit("muted", p) } }) } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], cjxJL: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("../utils"), a = n("./autoOrientation"), o = s.interopDefault(a), c = n("./autoPlayback"), u = s.interopDefault(c), f = n("./fastForward"), h = s.interopDefault(f), p = n("./lock"), v = s.interopDefault(p), g = n("./miniProgressBar"), y = s.interopDefault(g); t.default = class { constructor(w) { this.art = w, this.id = 0; let { option: T } = w; T.miniProgressBar && !T.isLive && this.add(y.default), T.lock && i.isMobile && this.add(v.default), T.autoPlayback && !T.isLive && this.add(u.default), T.autoOrientation && i.isMobile && this.add(o.default), T.fastForward && i.isMobile && !T.isLive && this.add(h.default); for (let S = 0; S < T.plugins.length; S++)this.add(T.plugins[S]) } add(w) { this.id += 1; let T = w.call(this.art, this.art); return T instanceof Promise ? T.then(S => this.next(w, S)) : this.next(w, T) } next(w, T) { let S = T && T.name || w.name || `plugin${this.id}`; return (0, i.errorHandle)(!(0, i.has)(this, S), `Cannot add a plugin that already has the same name: ${S}`), (0, i.def)(this, S, { value: T }), this } } }, { "../utils": "aBlEo", "./autoOrientation": "jb9jb", "./autoPlayback": "21HWM", "./fastForward": "4sxBO", "./lock": "fjy9V", "./miniProgressBar": "d0xRp", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], jb9jb: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { notice: c, constructor: u, template: { $player: f, $video: h } } = o, p = "art-auto-orientation", v = "art-auto-orientation-fullscreen", g = !1; function y() { let { videoWidth: w, videoHeight: T } = h, S = document.documentElement.clientWidth, E = document.documentElement.clientHeight; return w > T && S < E || w < T && S > E } return o.on("fullscreenWeb", w => { w ? y() && setTimeout(() => { o.fullscreenWeb && !(0, i.hasClass)(f, p) && (function () { let T = document.documentElement.clientWidth, S = document.documentElement.clientHeight; (0, i.setStyle)(f, "width", `${S}px`), (0, i.setStyle)(f, "height", `${T}px`), (0, i.setStyle)(f, "transform-origin", "0 0"), (0, i.setStyle)(f, "transform", `rotate(90deg) translate(0, -${T}px)`), (0, i.addClass)(f, p), o.isRotate = !0, o.emit("resize") })() }, Number(u.AUTO_ORIENTATION_TIME ?? 0)) : (0, i.hasClass)(f, p) && ((0, i.setStyle)(f, "width", ""), (0, i.setStyle)(f, "height", ""), (0, i.setStyle)(f, "transform-origin", ""), (0, i.setStyle)(f, "transform", ""), (0, i.removeClass)(f, p), o.isRotate = !1, o.emit("resize")) }), o.on("fullscreen", async w => { let T = !!screen?.orientation?.lock; if (w) { if (T && y()) try { let S = screen.orientation.type.startsWith("portrait") ? "landscape" : "portrait"; await screen.orientation.lock(S), g = !0, (0, i.addClass)(f, v) } catch (S) { g = !1, c.show = S } } else if ((0, i.hasClass)(f, v) && (0, i.removeClass)(f, v), T && g) { try { screen.orientation.unlock() } catch { } g = !1 } }), { name: "autoOrientation", get state() { return (0, i.hasClass)(f, p) } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "21HWM": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { i18n: c, icons: u, storage: f, constructor: h, proxy: p, template: { $poster: v } } = o, g = o.layers.add({ name: "auto-playback", html: '<div class="art-auto-playback-close"></div><div class="art-auto-playback-last"></div><div class="art-auto-playback-jump"></div>' }), y = (0, i.query)(".art-auto-playback-last", g), w = (0, i.query)(".art-auto-playback-jump", g), T = (0, i.query)(".art-auto-playback-close", g); (0, i.append)(T, u.close); let S = null; function E() { let I = (f.get("times") || {})[o.option.id || o.option.url]; clearTimeout(S), (0, i.setStyle)(g, "display", "none"), I && I >= h.AUTO_PLAYBACK_MIN && ((0, i.setStyle)(g, "display", "flex"), y.textContent = `${c.get("Last Seen")} ${(0, i.secondToTime)(I)}`, w.textContent = c.get("Jump Play"), p(T, "click", () => { (0, i.setStyle)(g, "display", "none") }), p(w, "click", () => { o.seek = I, o.play(), (0, i.setStyle)(v, "display", "none"), (0, i.setStyle)(g, "display", "none") }), o.once("video:timeupdate", () => { S = setTimeout(() => { (0, i.setStyle)(g, "display", "none") }, h.AUTO_PLAYBACK_TIMEOUT) })) } return o.on("video:timeupdate", () => { if (o.playing) { let I = f.get("times") || {}, C = Object.keys(I); C.length > h.AUTO_PLAYBACK_MAX && delete I[C[0]], I[o.option.id || o.option.url] = o.currentTime, f.set("times", I) } }), o.on("ready", E), o.on("restart", E), { name: "auto-playback", get times() { return f.get("times") || {} }, clear: () => f.del("times"), delete(I) { let C = f.get("times") || {}; return delete C[I], f.set("times", C), C } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "4sxBO": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { constructor: c, proxy: u, template: { $player: f, $video: h } } = o, p = null, v = !1, g = 1, y = () => { clearTimeout(p), v && (v = !1, o.playbackRate = g, (0, i.removeClass)(f, "art-fast-forward")) }; return u(h, "touchstart", w => { w.touches.length === 1 && o.playing && !o.isLock && (p = setTimeout(() => { v = !0, g = o.playbackRate, o.playbackRate = c.FAST_FORWARD_VALUE, (0, i.addClass)(f, "art-fast-forward") }, c.FAST_FORWARD_TIME)) }), o.on("document:touchmove", y), o.on("document:touchend", y), { name: "fastForward", get state() { return (0, i.hasClass)(f, "art-fast-forward") } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fjy9V: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { layers: c, icons: u, template: { $player: f } } = o; function h() { return (0, i.hasClass)(f, "art-lock") } function p() { (0, i.addClass)(f, "art-lock"), o.isLock = !0, o.emit("lock", !0) } function v() { (0, i.removeClass)(f, "art-lock"), o.isLock = !1, o.emit("lock", !1) } return c.add({ name: "lock", mounted(g) { let y = (0, i.append)(g, u.lock), w = (0, i.append)(g, u.unlock); (0, i.setStyle)(y, "display", "none"), o.on("lock", T => { T ? ((0, i.setStyle)(y, "display", "inline-flex"), (0, i.setStyle)(w, "display", "none")) : ((0, i.setStyle)(y, "display", "none"), (0, i.setStyle)(w, "display", "inline-flex")) }) }, click() { h() ? v() : p() } }), { name: "lock", get state() { return h() }, set state(g) { g ? p() : v() } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], d0xRp: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { return o.on("control", c => { c ? (0, i.removeClass)(o.template.$player, "art-mini-progress-bar") : (0, i.addClass)(o.template.$player, "art-mini-progress-bar") }), { name: "mini-progress-bar" } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], bwLGT: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("../utils"), a = n("../utils/component"), o = s.interopDefault(a), c = n("./aspectRatio"), u = s.interopDefault(c), f = n("./flip"), h = s.interopDefault(f), p = n("./playbackRate"), v = s.interopDefault(p), g = n("./subtitleOffset"), y = s.interopDefault(g); class w extends o.default { constructor(S) { super(S); let { option: E, controls: I, template: { $setting: C } } = S; this.name = "setting", this.$parent = C, this.id = 0, this.active = null, this.cache = new Map, this.option = [...this.builtin, ...E.settings], E.setting && (this.format(), this.render(), S.on("blur", () => { this.show && (this.show = !1, this.render()) }), S.on("focus", D => { let R = (0, i.includeFromEvent)(D, I.setting), N = (0, i.includeFromEvent)(D, this.$parent); !this.show || R || N || (this.show = !1, this.render()) }), S.on("resize", () => this.resize())) } get builtin() { let S = [], { option: E } = this.art; return E.playbackRate && S.push((0, v.default)(this.art)), E.aspectRatio && S.push((0, u.default)(this.art)), E.flip && S.push((0, h.default)(this.art)), E.subtitleOffset && S.push((0, y.default)(this.art)), S } traverse(S, E = this.option) { for (let I = 0; I < E.length; I++) { let C = E[I]; S(C), C.selector?.length && this.traverse(S, C.selector) } } check(S) { S.$parent.tooltip = S.html, this.traverse(E => { E.default = E === S, E.default && E.$item && (0, i.inverseClass)(E.$item, "art-current") }, S.$option), this.render(S.$parents) } format(S = this.option, E, I, C = []) { for (let D = 0; D < S.length; D++) { let R = S[D]; if (R?.name ? ((0, i.errorHandle)(!C.includes(R.name), `The [${R.name}] already exists in [setting]`), C.push(R.name)) : R.name = `setting-${this.id++}`, !R.$formatted) { (0, i.def)(R, "$parent", { get: () => E }), (0, i.def)(R, "$parents", { get: () => I }), (0, i.def)(R, "$option", { get: () => S }); let N = []; (0, i.def)(R, "$events", { get: () => N }), (0, i.def)(R, "$formatted", { get: () => !0 }) } this.format(R.selector || [], R, S, C) } this.option = S } find(S = "") { let E = null; return this.traverse(I => { I.name === S && (E = I) }), E } resize() { let { controls: S, constructor: { SETTING_WIDTH: E, SETTING_ITEM_HEIGHT: I }, template: { $player: C, $setting: D } } = this.art; if (S.setting && this.show) { let R = this.active[0]?.$parent?.width || E, { left: N, width: P } = (0, i.getRect)(S.setting), { left: _, width: M } = (0, i.getRect)(C), $ = N - _ + P / 2 - R / 2, B = this.active === this.option ? this.active.length * I : (this.active.length + 1) * I; if ((0, i.setStyle)(D, "height", `${B}px`), (0, i.setStyle)(D, "width", `${R}px`), this.art.isRotate || i.isMobile) return; $ + R > M ? ((0, i.setStyle)(D, "left", null), (0, i.setStyle)(D, "right", null)) : ((0, i.setStyle)(D, "left", `${$}px`), (0, i.setStyle)(D, "right", "auto")) } } inactivate(S) { for (let E = 0; E < S.$events.length; E++)this.art.events.remove(S.$events[E]); S.$events.length = 0 } remove(S) { let E = this.find(S); (0, i.errorHandle)(E, `Can't find [${S}] in the [setting]`); let I = E.$option.indexOf(E); E.$option.splice(I, 1), this.inactivate(E), E.$item && (0, i.remove)(E.$item), this.render() } update(S) { let E = this.find(S.name); return E ? (this.inactivate(E), Object.assign(E, S), this.format(), this.createItem(E, !0), this.render(), E) : this.add(S) } add(S, E = this.option) { return E.push(S), this.format(), this.createItem(S), this.render(), S } createHeader(S) { if (!this.cache.has(S.$option)) return; let E = this.cache.get(S.$option), { proxy: I, icons: { arrowLeft: C }, constructor: { SETTING_ITEM_HEIGHT: D } } = this.art, R = (0, i.createElement)("div"); (0, i.setStyle)(R, "height", `${D}px`), (0, i.addClass)(R, "art-setting-item"), (0, i.addClass)(R, "art-setting-item-back"); let N = (0, i.append)(R, '<div class="art-setting-item-left"></div>'), P = (0, i.createElement)("div"); (0, i.addClass)(P, "art-setting-item-left-icon"), (0, i.append)(P, C), (0, i.append)(N, P), (0, i.append)(N, S.$parent.html); let _ = I(R, "click", () => this.render(S.$parents)); S.$parent.$events.push(_), (0, i.append)(E, R) } createItem(S, E = !1) { if (!this.cache.has(S.$option)) return; let I = this.cache.get(S.$option), C = S.$item, D = "selector"; (0, i.has)(S, "switch") && (D = "switch"), (0, i.has)(S, "range") && (D = "range"), (0, i.has)(S, "onClick") && (D = "button"); let { icons: R, proxy: N, constructor: P } = this.art, _ = (0, i.createElement)("div"); (0, i.addClass)(_, "art-setting-item"), (0, i.setStyle)(_, "height", `${P.SETTING_ITEM_HEIGHT}px`), _.dataset.name = S.name || "", _.dataset.value = S.value || ""; let M = (0, i.append)(_, '<div class="art-setting-item-left"></div>'), $ = (0, i.append)(_, '<div class="art-setting-item-right"></div>'), B = (0, i.createElement)("div"); switch ((0, i.addClass)(B, "art-setting-item-left-icon"), D) { case "button": case "switch": case "range": (0, i.append)(B, S.icon || R.config); break; case "selector": S.selector?.length ? (0, i.append)(B, S.icon || R.config) : (0, i.append)(B, R.check) }(0, i.append)(M, B), (0, i.def)(S, "$icon", { configurable: !0, get: () => B }), (0, i.def)(S, "icon", { configurable: !0, get: () => B.innerHTML, set(U) { B.innerHTML = "", (0, i.append)(B, U) } }); let V = (0, i.createElement)("div"); (0, i.addClass)(V, "art-setting-item-left-text"), (0, i.append)(V, S.html || ""), (0, i.append)(M, V), (0, i.def)(S, "$html", { configurable: !0, get: () => V }), (0, i.def)(S, "html", { configurable: !0, get: () => V.innerHTML, set(U) { V.innerHTML = "", (0, i.append)(V, U) } }); let W = (0, i.createElement)("div"); switch ((0, i.addClass)(W, "art-setting-item-right-tooltip"), (0, i.append)(W, S.tooltip || ""), (0, i.append)($, W), (0, i.def)(S, "$tooltip", { configurable: !0, get: () => W }), (0, i.def)(S, "tooltip", { configurable: !0, get: () => W.innerHTML, set(U) { W.innerHTML = "", (0, i.append)(W, U) } }), D) { case "switch": { let U = (0, i.createElement)("div"); (0, i.addClass)(U, "art-setting-item-right-icon"); let q = (0, i.append)(U, R.switchOn), z = (0, i.append)(U, R.switchOff); (0, i.setStyle)(S.switch ? z : q, "display", "none"), (0, i.append)($, U), (0, i.def)(S, "$switch", { configurable: !0, get: () => U }); let X = S.switch; (0, i.def)(S, "switch", { configurable: !0, get: () => X, set(Z) { X = Z, Z ? ((0, i.setStyle)(z, "display", "none"), (0, i.setStyle)(q, "display", null)) : ((0, i.setStyle)(z, "display", null), (0, i.setStyle)(q, "display", "none")) } }); break } case "range": { let U = (0, i.createElement)("div"); (0, i.addClass)(U, "art-setting-item-right-icon"); let q = (0, i.append)(U, '<input type="range">'); q.value = S.range[0], q.min = S.range[1], q.max = S.range[2], q.step = S.range[3], (0, i.addClass)(q, "art-setting-range"), (0, i.append)($, U), (0, i.def)(S, "$range", { configurable: !0, get: () => q }); let z = [...S.range]; (0, i.def)(S, "range", { configurable: !0, get: () => z, set(X) { z = [...X], q.value = X[0], q.min = X[1], q.max = X[2], q.step = X[3] } }) } break; case "selector": if (S.selector?.length) { let U = (0, i.createElement)("div"); (0, i.addClass)(U, "art-setting-item-right-icon"), (0, i.append)(U, R.arrowRight), (0, i.append)($, U) } }switch (D) { case "switch": if (S.onSwitch) { let U = N(_, "click", async q => { S.switch = await S.onSwitch.call(this.art, S, _, q) }); S.$events.push(U) } break; case "range": if (S.$range) { if (S.onRange) { let U = N(S.$range, "change", async q => { S.range[0] = S.$range.valueAsNumber, S.tooltip = await S.onRange.call(this.art, S, _, q) }); S.$events.push(U) } if (S.onChange) { let U = N(S.$range, "input", async q => { S.range[0] = S.$range.valueAsNumber, S.tooltip = await S.onChange.call(this.art, S, _, q) }); S.$events.push(U) } } break; case "selector": { let U = N(_, "click", async q => { S.selector?.length ? this.render(S.selector) : (this.check(S), S.$parent.onSelect && (S.$parent.tooltip = await S.$parent.onSelect.call(this.art, S, _, q))) }); S.$events.push(U), S.default && (0, i.addClass)(_, "art-current") } break; case "button": if (S.onClick) { let U = N(_, "click", async q => { S.tooltip = await S.onClick.call(this.art, S, _, q) }); S.$events.push(U) } }(0, i.def)(S, "$item", { configurable: !0, get: () => _ }), E ? (0, i.replaceElement)(_, C) : (0, i.append)(I, _), S.mounted && setTimeout(() => S.mounted.call(this.art, S.$item, S), 0) } render(S = this.option) { if (this.active = S, this.cache.has(S)) { let E = this.cache.get(S); (0, i.inverseClass)(E, "art-current") } else { let E = (0, i.createElement)("div"); this.cache.set(S, E), (0, i.addClass)(E, "art-setting-panel"), (0, i.append)(this.$parent, E), (0, i.inverseClass)(E, "art-current"), S[0]?.$parent && this.createHeader(S[0]); for (let I = 0; I < S.length; I++)this.createItem(S[I]) } this.resize() } } t.default = w }, { "../utils": "aBlEo", "../utils/component": "idCEj", "./aspectRatio": "cb8VK", "./flip": "ljJTO", "./playbackRate": "3QcSQ", "./subtitleOffset": "eB5hg", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], cb8VK: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a) { let { i18n: o, icons: c, constructor: { SETTING_ITEM_WIDTH: u, ASPECT_RATIO: f } } = a; function h(v) { return v === "default" ? o.get("Default") : v } function p() { let v = a.setting.find(`aspect-ratio-${a.aspectRatio}`); a.setting.check(v) } return { width: u, name: "aspect-ratio", html: o.get("Aspect Ratio"), icon: c.aspectRatio, tooltip: h(a.aspectRatio), selector: f.map(v => ({ value: v, name: `aspect-ratio-${v}`, default: v === a.aspectRatio, html: h(v) })), onSelect: v => (a.aspectRatio = v.value, v.html), mounted: () => { p(), a.on("aspectRatio", () => p()) } } } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], ljJTO: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t), s.export(t, "default", () => a); var i = n("../utils"); function a(o) { let { i18n: c, icons: u, constructor: { SETTING_ITEM_WIDTH: f, FLIP: h } } = o; function p(g) { return c.get((0, i.capitalize)(g)) } function v() { let g = o.setting.find(`flip-${o.flip}`); o.setting.check(g) } return { width: f, name: "flip", html: c.get("Video Flip"), tooltip: p(o.flip), icon: u.flip, selector: h.map(g => ({ value: g, name: `flip-${g}`, default: g === o.flip, html: p(g) })), onSelect: g => (o.flip = g.value, g.html), mounted: () => { v(), o.on("flip", () => v()) } } } }, { "../utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "3QcSQ": [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a) { let { i18n: o, icons: c, constructor: { SETTING_ITEM_WIDTH: u, PLAYBACK_RATE: f } } = a; function h(v) { return v === 1 ? o.get("Normal") : v.toFixed(1) } function p() { let v = a.setting.find(`playback-rate-${a.playbackRate}`); a.setting.check(v) } return { width: u, name: "playback-rate", html: o.get("Play Speed"), tooltip: h(a.playbackRate), icon: c.playbackRate, selector: f.map(v => ({ value: v, name: `playback-rate-${v}`, default: v === a.playbackRate, html: h(v) })), onSelect: v => (a.playbackRate = v.value, v.html), mounted: () => { p(), a.on("video:ratechange", () => p()) } } } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], eB5hg: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); function i(a) { let { i18n: o, icons: c, constructor: u } = a; return { width: u.SETTING_ITEM_WIDTH, name: "subtitle-offset", html: o.get("Subtitle Offset"), icon: c.subtitle, tooltip: "0s", range: [0, -10, 10, .1], onChange: f => (a.subtitleOffset = f.range[0], `${f.range[0]}s`), mounted: (f, h) => { a.on("subtitleOffset", p => { h.$range.value = p, h.tooltip = `${p}s` }) } } } s.defineInteropFlag(t), s.export(t, "default", () => i) }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], kwqbK: [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t), t.default = class { constructor() { this.name = "artplayer_settings", this.settings = {} } get(s) { try { let i = JSON.parse(window.localStorage.getItem(this.name)) || {}; return s ? i[s] : i } catch { return s ? this.settings[s] : this.settings } } set(s, i) { try { let a = Object.assign({}, this.get(), { [s]: i }); window.localStorage.setItem(this.name, JSON.stringify(a)) } catch { this.settings[s] = i } } del(s) { try { let i = this.get(); delete i[s], window.localStorage.setItem(this.name, JSON.stringify(i)) } catch { delete this.settings[s] } } clear() { try { window.localStorage.removeItem(this.name) } catch { this.settings = {} } } } }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], k5613: [function (n, e, t, r) { var s = n("@parcel/transformer-js/src/esmodule-helpers.js"); s.defineInteropFlag(t); var i = n("option-validator"), a = s.interopDefault(i), o = n("./scheme"), c = s.interopDefault(o), u = n("./utils"), f = n("./utils/component"), h = s.interopDefault(f); class p extends h.default { constructor(g) { super(g), this.name = "subtitle", this.option = null, this.destroyEvent = () => null, this.init(g.option.subtitle); let y = !1; g.on("video:timeupdate", () => { if (!this.url) return; let w = this.art.template.$video.webkitDisplayingFullscreen; typeof w == "boolean" && w !== y && (y = w, this.createTrack(w ? "subtitles" : "metadata", this.url)) }) } get url() { return this.art.template.$track.src } set url(g) { this.switch(g) } get textTrack() { return this.art.template.$video?.textTracks?.[0] } get activeCues() { return this.textTrack ? Array.from(this.textTrack.activeCues) : [] } get cues() { return this.textTrack ? Array.from(this.textTrack.cues) : [] } style(g, y) { let { $subtitle: w } = this.art.template; return typeof g == "object" ? (0, u.setStyles)(w, g) : (0, u.setStyle)(w, g, y) } update() { let { option: { subtitle: g }, template: { $subtitle: y } } = this.art; y.innerHTML = "", this.activeCues.length && (this.art.emit("subtitleBeforeUpdate", this.activeCues), y.innerHTML = this.activeCues.map((w, T) => w.text.split(/\r?\n/).filter(S => S.trim()).map(S => `<div class="art-subtitle-line" data-group="${T}">${g.escape ? (0, u.escape)(S) : S}</div>`).join("")).join(""), this.art.emit("subtitleAfterUpdate", this.activeCues)) } async switch(g, y = {}) { let { i18n: w, notice: T, option: S } = this.art, E = { ...S.subtitle, ...y, url: g }, I = await this.init(E); return y.name && (T.show = `${w.get("Switch Subtitle")}: ${y.name}`), I } createTrack(g, y) { let { template: w, proxy: T, option: S } = this.art, { $video: E, $track: I } = w, C = (0, u.createElement)("track"); C.default = !0, C.kind = g, C.src = y, C.label = S.subtitle.name || "Artplayer", C.track.mode = "hidden", C.onload = () => { this.art.emit("subtitleLoad", this.cues, this.option) }, this.art.events.remove(this.destroyEvent), I.onload = null, (0, u.remove)(I), (0, u.append)(E, C), w.$track = C, this.destroyEvent = T(this.textTrack, "cuechange", () => this.update()) } async init(g) { let { notice: y, template: { $subtitle: w } } = this.art; return this.textTrack ? ((0, a.default)(g, c.default.subtitle), g.url ? (this.option = g, this.style(g.style), fetch(g.url).then(T => T.arrayBuffer()).then(T => { let S = new TextDecoder(g.encoding).decode(T); switch (g.type || (0, u.getExt)(g.url)) { case "srt": { let E = (0, u.srtToVtt)(S), I = g.onVttLoad(E); return (0, u.vttToBlob)(I) } case "ass": { let E = (0, u.assToVtt)(S), I = g.onVttLoad(E); return (0, u.vttToBlob)(I) } case "vtt": { let E = g.onVttLoad(S); return (0, u.vttToBlob)(E) } default: return g.url } }).then(T => (w.innerHTML = "", this.url === T || (URL.revokeObjectURL(this.url), this.createTrack("metadata", T)), T)).catch(T => { throw w.innerHTML = "", y.show = T, T })) : void 0) : null } } t.default = p }, { "option-validator": "g7VGh", "./scheme": "biLjm", "./utils": "aBlEo", "./utils/component": "idCEj", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], fwOA1: [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t); var s = n("../package.json"), i = n("./utils"); class a { constructor(c) { this.art = c; let { option: u, constructor: f } = c; u.container instanceof Element ? this.$container = u.container : (this.$container = (0, i.query)(u.container), (0, i.errorHandle)(this.$container, `No container element found by ${u.container}`)), (0, i.errorHandle)((0, i.supportsFlex)(), "The current browser does not support flex layout"); let h = this.$container.tagName.toLowerCase(); (0, i.errorHandle)(h === "div", `Unsupported container element type, only support 'div' but got '${h}'`), (0, i.errorHandle)(f.instances.every(p => p.template.$container !== this.$container), "Cannot mount multiple instances on the same dom element"), this.query = this.query.bind(this), this.$container.dataset.artId = c.id, this.init() } static get html() { return `<div class="art-video-player art-subtitle-show art-layer-show art-control-show art-mask-show"><video class="art-video"><track default kind="metadata" src=""></track></video><div class="art-poster"></div><div class="art-subtitle"></div><div class="art-danmuku"></div><div class="art-layers"></div><div class="art-mask"><div class="art-state"></div></div><div class="art-bottom"><div class="art-progress"></div><div class="art-controls"><div class="art-controls-left"></div><div class="art-controls-center"></div><div class="art-controls-right"></div></div></div><div class="art-loading"></div><div class="art-notice"><div class="art-notice-inner"></div></div><div class="art-settings"></div><div class="art-info"><div class="art-info-panel"><div class="art-info-item"><div class="art-info-title">Player version:</div><div class="art-info-content">${s.version}</div></div><div class="art-info-item"><div class="art-info-title">Video url:</div><div class="art-info-content" data-video="src"></div></div><div class="art-info-item"><div class="art-info-title">Video volume:</div><div class="art-info-content" data-video="volume"></div></div><div class="art-info-item"><div class="art-info-title">Video time:</div><div class="art-info-content" data-video="currentTime"></div></div><div class="art-info-item"><div class="art-info-title">Video duration:</div><div class="art-info-content" data-video="duration"></div></div><div class="art-info-item"><div class="art-info-title">Video resolution:</div><div class="art-info-content"><span data-video="videoWidth"></span>x<span data-video="videoHeight"></span></div></div></div><div class="art-info-close">[x]</div></div><div class="art-contextmenus"></div></div>` } query(c) { return (0, i.query)(c, this.$container) } init() { let { option: c } = this.art; if (c.useSSR || (this.$container.innerHTML = a.html), this.$player = this.query(".art-video-player"), this.$video = this.query(".art-video"), this.$track = this.query("track"), this.$poster = this.query(".art-poster"), this.$subtitle = this.query(".art-subtitle"), this.$danmuku = this.query(".art-danmuku"), this.$bottom = this.query(".art-bottom"), this.$progress = this.query(".art-progress"), this.$controls = this.query(".art-controls"), this.$controlsLeft = this.query(".art-controls-left"), this.$controlsCenter = this.query(".art-controls-center"), this.$controlsRight = this.query(".art-controls-right"), this.$layer = this.query(".art-layers"), this.$loading = this.query(".art-loading"), this.$notice = this.query(".art-notice"), this.$noticeInner = this.query(".art-notice-inner"), this.$mask = this.query(".art-mask"), this.$state = this.query(".art-state"), this.$setting = this.query(".art-settings"), this.$info = this.query(".art-info"), this.$infoPanel = this.query(".art-info-panel"), this.$infoClose = this.query(".art-info-close"), this.$contextmenu = this.query(".art-contextmenus"), c.proxy) { let u = c.proxy.call(this.art, this.art); (0, i.errorHandle)(u instanceof HTMLVideoElement || u instanceof HTMLCanvasElement, "Function 'option.proxy' needs to return 'HTMLVideoElement' or 'HTMLCanvasElement'"), (0, i.replaceElement)(u, this.$video), u.className = "art-video", this.$video = u } c.backdrop && (0, i.addClass)(this.$player, "art-backdrop"), i.isMobile && (0, i.addClass)(this.$player, "art-mobile") } destroy(c) { c ? this.$container.innerHTML = "" : (0, i.addClass)(this.$player, "art-destroy") } } t.default = a }, { "../package.json": "lh3R5", "./utils": "aBlEo", "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }], "4NM7P": [function (n, e, t, r) { n("@parcel/transformer-js/src/esmodule-helpers.js").defineInteropFlag(t), t.default = class { on(s, i, a) { let o = this.e || (this.e = {}); return (o[s] || (o[s] = [])).push({ fn: i, ctx: a }), this } once(s, i, a) { let o = this; function c(...u) { o.off(s, c), i.apply(a, u) } return c._ = i, this.on(s, c, a) } emit(s, ...i) { let a = ((this.e || (this.e = {}))[s] || []).slice(); for (let o = 0; o < a.length; o += 1)a[o].fn.apply(a[o].ctx, i); return this } off(s, i) { let a = this.e || (this.e = {}), o = a[s], c = []; if (o && i) for (let u = 0, f = o.length; u < f; u += 1)o[u].fn !== i && o[u].fn._ !== i && c.push(o[u]); return c.length ? a[s] = c : delete a[s], this } } }, { "@parcel/transformer-js/src/esmodule-helpers.js": "loqXi" }]
  }, ["esqvp"], "esqvp", "parcelRequire4dc0", {}); let { default: rn } = parcelRequire4dc0("esqvp"); const py = `
.artplayer-plugin-chapter .art-control-progress-inner {
    height: 100% !important;
    background-color: transparent !important;
}
.artplayer-plugin-chapter .art-control-progress-inner > .art-progress-hover,
.artplayer-plugin-chapter .art-control-progress-inner > .art-progress-loaded,
.artplayer-plugin-chapter .art-control-progress-inner > .art-progress-played {
    display: none !important;
}
.artplayer-plugin-chapter .art-control-thumbnails {
    bottom: calc(var(--art-bottom-gap) + 64px) !important;
}
.artplayer-plugin-chapter .art-chapters {
    position: absolute;
    z-index: 0;
    inset: 0;
    display: flex;
    align-items: center;
    gap: 4px;
    height: 100%;
    transform: scaleY(1.25);
}
.artplayer-plugin-chapter .art-chapters .art-chapter {
    display: flex;
    align-items: center;
    height: 100%;
}
.artplayer-plugin-chapter .art-chapters .art-chapter .art-chapter-inner {
    position: relative;
    cursor: pointer;
    width: 100%;
    height: 50%;
    border-radius: 10px;
    overflow: hidden;
    transition: height var(--art-transition-duration) ease;
    background-color: var(--art-progress-color);
}
.artplayer-plugin-chapter .art-chapters .art-chapter:hover .art-chapter-inner {
    height: 100%;
}
.artplayer-plugin-chapter .art-chapter-title {
    display: none;
    position: absolute;
    z-index: 70;
    top: -50px;
    left: 0;
    padding: 3px 5px;
    line-height: 1;
    font-size: 14px;
    border-radius: var(--art-border-radius);
    white-space: nowrap;
    background-color: var(--art-tip-background);
}
`; function tS(n = {}) {
    return e => {
      const { $player: t } = e.template, { setStyle: r, append: s, clamp: i, query: a, isMobile: o, addClass: c, removeClass: u } = e.constructor.utils, f = `
                <div class="art-chapter">
                    <div class="art-chapter-inner">
                        <div class="art-progress-hover"></div>
                        <div class="art-progress-loaded"></div>
                        <div class="art-progress-played"></div>
                    </div>
                </div>
        `; let h = null, p = []; const v = e.query(".art-control-progress"), g = e.query(".art-control-progress-inner"), y = s(g, '<div class="art-chapters"></div>'), w = s(g, '<div class="art-chapter-title"></div>'); function T({ $chapter: E, width: I }) { const C = E.dataset.title.trim(); if (C) { r(w, "display", "flex"), w.innerText = C; const D = w.clientWidth; I <= D / 2 ? r(w, "left", 0) : I > g.clientWidth - D / 2 ? r(w, "left", `${g.clientWidth - D}px`) : r(w, "left", `${I - D / 2}px`) } else r(w, "display", "none") } function S(E = []) { if (p = [], y.innerText = "", u(t, "artplayer-plugin-chapter"), !!Array.isArray(E) && E.length && e.duration) { E = E.sort((I, C) => I.start - C.start); for (let I = 0; I < E.length; I++) { const C = E[I], D = E[I + 1]; if (C.end === 1 / 0 && (C.end = e.duration), typeof C.start != "number" || typeof C.end != "number" || typeof C.title != "string") throw new Error("Illegal chapter data type"); if (C.start < 0 || C.end > Math.ceil(e.duration) || C.start >= C.end) throw new Error("Illegal chapter time point"); if (D && C.end > D.start) throw new Error("Illegal chapter time point") } E[0].start > 0 && E.unshift({ start: 0, end: E[0].start, title: "" }), E[E.length - 1].end < e.duration && E.push({ start: E[E.length - 1].end, end: e.duration, title: "" }); for (let I = 0; I < E.length - 1; I++)E[I].end !== E[I + 1].start && E.splice(I + 1, 0, { start: E[I].end, end: E[I + 1].start, title: "" }); p = E.map(I => { const C = s(y, f), D = i(I.start, 0, e.duration), R = i(I.end, 0, e.duration), N = R - D, P = N / e.duration; return C.dataset.start = D, C.dataset.end = R, C.dataset.duration = N, C.dataset.title = I.title.trim(), C.style.width = `${P * 100}%`, { $chapter: C, $hover: a(".art-progress-hover", C), $loaded: a(".art-progress-loaded", C), $played: a(".art-progress-played", C) } }), c(t, "artplayer-plugin-chapter"), e.emit("setBar", "loaded", e.loaded || 0) } } return e.on("setBar", (E, I, C) => { if (p.length) for (let D = 0; D < p.length; D++) { const { $chapter: R, $loaded: N, $played: P, $hover: _ } = p[D], M = { hover: _, loaded: N, played: P }[E]; if (!M) return; const $ = y.clientWidth * I, B = e.duration * I, V = parseFloat(R.dataset.duration), W = parseFloat(R.dataset.start), U = parseFloat(R.dataset.end); if (B < W && r(M, "width", 0), B > U && r(M, "width", "100%"), B >= W && B <= U) { const q = (B - W) / V; r(M, "width", `${q * 100}%`), o ? E === "played" && C && (T({ $chapter: R, width: $ }), clearTimeout(h), h = setTimeout(() => { r(w, "display", "none") }, 500)) : E === "hover" && T({ $chapter: R, width: $ }) } } }), o || e.proxy(v, "mouseleave", () => { p.length && r(w, "display", "none") }), e.once("video:loadedmetadata", () => S(n.chapters)), { name: "artplayerPluginChapter", update: ({ chapters: E }) => S(E) }
    }
  } if (typeof document < "u") { const n = "artplayer-plugin-chapter", e = document.getElementById(n); if (e) e.textContent = py; else { const t = document.createElement("style"); t.id = n, t.textContent = py, document.head.appendChild(t) } } typeof window < "u" && (window.artplayerPluginChapter = tS); function ND(n) { function e(t) { if (!Array.isArray(t)) throw new TypeError("Option must be an array of time ranges"); t.forEach((r, s) => { if (!Array.isArray(r) || r.length !== 2) throw new TypeError(`Range at index ${s} must be an array of two numbers`); const [i, a] = r; if (typeof i != "number" || typeof a != "number" && a !== 1 / 0) throw new TypeError(`Range at index ${s} must contain valid numbers or Infinity`); if (i > a && a !== 1 / 0) throw new RangeError(`In range at index ${s}, start time must be less than end time`); if (s > 0) { const o = t[s - 1][1]; if (o !== 1 / 0 && i <= o) throw new RangeError(`Range at index ${s} overlaps with the previous range`) } }) } return e(n), t => { let r = n; function s() { const a = t.duration; r = r.map(([o, c]) => [o, c === 1 / 0 ? a : c]) } function i() { const a = t.currentTime; for (const [o, c] of r) if (a >= o && a < c) { t.seek = c; break } } return t.on("video:timeupdate", i), t.on("video:loadedmetadata", s), { name: "autoSkip", update(a = []) { e(a), r = a, s() } } } } function DD(n, e, t) { return n.length > e ? String(n) : (e = e - n.length, e > t.length && (t += t.repeat(e / t.length)), String(n) + t.slice(0, e)) } function my(n) { var e = n.split("."), t = e[0].split(":") || [], r = DD(e[1] || "0", 3, "0"), s = Number(r) / 1e3, i = Number(t[t.length - 3] || 0) * 3600, a = Number(t[t.length - 2] || 0) * 60, o = Number(t[t.length - 1] || 0); return i + a + o + s } async function OD(n = "") { let t = (await (await fetch(n)).text()).split(/\r?\n/).filter(c => c.trim()); const r = [], s = t[0].trim().toUpperCase() === "WEBVTT"; let i = 0, a = 2; const o = /^\d+$/; if (!s && o.test(t[0].trim())) a = 3, i = 1; else if (s) { const c = t[1]; c && o.test(c.trim()) ? (a = 3, i = 2) : (i = 1, a = 2) } for (let c = i; c < t.length; c += a) { const u = t[c], f = t[c + 1]; if (!f.trim()) continue; const h = /((?:[0-9]{2}:)?(?:[0-9]{2}:)?[0-9]{2}(?:.[0-9]{3})?)(?: ?--> ?)((?:[0-9]{2}:)?(?:[0-9]{2}:)?[0-9]{2}(?:.[0-9]{3})?)/, p = u.match(h); if (!p) continue; const v = /(.*)#(\w{4})=(.*)/i, g = f.match(v), y = Math.floor(my(p[1])), w = Math.floor(my(p[2])); let T = g[1]; if (!/^\/|((https?|ftp|file):\/\/)/i.test(T)) { const D = n.split("/"); D.pop(), D.push(T), T = D.join("/") } const E = { start: y, end: w, url: T }, I = g[2].split(""), C = g[3].split(","); for (let D = 0; D < I.length; D++)E[I[D]] = C[D]; r.push(E) } return r } function MD(n) { return async e => { const { constructor: { utils: { setStyle: t, isMobile: r, addClass: s } }, template: { $progress: i } } = e; let a = null; const o = await OD(n.vtt); function c(u, f, h) { t(u, "backgroundImage", `url(${f.url})`), t(u, "height", `${f.h}px`), t(u, "width", `${f.w}px`), t(u, "backgroundPosition", `-${f.x}px -${f.y}px`), h <= f.w / 2 ? t(u, "left", 0) : h > i.clientWidth - f.w / 2 ? t(u, "left", `${i.clientWidth - f.w}px`) : t(u, "left", `${h - f.w / 2}px`) } return e.controls.add({ name: "vtt-thumbnail", position: "top", index: 20, style: n.style || {}, mounted(u) { s(u, "art-control-thumbnails"), e.on("setBar", async (f, h, p) => { const v = f === "played" && p && r; if (f === "hover" || v) { const g = i.clientWidth * h, y = h * e.duration; t(u, "display", "flex"); const w = o.find(T => y >= T.start && y <= T.end); if (!w) return t(u, "display", "none"); g > 0 && g < i.clientWidth ? c(u, w, g) : r || t(u, "display", "none"), v && (clearTimeout(a), a = setTimeout(() => { t(u, "display", "none") }, 500)) } }) } }), { name: "artplayerPluginVttThumbnail" } } } const jD = `<svg viewBox="-5 -10 75 75" xmlns="http://www.w3.org/2000/svg" width="35" height="35">
<path d="M11.9199 45H7.20508V26.5391L2.60645 28.3154V24.3975L11.4219 20.7949H11.9199V45ZM30.1013 35.0059C30.1013 38.3483 29.4926 40.9049 28.2751 42.6758C27.0687 44.4466 25.3422 45.332 23.0954 45.332C20.8708 45.332 19.1498 44.4743 17.9323 42.7588C16.726 41.0322 16.1006 38.5641 16.0564 35.3545V30.7891C16.0564 27.4577 16.6596 24.9121 17.8659 23.1523C19.0723 21.3815 20.8044 20.4961 23.0622 20.4961C25.32 20.4961 27.0521 21.3704 28.2585 23.1191C29.4649 24.8678 30.0792 27.3636 30.1013 30.6064V35.0059ZM25.3864 30.1084C25.3864 28.2048 25.1983 26.777 24.822 25.8252C24.4457 24.8734 23.8591 24.3975 23.0622 24.3975C21.5681 24.3975 20.7933 26.1406 20.738 29.627V35.6533C20.738 37.6012 20.9262 39.0511 21.3025 40.0029C21.6898 40.9548 22.2875 41.4307 23.0954 41.4307C23.8591 41.4307 24.4236 40.988 24.7888 40.1025C25.1651 39.2061 25.3643 37.8392 25.3864 36.002V30.1084Z" fill="white"/>
<path d="M11.9894 5.45398V0L2 7.79529L11.9894 15.5914V10.3033H47.0886V40.1506H33.2442V45H52V5.45398H11.9894Z" fill="white"/>
</svg>`, FD = `
                        <svg viewBox="-5 -10 75 75" xmlns="http://www.w3.org/2000/svg" width="35" height="35">
<path d="M29.9199 45H25.2051V26.5391L20.6064 28.3154V24.3975L29.4219 20.7949H29.9199V45ZM48.1013 35.0059C48.1013 38.3483 47.4926 40.9049 46.2751 42.6758C45.0687 44.4466 43.3422 45.332 41.0954 45.332C38.8708 45.332 37.1498 44.4743 35.9323 42.7588C34.726 41.0322 34.1006 38.5641 34.0564 35.3545V30.7891C34.0564 27.4577 34.6596 24.9121 35.8659 23.1523C37.0723 21.3815 38.8044 20.4961 41.0622 20.4961C43.32 20.4961 45.0521 21.3704 46.2585 23.1191C47.4649 24.8678 48.0792 27.3636 48.1013 30.6064V35.0059ZM43.3864 30.1084C43.3864 28.2048 43.1983 26.777 42.822 25.8252C42.4457 24.8734 41.8591 24.3975 41.0622 24.3975C39.5681 24.3975 38.7933 26.1406 38.738 29.627V35.6533C38.738 37.6012 38.9262 39.0511 39.3025 40.0029C39.6898 40.9548 40.2875 41.4307 41.0954 41.4307C41.8591 41.4307 42.4236 40.988 42.7888 40.1025C43.1651 39.2061 43.3643 37.8392 43.3864 36.002V30.1084Z" fill="white"/>
<path d="M40.0106 5.45398V0L50 7.79529L40.0106 15.5914V10.3033H4.9114V40.1506H18.7558V45H2.01875e-06V5.45398H40.0106Z" fill="white"/>
</svg>`, $D = `<svg viewBox="0 0 512 512" width="30" height="30">
  <path d="M500.5 231.4l-192-160C287.9 54.3 256 68.6 256 96v320c0 27.4 31.9 41.8 52.5 24.6l192-160c15.3-12.8 15.3-36.4 0-49.2zm-256 0l-192-160C31.9 54.3 0 68.6 0 96v320c0 27.4 31.9 41.8 52.5 24.6l192-160c15.3-12.8 15.3-36.4 0-49.2z"/>
</svg>`, BD = `<svg viewBox="0 0 512 512" width="30" height="30" transform="scale(-1, 1)">
  <path d="M500.5 231.4l-192-160C287.9 54.3 256 68.6 256 96v320c0 27.4 31.9 41.8 52.5 24.6l192-160c15.3-12.8 15.3-36.4 0-49.2zm-256 0l-192-160C31.9 54.3 0 68.6 0 96v320c0 27.4 31.9 41.8 52.5 24.6l192-160c15.3-12.8 15.3-36.4 0-49.2z"/>
</svg>`, UD = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="24" height="24"><path d="M116.5,42.8v154.4c0,2.8-1.7,3.6-3.8,1.7l-54.1-48H29c-2.8,0-5.2-2.3-5.2-5.2V94.3c0-2.8,2.3-5.2,5.2-5.2h29.6l54.1-48C114.8,39.2,116.5,39.9,116.5,42.8z"/><path d="M136.2,160v-20c11.1,0,20-8.9,20-20s-8.9-20-20-20V80c22.1,0,40,17.9,40,40S158.3,160,136.2,160z"/><path d="M216.2,120c0-44.2-35.8-80-80-80v20c33.1,0,60,26.9,60,60s-26.9,60-60,60v20C180.4,199.9,216.1,164.1,216.2,120z" fill="#fff"/></svg>', zD = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="24" height="24">
    <path d="M116.4,42.8v154.5c0,2.8-1.7,3.6-3.8,1.7l-54.1-48.1H28.9c-2.8,0-5.2-2.3-5.2-5.2V94.2c0-2.8,2.3-5.2,5.2-5.2h29.6l54.1-48.1C114.6,39.1,116.4,39.9,116.4,42.8z M212.3,96.4l-14.6-14.6l-23.6,23.6l-23.6-23.6l-14.6,14.6l23.6,23.6l-23.6,23.6l14.6,14.6l23.6-23.6l23.6,23.6l14.6-14.6L188.7,120L212.3,96.4z"
    fill="#fff"/>
</svg>
`, VD = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 16 240 240" width="28" height="28">
    <path d="M215,40H25c-2.7,0-5,2.2-5,5v150c0,2.7,2.2,5,5,5h190c2.7,0,5-2.2,5-5V45C220,42.2,217.8,40,215,40z M108.1,137.7c0.7-0.7,1.5-1.5,2.4-2.3l6.6,7.8c-2.2,2.4-5,4.4-8,5.8c-8,3.5-17.3,2.4-24.3-2.9c-3.9-3.6-5.9-8.7-5.5-14v-25.6c0-2.7,0.5-5.3,1.5-7.8c0.9-2.2,2.4-4.3,4.2-5.9c5.7-4.5,13.2-6.2,20.3-4.6c3.3,0.5,6.3,2,8.7,4.3c1.3,1.3,2.5,2.6,3.5,4.2l-7.1,6.9c-2.4-3.7-6.5-5.9-10.9-5.9c-2.4-0.2-4.8,0.7-6.6,2.3c-1.7,1.7-2.5,4.1-2.4,6.5v25.6C90.4,141.7,102,143.5,108.1,137.7z M152.9,137.7c0.7-0.7,1.5-1.5,2.4-2.3l6.6,7.8c-2.2,2.4-5,4.4-8,5.8c-8,3.5-17.3,2.4-24.3-2.9c-3.9-3.6-5.9-8.7-5.5-14v-25.6c0-2.7,0.5-5.3,1.5-7.8c0.9-2.2,2.4-4.3,4.2-5.9c5.7-4.5,13.2-6.2,20.3-4.6c3.3,0.5,6.3,2,8.7,4.3c1.3,1.3,2.5,2.6,3.5,4.2l-7.1,6.9c-2.4-3.7-6.5-5.9-10.9-5.9c-2.4-0.2-4.8,0.7-6.6,2.3c-1.7,1.7-2.5,4.1-2.4,6.5v25.6C135.2,141.7,146.8,143.5,152.9,137.7z"
    fill="#fff"/>
</svg>
`, GD = '<svg width="80" height="80" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><style>.spinner_l9ve{animation:spinner_rcyq 1.2s cubic-bezier(0.52,.6,.25,.99) infinite}.spinner_cMYp{animation-delay:.4s}.spinner_gHR3{animation-delay:.8s}@keyframes spinner_rcyq{0%{transform:translate(12px,12px) scale(0);opacity:1}100%{transform:translate(0,0) scale(1);opacity:0}}</style><path class="spinner_l9ve" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,20a9,9,0,1,1,9-9A9,9,0,0,1,12,21Z" transform="translate(12, 12) scale(0)"/><path class="spinner_l9ve spinner_cMYp" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,20a9,9,0,1,1,9-9A9,9,0,0,1,12,21Z" transform="translate(12, 12) scale(0)"/><path class="spinner_l9ve spinner_gHR3" d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,20a9,9,0,1,1,9-9A9,9,0,0,1,12,21Z" transform="translate(12, 12) scale(0)"/></svg>', HD = `<svg width="24" height="24" viewBox="0 0 24 24" style="margin-bottom: 3px; vertical-align: middle;" xmlns="http://www.w3.org/2000/svg">
<path d="M20 5.125V9.125H22V4.155C22 3.58616 21.5389 3.125 20.97 3.125H2.03C1.46116 3.125 1 3.58613 1 4.155V17.095C1 17.6639 1.46119 18.125 2.03 18.125H12V16.125H3V5.125H20ZM14 11.875C14 11.3227 14.4477 10.875 15 10.875H22C22.5523 10.875 23 11.3227 23 11.875V17.875C23 18.4273 22.5523 18.875 22 18.875H15C14.4477 18.875 14 18.4273 14 17.875V11.875ZM6 12.375L7.79289 10.5821L5.29288 8.0821L6.7071 6.66788L9.20711 9.16789L11 7.375V12.375H6Z" fill="white"/>
</svg>`, WD = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="80" height="80"><path d="M62.8,199.5c-1,0.8-2.4,0.6-3.3-0.4c-0.4-0.5-0.6-1.1-0.5-1.8V42.6c-0.2-1.3,0.7-2.4,1.9-2.6c0.7-0.1,1.3,0.1,1.9,0.4l154.7,77.7c2.1,1.1,2.1,2.8,0,3.8L62.8,199.5z" fill="white"/></svg>', KD = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="24" height="24"><path d="M62.8,199.5c-1,0.8-2.4,0.6-3.3-0.4c-0.4-0.5-0.6-1.1-0.5-1.8V42.6c-0.2-1.3,0.7-2.4,1.9-2.6c0.7-0.1,1.3,0.1,1.9,0.4l154.7,77.7c2.1,1.1,2.1,2.8,0,3.8L62.8,199.5z"/></svg>', qD = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="24" height="24"><path d="M100,194.9c0.2,2.6-1.8,4.8-4.4,5c-0.2,0-0.4,0-0.6,0H65c-2.6,0.2-4.8-1.8-5-4.4c0-0.2,0-0.4,0-0.6V45c-0.2-2.6,1.8-4.8,4.4-5c0.2,0,0.4,0,0.6,0h30c2.6-0.2,4.8,1.8,5,4.4c0,0.2,0,0.4,0,0.6V194.9z M180,45.1c0.2-2.6-1.8-4.8-4.4-5c-0.2,0-0.4,0-0.6,0h-30c-2.6-0.2-4.8,1.8-5,4.4c0,0.2,0,0.4,0,0.6V195c-0.2,2.6,1.8,4.8,4.4,5c0.2,0,0.4,0,0.6,0h30c2.6,0.2,4.8-1.8,5-4.4c0-0.2,0-0.4,0-0.6V45.1z"/></svg>', YD = `
<svg 
  xmlns="http://www.w3.org/2000/svg" 
  viewBox="0 0 16 16" 
  fill="currentColor" 
  width="24" 
  height="24" 
  style="vertical-align: middle;">
  <path fill-rule="evenodd" d="M8 0a5.53 5.53 0 0 0-3.594 1.342c-.766.66-1.321 1.52-1.464 2.383C1.266 4.095 0 5.555 0 7.318 0 9.366 1.708 11 3.781 11H7.5V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V11h4.188C14.502 11 16 9.57 16 7.773c0-1.636-1.242-2.969-2.834-3.194C12.923 1.999 10.69 0 8 0m-.5 14.5V11h1v3.5a.5.5 0 0 1-1 0"/>
</svg>`, XD = `
<svg 
  xmlns="http://www.w3.org/2000/svg" 
  viewBox="0 0 240 240" 
  width="24" 
  height="24" 
  style="margin-bottom: 5px; vertical-align: middle;">
  <path d="M204,145l-25-14c0.8-3.6,1.2-7.3,1-11c0.2-3.7-0.2-7.4-1-11l25-14c2.2-1.6,3.1-4.5,2-7l-16-26c-1.2-2.1-3.8-2.9-6-2l-25,14c-6-4.2-12.3-7.9-19-11V35c0.2-2.6-1.8-4.8-4.4-5c-0.2,0-0.4,0-0.6,0h-30c-2.6-0.2-4.8,1.8-5,4.4c0,0.2,0,0.4,0,0.6v28c-6.7,3.1-13,6.7-19,11L56,60c-2.2-0.9-4.8-0.1-6,2L35,88c-1.6,2.2-1.3,5.3,0.9,6.9c0,0,0.1,0,0.1,0.1l25,14c-0.8,3.6-1.2,7.3-1,11c-0.2,3.7,0.2,7.4,1,11l-25,14c-2.2,1.6-3.1,4.5-2,7l16,26c1.2,2.1,3.8,2.9,6,2l25-14c5.7,4.6,12.2,8.3,19,11v28c-0.2,2.6,1.8,4.8,4.4,5c0.2,0,0.4,0,0.6,0h30c2.6,0.2,4.8-1.8,5-4.4c0-0.2,0-0.4,0-0.6v-28c7-2.3,13.5-6,19-11l25,14c2.5,1.3,5.6,0.4,7-2l15-26C206.7,149.4,206,146.7,204,145z M120,149.9c-16.5,0-30-13.4-30-30s13.4-30,30-30s30,13.4,30,30c0.3,16.3-12.6,29.7-28.9,30C120.7,149.9,120.4,149.9,120,149.9z"/>
</svg>`, QD = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="24" height="24" style="margin-bottom: 5px; vertical-align: middle;"><path d="M96.3,186.1c1.9,1.9,1.3,4-1.4,4.4l-50.6,8.4c-1.8,0.5-3.7-0.6-4.2-2.4c-0.2-0.6-0.2-1.2,0-1.7l8.4-50.6c0.4-2.7,2.4-3.4,4.4-1.4l14.5,14.5l28.2-28.2l14.3,14.3l-28.2,28.2L96.3,186.1z M195.8,39.1l-50.6,8.4c-2.7,0.4-3.4,2.4-1.4,4.4l14.5,14.5l-28.2,28.2l14.3,14.3l28.2-28.2l14.5,14.5c1.9,1.9,4,1.3,4.4-1.4l8.4-50.6c0.5-1.8-0.6-3.6-2.4-4.2C197,39,196.4,39,195.8,39.1L195.8,39.1z" fill="#fff"/></svg>', ZD = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240"width="24" height="24" style="margin-bottom: 5px; vertical-align: middle;"><path d="M109.2,134.9l-8.4,50.1c-0.4,2.7-2.4,3.3-4.4,1.4L82,172l-27.9,27.9l-14.2-14.2l27.9-27.9l-14.4-14.4c-1.9-1.9-1.3-3.9,1.4-4.4l50.1-8.4c1.8-0.5,3.6,0.6,4.1,2.4C109.4,133.7,109.4,134.3,109.2,134.9L109.2,134.9z M172.1,82.1L200,54.2L185.8,40l-27.9,27.9l-14.4-14.4c-1.9-1.9-3.9-1.3-4.4,1.4l-8.4,50.1c-0.5,1.8,0.6,3.6,2.4,4.1c0.5,0.2,1.2,0.2,1.7,0l50.1-8.4c2.7-0.4,3.3-2.4,1.4-4.4L172.1,82.1z"/></svg>', JD = `<p style="display: flex; gap: 7px; align-items: center; background-color:#1F2020; padding:5px;padding-inline:7px; border-radius:5px">
    <b style="color: white;">Powered by</b>
    <img src="/logo.jpg" alt="AniRock Logo" style="height: 20px; object-fit: contain;" />
</p>`; function e6(n, e) {
    let t = `
        .art-chapters {
            gap: 0px !important;
        }
    `; return n && e && (n.start === 0 && n.end === 0 && e.start === 0 && e.end === 0 ? t += "" : n.start === 0 && n.end === 0 && e.start !== 0 && e.end !== 0 ? t += `
                .art-chapter:nth-child(2) {
                    background-color: #fdd253;
                    transform: scaleY(0.6);
                }
            `: n.start === 0 && n.end !== 0 && e.start === 0 && e.end === 0 ? t += `
                .art-chapter:nth-child(1){
                    background-color: #fdd253;
                    transform: scaleY(0.6);
                }
            `: n.start === 0 && n.end !== 0 && e.start !== 0 && e.end !== 0 ? t += `
                .art-chapter:nth-child(1), 
                .art-chapter:nth-child(3) {
                    background-color: #fdd253;
                    transform: scaleY(0.6);
                }
            `: n.start !== 0 && n.end !== 0 && e.start === 0 && e.end === 0 ? t += `
                .art-chapter:nth-child(2) {
                    background-color: #fdd253;
                    transform: scaleY(0.6);
                }
            `: n.start !== 0 && n.end !== 0 && e.start !== 0 && e.end !== 0 && (t += `
                .art-chapter:nth-child(2),
                .art-chapter:nth-child(4) {
                    background-color: #fdd253;
                    transform: scaleY(0.6);
                }
            `)), t
  } function gy(n) { throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var Ba = { exports: {} }; Ba.exports; var xy; function t6() {
    return xy || (xy = 1, (function (n, e) {/*!
 * artplayer-plugin-hls-control.js v1.0.1
 * Github: https://github.com/zhw2590582/ArtPlayer
 * (c) 2017-2024 Harvey Zack
 * Released under the MIT License.
 */(function (t, r, s, i, a) { var o = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof y0 < "u" ? y0 : {}, c = typeof o[i] == "function" && o[i], u = c.cache || {}, f = typeof gy == "function" && gy.bind(n); function h(g, y) { if (!u[g]) { if (!t[g]) { var w = typeof o[i] == "function" && o[i]; if (!y && w) return w(g, !0); if (c) return c(g, !0); if (f && typeof g == "string") return f(g); var T = Error("Cannot find module '" + g + "'"); throw T.code = "MODULE_NOT_FOUND", T } E.resolve = function (I) { var C = t[g][1][I]; return C ?? I }, E.cache = {}; var S = u[g] = new h.Module(g); t[g][0].call(S.exports, E, S, S.exports, this) } return u[g].exports; function E(I) { var C = E.resolve(I); return C === !1 ? {} : h(C) } } h.isParcelRequire = !0, h.Module = function (g) { this.id = g, this.bundle = h, this.exports = {} }, h.modules = t, h.cache = u, h.parent = c, h.register = function (g, y) { t[g] = [function (w, T) { T.exports = y }, {}] }, Object.defineProperty(h, "root", { get: function () { return o[i] } }), o[i] = h; for (var p = 0; p < r.length; p++)h(r[p]); { var v = h(s); n.exports = v } })({ haa6A: [function (t, r, s) { var i = t("@parcel/transformer-js/src/esmodule-helpers.js"); i.defineInteropFlag(s), i.export(s, "default", () => h); var a = t("bundle-text:./quality.svg"), o = i.interopDefault(a), c = t("bundle-text:./audio.svg"), u = i.interopDefault(c); function f(p, v) { let g = new Map; return p.filter(y => { let w = y[v]; return w === void 0 || !g.has(w) && g.set(w, 1) }) } function h(p = {}) { return v => { let { $video: g } = v.template, { errorHandle: y } = v.constructor.utils; function w() { y(v.hls?.media === g, 'Cannot find instance of HLS from "art.hls"'), (function (T) { if (!T.levels.length) return; let S = p.quality || {}, E = S.auto || "Auto", I = S.title || "Quality", C = S.getName || (_ => _.name || _.height + "P"), D = T.levels[T.currentLevel], R = D ? C(D) : E, N = f(T.levels.map((_, M) => ({ html: C(_, M), value: M, default: T.currentLevel === M })), "html").sort((_, M) => M.value - _.value); N.push({ html: E, value: -1, default: T.currentLevel === -1 }); let P = _ => (T.currentLevel = _.value, v.notice.show = `${I}: ${_.html}`, S.control && v.controls.check(_), S.setting && v.setting.check(_), _.html); S.control && v.controls.update({ name: "hls-quality", position: "right", html: R, style: { padding: "0 10px" }, selector: N, onSelect: P }), S.setting && v.setting.update({ name: "hls-quality", tooltip: R, html: I, icon: o.default, width: 200, selector: N, onSelect: P }) })(v.hls), (function (T) { if (!T.audioTracks.length) return; let S = p.audio || {}, E = S.auto || "Auto", I = S.title || "Audio", C = S.getName || (_ => _.name || _.lang || _.language), D = T.audioTracks[T.audioTrack], R = D ? C(D) : E, N = f(T.audioTracks.map((_, M) => ({ html: C(_, M), value: _.id, default: T.audioTrack === _.id })), "html"), P = _ => (T.audioTrack = _.value, v.notice.show = `${I}: ${_.html}`, S.control && v.controls.check(_), S.setting && v.setting.check(_), _.html); S.control && v.controls.update({ name: "hls-audio", position: "right", html: R, style: { padding: "0 10px" }, selector: N, onSelect: P }), S.setting && v.setting.update({ name: "hls-audio", tooltip: R, html: I, icon: u.default, width: 200, selector: N, onSelect: P }) })(v.hls) } return v.on("ready", w), v.on("restart", w), { name: "artplayerPluginHlsControl", update: w } } } typeof window < "u" && (window.artplayerPluginHlsControl = h) }, { "bundle-text:./quality.svg": "5aI3W", "bundle-text:./audio.svg": "kbgg8", "@parcel/transformer-js/src/esmodule-helpers.js": "9pCYc" }], "5aI3W": [function (t, r, s) { r.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18"><path fill="#fff" d="M0 96c0-35.3 28.7-64 64-64h384c35.3 0 64 28.7 64 64v320c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96zm323.8 106.5c-4.5-6.6-11.9-10.5-19.8-10.5s-15.4 3.9-19.8 10.5l-87 127.6-26.5-33.1c-4.6-5.7-11.5-9-18.7-9s-14.2 3.3-18.7 9l-64 80c-5.8 7.2-6.9 17.1-2.9 25.4S78.8 416 88 416h336c8.9 0 17.1-4.9 21.2-12.8s3.6-17.4-1.4-24.7l-120-176zM112 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"/></svg>' }, {}], kbgg8: [function (t, r, s) { r.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="18"><path fill="#fff" d="M256 80C149.9 80 62.4 159.4 49.6 262c9.4-3.8 19.6-6 30.4-6 26.5 0 48 21.5 48 48v128c0 26.5-21.5 48-48 48-44.2 0-80-35.8-80-80V288C0 146.6 114.6 32 256 32s256 114.6 256 256v112c0 44.2-35.8 80-80 80-26.5 0-48-21.5-48-48V304c0-26.5 21.5-48 48-48 10.8 0 21 2.1 30.4 6C449.6 159.4 362.1 80 256 80z"/></svg>' }, {}], "9pCYc": [function (t, r, s) { s.interopDefault = function (i) { return i && i.__esModule ? i : { default: i } }, s.defineInteropFlag = function (i) { Object.defineProperty(i, "__esModule", { value: !0 }) }, s.exportAll = function (i, a) { return Object.keys(i).forEach(function (o) { o === "default" || o === "__esModule" || Object.prototype.hasOwnProperty.call(a, o) || Object.defineProperty(a, o, { enumerable: !0, get: function () { return i[o] } }) }), a }, s.export = function (i, a, o) { Object.defineProperty(i, a, { enumerable: !0, get: o }) } }, {}] }, ["haa6A"], "haa6A", "parcelRequire4dc0")
    })(Ba, Ba.exports)), Ba.exports
  } var r6 = t6(); const n6 = Mh(r6); function s6() {
    return n => {
      const { getExt: e } = n.constructor.utils; n.setting.add({
        html: `
        <div class="subtitle-upload-wrapper" style="position: relative;">
          <input 
            type="file" 
            name="subtitle-upload" 
            id="subtitle-upload" 
            style="display: none;" 
          />
          <label 
            for="subtitle-upload" 
            class="subtitle-upload-label"
            style="cursor: pointer; user-select: none;"
          >
            Upload Subtitle
          </label>
        </div>
      `, icon: YD, onClick(t, r) { const s = r.querySelector("input[name='subtitle-upload']"), i = r.querySelector(".subtitle-upload-label"); n.proxy(s, "change", a => { const o = a.target?.files?.[0]; if (!o) return; const c = URL.createObjectURL(o); n.subtitle.switch(c, { type: e(o.name) }), a.target.value = null, i.textContent = o.name, n.notice.show = `Upload Subtitle ${o.name}`, t.tooltip = o.name }) }
      })
    }
  } rn.LOG_VERSION = !1; rn.CONTEXTMENU = !1; const In = { M: "m", I: "i", F: "f", V: "v", SPACE: " ", ARROW_UP: "arrowup", ARROW_DOWN: "arrowdown", ARROW_RIGHT: "arrowright", ARROW_LEFT: "arrowleft" }; function i6({ streamUrl: n, subtitles: e, thumbnail: t, intro: r, outro: s, autoSkipIntro: i, autoPlay: a, autoNext: o, episodeId: c, episodes: u, playNext: f, animeInfo: h, episodeNum: p, streamInfo: v }) { const g = j.useRef(null), y = j.useRef(0), w = "<proxy_server_name>/?url=", T = "https://proxy-one-gilt.vercel.app/m3u8-proxy?url=".split(",") || [], [S, E] = j.useState(u?.findIndex(R => R.id.match(/ep=(\d+)/)?.[1] === c)); j.useEffect(() => { if (u?.length > 0) { const R = u.findIndex(N => N.id.match(/ep=(\d+)/)?.[1] === c); E(R) } }, [c, u]), j.useEffect(() => { const R = () => { document.querySelectorAll("style[data-chapter-styles]").forEach(M => M.remove()); const P = document.createElement("style"); P.setAttribute("data-chapter-styles", "true"); const _ = e6(r, s); return P.textContent = _, document.head.appendChild(P), () => { P.remove() } }; if (n || r || s) return R() }, [n, r, s]); const I = (R, N, P) => { if (Rn.isSupported()) { P.hls && P.hls.destroy(); const _ = new Rn; _.loadSource(N), _.attachMedia(R), P.hls = _, P.on("destroy", () => _.destroy()), R.addEventListener("timeupdate", () => { const M = Math.round(R.currentTime), $ = Math.round(R.duration); $ > 0 && M >= $ && (P.pause(), S < u?.length - 1 && o && f(u[S + 1].id.match(/ep=(\d+)/)?.[1])) }) } else R.canPlayType("application/vnd.apple.mpegurl") ? (R.src = N, R.addEventListener("timeupdate", () => { const _ = Math.round(R.currentTime), M = Math.round(R.duration); M > 0 && _ >= M && (P.pause(), S < u?.length - 1 && o && f(u[S + 1].id.match(/ep=(\d+)/)?.[1])) })) : console.log("Unsupported playback format: m3u8") }, C = () => { const R = []; return (r?.start !== 0 || r?.end !== 0) && R.push({ start: r.start, end: r.end, title: "intro" }), (s?.start !== 0 || s?.end !== 0) && R.push({ start: s.start, end: s.end, title: "outro" }), R }, D = (R, N) => { const P = R.target.tagName.toLowerCase(); if (!(P === "input" || P === "textarea")) switch (R.key.toLowerCase()) { case In.M: N.muted = !N.muted; break; case In.I: N.pip = !N.pip; break; case In.F: R.preventDefault(), R.stopPropagation(), N.fullscreen = !N.fullscreen; break; case In.V: R.preventDefault(), R.stopPropagation(), N.subtitle.show = !N.subtitle.show; break; case In.SPACE: R.preventDefault(), R.stopPropagation(), N.playing ? N.pause() : N.play(); break; case In.ARROW_UP: R.preventDefault(), R.stopPropagation(), N.volume = Math.min(N.volume + .1, 1); break; case In.ARROW_DOWN: R.preventDefault(), R.stopPropagation(), N.volume = Math.max(N.volume - .1, 0); break; case In.ARROW_RIGHT: R.preventDefault(), R.stopPropagation(), N.currentTime = Math.min(N.currentTime + 10, N.duration); break; case In.ARROW_LEFT: R.preventDefault(), R.stopPropagation(), N.currentTime = Math.max(N.currentTime - 10, 0); break } }; return j.useEffect(() => { if (!n || !g.current) return; const R = v?.streamingLink?.iframe, N = {}; N.referer = new URL(R).origin + "/", console.log(T[Math.floor(Math.random() * T?.length)] + encodeURIComponent(n) + "&headers=" + encodeURIComponent(JSON.stringify(N))); const P = new rn({ url: T[Math.floor(Math.random() * T?.length)] + encodeURIComponent(n) + "&headers=" + encodeURIComponent(JSON.stringify(N)), container: g.current, type: "m3u8", autoplay: a, volume: 1, setting: !0, playbackRate: !0, pip: !0, hotkey: !1, fullscreen: !0, mutex: !0, playsInline: !0, lock: !0, airplay: !0, autoOrientation: !0, fastForward: !0, aspectRatio: !0, moreVideoAttr: { crossOrigin: "anonymous", preload: "none", playsInline: !0 }, plugins: [n6({ quality: { setting: !0, getName: _ => _.height + "P", title: "Quality", auto: "Auto" } }), s6(), tS({ chapters: C() })], subtitle: { style: { color: "#fff", "font-weight": "400", left: "50%", transform: "translateX(-50%)", "margin-bottom": "2rem" }, escape: !1 }, layers: [{ name: _n, html: JD, tooltip: _n, style: { opacity: 1, position: "absolute", top: "5px", right: "5px", transition: "opacity 0.5s ease-out" } }, { html: "", style: { position: "absolute", left: "50%", top: 0, width: "20%", height: "100%", transform: "translateX(-50%)" }, disable: !rn.utils.isMobile, click: () => P.toggle() }, { name: "rewind", html: "", style: { position: "absolute", left: 0, top: 0, width: "40%", height: "100%" }, disable: !rn.utils.isMobile, click: () => { P.controls.show = !P.controls.show } }, { name: "forward", html: "", style: { position: "absolute", right: 0, top: 0, width: "40%", height: "100%" }, disable: !rn.utils.isMobile, click: () => { P.controls.show = !P.controls.show } }, { name: "backwardIcon", html: BD, style: { position: "absolute", left: "25%", top: "50%", transform: "translate(50%,-50%)", opacity: 0, transition: "opacity 0.5s ease-in-out" }, disable: !rn.utils.isMobile }, { name: "forwardIcon", html: $D, style: { position: "absolute", right: "25%", top: "50%", transform: "translate(50%, -50%)", opacity: 0, transition: "opacity 0.5s ease-in-out" }, disable: !rn.utils.isMobile }], controls: [{ html: jD, position: "right", tooltip: "Backward 10s", click: () => { P.currentTime = Math.max(P.currentTime - 10, 0) } }, { html: FD, position: "right", tooltip: "Forward 10s", click: () => { P.currentTime = Math.min(P.currentTime + 10, P.duration) } }], icons: { play: KD, pause: qD, setting: XD, volume: UD, pip: HD, volumeClose: zD, state: WD, loading: GD, fullscreenOn: QD, fullscreenOff: ZD }, customType: { m3u8: I } }); return P.on("resize", () => { P.subtitle.style({ fontSize: (P.width > 500 ? P.width * .02 : P.width * .03) + "px" }) }), P.on("ready", () => { const M = (JSON.parse(localStorage.getItem("continueWatching")) || []).find(U => U.episodeId === c); M?.leftAt && (P.currentTime = M.leftAt), P.on("video:timeupdate", () => { y.current = Math.floor(P.currentTime) }), setTimeout(() => { P.layers[_n].style.opacity = 0 }, 2e3); const $ = e?.find(U => U.label.toLowerCase() === "english"); $ && P.subtitle.switch($.file, { name: $.label, default: !0 }); const B = [...r.start != null && r.end != null ? [[r.start + 1, r.end - 1]] : [], ...s.start != null && s.end != null ? [[s.start + 1, s.end]] : []]; i && P.plugins.add(ND(B)), document.addEventListener("keydown", U => D(U, P)), P.subtitle.style({ fontSize: (P.width > 500 ? P.width * .02 : P.width * .03) + "px" }), t && P.plugins.add(MD({ vtt: `${w}${t}` })); const V = P.layers.rewind, W = P.layers.forward; if (rn.utils.isMobile && P.proxy(V, "dblclick", () => { P.currentTime = Math.max(0, P.currentTime - 10), P.layers.backwardIcon.style.opacity = 1, setTimeout(() => { P.layers.backwardIcon.style.opacity = 0 }, 300) }), rn.utils.isMobile && P.proxy(W, "dblclick", () => { P.currentTime = Math.max(0, P.currentTime + 10), P.layers.forwardIcon.style.opacity = 1, setTimeout(() => { P.layers.forwardIcon.style.opacity = 0 }, 300) }), e?.length > 0) { const U = e.find(q => q.label.toLowerCase() === "english" && q.default) || e.find(q => q.label.toLowerCase() === "english"); P.setting.add({ name: "captions", icon: VD, html: "Subtitle", tooltip: U?.label || "default", position: "right", selector: [{ html: "Display", switch: !0, onSwitch: q => (q.tooltip = q.switch ? "Hide" : "Show", P.subtitle.show = !q.switch, !q.switch) }, ...e.map(q => ({ default: q.label.toLowerCase() === "english" && q === U, html: q.label, url: q.file }))], onSelect: q => (P.subtitle.switch(q.url, { name: q.html }), q.html) }) } }), () => { P && P.destroy && P.destroy(!1), document.removeEventListener("keydown", D); const _ = JSON.parse(localStorage.getItem("continueWatching")) || [], M = { id: h?.id, data_id: h?.data_id, episodeId: c, episodeNum: p, adultContent: h?.adultContent, poster: h?.poster, title: h?.title, japanese_title: h?.japanese_title, leftAt: y.current }; if (!M.data_id) return; const $ = _.findIndex(B => B.data_id === M.data_id); $ !== -1 ? _[$] = M : _.push(M), localStorage.setItem("continueWatching", JSON.stringify(_)) } }, [n, e, r, s]), x.jsx("div", { ref: g, className: "w-full h-full" }) } function a6({ onToggle: n, isActive: e }) { const [t, r] = j.useState(e || !1), [s, i] = j.useState(!1); j.useEffect(() => { r(e) }, [e]); const a = () => { const c = !t; r(c), n(c), localStorage.setItem("theater-mode", c.toString()) }, o = () => { i(!s) }; return j.useEffect(() => (t ? document.body.classList.add("theater-mode") : (document.body.classList.remove("theater-mode"), i(!1)), () => { document.body.classList.remove("theater-mode") }), [t]), j.useEffect(() => (s ? document.body.classList.add("hide-watch-ui") : document.body.classList.remove("hide-watch-ui"), () => { document.body.classList.remove("hide-watch-ui") }), [s]), x.jsxs("div", { className: "theater-controls flex items-center gap-2", children: [x.jsxs("button", { onClick: a, className: `flex items-center gap-2 px-3 py-2 rounded-lg transition-all duration-300 ${t ? "bg-purple-500/20 text-purple-400 border border-purple-500/30" : "bg-white/5 text-white/70 hover:bg-white/10 hover:text-white border border-white/10"}`, "data-testid": "button-theater-mode", title: t ? "Exit Theater Mode" : "Enter Theater Mode", children: [x.jsx(me, { icon: t ? gC : DC }), x.jsx("span", { className: "text-sm font-medium", children: t ? "Exit Theater" : "Theater Mode" })] }), t && x.jsxs("button", { onClick: o, className: `flex items-center gap-2 px-3 py-2 rounded-lg transition-all duration-300 ${s ? "bg-blue-500/20 text-blue-400 border border-blue-500/30" : "bg-white/5 text-white/70 hover:bg-white/10 hover:text-white border border-white/10"}`, "data-testid": "button-hide-ui", title: s ? "Show UI" : "Hide UI", children: [x.jsx(me, { icon: s ? ph : vC }), x.jsx("span", { className: "text-sm font-medium", children: s ? "Show UI" : "Hide UI" })] })] }) } function o6({ animeInfo: n, episodeId: e, episodeNum: t, totalEpisodes: r, currentTime: s = 0, duration: i = 0 }) { const [a, o] = j.useState("watching"), [c, u] = j.useState(0), [f, h] = j.useState(!1), [p, v] = j.useState(0), [g, y] = j.useState(!1); j.useEffect(() => { const N = localStorage.getItem(`anime-progress-${n?.id}`), P = localStorage.getItem(`anime-status-${n?.id}`), _ = localStorage.getItem(`anime-rating-${n?.id}`), M = localStorage.getItem(`anime-favorite-${n?.id}`); N && v(JSON.parse(N)), P && o(P), _ && u(parseInt(_)), M && h(M === "true") }, [n?.id]); const w = r ? Math.round((parseInt(t) - 1) / r * 100) : 0, T = N => { const P = { animeId: n?.id, episodeId: e, episodeNum: t, progress: Math.round(N), lastWatched: new Date().toISOString(), currentTime: s, duration: i }; localStorage.setItem(`anime-progress-${n?.id}`, JSON.stringify(P)), v(N) }, S = N => { o(N), localStorage.setItem(`anime-status-${n?.id}`, N), (N === "completed" || r && parseInt(t) >= r) && T(100) }, E = N => { u(N), localStorage.setItem(`anime-rating-${n?.id}`, N.toString()) }, I = () => { const N = !f; h(N), localStorage.setItem(`anime-favorite-${n?.id}`, N.toString()) }, C = async () => { const N = { title: `Watch ${n?.title}`, text: `Currently watching episode ${t} of ${n?.title}`, url: window.location.href }; if (navigator.share) try { await navigator.share(N) } catch { navigator.clipboard.writeText(window.location.href) } else navigator.clipboard.writeText(window.location.href) }, D = N => { switch (N) { case "completed": return db; case "watching": return ph; case "plan-to-watch": return ap; case "dropped": return yC; default: return ph } }, R = N => { switch (N) { case "completed": return "text-green-400 bg-green-500/20 border-green-500/30"; case "watching": return "text-blue-400 bg-blue-500/20 border-blue-500/30"; case "plan-to-watch": return "text-yellow-400 bg-yellow-500/20 border-yellow-500/30"; case "dropped": return "text-red-400 bg-red-500/20 border-red-500/30"; default: return "text-gray-400 bg-gray-500/20 border-gray-500/30" } }; return x.jsxs("div", { className: "watch-progress bg-white/5 backdrop-blur-md rounded-xl p-4 border border-white/10", children: [x.jsxs("div", { className: "flex items-center justify-between mb-4", children: [x.jsx("h3", { className: "text-lg font-semibold text-white", children: "Your Progress" }), x.jsx("button", { onClick: () => y(!0), className: "text-sm text-blue-400 hover:text-blue-300 transition-colors", "data-testid": "button-progress-details", children: "View Details" })] }), x.jsxs("div", { className: "mb-4", children: [x.jsxs("div", { className: "flex justify-between text-sm text-white/70 mb-2", children: [x.jsxs("span", { children: ["Episode ", t, " of ", r || "?"] }), x.jsxs("span", { children: [w, "% Complete"] })] }), x.jsx("div", { className: "w-full bg-white/10 rounded-full h-2 overflow-hidden", children: x.jsx("div", { className: "h-full bg-gradient-to-r from-blue-500 to-purple-600 transition-all duration-500 ease-out", style: { width: `${w}%` } }) })] }), x.jsxs("div", { className: "grid grid-cols-2 gap-3", children: [x.jsxs("div", { className: "relative", children: [x.jsxs("select", { value: a, onChange: N => S(N.target.value), className: `w-full px-3 py-2 rounded-lg border transition-all duration-300 ${R(a)} appearance-none cursor-pointer`, "data-testid": "select-watch-status", children: [x.jsx("option", { value: "watching", children: "Watching" }), x.jsx("option", { value: "completed", children: "Completed" }), x.jsx("option", { value: "plan-to-watch", children: "Plan to Watch" }), x.jsx("option", { value: "dropped", children: "Dropped" })] }), x.jsx(me, { icon: D(a), className: "absolute right-3 top-1/2 transform -translate-y-1/2 pointer-events-none" })] }), x.jsxs("div", { className: "flex items-center gap-2", children: [x.jsx("button", { onClick: I, className: `flex-1 flex items-center justify-center gap-1 px-2 py-2 rounded-lg transition-all duration-300 ${f ? "text-red-400 bg-red-500/20 border border-red-500/30" : "text-white/60 bg-white/5 border border-white/10 hover:bg-white/10"}`, "data-testid": "button-favorite", title: f ? "Remove from Favorites" : "Add to Favorites", children: x.jsx(me, { icon: IC }) }), x.jsx("button", { onClick: C, className: "flex-1 flex items-center justify-center gap-1 px-2 py-2 rounded-lg bg-white/5 border border-white/10 text-white/60 hover:bg-white/10 hover:text-white transition-all duration-300", "data-testid": "button-share", title: "Share Episode", children: x.jsx(me, { icon: UC }) })] })] }), x.jsx("div", { className: "mt-4 pt-4 border-t border-white/10", children: x.jsxs("div", { className: "flex items-center justify-between", children: [x.jsx("span", { className: "text-sm text-white/70", children: "Your Rating:" }), x.jsx("div", { className: "flex items-center gap-1", children: [1, 2, 3, 4, 5].map(N => x.jsx("button", { onClick: () => E(N), className: `p-1 transition-colors ${N <= c ? "text-yellow-400" : "text-white/30 hover:text-yellow-300"}`, "data-testid": `button-rating-${N}`, children: x.jsx(me, { icon: sp, className: "text-sm" }) }, N)) })] }) }), g && x.jsx("div", { className: "fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4", children: x.jsxs("div", { className: "bg-gray-900 rounded-2xl p-6 max-w-md w-full border border-white/10", children: [x.jsx("h3", { className: "text-xl font-bold text-white mb-4", children: "Progress Details" }), x.jsxs("div", { className: "space-y-4", children: [x.jsxs("div", { children: [x.jsx("span", { className: "text-white/70", children: "Current Episode:" }), x.jsx("span", { className: "text-white ml-2", children: t })] }), x.jsxs("div", { children: [x.jsx("span", { className: "text-white/70", children: "Total Episodes:" }), x.jsx("span", { className: "text-white ml-2", children: r || "Unknown" })] }), x.jsxs("div", { children: [x.jsx("span", { className: "text-white/70", children: "Overall Progress:" }), x.jsxs("span", { className: "text-white ml-2", children: [w, "%"] })] }), x.jsxs("div", { children: [x.jsx("span", { className: "text-white/70", children: "Status:" }), x.jsx("span", { className: "text-white ml-2 capitalize", children: a.replace("-", " ") })] }), c > 0 && x.jsxs("div", { children: [x.jsx("span", { className: "text-white/70", children: "Your Rating:" }), x.jsxs("span", { className: "text-white ml-2", children: [c, "/5 "] })] })] }), x.jsx("button", { onClick: () => y(!1), className: "w-full mt-6 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors", "data-testid": "button-close-modal", children: "Close" })] }) })] }) } function l6({ isOpen: n, onClose: e }) { const [t, r] = j.useState([]), [s, i] = j.useState([]), [a, o] = j.useState("recent"), [c, u] = j.useState(!0), [f, h] = j.useState(!0), [p, v] = j.useState(!1); j.useEffect(() => { n && (() => { const E = JSON.parse(localStorage.getItem("continueWatching")) || [], I = {}, C = {}; for (let R = 0; R < localStorage.length; R++) { const N = localStorage.key(R); if (N.startsWith("anime-status-")) { const P = N.replace("anime-status-", ""); I[P] = localStorage.getItem(N) } if (N.startsWith("anime-rating-")) { const P = N.replace("anime-rating-", ""); C[P] = parseInt(localStorage.getItem(N)) || 0 } } const D = E.map(R => ({ ...R, status: I[R.id] || "watching", rating: C[R.id] || 0, lastWatched: R.lastWatched || new Date().toISOString() })); r(D) })() }, [n]), j.useEffect(() => { let S = t.filter(E => { const I = E.status || "watching"; return !(I === "completed" && !c || I === "watching" && !f || I === "dropped" && !p) }); S.sort((E, I) => { switch (a) { case "title": return (E.title || "").localeCompare(I.title || ""); case "progress": const C = E.episodeNum ? parseInt(E.episodeNum) : 0; return (I.episodeNum ? parseInt(I.episodeNum) : 0) - C; case "recent": default: return new Date(I.lastWatched || 0) - new Date(E.lastWatched || 0) } }), i(S) }, [t, a, c, f, p]); const g = () => { confirm("Are you sure you want to clear your entire watch history? This action cannot be undone.") && (localStorage.removeItem("continueWatching"), r([]), i([])) }, y = S => { const I = (JSON.parse(localStorage.getItem("continueWatching")) || []).filter(C => C.id !== S); localStorage.setItem("continueWatching", JSON.stringify(I)), r(C => C.filter(D => D.id !== S)) }, w = S => { const E = new Date(S), C = new Date - E, D = Math.floor(C / (1e3 * 60 * 60 * 24)); return D === 0 ? "Today" : D === 1 ? "Yesterday" : D < 7 ? `${D} days ago` : D < 30 ? `${Math.floor(D / 7)} weeks ago` : E.toLocaleDateString() }, T = S => { switch (S) { case "completed": return "text-green-400 bg-green-500/20"; case "watching": return "text-blue-400 bg-blue-500/20"; case "dropped": return "text-red-400 bg-red-500/20"; default: return "text-gray-400 bg-gray-500/20" } }; return n ? x.jsx("div", { className: "fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4", children: x.jsxs("div", { className: "bg-gray-900 rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden border border-white/10", children: [x.jsxs("div", { className: "p-6 border-b border-white/10", children: [x.jsxs("div", { className: "flex items-center justify-between mb-4", children: [x.jsxs("h2", { className: "text-2xl font-bold text-white flex items-center gap-3", children: [x.jsx(me, { icon: mh, className: "text-blue-400" }), "Watch History"] }), x.jsx("button", { onClick: e, className: "text-white/60 hover:text-white text-xl transition-colors", "data-testid": "button-close-history", children: "" })] }), x.jsxs("div", { className: "flex items-center justify-between flex-wrap gap-4", children: [x.jsxs("div", { className: "flex items-center gap-4", children: [x.jsxs("div", { className: "flex items-center gap-2", children: [x.jsx(me, { icon: AC, className: "text-white/60" }), x.jsxs("select", { value: a, onChange: S => o(S.target.value), className: "bg-white/10 border border-white/20 rounded-lg px-3 py-1 text-white text-sm", "data-testid": "select-sort-history", children: [x.jsx("option", { value: "recent", children: "Most Recent" }), x.jsx("option", { value: "title", children: "Title (A-Z)" }), x.jsx("option", { value: "progress", children: "Progress" })] })] }), x.jsxs("div", { className: "flex items-center gap-2", children: [x.jsxs("label", { className: "flex items-center gap-1 text-sm", children: [x.jsx("input", { type: "checkbox", checked: f, onChange: S => h(S.target.checked), className: "rounded", "data-testid": "checkbox-show-watching" }), x.jsx("span", { className: "text-blue-400", children: "Watching" })] }), x.jsxs("label", { className: "flex items-center gap-1 text-sm", children: [x.jsx("input", { type: "checkbox", checked: c, onChange: S => u(S.target.checked), className: "rounded", "data-testid": "checkbox-show-completed" }), x.jsx("span", { className: "text-green-400", children: "Completed" })] }), x.jsxs("label", { className: "flex items-center gap-1 text-sm", children: [x.jsx("input", { type: "checkbox", checked: p, onChange: S => v(S.target.checked), className: "rounded", "data-testid": "checkbox-show-dropped" }), x.jsx("span", { className: "text-red-400", children: "Dropped" })] })] })] }), x.jsxs("button", { onClick: g, className: "flex items-center gap-2 px-3 py-1 bg-red-500/20 text-red-400 border border-red-500/30 rounded-lg hover:bg-red-500/30 transition-colors text-sm", "data-testid": "button-clear-history", children: [x.jsx(me, { icon: zx }), "Clear All"] })] })] }), x.jsx("div", { className: "p-6 overflow-y-auto max-h-[60vh]", children: s.length === 0 ? x.jsxs("div", { className: "text-center py-12", children: [x.jsx(me, { icon: mh, className: "text-6xl text-white/20 mb-4" }), x.jsx("p", { className: "text-white/60 text-lg", children: "No watch history found" }), x.jsx("p", { className: "text-white/40 text-sm", children: "Start watching some anime to see your history here" })] }) : x.jsx("div", { className: "space-y-4", children: s.map((S, E) => x.jsx("div", { className: "bg-white/5 rounded-xl p-4 border border-white/10 hover:bg-white/8 transition-all duration-300 group", "data-testid": `history-item-${E}`, children: x.jsxs("div", { className: "flex items-start gap-4", children: [x.jsx("img", { src: S.poster, alt: S.title, className: "w-16 h-20 object-cover rounded-lg flex-shrink-0" }), x.jsxs("div", { className: "flex-1 min-w-0", children: [x.jsxs("div", { className: "flex items-start justify-between mb-2", children: [x.jsx("h3", { className: "text-white font-medium text-lg line-clamp-1 group-hover:text-blue-300 transition-colors", children: S.title }), x.jsxs("div", { className: "flex items-center gap-2 ml-4", children: [x.jsx("span", { className: `px-2 py-1 rounded-full text-xs font-medium ${T(S.status)}`, children: S.status === "plan-to-watch" ? "Plan to Watch" : S.status.charAt(0).toUpperCase() + S.status.slice(1) }), x.jsx("button", { onClick: () => y(S.id), className: "text-white/40 hover:text-red-400 transition-colors p-1", "data-testid": `button-remove-${E}`, title: "Remove from history", children: x.jsx(me, { icon: zx, className: "text-sm" }) })] })] }), x.jsxs("div", { className: "flex items-center gap-4 text-sm text-white/60 mb-3", children: [x.jsxs("span", { className: "flex items-center gap-1", children: [x.jsx(me, { icon: Xt }), "Episode ", S.episodeNum] }), x.jsxs("span", { className: "flex items-center gap-1", children: [x.jsx(me, { icon: ub }), w(S.lastWatched)] }), S.rating > 0 && x.jsxs("span", { className: "flex items-center gap-1", children: [" ", S.rating, "/5"] })] }), x.jsxs("div", { className: "flex items-center justify-between", children: [x.jsxs(We, { to: `/watch/${S.id}?ep=${S.episodeId}`, className: "flex items-center gap-2 px-4 py-2 bg-blue-500/20 text-blue-400 border border-blue-500/30 rounded-lg hover:bg-blue-500/30 transition-colors", "data-testid": `link-continue-${E}`, children: [x.jsx(me, { icon: Xt }), "Continue Watching"] }), x.jsx(We, { to: `/${S.id}`, className: "text-white/60 hover:text-white transition-colors text-sm", "data-testid": `link-details-${E}`, children: "View Details" })] })] })] }) }, S.id + E)) }) })] }) }) : null } function c6() { const n = zr(), e = _r(), { id: t } = cc(); let s = new URLSearchParams(n.search).get("ep"); const [i, a] = j.useState([]), { language: o } = pn(), { homeInfo: c } = Vh(), u = j.useRef(!0), [f, h] = j.useState(!0), [p, v] = j.useState(!1), [g, y] = j.useState(!1), [w, T] = j.useState(!1), { buffering: S, streamInfo: E, Url: I, animeInfo: C, episodes: D, nextEpisodeSchedule: R, totalEpisodes: N, isFullOverview: P, intro: _, outro: M, subtitles: $, thumbnail: B, setIsFullOverview: V, activeEpisodeNum: W, seasons: U, episodeId: q, setEpisodeId: z, activeServerId: X, setActiveServerId: Z, servers: F, serverLoading: H, activeServerType: ae, setActiveServerType: he, activeServerName: de, setActiveServerName: pe } = AR(t, s), { autoPlay: Ce, setAutoPlay: Ie, autoSkipIntro: Pe, setAutoSkipIntro: Ve, autoNext: rt, setAutoNext: ft } = kR(), je = j.useRef(null), Oe = j.useRef(null), ot = j.useRef(null), Le = j.useRef(null); return j.useEffect(() => { if (!D || D.length === 0) return; const ie = D.some(qe => qe.id.split("ep=")[1] === q); if (!q || !ie) { const qe = D[0].id.match(/ep=(\d+)/)?.[1]; qe && qe !== q && z(qe); return } const _e = `/watch/${t}?ep=${q}`; u.current ? (e(_e, { replace: !0 }), u.current = !1) : e(_e) }, [q, t, e, D]), j.useEffect(() => (C && (document.title = `Watch ${C.title} English Sub/Dub online Free on ${_n}`), () => { document.title = `${_n} | Free anime streaming platform` }), [t]), j.useEffect(() => { N !== null && N === 0 && e(`/${t}`) }, [E, q, t, N, e]), j.useEffect(() => { const ie = () => { if (window.innerWidth > 1200) { if (Oe.current && ot.current && Le.current) { const vt = Oe.current.offsetHeight, Et = ot.current.offsetHeight, _t = vt + Et; Le.current.style.height = `${_t}px` } } else Le.current && (Le.current.style.height = "auto") }, _e = setTimeout(() => { ie() }, 500); window.addEventListener("resize", ie); const qe = new MutationObserver(() => { setTimeout(ie, 100) }); Oe.current && qe.observe(Oe.current, { attributes: !0, childList: !0, subtree: !0 }), ot.current && qe.observe(ot.current, { attributes: !0, childList: !0, subtree: !0 }); const Ze = setInterval(ie, 1e3); return () => { clearTimeout(_e), clearInterval(Ze), qe.disconnect(), window.removeEventListener("resize", ie) } }, [S, ae, de, q, I, D]), j.useEffect(() => { a([{ condition: C?.animeInfo?.tvInfo?.rating, bgColor: "#ffffff", text: C?.animeInfo?.tvInfo?.rating }, { condition: C?.animeInfo?.tvInfo?.quality, bgColor: "#FFBADE", text: C?.animeInfo?.tvInfo?.quality }, { condition: C?.animeInfo?.tvInfo?.sub, icon: Mn, bgColor: "#B0E3AF", text: C?.animeInfo?.tvInfo?.sub }, { condition: C?.animeInfo?.tvInfo?.dub, icon: On, bgColor: "#B9E7FF", text: C?.animeInfo?.tvInfo?.dub }]) }, [t, C]), x.jsxs("div", { className: "w-full min-h-screen bg-[#0a0a0a]", children: [x.jsx("div", { className: "w-full max-w-[1920px] mx-auto pt-16 pb-6 w-full max-[1200px]:pt-12", children: x.jsxs("div", { className: "grid grid-cols-[minmax(0,70%),minmax(0,30%)] gap-6 w-full h-full max-[1200px]:flex max-[1200px]:flex-col", children: [x.jsxs("div", { className: "flex flex-col w-full gap-6", children: [x.jsxs("div", { ref: je, className: "player w-full h-fit bg-black flex flex-col rounded-xl overflow-hidden", children: [x.jsxs("div", { ref: Oe, className: "w-full relative aspect-video bg-black", children: [S ? x.jsx("div", { className: "absolute inset-0 flex justify-center items-center bg-black", children: x.jsx(gs, {}) }) : ["hd-1", "hd-4"].includes(de.toLowerCase()) ? x.jsx(IR, { episodeId: q, servertype: ae, serverName: de, animeInfo: C, episodeNum: W, episodes: D, playNext: ie => z(ie), autoNext: rt }) : x.jsx(i6, { streamUrl: I, subtitles: $, intro: _, outro: M, serverName: de.toLowerCase(), thumbnail: B, autoSkipIntro: Pe, autoPlay: Ce, autoNext: rt, episodeId: q, episodes: D, playNext: ie => z(ie), animeInfo: C, episodeNum: W, streamInfo: E }), x.jsx("p", { className: "text-center underline font-medium text-[15px] absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none text-gray-300", children: !S && !ae ? F ? x.jsxs(x.Fragment, { children: ["Probably this server is down, try other servers", x.jsx("br", {}), "Either reload or try again after sometime"] }) : x.jsxs(x.Fragment, { children: ["Probably streaming server is down", x.jsx("br", {}), "Either reload or try again after sometime"] }) : null })] }), x.jsxs("div", { className: "bg-[#121212]", children: [!S && x.jsxs("div", { ref: ot, children: [x.jsx(CR, { autoPlay: Ce, setAutoPlay: Ie, autoSkipIntro: Pe, setAutoSkipIntro: Ve, autoNext: rt, setAutoNext: ft, episodes: D, totalEpisodes: N, episodeId: q, onButtonClick: ie => z(ie) }), x.jsx("div", { className: "px-3 py-2 border-t border-gray-800/50", children: x.jsxs("div", { className: "flex items-center justify-between flex-wrap gap-3", children: [x.jsx(a6, { onToggle: v, isActive: p }), x.jsxs("div", { className: "flex items-center gap-2", children: [x.jsxs("button", { onClick: () => y(!0), className: "flex items-center gap-2 px-3 py-2 rounded-lg bg-white/5 text-white/70 hover:bg-white/10 hover:text-white border border-white/10 transition-all duration-300", "data-testid": "button-watch-history", title: "Watch History", children: [x.jsx(me, { icon: mh }), x.jsx("span", { className: "text-sm font-medium hidden sm:inline", children: "History" })] }), x.jsxs("button", { onClick: () => T(!w), className: `flex items-center gap-2 px-3 py-2 rounded-lg transition-all duration-300 ${w ? "bg-blue-500/20 text-blue-400 border border-blue-500/30" : "bg-white/5 text-white/70 hover:bg-white/10 hover:text-white border border-white/10"}`, "data-testid": "button-anime-info", title: "Anime Info", children: [x.jsx(me, { icon: hC }), x.jsx("span", { className: "text-sm font-medium hidden sm:inline", children: "Info" })] })] })] }) })] }), x.jsx("div", { className: "px-3 py-2", children: x.jsx("div", { children: x.jsx(LR, { servers: F, activeEpisodeNum: W, activeServerId: X, setActiveServerId: Z, serverLoading: H, setActiveServerType: he, activeServerType: ae, setActiveServerName: pe }) }) }), R?.nextEpisodeSchedule && f && x.jsx("div", { className: "px-3 pb-3", children: x.jsxs("div", { className: "w-full p-3 rounded-lg bg-[#272727] flex items-center justify-between", children: [x.jsxs("div", { className: "flex items-center gap-x-3", children: [x.jsx("span", { className: "text-[18px]", children: "" }), x.jsxs("div", { children: [x.jsx("span", { className: "text-gray-400 text-sm", children: "Next episode estimated at" }), x.jsx("span", { className: "ml-2 text-white text-sm font-medium", children: new Date(new Date(R.nextEpisodeSchedule).getTime() - new Date().getTimezoneOffset() * 6e4).toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", year: "numeric", hour: "2-digit", minute: "2-digit", second: "2-digit", hour12: !0 }) })] })] }), x.jsx("button", { className: "text-2xl text-gray-500 hover:text-white transition-colors", onClick: () => h(!1), children: "" })] }) })] })] }), U?.length > 0 && x.jsxs("div", { className: "hidden max-[1200px]:block bg-[#141414] rounded-lg p-4", children: [x.jsx("h2", { className: "text-xl font-semibold mb-4 text-white", children: "More Seasons" }), x.jsx("div", { className: "grid grid-cols-2 gap-2", children: U.map((ie, _e) => x.jsxs(We, { to: `/${ie.id}`, className: `relative w-full aspect-[3/1] rounded-lg overflow-hidden cursor-pointer group ${t === String(ie.id) ? "ring-2 ring-white/40 shadow-lg shadow-white/10" : ""}`, children: [x.jsx("img", { src: ie.season_poster, alt: ie.season, className: `w-full h-full object-cover scale-150 ${t === String(ie.id) ? "opacity-50" : "opacity-40 group-hover:opacity-50 transition-opacity"}` }), x.jsx("div", { className: "absolute inset-0 z-10", style: { backgroundImage: `url('data:image/svg+xml,<svg width="3" height="3" viewBox="0 0 3 3" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="1.5" cy="1.5" r="0.5" fill="white" fill-opacity="0.25"/></svg>')`, backgroundSize: "3px 3px" } }), x.jsx("div", { className: `absolute inset-0 z-20 bg-gradient-to-r ${t === String(ie.id) ? "from-black/50 to-transparent" : "from-black/40 to-transparent"}` }), x.jsx("div", { className: "absolute inset-0 z-30 flex items-center justify-center", children: x.jsx("p", { className: `text-[14px] font-bold text-center px-2 transition-colors duration-300 ${t === String(ie.id) ? "text-white" : "text-white/90 group-hover:text-white"}`, children: ie.season }) })] }, _e)) })] }), x.jsx("div", { className: "hidden max-[1200px]:block", children: x.jsx("div", { ref: Le, className: "episodes flex-shrink-0 bg-[#141414] rounded-lg overflow-hidden", children: D ? x.jsx(Zx, { episodes: D, currentEpisode: q, onEpisodeClick: ie => z(ie), totalEpisodes: N }) : x.jsx("div", { className: "h-full flex items-center justify-center", children: x.jsx(gs, {}) }) }) }), x.jsx("div", { className: "bg-[#141414] rounded-lg p-4", children: x.jsxs("div", { className: "flex gap-x-6 max-[600px]:flex-row max-[600px]:gap-4", children: [C && C?.poster ? x.jsx("img", { src: `${C?.poster}`, alt: "", className: "w-[120px] h-[180px] object-cover rounded-md max-[600px]:w-[100px] max-[600px]:h-[150px]" }) : x.jsx(Se, { className: "w-[120px] h-[180px] rounded-md max-[600px]:w-[100px] max-[600px]:h-[150px]" }), x.jsxs("div", { className: "flex flex-col gap-y-4 flex-1 max-[600px]:gap-y-2", children: [C && C?.title ? x.jsxs(We, { to: `/${t}`, className: "group", children: [x.jsx("h1", { className: "text-[28px] font-medium text-white leading-tight group-hover:text-gray-300 transition-colors max-[600px]:text-[20px]", children: o ? C?.title : C?.japanese_title }), x.jsxs("div", { className: "flex items-center gap-1.5 mt-1 text-gray-400 text-sm group-hover:text-white transition-colors max-[600px]:text-[12px] max-[600px]:mt-0.5", children: [x.jsx("span", { children: "View Details" }), x.jsx("svg", { className: "w-4 h-4 transform group-hover:translate-x-0.5 transition-transform max-[600px]:w-3 max-[600px]:h-3", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: x.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5l7 7-7 7" }) })] })] }) : x.jsx(Se, { className: "w-[170px] h-[20px] rounded-xl" }), x.jsx("div", { className: "flex flex-wrap gap-2 max-[600px]:gap-1.5", children: C ? i.map(({ condition: ie, icon: _e, text: qe }, Ze) => ie && x.jsxs("span", { className: "px-3 py-1 bg-[#1a1a1a] rounded-full text-sm flex items-center gap-x-1 text-gray-300 max-[600px]:px-2 max-[600px]:py-0.5 max-[600px]:text-[11px]", children: [_e && x.jsx(me, { icon: _e, className: "text-[12px] max-[600px]:text-[10px]" }), qe] }, Ze)) : x.jsx(Se, { className: "w-[70px] h-[20px] rounded-xl" }) }), C?.animeInfo?.Overview && x.jsx("p", { className: "text-[15px] text-gray-400 leading-relaxed max-[600px]:text-[13px] max-[600px]:leading-normal", children: C?.animeInfo?.Overview.length > 270 ? x.jsxs(x.Fragment, { children: [P ? C?.animeInfo?.Overview : `${C?.animeInfo?.Overview.slice(0, 270)}...`, x.jsx("button", { className: "ml-2 text-gray-300 hover:text-white transition-colors max-[600px]:text-[12px] max-[600px]:ml-1", onClick: () => V(!P), children: P ? "Show Less" : "Read More" })] }) : C?.animeInfo?.Overview })] })] }) }), U?.length > 0 && x.jsxs("div", { className: "bg-[#141414] rounded-lg p-4 max-[1200px]:hidden", children: [x.jsx("h2", { className: "text-xl font-semibold mb-4 text-white", children: "More Seasons" }), x.jsx("div", { className: "grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 sm:gap-4", children: U.map((ie, _e) => x.jsxs(We, { to: `/${ie.id}`, className: `relative w-full aspect-[3/1] rounded-lg overflow-hidden cursor-pointer group ${t === String(ie.id) ? "ring-2 ring-white/40 shadow-lg shadow-white/10" : ""}`, children: [x.jsx("img", { src: ie.season_poster, alt: ie.season, className: `w-full h-full object-cover scale-150 ${t === String(ie.id) ? "opacity-50" : "opacity-40 group-hover:opacity-50 transition-opacity"}` }), x.jsx("div", { className: "absolute inset-0 z-10", style: { backgroundImage: `url('data:image/svg+xml,<svg width="3" height="3" viewBox="0 0 3 3" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="1.5" cy="1.5" r="0.5" fill="white" fill-opacity="0.25"/></svg>')`, backgroundSize: "3px 3px" } }), x.jsx("div", { className: `absolute inset-0 z-20 bg-gradient-to-r ${t === String(ie.id) ? "from-black/50 to-transparent" : "from-black/40 to-transparent"}` }), x.jsx("div", { className: "absolute inset-0 z-30 flex items-center justify-center", children: x.jsx("p", { className: `text-[14px] sm:text-[16px] font-bold text-center px-2 sm:px-4 transition-colors duration-300 ${t === String(ie.id) ? "text-white" : "text-white/90 group-hover:text-white"}`, children: ie.season }) })] }, _e)) })] })] }), x.jsxs("div", { className: "flex flex-col gap-6 h-full max-[1200px]:hidden", children: [x.jsx(o6, { animeInfo: C, episodeId: q, episodeNum: W, totalEpisodes: N }), x.jsx("div", { ref: Le, className: "episodes flex-shrink-0 bg-[#141414] rounded-lg overflow-hidden", children: D ? x.jsx(Zx, { episodes: D, currentEpisode: q, onEpisodeClick: ie => z(ie), totalEpisodes: N }) : x.jsx("div", { className: "h-full flex items-center justify-center", children: x.jsx(gs, {}) }) }), C && C.related_data ? x.jsxs("div", { className: "bg-[#141414] rounded-lg p-4", children: [x.jsx("h2", { className: "text-xl font-semibold mb-4 text-white", children: "Related Anime" }), x.jsx(Yx, { data: C.related_data, className: "!mt-0" })] }) : x.jsx("div", { className: "mt-6", children: x.jsx(up, {}) })] }), C && C.related_data && x.jsxs("div", { className: "hidden max-[1200px]:block bg-[#141414] rounded-lg p-4", children: [x.jsx("h2", { className: "text-xl font-semibold mb-4 text-white", children: "Related Anime" }), x.jsx(Yx, { data: C.related_data, className: "!mt-0" })] })] }) }), x.jsx(l6, { isOpen: g, onClose: () => y(!1) })] }) } const u6 = async (n, e) => { const t = "https://apii-orcin-theta.vercel.app/api"; try { return (await Ke.get(`${t}/producer/${n}?page=${e}`)).data.results } catch (r) { return console.error("Error fetching genre info:", r), r } }; function d6() { const { id: n } = cc(), [e, t] = Nc(), [r, s] = j.useState(null), [i, a] = j.useState(!0), [o, c] = j.useState(null), [u, f] = j.useState(0), h = parseInt(e.get("page")) || 1, p = _r(); if (j.useEffect(() => { (async () => { a(!0); try { const w = await u6(n, h); s(w.data), f(w.totalPages), a(!1) } catch (w) { c(w), console.error("Error fetching category info:", w) } })(), window.scrollTo({ top: 0, behavior: "smooth" }) }, [n, h]), i) return x.jsx(Qa, { type: "producer" }); if (o) return p("/error-page"), x.jsx(Pn, {}); if (!r) return p("/404-not-found-page"), null; const v = y => { t({ page: y }) }, g = (n.charAt(0).toUpperCase() + n.slice(1)).split("-").join(" "); return x.jsx("div", { className: "max-w-[1600px] mx-auto flex flex-col mt-[64px] max-md:mt-[50px]", children: x.jsx("div", { className: "w-full flex flex-col gap-y-8 mt-6", children: i ? x.jsx(Qa, { type: "producer" }) : h > u ? x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsxs("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: [g, " Anime"] }), x.jsxs("p", { className: "text-white text-lg max-[478px]:text-[16px] max-[300px]:leading-6", children: ["You came a long way, go back ", x.jsx("br", { className: "max-[300px]:hidden" }), "nothing is here"] })] }) : r && r.length > 0 ? x.jsxs("div", { className: "flex flex-col gap-y-2 max-[478px]:gap-y-0", children: [x.jsxs("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: [g, " Anime"] }), x.jsx(Es, { data: r, showViewMore: !1, className: "mt-0", cardStyle: "grid-cols-8 max-[1600px]:grid-cols-6 max-[1200px]:grid-cols-4 max-[758px]:grid-cols-3 max-[478px]:grid-cols-3 max-[478px]:gap-x-2" }), x.jsx("div", { className: "flex justify-center w-full mt-8", children: x.jsx(mo, { page: h, totalPages: u, handlePageChange: v }) })] }) : o ? x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsxs("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: [g, " Anime"] }), x.jsx("p", { className: "text-white text-lg max-[478px]:text-[16px]", children: "Couldn't get results, please try again" })] }) : x.jsxs("div", { className: "flex flex-col gap-y-4", children: [x.jsxs("h1", { className: "font-bold text-2xl text-white max-[478px]:text-[18px]", children: [g, " Anime"] }), x.jsx("p", { className: "text-white text-lg max-[478px]:text-[16px]", children: "No results found" })] }) }) }) } function f6() { const n = _r(), [e, t] = j.useState(""), [r, s] = j.useState(!1); j.useEffect(() => { s(!0) }, []); const i = j.useCallback(() => { const o = e.trim(); if (!o) return; const c = encodeURIComponent(o); n(`/search?keyword=${c}`) }, [e, n]), a = j.useCallback(o => { o.key === "Enter" && i() }, [i]); return x.jsxs("div", { className: `splash-container ${r ? "visible" : ""}`, children: [x.jsx("div", { className: "splash-background-minimal", children: x.jsx("div", { className: "particles-minimal", children: [...Array(20)].map((o, c) => x.jsx("div", { className: "particle-minimal", style: { left: `${Math.random() * 100}%`, animationDelay: `${Math.random() * 15}s`, animationDuration: `${15 + Math.random() * 15}s` } }, c)) }) }), x.jsx("div", { className: "hero-section-minimal", children: x.jsxs("div", { className: "hero-content-minimal", children: [x.jsx("div", { className: "logo-container-minimal", children: x.jsx("img", { src: "/logo.jpg", alt: Ab, className: "logo-minimal", "data-testid": "logo-splash" }) }), x.jsxs("h1", { className: "hero-title-minimal", children: ["Watch Anime ", x.jsx("span", { className: "white-text", children: "Anytime, Anywhere" })] }), x.jsx("p", { className: "hero-subtitle-minimal", children: "Stream thousands of anime episodes in HD quality, completely free." }), x.jsxs("div", { className: "search-container-minimal", children: [x.jsx("input", { type: "text", placeholder: "Search anime...", className: "search-input-minimal", value: e, onChange: o => t(o.target.value), onKeyDown: a, "data-testid": "input-search-splash" }), x.jsx("button", { className: "search-button-minimal", onClick: i, "aria-label": "Search", "data-testid": "button-search-splash", children: x.jsx(me, { icon: po }) })] }), x.jsxs(We, { to: "/home", className: "primary-button-minimal", "data-testid": "link-enter-homepage", children: [x.jsx(me, { icon: Xt, className: "button-icon-minimal" }), "Start Watching"] })] }) })] }) }/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */const h6 = { prefix: "fab", iconName: "discord", icon: [640, 512, [], "f392", "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"] }, p6 = { prefix: "fab", iconName: "twitter", icon: [512, 512, [], "f099", "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"] }, m6 = [{ icon: h6, title: "Discord", link: "#" }, { icon: p6, title: "Twitter", link: "#" }, { icon: LC, title: "Email", link: "mailto:support@example.com" }]; function g6() { const [n, e] = j.useState({ name: "", email: "", message: "" }), [t, r] = j.useState(!1), [s, i] = j.useState(null), a = c => { const { name: u, value: f } = c.target; e(h => ({ ...h, [u]: f })) }, o = async c => { c.preventDefault(), r(!0), setTimeout(() => { r(!1), i("success"), e({ name: "", email: "", message: "" }), setTimeout(() => { i(null) }, 5e3) }, 2e3) }; return x.jsx("div", { className: "min-h-screen pt-20 pb-12 px-4", children: x.jsxs("div", { className: "max-w-2xl mx-auto", children: [x.jsxs("div", { className: "text-center mb-12", children: [x.jsx("h1", { className: "text-3xl font-bold mb-4 text-white", children: "Contact Us" }), x.jsx("p", { className: "text-white/60", children: "Get in touch with us through any of the channels below" })] }), x.jsx("div", { className: "mb-12", children: x.jsx("div", { className: "grid grid-cols-2 md:grid-cols-3 gap-4", children: m6.map((c, u) => x.jsxs("a", { href: c.link, target: "_blank", rel: "noopener noreferrer", className: "flex flex-col items-center p-4 bg-white/5 rounded-lg border border-white/10 hover:bg-white/10 hover:border-white/20 transition-all duration-200", "data-testid": `contact-method-${u}`, children: [x.jsx(me, { icon: c.icon, className: "text-xl text-white/70 mb-2" }), x.jsx("span", { className: "text-sm text-white/60", children: c.title })] }, u)) }) }), x.jsxs("div", { className: "bg-white/5 rounded-lg p-6 border border-white/10", children: [x.jsx("h2", { className: "text-xl font-semibold text-white mb-6", children: "Send Message" }), s === "success" && x.jsxs("div", { className: "mb-4 p-3 bg-green-500/20 border border-green-500/50 rounded-lg text-green-300 flex items-center gap-2", children: [x.jsx(me, { icon: TC }), x.jsx("span", { className: "text-sm", children: "Message sent successfully!" })] }), x.jsxs("form", { onSubmit: o, className: "space-y-4", children: [x.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [x.jsx("div", { children: x.jsx("input", { type: "text", name: "name", value: n.name, onChange: a, required: !0, className: "w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-white/40 focus:outline-none focus:border-blue-500/50 transition-colors", placeholder: "Your Name", "data-testid": "input-name" }) }), x.jsx("div", { children: x.jsx("input", { type: "email", name: "email", value: n.email, onChange: a, required: !0, className: "w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-white/40 focus:outline-none focus:border-blue-500/50 transition-colors", placeholder: "Email Address", "data-testid": "input-email" }) })] }), x.jsx("div", { children: x.jsx("textarea", { name: "message", value: n.message, onChange: a, required: !0, rows: 4, className: "w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-white/40 focus:outline-none focus:border-blue-500/50 transition-colors resize-none", placeholder: "Your message...", "data-testid": "textarea-message" }) }), x.jsx("button", { type: "submit", disabled: t, className: "w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2", "data-testid": "button-submit-contact", children: t ? x.jsxs(x.Fragment, { children: [x.jsx("div", { className: "w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" }), "Sending..."] }) : x.jsxs(x.Fragment, { children: [x.jsx(me, { icon: zC }), "Send Message"] }) })] })] })] }) }) } function x6() { const n = zr(); j.useEffect(() => { window.scrollTo(0, 0) }, [n]); const e = n.pathname === "/"; return x.jsx(aI, { children: x.jsxs("div", { className: "app-container px-4 lg:px-10", children: [x.jsxs("main", { className: "content max-w-[2048px] mx-auto w-full", children: [!e && x.jsx(hR, {}), x.jsxs(JE, { children: [x.jsx(ar, { path: "/", element: x.jsx(f6, {}) }), x.jsx(ar, { path: "/home", element: x.jsx(Yk, {}) }), x.jsx(ar, { path: "/:id", element: x.jsx(Qx, {}) }), x.jsx(ar, { path: "/watch/:id", element: x.jsx(c6, {}) }), x.jsx(ar, { path: "/random", element: x.jsx(Qx, { random: !0 }) }), x.jsx(ar, { path: "/404-not-found-page", element: x.jsx(Pn, { error: "404" }) }), x.jsx(ar, { path: "/error-page", element: x.jsx(Pn, {}) }), x.jsx(ar, { path: "/contact", element: x.jsx(g6, {}) }), xR.map(t => x.jsx(ar, { path: `/${t}`, element: x.jsx(mR, { path: t, label: t.split("-").join(" ") }) }, t)), vR.map(t => x.jsx(ar, { path: `/${t}`, element: x.jsx(gR, { path: t }) }, t)), x.jsx(ar, { path: "/producer/:id", element: x.jsx(d6, {}) }), x.jsx(ar, { path: "/search", element: x.jsx(bR, {}) }), x.jsx(ar, { path: "*", element: x.jsx(Pn, { error: "404" }) })] }), !e && x.jsx(pR, {})] }), x.jsx(bT, {}), x.jsx(kT, {})] }) }) } lE.createRoot(document.getElementById("root")).render(x.jsx(nE, { children: x.jsx(oT, { children: x.jsx(x6, {}) }) }))
}); export default v6();
